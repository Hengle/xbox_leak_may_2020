; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\dmsegobj.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@DIODOBIN@Segment?5?$CFlx?5created?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@NCKHKOOB@Segment?5?$CFlx?5destroyed?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@PCAOPAPI@Warning?3?5Segment?5queried?5for?5unk@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BMIEACAF@?$CFs?3?5Invalid?5pointer?5pmtLength?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@EKMAJFDC@Error?3?5Can?5not?5set?5segment?5lengt@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GM@DJIFMAEG@Error?3?5Can?5not?5set?5segment?5lengt@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@DHDHGHJI@?$CFs?3?5Invalid?5pointer?5pdwResolutio@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FF@GMMOCCJF@Warning?3?5Attempt?5to?5set?5resoluti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@MKCBNIGA@?$CFs?3?5Invalid?5pointer?5prtLength?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@ENKCIHOK@?$CFs?3?5Invalid?5pointer?5pfClockTime?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@JAIPAHKP@?$CFs?3?5Invalid?5pointer?5prtStart?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@MJIALHAM@?$CFs?3?5Invalid?5pointer?5prtEnd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@ODGPLPH@Error?3?5GetTrack?5could?5not?5find?5t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@CFHKAGAC@?$CFs?3?5Invalid?5pointer?5pdwGroupBits@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@LBJDIHII@Error?3?5GetTrackGroup?5could?5not?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@POOIHMED@Error?3?5InsertTrack?5called?5with?5d@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@MBGFCKPL@Error?3?5Track?5failed?5to?5initializ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@FPCABBFI@Warning?3?5RemoveTrack?5failed?5beca@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@FGIKBJAM@Error?3?5GetGraph?5failed?5because?5s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GJ@GBKIELAO@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GA@LHGCACMA@Warning?3?5Unable?5to?5remove?5reques@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GM@JGDHBIOO@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FO@BJBDGCNH@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@GDEBGBFJ@Warning?3?5Segment?5GetParam?5failed@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FO@GNGHBGLK@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@MHEHIJLM@Warning?3?5Segment?5SetParam?5failed@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@BJBAKHPF@Warning?3?5dwReadhead?5is?5less?5than@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@CFOHLKLL@Segment?3?3SetWavePlaybackParams?3?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GB@MOMCJDPJ@?$CB?$CIdwFlags?5?$CG?5?$CIDMUS_WAVEF_OFF?$CJ?$CJ?5?$CG?$CG@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0ED@IKKOIILC@Error?3?5Segment?5SetTrackConfig?5fa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FL@FDOOPLA@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EK@BGLLPLII@Warning?3?5Insertion?5of?5cloned?5tra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@KNLAPKHK@Warning?3?5Track?5clone?5failed?0?5clo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@CFDENOHG@?$CFs?3?5Invalid?5pointer?5ppAudioPathC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GI@EGHNDHOM@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@DJEFHAIL@Warning?3?5No?5embedded?5audiopath?5c@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHMDLDHF@?$CFs?3?5Invalid?5pointer?5ppComposedSe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@MOGMFKFK@Warning?3?5A?5time?5value?5of?5?$CFld?5was@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FN@HDJJPDEB@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GB@OANALOD@Error?3?5Unable?5to?5set?5start?5point@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@FIBGFLCL@?$CFs?3?5Invalid?5pointer?5pmtEnd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DKJNJEKL@Error?3?5Bad?5call?5to?5SetPChannelsU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EACKAIM@?$CFs?3?5Invalid?5pointer?5paPChannels?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FH@MFHKEMPP@Error?3?5Segment?5unable?5to?5parse?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08ELKFENNM@pIStream?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@IEHOMPKI@Error?3?5Unknown?5file?5format?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EACLOAKF@Error?3?5Invalid?5track?5header?5in?5S@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EK@MMOCDHEO@Error?3?5Invalid?5track?5in?5Segment?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KCKPANJI@pStream?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BFOKDOGK@Segment?5failed?5loading?5embedded?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@CALKDLEC@Error?3?5Segment?5unable?5to?5parse?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ?Init@CSegment@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSegment@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicSegment@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPersistStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicObjectP@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTrackList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNotificationList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSegment@@QAE@PAU_DMUS_IO_SEGMENT_HEADER@@PAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSegment@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CSegment@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Zombie@CSegment@@UAGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSegment@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CSegment@@UAGJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@CSegment@@UAGJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRepeats@CSegment@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRepeats@CSegment@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultResolution@CSegment@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDefaultResolution@CSegment@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClockTimeLength@CSegment@@UAGJ_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClockTimeLoopPoints@CSegment@@QAGJ_J0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTempoSource@CSegment@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrackByParam@CSegment@@QAEJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlay@CSegment@@QAGJPAPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClockTimeDuration@CSegment@@QAEJ_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlags@CSegment@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNotificationTypeToAllTracks@CSegment@@QAEXABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNotificationItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNotificationType@CSegment@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWavePlaybackParams@CSegment@@UAGJKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Download@CSegment@@UAGJPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@CSegment@@UAGJPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrackConfig@CSegment@@QAEJABU_GUID@@KKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComposeInternal@CSegment@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartPoint@CSegment@@UAGJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStartPoint@CSegment@@UAGJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLoopPoints@CSegment@@UAGJPAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLoopPoints@CSegment@@UAGJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPChannelsUsed@CSegment@@UAGJKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckNotification@CSegment@@QAEJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassID@CSegment@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDirty@CSegment@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CSegment@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CSegment@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSizeMax@CSegment@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadDirectMusicSegment@CSegment@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTrack@CSegment@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateTrack@CSegment@@QAEJAAU_DMUS_IO_TRACK_HEADER@@KKPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadGraph@CSegment@@QAEJPAVCRiffParser@@PAPAVCGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadAudioPath@CSegment@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CSegmentList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToReference@@YG_JJN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToMusic@@YGJ_JN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@PAVCTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@PAVCTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@PAVCTrack@@@@QAEXPAV?$TListItem@PAVCTrack@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@PAVCTrack@@@@QAE@ABQAVCTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@PAVCTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@PAVCTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@PAVCTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@WM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@WM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@WM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PrivateTempo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CSegmentList@@QAEPAVCSegment@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetStream@CRiffParser@@QAEPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Load@CSegment@@UAGJPAUIStream@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetClassID@CSegment@@UAGJPAU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetPChannelsUsed@CSegment@@UAGJKPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetLoopPoints@CSegment@@UAGJPAJ0@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetStartPoint@CSegment@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Unload@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Download@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??AddNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Cat@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCTrack@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Less@CTrack@@QAE_NPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _!=@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetDefaultResolution@CSegment@@UAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetRepeats@CSegment@@UAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetLength@CSegment@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CNotificationItem@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CTrackList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CTrack@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7IDirectMusicObjectP@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSegment@@6BIDirectMusicObjectP@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSegment@@6BIDirectMusicObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSegment@@6BIPersistStream@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSegment@@6BIDirectMusicSegment@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?g_lNewTrackID@@3JA				; g_lNewTrackID
_BSS	SEGMENT
?g_lNewTrackID@@3JA DD 01H DUP (?)			; g_lNewTrackID
_BSS	ENDS
PUBLIC	?Init@CSegment@@QAEXXZ				; CSegment::Init
EXTRN	?Init@CInfo@@QAEXXZ:NEAR			; CInfo::Init
EXTRN	__imp__RtlInitializeCriticalSection@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsegobj.cpp
;	COMDAT ?Init@CSegment@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Init@CSegment@@QAEXXZ PROC NEAR			; CSegment::Init, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 18   :     INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 19   :     m_pSong = NULL;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	c7 81 c8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+968], 0

; 20   :     m_dwNextPlayFlags = 0;

  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	c7 82 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+980], 0

; 21   :     m_dwNextPlayID = 0xFFFFFFFF;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 80 d0 03 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+976], -1

; 22   :     m_dwPlayID = 0;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	c7 81 cc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+972], 0

; 23   : 	m_mtLength = 1;

  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	c7 42 70 01 00
	00 00		 mov	 DWORD PTR [edx+112], 1

; 24   : 	m_mtStart = 0;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 25   : 	m_mtLoopStart = 0;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0

; 26   : 	m_mtLoopEnd = 0;

  00066	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00069	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], 0

; 27   :     m_rtLoopStart = 0;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], 0
  0007a	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0

; 28   :     m_rtLoopEnd = 0;

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0
  0008b	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 29   :     m_rtLength = 0;

  00092	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00095	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0
  0009c	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], 0

; 30   : 	m_dwRepeats = 0;

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 31   : 	m_dwResolution = 0;

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 32   : 	m_dwNumPChannels = 0;

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	c7 82 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+128], 0

; 33   : 	m_paPChannels = NULL;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], 0

; 34   : 	m_pGraph = NULL;

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 35   :     m_pAudioPathConfig = NULL;

  000db	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000de	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 36   : 	m_pUnkDispatch = NULL;

  000e5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], 0

; 37   :     m_dwSegFlags = 0;

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 38   : 	m_cRef = 0; 

  000fc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ff	c7 82 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+136], 0

; 39   :     m_dwVersion = 0; // Init to 6.1 behavior.

  00109	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	c7 80 bc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+956], 0

; 40   :     m_Info.Init();

  00116	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0011f	e8 00 00 00 00	 call	 ?Init@CInfo@@QAEXXZ	; CInfo::Init

; 41   :     m_fZombie = false;

  00124	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	c6 81 c0 03 00
	00 00		 mov	 BYTE PTR [ecx+960], 0

; 42   :     IncrementDLLCount();
; 43   : 	TraceI(2, "Segment %lx created\n", this );
; 44   : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
?Init@CSegment@@QAEXXZ ENDP				; CSegment::Init
_TEXT	ENDS
PUBLIC	?Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z ; CSegment::Clone
PUBLIC	?GetStartPoint@CSegment@@UAGJPAJ@Z		; CSegment::GetStartPoint
PUBLIC	?SetStartPoint@CSegment@@UAGJJ@Z		; CSegment::SetStartPoint
PUBLIC	?GetLoopPoints@CSegment@@UAGJPAJ0@Z		; CSegment::GetLoopPoints
PUBLIC	?SetLoopPoints@CSegment@@UAGJJJ@Z		; CSegment::SetLoopPoints
PUBLIC	?SetPChannelsUsed@CSegment@@UAGJKPAK@Z		; CSegment::SetPChannelsUsed
PUBLIC	?GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z	; CSegment::GetClockTimeLength
PUBLIC	?SetClockTimeLength@CSegment@@UAGJ_JH@Z		; CSegment::SetClockTimeLength
PUBLIC	??0CInfo@@QAE@XZ				; CInfo::CInfo
PUBLIC	?SetWavePlaybackParams@CSegment@@UAGJKK@Z	; CSegment::SetWavePlaybackParams
PUBLIC	?GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z ; CSegment::GetAudioPathConfig
PUBLIC	?Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU2@@Z ; CSegment::Compose
PUBLIC	?Download@CSegment@@UAGJPAUIUnknown@@@Z		; CSegment::Download
PUBLIC	?Unload@CSegment@@UAGJPAUIUnknown@@@Z		; CSegment::Unload
PUBLIC	?GetClassID@CSegment@@UAGJPAU_GUID@@@Z		; CSegment::GetClassID
PUBLIC	?IsDirty@CSegment@@UAGJXZ			; CSegment::IsDirty
PUBLIC	?Load@CSegment@@UAGJPAUIStream@@@Z		; CSegment::Load
PUBLIC	?Save@CSegment@@UAGJPAUIStream@@H@Z		; CSegment::Save
PUBLIC	?GetSizeMax@CSegment@@UAGJPAT_ULARGE_INTEGER@@@Z ; CSegment::GetSizeMax
PUBLIC	?GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z ; CSegment::GetDescriptor
PUBLIC	?SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z ; CSegment::SetDescriptor
PUBLIC	?ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z ; CSegment::ParseDescriptor
PUBLIC	?Zombie@CSegment@@UAGXXZ			; CSegment::Zombie
PUBLIC	??_7CSegment@@6BIDirectMusicSegment@@@		; CSegment::`vftable'
PUBLIC	??_7CSegment@@6BIPersistStream@@@		; CSegment::`vftable'
PUBLIC	??_7CSegment@@6BIDirectMusicObject@@@		; CSegment::`vftable'
PUBLIC	??_7CSegment@@6BIDirectMusicObjectP@@@		; CSegment::`vftable'
PUBLIC	??0IPersistStream@@QAE@XZ			; IPersistStream::IPersistStream
PUBLIC	??0IDirectMusicObject@@QAE@XZ			; IDirectMusicObject::IDirectMusicObject
PUBLIC	?QueryInterface@CSegment@@W3AGJABU_GUID@@PAPAX@Z ; CSegment::QueryInterface
PUBLIC	?AddRef@CSegment@@W3AGKXZ			; CSegment::AddRef
PUBLIC	?Release@CSegment@@W3AGKXZ			; CSegment::Release
PUBLIC	?QueryInterface@CSegment@@W7AGJABU_GUID@@PAPAX@Z ; CSegment::QueryInterface
PUBLIC	?AddRef@CSegment@@W7AGKXZ			; CSegment::AddRef
PUBLIC	?Release@CSegment@@W7AGKXZ			; CSegment::Release
PUBLIC	??0CTrackList@@QAE@XZ				; CTrackList::CTrackList
PUBLIC	?QueryInterface@CSegment@@WM@AGJABU_GUID@@PAPAX@Z ; CSegment::QueryInterface
PUBLIC	?AddRef@CSegment@@WM@AGKXZ			; CSegment::AddRef
PUBLIC	?Release@CSegment@@WM@AGKXZ			; CSegment::Release
PUBLIC	??0CNotificationList@@QAE@XZ			; CNotificationList::CNotificationList
PUBLIC	??0IDirectMusicObjectP@@QAE@XZ			; IDirectMusicObjectP::IDirectMusicObjectP
PUBLIC	??0AListItem@@QAE@XZ				; AListItem::AListItem
PUBLIC	??0CSegment@@QAE@XZ				; CSegment::CSegment
PUBLIC	?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z	; CSegment::QueryInterface
PUBLIC	?AddRef@CSegment@@UAGKXZ			; CSegment::AddRef
PUBLIC	?Release@CSegment@@UAGKXZ			; CSegment::Release
PUBLIC	?GetLength@CSegment@@UAGJPAJ@Z			; CSegment::GetLength
PUBLIC	?SetLength@CSegment@@UAGJJ@Z			; CSegment::SetLength
PUBLIC	?GetRepeats@CSegment@@UAGJPAK@Z			; CSegment::GetRepeats
PUBLIC	?SetRepeats@CSegment@@UAGJK@Z			; CSegment::SetRepeats
PUBLIC	?GetDefaultResolution@CSegment@@UAGJPAK@Z	; CSegment::GetDefaultResolution
PUBLIC	?SetDefaultResolution@CSegment@@UAGJK@Z		; CSegment::SetDefaultResolution
PUBLIC	?GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z ; CSegment::GetTrack
PUBLIC	?GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z ; CSegment::GetTrackGroup
PUBLIC	??0IDirectMusicSegment@@QAE@XZ			; IDirectMusicSegment::IDirectMusicSegment
PUBLIC	?InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z ; CSegment::InsertTrack
PUBLIC	?RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z ; CSegment::RemoveTrack
PUBLIC	?GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z ; CSegment::GetGraph
PUBLIC	?SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z ; CSegment::SetGraph
PUBLIC	?AddNotificationType@CSegment@@UAGJABU_GUID@@@Z	; CSegment::AddNotificationType
PUBLIC	?RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z ; CSegment::RemoveNotificationType
PUBLIC	?GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z	; CSegment::GetParam
PUBLIC	?SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z	; CSegment::SetParam
EXTRN	??0CMemTrack@@QAE@K@Z:NEAR			; CMemTrack::CMemTrack
;	COMDAT ??_7CSegment@@6BIDirectMusicSegment@@@
CONST	SEGMENT
??_7CSegment@@6BIDirectMusicSegment@@@ DD FLAT:?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z ; CSegment::`vftable'
	DD	FLAT:?AddRef@CSegment@@UAGKXZ
	DD	FLAT:?Release@CSegment@@UAGKXZ
	DD	FLAT:?SetRepeats@CSegment@@UAGJK@Z
	DD	FLAT:?Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU2@@Z
	DD	FLAT:?Download@CSegment@@UAGJPAUIUnknown@@@Z
	DD	FLAT:?Unload@CSegment@@UAGJPAUIUnknown@@@Z
	DD	FLAT:?GetLength@CSegment@@UAGJPAJ@Z
	DD	FLAT:?SetLength@CSegment@@UAGJJ@Z
	DD	FLAT:?SetClockTimeLength@CSegment@@UAGJ_JH@Z
	DD	FLAT:?GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z
	DD	FLAT:?SetLoopPoints@CSegment@@UAGJJJ@Z
	DD	FLAT:?GetLoopPoints@CSegment@@UAGJPAJ0@Z
	DD	FLAT:?SetStartPoint@CSegment@@UAGJJ@Z
	DD	FLAT:?GetStartPoint@CSegment@@UAGJPAJ@Z
	DD	FLAT:?SetWavePlaybackParams@CSegment@@UAGJKK@Z
	DD	FLAT:?AddNotificationType@CSegment@@UAGJABU_GUID@@@Z
	DD	FLAT:?RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z
	DD	FLAT:?GetRepeats@CSegment@@UAGJPAK@Z
	DD	FLAT:?GetDefaultResolution@CSegment@@UAGJPAK@Z
	DD	FLAT:?SetDefaultResolution@CSegment@@UAGJK@Z
	DD	FLAT:?GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z
	DD	FLAT:?GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z
	DD	FLAT:?InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z
	DD	FLAT:?RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z
	DD	FLAT:?GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z
	DD	FLAT:?SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z
	DD	FLAT:?GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z
	DD	FLAT:?SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z
	DD	FLAT:?Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z
	DD	FLAT:?SetPChannelsUsed@CSegment@@UAGJKPAK@Z
	DD	FLAT:?GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z
CONST	ENDS
;	COMDAT ??_7CSegment@@6BIPersistStream@@@
CONST	SEGMENT
??_7CSegment@@6BIPersistStream@@@ DD FLAT:?QueryInterface@CSegment@@W3AGJABU_GUID@@PAPAX@Z ; CSegment::`vftable'
	DD	FLAT:?AddRef@CSegment@@W3AGKXZ
	DD	FLAT:?Release@CSegment@@W3AGKXZ
	DD	FLAT:?GetClassID@CSegment@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@CSegment@@UAGJXZ
	DD	FLAT:?Load@CSegment@@UAGJPAUIStream@@@Z
	DD	FLAT:?Save@CSegment@@UAGJPAUIStream@@H@Z
	DD	FLAT:?GetSizeMax@CSegment@@UAGJPAT_ULARGE_INTEGER@@@Z
CONST	ENDS
;	COMDAT ??_7CSegment@@6BIDirectMusicObject@@@
CONST	SEGMENT
??_7CSegment@@6BIDirectMusicObject@@@ DD FLAT:?QueryInterface@CSegment@@W7AGJABU_GUID@@PAPAX@Z ; CSegment::`vftable'
	DD	FLAT:?AddRef@CSegment@@W7AGKXZ
	DD	FLAT:?Release@CSegment@@W7AGKXZ
	DD	FLAT:?GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z
	DD	FLAT:?SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z
	DD	FLAT:?ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z
CONST	ENDS
;	COMDAT ??_7CSegment@@6BIDirectMusicObjectP@@@
CONST	SEGMENT
??_7CSegment@@6BIDirectMusicObjectP@@@ DD FLAT:?QueryInterface@CSegment@@WM@AGJABU_GUID@@PAPAX@Z ; CSegment::`vftable'
	DD	FLAT:?AddRef@CSegment@@WM@AGKXZ
	DD	FLAT:?Release@CSegment@@WM@AGKXZ
	DD	FLAT:?Zombie@CSegment@@UAGXXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSegment@@QAE@XZ PROC NEAR				; CSegment::CSegment, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IDirectMusicSegment@@QAE@XZ
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	e8 00 00 00 00	 call	 ??0IPersistStream@@QAE@XZ
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0IDirectMusicObject@@QAE@XZ
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 10	 add	 ecx, 16			; 00000010H
  0002b	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ??0IDirectMusicObjectP@@QAE@XZ
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSegment@@6BIDirectMusicSegment@@@
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSegment@@6BIPersistStream@@@
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00051	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET FLAT:??_7CSegment@@6BIDirectMusicObject@@@
  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:??_7CSegment@@6BIDirectMusicObjectP@@@
  00062	6a 03		 push	 3
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 14	 add	 ecx, 20			; 00000014H
  0006a	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	83 c1 44	 add	 ecx, 68			; 00000044H
  00075	e8 00 00 00 00	 call	 ??0CTrackList@@QAE@XZ
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 50	 add	 ecx, 80			; 00000050H
  00080	e8 00 00 00 00	 call	 ??0CNotificationList@@QAE@XZ
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0008e	e8 00 00 00 00	 call	 ??0CInfo@@QAE@XZ	; CInfo::CInfo

; 48   :     Init();

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?Init@CSegment@@QAEXXZ	; CSegment::Init

; 49   : }

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
??0CSegment@@QAE@XZ ENDP				; CSegment::CSegment
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt
;	COMDAT ??0IDirectMusicSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicSegment@@QAE@XZ PROC NEAR		; IDirectMusicSegment::IDirectMusicSegment, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicSegment@@QAE@XZ ENDP			; IDirectMusicSegment::IDirectMusicSegment
_TEXT	ENDS
PUBLIC	??0IPersist@@QAE@XZ				; IPersist::IPersist
; Function compile flags: /Odt
;	COMDAT ??0IPersistStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPersistStream@@QAE@XZ PROC NEAR			; IPersistStream::IPersistStream, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IPersist@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IPersistStream@@QAE@XZ ENDP				; IPersistStream::IPersistStream
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicObject@@QAE@XZ PROC NEAR			; IDirectMusicObject::IDirectMusicObject, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicObject@@QAE@XZ ENDP			; IDirectMusicObject::IDirectMusicObject
_TEXT	ENDS
PUBLIC	??_7IDirectMusicObjectP@@6B@			; IDirectMusicObjectP::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IDirectMusicObjectP@@6B@
CONST	SEGMENT
??_7IDirectMusicObjectP@@6B@ DD FLAT:__purecall		; IDirectMusicObjectP::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0IDirectMusicObjectP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicObjectP@@QAE@XZ PROC NEAR		; IDirectMusicObjectP::IDirectMusicObjectP, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IDirectMusicObjectP@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0IDirectMusicObjectP@@QAE@XZ ENDP			; IDirectMusicObjectP::IDirectMusicObjectP
_TEXT	ENDS
PUBLIC	??0AList@@QAE@XZ				; AList::AList
; Function compile flags: /Odt
;	COMDAT ??0CTrackList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CTrackList@@QAE@XZ PROC NEAR				; CTrackList::CTrackList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CTrackList@@QAE@XZ ENDP				; CTrackList::CTrackList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CNotificationList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CNotificationList@@QAE@XZ PROC NEAR			; CNotificationList::CNotificationList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CNotificationList@@QAE@XZ ENDP			; CNotificationList::CNotificationList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPersist@@QAE@XZ PROC NEAR				; IPersist::IPersist, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IPersist@@QAE@XZ ENDP				; IPersist::IPersist
_TEXT	ENDS
PUBLIC	?GetNext@CTrack@@QAEPAV1@XZ			; CTrack::GetNext
PUBLIC	?GetHead@CTrackList@@QAEPAVCTrack@@XZ		; CTrackList::GetHead
PUBLIC	??0CSegment@@QAE@PAU_DMUS_IO_SEGMENT_HEADER@@PAV0@@Z ; CSegment::CSegment
EXTRN	?CreateCopyWithBlankState@CTrackList@@QAEJPAV1@@Z:NEAR ; CTrackList::CreateCopyWithBlankState
; Function compile flags: /Odt
;	COMDAT ??0CSegment@@QAE@PAU_DMUS_IO_SEGMENT_HEADER@@PAV0@@Z
_TEXT	SEGMENT
_this$ = -8
_pTrack$69446 = -4
_pHeader$ = 8
_pSource$ = 12
??0CSegment@@QAE@PAU_DMUS_IO_SEGMENT_HEADER@@PAV0@@Z PROC NEAR ; CSegment::CSegment, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0IDirectMusicSegment@@QAE@XZ
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 c1 04	 add	 ecx, 4
  00017	e8 00 00 00 00	 call	 ??0IPersistStream@@QAE@XZ
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 08	 add	 ecx, 8
  00022	e8 00 00 00 00	 call	 ??0IDirectMusicObject@@QAE@XZ
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 10	 add	 ecx, 16			; 00000010H
  0002d	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00038	e8 00 00 00 00	 call	 ??0IDirectMusicObjectP@@QAE@XZ
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSegment@@6BIDirectMusicSegment@@@
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSegment@@6BIPersistStream@@@
  00050	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00053	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET FLAT:??_7CSegment@@6BIDirectMusicObject@@@
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:??_7CSegment@@6BIDirectMusicObjectP@@@
  00064	6a 03		 push	 3
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 14	 add	 ecx, 20			; 00000014H
  0006c	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 44	 add	 ecx, 68			; 00000044H
  00077	e8 00 00 00 00	 call	 ??0CTrackList@@QAE@XZ
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 50	 add	 ecx, 80			; 00000050H
  00082	e8 00 00 00 00	 call	 ??0CNotificationList@@QAE@XZ
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00090	e8 00 00 00 00	 call	 ??0CInfo@@QAE@XZ	; CInfo::CInfo

; 54   :     Init();

  00095	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?Init@CSegment@@QAEXXZ	; CSegment::Init

; 55   :     AddRef(); // so that this doesn't get deleted in Track::Init...

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?AddRef@CSegment@@UAGKXZ ; CSegment::AddRef

; 56   :     // Force the version to at least 8 so audiopath functionality will be turned on.
; 57   :     m_dwVersion = 8;

  000a6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	c7 82 bc 03 00
	00 08 00 00 00	 mov	 DWORD PTR [edx+956], 8

; 58   :     m_dwResolution = pHeader->dwResolution;

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000b9	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000bc	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 59   : 	m_mtLength = pHeader->mtLength;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000c5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c8	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 60   : 	m_mtStart = pHeader->mtPlayStart;

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000d1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d4	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 61   : 	m_mtLoopStart = pHeader->mtLoopStart;

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000dd	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000e0	89 50 78	 mov	 DWORD PTR [eax+120], edx

; 62   : 	m_mtLoopEnd = pHeader->mtLoopEnd;

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000e9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000ec	89 50 7c	 mov	 DWORD PTR [eax+124], edx

; 63   : 	m_dwRepeats = pHeader->dwRepeats;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 64   :     m_dwSegFlags = pHeader->dwFlags;

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  00100	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00103	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 65   :     if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)

  00106	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00109	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0010c	83 e1 01	 and	 ecx, 1
  0010f	85 c9		 test	 ecx, ecx
  00111	74 14		 je	 SHORT $L69443

; 66   :     {
; 67   :         m_rtLength = pHeader->rtLength;

  00113	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00116	8b 45 08	 mov	 eax, DWORD PTR _pHeader$[ebp]
  00119	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0011c	89 4a 58	 mov	 DWORD PTR [edx+88], ecx
  0011f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00122	89 42 5c	 mov	 DWORD PTR [edx+92], eax

; 68   :     }
; 69   :     else

  00125	eb 11		 jmp	 SHORT $L69444
$L69443:

; 70   :     {
; 71   :         m_rtLength = 0; 

  00127	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0
  00131	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0
$L69444:

; 72   :     }
; 73   :     if (pSource)

  00138	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  0013c	74 4b		 je	 SHORT $L69442

; 74   :     {
; 75   :         pSource->m_TrackList.CreateCopyWithBlankState(&m_TrackList);

  0013e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00141	83 c2 44	 add	 edx, 68			; 00000044H
  00144	52		 push	 edx
  00145	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  00148	83 c1 44	 add	 ecx, 68			; 00000044H
  0014b	e8 00 00 00 00	 call	 ?CreateCopyWithBlankState@CTrackList@@QAEJPAV1@@Z ; CTrackList::CreateCopyWithBlankState

; 76   :         CTrack *pTrack = m_TrackList.GetHead();

  00150	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	83 c1 44	 add	 ecx, 68			; 00000044H
  00156	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  0015b	89 45 fc	 mov	 DWORD PTR _pTrack$69446[ebp], eax

; 77   :         for (;pTrack;pTrack = pTrack->GetNext())

  0015e	eb 0b		 jmp	 SHORT $L69447
$L69448:
  00160	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$69446[ebp]
  00163	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00168	89 45 fc	 mov	 DWORD PTR _pTrack$69446[ebp], eax
$L69447:
  0016b	83 7d fc 00	 cmp	 DWORD PTR _pTrack$69446[ebp], 0
  0016f	74 18		 je	 SHORT $L69442

; 78   :         {
; 79   :             pTrack->m_pTrack->Init( this );

  00171	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00174	50		 push	 eax
  00175	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$69446[ebp]
  00178	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0017b	8b 45 fc	 mov	 eax, DWORD PTR _pTrack$69446[ebp]
  0017e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00181	8b 12		 mov	 edx, DWORD PTR [edx]
  00183	51		 push	 ecx
  00184	ff 52 0c	 call	 DWORD PTR [edx+12]

; 80   :         }

  00187	eb d7		 jmp	 SHORT $L69448
$L69442:

; 81   :     }
; 82   : }

  00189	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 08 00	 ret	 8
??0CSegment@@QAE@PAU_DMUS_IO_SEGMENT_HEADER@@PAV0@@Z ENDP ; CSegment::CSegment
_TEXT	ENDS
PUBLIC	?Clear@CSegment@@QAEX_N@Z			; CSegment::Clear
PUBLIC	?DeleteCriticalSection@@YGXPAX@Z		; DeleteCriticalSection
PUBLIC	??1CSegment@@QAE@XZ				; CSegment::~CSegment
EXTRN	??1CMemTrack@@QAE@XZ:NEAR			; CMemTrack::~CMemTrack
; Function compile flags: /Odt
;	COMDAT ??1CSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CSegment@@QAE@XZ PROC NEAR				; CSegment::~CSegment, COMDAT
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSegment@@6BIDirectMusicSegment@@@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSegment@@6BIPersistStream@@@
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET FLAT:??_7CSegment@@6BIDirectMusicObject@@@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:??_7CSegment@@6BIDirectMusicObjectP@@@

; 86   : 	if (m_pUnkDispatch)

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 b9 8c 00 00
	00 00		 cmp	 DWORD PTR [ecx+140], 0
  00038	74 18		 je	 SHORT $L69453

; 87   : 		m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	52		 push	 edx
  0004f	ff 50 08	 call	 DWORD PTR [eax+8]
$L69453:

; 88   :     Clear(false);

  00052	6a 00		 push	 0
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?Clear@CSegment@@QAEX_N@Z ; CSegment::Clear

; 89   :     DELETE_CRITICAL_SECTION(&m_CriticalSection);

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection

; 90   :     DecrementDLLCount();
; 91   : 	TraceI(2, "Segment %lx destroyed\n", this );
; 92   : }

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	83 c1 14	 add	 ecx, 20			; 00000014H
  0006e	e8 00 00 00 00	 call	 ??1CMemTrack@@QAE@XZ	; CMemTrack::~CMemTrack
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??1CSegment@@QAE@XZ ENDP				; CSegment::~CSegment
_TEXT	ENDS
PUBLIC	?Clear@CTrackList@@QAEXXZ			; CTrackList::Clear
PUBLIC	?GetNext@CNotificationItem@@QAEPAV1@XZ		; CNotificationItem::GetNext
PUBLIC	?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
PUBLIC	?Remove@AList@@QAEXPAVAListItem@@@Z		; AList::Remove
; Function compile flags: /Odt
;	COMDAT ?Clear@CSegment@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -20
$T71854 = -16
$T71853 = -12
_pNext$69465 = -8
_pItem$69461 = -4
_fZombie$ = 8
?Clear@CSegment@@QAEX_N@Z PROC NEAR			; CSegment::Clear, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	m_TrackList.Clear();

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 44	 add	 ecx, 68			; 00000044H
  0000f	e8 00 00 00 00	 call	 ?Clear@CTrackList@@QAEXXZ ; CTrackList::Clear

; 97   :     if (m_pAudioPathConfig)

  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  0001b	74 1c		 je	 SHORT $L69459

; 98   :     {
; 99   :         m_pAudioPathConfig->Release();

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00023	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00029	8b 12		 mov	 edx, DWORD PTR [edx]
  0002b	51		 push	 ecx
  0002c	ff 52 08	 call	 DWORD PTR [edx+8]

; 100  :         m_pAudioPathConfig = NULL;

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
$L69459:

; 101  :     }
; 102  : 	SetGraph(NULL); // shut down the graph and release it

  00039	6a 00		 push	 0
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00043	50		 push	 eax
  00044	ff 52 68	 call	 DWORD PTR [edx+104]

; 103  :     // We need the following stuff to hang around if the segment is being zombied.
; 104  :     if (!fZombie)

  00047	0f b6 4d 08	 movzx	 ecx, BYTE PTR _fZombie$[ebp]
  0004b	85 c9		 test	 ecx, ecx
  0004d	0f 85 86 00 00
	00		 jne	 $L69458

; 105  :     {
; 106  : 	    // remove all notifies
; 107  : 	    CNotificationItem* pItem = m_NotificationList.GetHead();

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 50	 add	 ecx, 80			; 00000050H
  00059	e8 00 00 00 00	 call	 ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
  0005e	89 45 fc	 mov	 DWORD PTR _pItem$69461[ebp], eax
$L69463:

; 108  : 	    while( pItem )

  00061	83 7d fc 00	 cmp	 DWORD PTR _pItem$69461[ebp], 0
  00065	74 34		 je	 SHORT $L69464

; 109  : 	    {
; 110  : 		    CNotificationItem* pNext = pItem->GetNext();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$69461[ebp]
  0006a	e8 00 00 00 00	 call	 ?GetNext@CNotificationItem@@QAEPAV1@XZ ; CNotificationItem::GetNext
  0006f	89 45 f8	 mov	 DWORD PTR _pNext$69465[ebp], eax

; 111  : 		    m_NotificationList.Remove( pItem );

  00072	8b 55 fc	 mov	 edx, DWORD PTR _pItem$69461[ebp]
  00075	52		 push	 edx
  00076	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	83 c1 50	 add	 ecx, 80			; 00000050H
  0007c	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove

; 112  : 		    delete pItem;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _pItem$69461[ebp]
  00084	89 45 f4	 mov	 DWORD PTR $T71853[ebp], eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR $T71853[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00090	83 c4 04	 add	 esp, 4

; 113  : 		    pItem = pNext;

  00093	8b 55 f8	 mov	 edx, DWORD PTR _pNext$69465[ebp]
  00096	89 55 fc	 mov	 DWORD PTR _pItem$69461[ebp], edx

; 114  : 	    }

  00099	eb c6		 jmp	 SHORT $L69463
$L69464:

; 115  : 	    if( m_paPChannels )

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [eax+132], 0
  000a5	74 32		 je	 SHORT $L69458

; 116  :         {
; 117  :             delete [] m_paPChannels;

  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  000b0	89 55 f0	 mov	 DWORD PTR $T71854[ebp], edx
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T71854[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000bc	83 c4 04	 add	 esp, 4

; 118  :             m_paPChannels = NULL;

  000bf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	c7 81 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+132], 0

; 119  :             m_dwNumPChannels = 0;

  000cc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	c7 82 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+128], 0
$L69458:

; 120  :         }
; 121  :     }
; 122  : }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
?Clear@CSegment@@QAEX_N@Z ENDP				; CSegment::Clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Zombie@CSegment@@UAGXXZ
_TEXT	SEGMENT
_this$ = 8
?Zombie@CSegment@@UAGXXZ PROC NEAR			; CSegment::Zombie, COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 126  : 	Clear(true);

  00003	6a 01		 push	 1
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00008	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  0000b	e8 00 00 00 00	 call	 ?Clear@CSegment@@QAEX_N@Z ; CSegment::Clear

; 127  : 	m_fZombie = true;

  00010	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c6 80 b4 03 00
	00 01		 mov	 BYTE PTR [eax+948], 1

; 128  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?Zombie@CSegment@@UAGXXZ ENDP				; CSegment::Zombie
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ ; `string'
PUBLIC	??_C@_0DB@PCAOPAPI@Warning?3?5Segment?5queried?5for?5unk@ ; `string'
PUBLIC	_==@8
EXTRN	_CLSID_AutDirectMusicSegment:BYTE
EXTRN	_IID_IDispatch:BYTE
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
EXTRN	_DebugBreak@0:NEAR
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IDirectMusicSegment:BYTE
EXTRN	_IID_IDirectMusicObject:BYTE
EXTRN	_DirectMusicCreateInstance@16:NEAR
EXTRN	_IID_IPersistStream:BYTE
EXTRN	_IsBadReadPtr@8:NEAR
EXTRN	_IsBadWritePtr@8:NEAR
EXTRN	_IID_IDirectMusicObjectP:BYTE
EXTRN	_IID_CSegment:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'Segment::QueryInterface', 00H		; `CSegment::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ DB '%s: Invalid '
	DB	'pointer ppv', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT
??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ DB '%'
	DB	's: Invalid pointer (void*)&iid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PCAOPAPI@Warning?3?5Segment?5queried?5for?5unk@
CONST	SEGMENT
??_C@_0DB@PCAOPAPI@Warning?3?5Segment?5queried?5for?5unk@ DB 'Warning: Se'
	DB	'gment queried for unknown interface.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv147 = -12
tv140 = -8
tv133 = -4
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CSegment::QueryInterface, COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 134  : 	V_INAME(CSegment::QueryInterface);
; 135  : 	V_PTRPTR_WRITE(ppv);

  00006	6a 04		 push	 4
  00008	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69480
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69480:

; 136  : 	V_REFGUID(iid);

  0002e	6a 10		 push	 16			; 00000010H
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L69484
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L69484:

; 137  : 
; 138  : 	*ppv = NULL;

  00056	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00059	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 139  :     if (iid == IID_IUnknown || iid == IID_IDirectMusicSegment)

  0005f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00064	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _==@8
  0006d	85 c0		 test	 eax, eax
  0006f	75 12		 jne	 SHORT $L69487
  00071	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegment
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _==@8
  0007f	85 c0		 test	 eax, eax
  00081	74 0d		 je	 SHORT $L69486
$L69487:

; 140  :     {
; 141  :         *ppv = static_cast<IDirectMusicSegment*>(this);

  00083	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00086	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00089	89 02		 mov	 DWORD PTR [edx], eax

; 142  :     } 
; 143  : 	else if (iid == IID_CSegment)

  0008b	e9 56 01 00 00	 jmp	 $L69489
$L69486:
  00090	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegment
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _==@8
  0009e	85 c0		 test	 eax, eax
  000a0	74 0d		 je	 SHORT $L69490

; 144  : 	{
; 145  :         *ppv = static_cast<CSegment*>(this);

  000a2	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  000a5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	89 02		 mov	 DWORD PTR [edx], eax

; 146  : 	} 
; 147  : 	else if (iid == IID_IDirectMusicSegment8)

  000aa	e9 37 01 00 00	 jmp	 $L69489
$L69490:
  000af	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegment
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _==@8
  000bd	85 c0		 test	 eax, eax
  000bf	74 1a		 je	 SHORT $L69493

; 148  :     {
; 149  :         m_dwVersion = 8;

  000c1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	c7 82 bc 03 00
	00 08 00 00 00	 mov	 DWORD PTR [edx+956], 8

; 150  :         *ppv = static_cast<IDirectMusicSegment*>(this);

  000ce	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx

; 151  :     }
; 152  : #ifdef DXAPI
; 153  : 	else if (iid == IID_IDirectMusicSegment8P)
; 154  :     {
; 155  :         *ppv = static_cast<IDirectMusicSegment8P*>(this);
; 156  :     }
; 157  :     else if (iid == IID_IDirectMusicSegment2)
; 158  :     {
; 159  :         m_dwVersion = 2;
; 160  :         *ppv = static_cast<IDirectMusicSegment*>(this);
; 161  :     } 
; 162  : #endif
; 163  : 	else if (iid == IID_IPersistStream)

  000d6	e9 0b 01 00 00	 jmp	 $L69489
$L69493:
  000db	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 _==@8
  000e9	85 c0		 test	 eax, eax
  000eb	74 25		 je	 SHORT $L69496

; 164  : 	{
; 165  :         *ppv = static_cast<IPersistStream*>(this);

  000ed	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  000f1	74 0b		 je	 SHORT $L71861
  000f3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	83 c0 04	 add	 eax, 4
  000f9	89 45 fc	 mov	 DWORD PTR tv133[ebp], eax
  000fc	eb 07		 jmp	 SHORT $L71862
$L71861:
  000fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$L71862:
  00105	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  00108	8b 55 fc	 mov	 edx, DWORD PTR tv133[ebp]
  0010b	89 11		 mov	 DWORD PTR [ecx], edx

; 166  : 	} 
; 167  : 	else if(iid == IID_IDirectMusicObject)

  0010d	e9 d4 00 00 00	 jmp	 $L69489
$L69496:
  00112	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicObject
  00117	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _==@8
  00120	85 c0		 test	 eax, eax
  00122	74 25		 je	 SHORT $L69499

; 168  : 	{
; 169  : 		*ppv = static_cast<IDirectMusicObject*>(this);

  00124	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  00128	74 0b		 je	 SHORT $L71863
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	83 c1 08	 add	 ecx, 8
  00130	89 4d f8	 mov	 DWORD PTR tv140[ebp], ecx
  00133	eb 07		 jmp	 SHORT $L71864
$L71863:
  00135	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$L71864:
  0013c	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  0013f	8b 45 f8	 mov	 eax, DWORD PTR tv140[ebp]
  00142	89 02		 mov	 DWORD PTR [edx], eax

; 170  : 	}
; 171  : 	else if (iid == IID_IDirectMusicObjectP)

  00144	e9 9d 00 00 00	 jmp	 $L69489
$L69499:
  00149	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicObjectP
  0014e	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _==@8
  00157	85 c0		 test	 eax, eax
  00159	74 22		 je	 SHORT $L69502

; 172  : 	{
; 173  : 		*ppv = static_cast<IDirectMusicObjectP*>(this);

  0015b	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  0015f	74 0b		 je	 SHORT $L71865
  00161	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00164	83 c2 0c	 add	 edx, 12			; 0000000cH
  00167	89 55 f4	 mov	 DWORD PTR tv147[ebp], edx
  0016a	eb 07		 jmp	 SHORT $L71866
$L71865:
  0016c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
$L71866:
  00173	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00176	8b 4d f4	 mov	 ecx, DWORD PTR tv147[ebp]
  00179	89 08		 mov	 DWORD PTR [eax], ecx

; 174  : 	}
; 175  : 	else if (iid == IID_IDispatch)

  0017b	eb 69		 jmp	 SHORT $L69489
$L69502:
  0017d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  00182	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _==@8
  0018b	85 c0		 test	 eax, eax
  0018d	74 57		 je	 SHORT $L69489

; 176  : 	{
; 177  : 		// A helper scripting object implements IDispatch, which we expose from the
; 178  : 		// Performance object via COM aggregation.
; 179  : 		if (!m_pUnkDispatch)

  0018f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00192	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  00199	75 1d		 jne	 SHORT $L69506

; 180  : 		{
; 181  : 			// Create the helper object
; 182  : 			DirectMusicCreateInstance(
; 183  : 				CLSID_AutDirectMusicSegment,
; 184  : 				static_cast<IDirectMusicSegment*>(this),
; 185  : 				IID_IUnknown,
; 186  : 				reinterpret_cast<void**>(&m_pUnkDispatch));

  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  001a4	51		 push	 ecx
  001a5	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  001aa	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001ad	52		 push	 edx
  001ae	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AutDirectMusicSegment
  001b3	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
$L69506:

; 187  : 		}
; 188  : 		if (m_pUnkDispatch)

  001b8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  001c2	74 22		 je	 SHORT $L69489

; 189  : 		{
; 190  : 			return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);

  001c4	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  001c7	51		 push	 ecx
  001c8	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  001cd	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001d0	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  001df	8b 00		 mov	 eax, DWORD PTR [eax]
  001e1	52		 push	 edx
  001e2	ff 10		 call	 DWORD PTR [eax]
  001e4	eb 2c		 jmp	 SHORT $L69476
$L69489:

; 191  : 		}
; 192  : 	}
; 193  : 
; 194  : 	if (*ppv == NULL)

  001e6	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  001e9	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001ec	75 16		 jne	 SHORT $L69510

; 195  :     {
; 196  :         Trace(4,"Warning: Segment queried for unknown interface.\n");

  001ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@PCAOPAPI@Warning?3?5Segment?5queried?5for?5unk@
  001f3	6a 04		 push	 4
  001f5	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001fa	83 c4 08	 add	 esp, 8

; 197  :         return E_NOINTERFACE;

  001fd	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  00202	eb 0e		 jmp	 SHORT $L69476
$L69510:

; 198  :     }
; 199  : 
; 200  :     reinterpret_cast<IUnknown*>(this)->AddRef();

  00204	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00207	8b 02		 mov	 eax, DWORD PTR [edx]
  00209	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	51		 push	 ecx
  0020d	ff 50 04	 call	 DWORD PTR [eax+4]

; 201  :     return S_OK;

  00210	33 c0		 xor	 eax, eax
$L69476:

; 202  : }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z ENDP	; CSegment::QueryInterface
_TEXT	ENDS
PUBLIC	_IsEqualGUID@8
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==@8	PROC NEAR					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     return IsEqualGUID(guidOne,guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IsEqualGUID@8

; 190  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
_==@8	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
_TEXT	ENDS
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsegobj.cpp
;	COMDAT ?AddRef@CSegment@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CSegment@@UAGKXZ PROC NEAR			; CSegment::AddRef, COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : //    DbgPrint("A Segment %lx: %ld->%ld\n",this,m_cRef,m_cRef+1);
; 208  :     return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 209  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?AddRef@CSegment@@UAGKXZ ENDP				; CSegment::AddRef
_TEXT	ENDS
PUBLIC	??_GCSegment@@QAEPAXI@Z				; CSegment::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CSegment@@UAGKXZ
_TEXT	SEGMENT
tv73 = -12
$T71880 = -8
$T71879 = -4
_this$ = 8
?Release@CSegment@@UAGKXZ PROC NEAR			; CSegment::Release, COMDAT

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 213  : //    DbgPrint("R Segment %lx: %ld->%ld\n",this,m_cRef,m_cRef-1);
; 214  :     if (!InterlockedDecrement(&m_cRef))

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00014	85 c0		 test	 eax, eax
  00016	75 39		 jne	 SHORT $L69521

; 215  :     {
; 216  : 		m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 81 88 00 00
	00 64 00 00 00	 mov	 DWORD PTR [ecx+136], 100 ; 00000064H

; 217  :         delete this;

  00025	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00028	89 55 f8	 mov	 DWORD PTR $T71880[ebp], edx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T71880[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR $T71879[ebp], eax
  00031	83 7d fc 00	 cmp	 DWORD PTR $T71879[ebp], 0
  00035	74 0f		 je	 SHORT $L71881
  00037	6a 01		 push	 1
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T71879[ebp]
  0003c	e8 00 00 00 00	 call	 ??_GCSegment@@QAEPAXI@Z
  00041	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00044	eb 07		 jmp	 SHORT $L71882
$L71881:
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L71882:

; 218  :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 09		 jmp	 SHORT $L69520
$L69521:

; 219  :     }
; 220  : 
; 221  :     return m_cRef;

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
$L69520:

; 222  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?Release@CSegment@@UAGKXZ ENDP				; CSegment::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCSegment@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCSegment@@QAEPAXI@Z PROC NEAR			; CSegment::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSegment@@QAE@XZ	; CSegment::~CSegment
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69527
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69527:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCSegment@@QAEPAXI@Z ENDP				; CSegment::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BP@BMIEACAF@?$CFs?3?5Invalid?5pointer?5pmtLength?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetLength@CSegment@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetLength@CSegment@@UAGJPAJ@Z@4QBDB DB 'ID'
	DB	'irectMusicSegment::GetLength', 00H		; `CSegment::GetLength'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BP@BMIEACAF@?$CFs?3?5Invalid?5pointer?5pmtLength?6?$AA@
CONST	SEGMENT
??_C@_0BP@BMIEACAF@?$CFs?3?5Invalid?5pointer?5pmtLength?6?$AA@ DB '%s: In'
	DB	'valid pointer pmtLength', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetLength@CSegment@@UAGJPAJ@Z
_TEXT	SEGMENT
_this$ = 8
_pmtLength$ = 12
?GetLength@CSegment@@UAGJPAJ@Z PROC NEAR		; CSegment::GetLength, COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  : 	V_INAME(IDirectMusicSegment::GetLength);
; 228  : 	V_PTR_WRITE(pmtLength, MUSIC_TIME);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pmtLength$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69535
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetLength@CSegment@@UAGJPAJ@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BMIEACAF@?$CFs?3?5Invalid?5pointer?5pmtLength?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69535:

; 229  : #ifdef DXAPI
; 230  : 	if (m_fZombie)
; 231  : 	{
; 232  : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetLength after the segment has been garbage collected.\n");
; 233  : 		return DMUS_S_GARBAGE_COLLECTED;
; 234  : 	}
; 235  : #endif
; 236  : 	*pmtLength = m_mtLength;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtLength$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 237  : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 238  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetLength@CSegment@@UAGJPAJ@Z ENDP			; CSegment::GetLength
_TEXT	ENDS
PUBLIC	??_C@_0DP@EKMAJFDC@Error?3?5Can?5not?5set?5segment?5lengt@ ; `string'
PUBLIC	??_C@_0GM@DJIFMAEG@Error?3?5Can?5not?5set?5segment?5lengt@ ; `string'
;	COMDAT ??_C@_0DP@EKMAJFDC@Error?3?5Can?5not?5set?5segment?5lengt@
CONST	SEGMENT
??_C@_0DP@EKMAJFDC@Error?3?5Can?5not?5set?5segment?5lengt@ DB 'Error: Can'
	DB	' not set segment length to a negative number (%ld.)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@DJIFMAEG@Error?3?5Can?5not?5set?5segment?5lengt@
CONST	SEGMENT
??_C@_0GM@DJIFMAEG@Error?3?5Can?5not?5set?5segment?5lengt@ DB 'Error: Can'
	DB	' not set segment length to %ld, which is either less that the'
	DB	' start time %ld or the loop end %ld', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetLength@CSegment@@UAGJJ@Z
_TEXT	SEGMENT
_this$ = 8
_mtLength$ = 12
?SetLength@CSegment@@UAGJJ@Z PROC NEAR			; CSegment::SetLength, COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  : #if defined DXAPI || defined DBG
; 245  : 	if( mtLength <=0 )

  00003	83 7d 0c 00	 cmp	 DWORD PTR _mtLength$[ebp], 0
  00007	7f 1a		 jg	 SHORT $L69542

; 246  :     {
; 247  :         Trace(1,"Error: Can not set segment length to a negative number (%ld.)\n",mtLength);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _mtLength$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@EKMAJFDC@Error?3?5Can?5not?5set?5segment?5lengt@
  00012	6a 01		 push	 1
  00014	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 248  : 		return E_INVALIDARG;

  0001c	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00021	eb 49		 jmp	 SHORT $L69541
$L69542:

; 249  :     }
; 250  : 	if(( mtLength <= m_mtStart ) || ( mtLength < m_mtLoopEnd ))

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 0c	 mov	 edx, DWORD PTR _mtLength$[ebp]
  00029	3b 51 74	 cmp	 edx, DWORD PTR [ecx+116]
  0002c	7e 0b		 jle	 SHORT $L69546
  0002e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _mtLength$[ebp]
  00034	3b 48 7c	 cmp	 ecx, DWORD PTR [eax+124]
  00037	7d 28		 jge	 SHORT $L69545
$L69546:

; 251  :     {
; 252  :         Trace(1,"Error: Can not set segment length to %ld, which is either less that the start time %ld or the loop end %ld\n",
; 253  :             mtLength,m_mtStart,m_mtLoopEnd);

  00039	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00046	52		 push	 edx
  00047	8b 45 0c	 mov	 eax, DWORD PTR _mtLength$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GM@DJIFMAEG@Error?3?5Can?5not?5set?5segment?5lengt@
  00050	6a 01		 push	 1
  00052	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00057	83 c4 14	 add	 esp, 20			; 00000014H

; 254  : 		return DMUS_E_OUT_OF_RANGE;

  0005a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0005f	eb 0b		 jmp	 SHORT $L69541
$L69545:

; 255  :     }
; 256  : #endif
; 257  : #ifdef DXAPI
; 258  :     if (m_fZombie)
; 259  : 	{
; 260  : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetLength after the segment has been garbage collected.\n");
; 261  : 		return DMUS_S_GARBAGE_COLLECTED;
; 262  : 	}
; 263  : #endif
; 264  : 	m_mtLength = mtLength;

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 55 0c	 mov	 edx, DWORD PTR _mtLength$[ebp]
  00067	89 51 70	 mov	 DWORD PTR [ecx+112], edx

; 265  : 	return S_OK;

  0006a	33 c0		 xor	 eax, eax
$L69541:

; 266  : }

  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?SetLength@CSegment@@UAGJJ@Z ENDP			; CSegment::SetLength
_TEXT	ENDS
PUBLIC	??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetRepeats@CSegment@@UAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetRepeats@CSegment@@UAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetRepeats', 00H	; `CSegment::GetRepeats'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@
CONST	SEGMENT
??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pdwRepeats', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetRepeats@CSegment@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwRepeats$ = 12
?GetRepeats@CSegment@@UAGJPAK@Z PROC NEAR		; CSegment::GetRepeats, COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 	V_INAME(IDirectMusicSegment::GetRepeats);
; 272  : 	V_PTR_WRITE(pdwRepeats, DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwRepeats$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69557
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetRepeats@CSegment@@UAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69557:

; 273  : #ifdef DXAPI
; 274  :     if (m_fZombie)
; 275  : 	{
; 276  :         Trace(2, "Warning: Call of IDirectMusicSegment::GetRepeats after the segment has been garbage collected.\n");
; 277  : 		return DMUS_S_GARBAGE_COLLECTED;
; 278  : 	}
; 279  : #endif
; 280  : 	*pdwRepeats = m_dwRepeats;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwRepeats$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 281  : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 282  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetRepeats@CSegment@@UAGJPAK@Z ENDP			; CSegment::GetRepeats
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetRepeats@CSegment@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8
_dwRepeats$ = 12
?SetRepeats@CSegment@@UAGJK@Z PROC NEAR			; CSegment::SetRepeats, COMDAT

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : #ifdef DXAPI
; 288  :     if (m_fZombie)
; 289  : 	{
; 290  : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetRepeats after the segment has been garbage collected.\n");
; 291  : 		return DMUS_S_GARBAGE_COLLECTED;
; 292  : 	}
; 293  : #endif
; 294  : 	m_dwRepeats = dwRepeats;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwRepeats$[ebp]
  00009	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 295  : 	return S_OK;

  0000c	33 c0		 xor	 eax, eax

; 296  : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?SetRepeats@CSegment@@UAGJK@Z ENDP			; CSegment::SetRepeats
_TEXT	ENDS
PUBLIC	??_C@_0CD@DHDHGHJI@?$CFs?3?5Invalid?5pointer?5pdwResolutio@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetDefaultResolution@CSegment@@UAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetDefaultResolution@CSegment@@UAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetDefaultResolution', 00H ; `CSegment::GetDefaultResolution'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CD@DHDHGHJI@?$CFs?3?5Invalid?5pointer?5pdwResolutio@
CONST	SEGMENT
??_C@_0CD@DHDHGHJI@?$CFs?3?5Invalid?5pointer?5pdwResolutio@ DB '%s: Inval'
	DB	'id pointer pdwResolution', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetDefaultResolution@CSegment@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwResolution$ = 12
?GetDefaultResolution@CSegment@@UAGJPAK@Z PROC NEAR	; CSegment::GetDefaultResolution, COMDAT

; 300  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  : 	V_INAME(IDirectMusicSegment::GetDefaultResolution);
; 302  : 	V_PTR_WRITE(pdwResolution, DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwResolution$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69572
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDefaultResolution@CSegment@@UAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@DHDHGHJI@?$CFs?3?5Invalid?5pointer?5pdwResolutio@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69572:

; 303  : 
; 304  : #ifdef DXAPI
; 305  :     if (m_fZombie)
; 306  : 	{
; 307  : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetDefaultResolution after the segment has been garbage collected.\n");
; 308  : 
; 309  : 		return DMUS_S_GARBAGE_COLLECTED;
; 310  : 	}
; 311  : #endif
; 312  :     
; 313  : 	*pdwResolution = m_dwResolution;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwResolution$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 315  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetDefaultResolution@CSegment@@UAGJPAK@Z ENDP		; CSegment::GetDefaultResolution
_TEXT	ENDS
PUBLIC	??_C@_0FF@GMMOCCJF@Warning?3?5Attempt?5to?5set?5resoluti@ ; `string'
;	COMDAT ??_C@_0FF@GMMOCCJF@Warning?3?5Attempt?5to?5set?5resoluti@
CONST	SEGMENT
??_C@_0FF@GMMOCCJF@Warning?3?5Attempt?5to?5set?5resoluti@ DB 'Warning: At'
	DB	'tempt to set resolution includes inappropriate or non-existan'
	DB	't flag: %lx', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetDefaultResolution@CSegment@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8
_dwResolution$ = 12
?SetDefaultResolution@CSegment@@UAGJK@Z PROC NEAR	; CSegment::SetDefaultResolution, COMDAT

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 340  : #ifdef DXAPI
; 341  :     if (m_fZombie)
; 342  : 	{
; 343  : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetDefaultResolution after the segment has been garbage collected.\n");
; 344  : 		return DMUS_S_GARBAGE_COLLECTED;
; 345  : 	}
; 346  : #endif
; 347  : #ifdef DBG
; 348  :     if ((dwResolution & LEGAL_RES_FLAGS) != dwResolution)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwResolution$[ebp]
  00006	25 80 bf ef 0f	 and	 eax, 267370368		; 0fefbf80H
  0000b	3b 45 0c	 cmp	 eax, DWORD PTR _dwResolution$[ebp]
  0000e	74 19		 je	 SHORT $L69579

; 349  :     {
; 350  :         Trace(2,"Warning: Attempt to set resolution includes inappropriate or non-existant flag: %lx\n",
; 351  :             dwResolution & ~LEGAL_RES_FLAGS);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _dwResolution$[ebp]
  00013	81 e1 7f 40 10
	f0		 and	 ecx, -267370369		; f010407fH
  00019	51		 push	 ecx
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FF@GMMOCCJF@Warning?3?5Attempt?5to?5set?5resoluti@
  0001f	6a 02		 push	 2
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69579:

; 352  :     }
; 353  : #endif
; 354  : 	m_dwResolution = dwResolution;

  00029	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _dwResolution$[ebp]
  0002f	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 355  : 	return S_OK;

  00032	33 c0		 xor	 eax, eax

; 356  : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?SetDefaultResolution@CSegment@@UAGJK@Z ENDP		; CSegment::SetDefaultResolution
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetClockTimeLength@CSegment@@UAGJ_JH@Z
_TEXT	SEGMENT
_this$ = 8
_rtLength$ = 12
_fClockTime$ = 20
?SetClockTimeLength@CSegment@@UAGJ_JH@Z PROC NEAR	; CSegment::SetClockTimeLength, COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 361  :     if (rtLength > 157680000000)

  00003	83 7d 10 24	 cmp	 DWORD PTR _rtLength$[ebp+4], 36 ; 00000024H
  00007	7c 19		 jl	 SHORT $L69587
  00009	7f 09		 jg	 SHORT $L71907
  0000b	81 7d 0c 00 dc
	75 b6		 cmp	 DWORD PTR _rtLength$[ebp], -1233789952 ; b675dc00H
  00012	76 0e		 jbe	 SHORT $L69587
$L71907:

; 362  :     {
; 363  :         rtLength = 157680000000;

  00014	c7 45 0c 00 dc
	75 b6		 mov	 DWORD PTR _rtLength$[ebp], -1233789952 ; b675dc00H
  0001b	c7 45 10 24 00
	00 00		 mov	 DWORD PTR _rtLength$[ebp+4], 36 ; 00000024H
$L69587:

; 364  :     }
; 365  :     m_rtLength = rtLength;

  00022	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _rtLength$[ebp]
  00028	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _rtLength$[ebp+4]
  0002e	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 366  :     if (fClockTime) 

  00031	83 7d 14 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  00035	74 11		 je	 SHORT $L69588

; 367  :     {
; 368  :         m_dwSegFlags |= DMUS_SEGIOF_REFLENGTH;

  00037	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0003d	83 c9 01	 or	 ecx, 1
  00040	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00043	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 369  :     }
; 370  :     else

  00046	eb 0f		 jmp	 SHORT $L69589
$L69588:

; 371  :     {
; 372  :         m_dwSegFlags &= ~DMUS_SEGIOF_REFLENGTH;

  00048	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0004e	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00051	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00054	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
$L69589:

; 373  :     }
; 374  :     return S_OK;

  00057	33 c0		 xor	 eax, eax

; 375  : }

  00059	5d		 pop	 ebp
  0005a	c2 10 00	 ret	 16			; 00000010H
?SetClockTimeLength@CSegment@@UAGJ_JH@Z ENDP		; CSegment::SetClockTimeLength
_TEXT	ENDS
PUBLIC	??_C@_0BP@MKCBNIGA@?$CFs?3?5Invalid?5pointer?5prtLength?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@ENKCIHOK@?$CFs?3?5Invalid?5pointer?5pfClockTime?6@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetClockTimeLength', 00H ; `CSegment::GetClockTimeLength'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BP@MKCBNIGA@?$CFs?3?5Invalid?5pointer?5prtLength?6?$AA@
CONST	SEGMENT
??_C@_0BP@MKCBNIGA@?$CFs?3?5Invalid?5pointer?5prtLength?6?$AA@ DB '%s: In'
	DB	'valid pointer prtLength', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ENKCIHOK@?$CFs?3?5Invalid?5pointer?5pfClockTime?6@
CONST	SEGMENT
??_C@_0CB@ENKCIHOK@?$CFs?3?5Invalid?5pointer?5pfClockTime?6@ DB '%s: Inva'
	DB	'lid pointer pfClockTime', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z
_TEXT	SEGMENT
tv85 = -8
tv91 = -4
_this$ = 8
_prtLength$ = 12
_pfClockTime$ = 16
?GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z PROC NEAR	; CSegment::GetClockTimeLength, COMDAT

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 380  : 	V_INAME(IDirectMusicSegment::GetClockTimeLength);
; 381  : 	V_PTR_WRITE(prtLength,REFERENCE_TIME);

  00006	6a 08		 push	 8
  00008	8b 45 0c	 mov	 eax, DWORD PTR _prtLength$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69599
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@MKCBNIGA@?$CFs?3?5Invalid?5pointer?5prtLength?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69599:

; 382  : 	V_PTR_WRITE(pfClockTime,BOOL);

  0002e	6a 04		 push	 4
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _pfClockTime$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L69602
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@ENKCIHOK@?$CFs?3?5Invalid?5pointer?5pfClockTime?6@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L69602:

; 383  :     if (m_rtLength >= 157680000000)

  00056	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00059	89 55 fc	 mov	 DWORD PTR tv91[ebp], edx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR tv91[ebp]
  0005f	83 78 5c 24	 cmp	 DWORD PTR [eax+92], 36	; 00000024H
  00063	7c 20		 jl	 SHORT $L69604
  00065	7f 0c		 jg	 SHORT $L71913
  00067	8b 4d fc	 mov	 ecx, DWORD PTR tv91[ebp]
  0006a	81 79 58 00 dc
	75 b6		 cmp	 DWORD PTR [ecx+88], -1233789952 ; b675dc00H
  00071	72 12		 jb	 SHORT $L69604
$L71913:

; 384  :     {
; 385  :         *prtLength = 0x7FFFFFFFFFFFFFFF;

  00073	8b 55 0c	 mov	 edx, DWORD PTR _prtLength$[ebp]
  00076	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  0007c	c7 42 04 ff ff
	ff 7f		 mov	 DWORD PTR [edx+4], 2147483647 ; 7fffffffH

; 386  :     }
; 387  :     else

  00083	eb 11		 jmp	 SHORT $L69605
$L69604:

; 388  :     {
; 389  :         *prtLength = m_rtLength;

  00085	8b 45 0c	 mov	 eax, DWORD PTR _prtLength$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0008e	89 10		 mov	 DWORD PTR [eax], edx
  00090	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  00093	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L69605:

; 390  :     }
; 391  :     *pfClockTime = (TRUE && (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)); 

  00096	ba 01 00 00 00	 mov	 edx, 1
  0009b	85 d2		 test	 edx, edx
  0009d	74 16		 je	 SHORT $L71911
  0009f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000a5	83 e1 01	 and	 ecx, 1
  000a8	85 c9		 test	 ecx, ecx
  000aa	74 09		 je	 SHORT $L71911
  000ac	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
  000b3	eb 07		 jmp	 SHORT $L71912
$L71911:
  000b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
$L71912:
  000bc	8b 55 10	 mov	 edx, DWORD PTR _pfClockTime$[ebp]
  000bf	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  000c2	89 02		 mov	 DWORD PTR [edx], eax

; 392  :     return S_OK;

  000c4	33 c0		 xor	 eax, eax

; 393  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 0c 00	 ret	 12			; 0000000cH
?GetClockTimeLength@CSegment@@UAGJPA_JPAH@Z ENDP	; CSegment::GetClockTimeLength
_TEXT	ENDS
PUBLIC	?SetClockTimeLoopPoints@CSegment@@QAGJ_J0@Z	; CSegment::SetClockTimeLoopPoints
; Function compile flags: /Odt
;	COMDAT ?SetClockTimeLoopPoints@CSegment@@QAGJ_J0@Z
_TEXT	SEGMENT
_this$ = 8
_rtStart$ = 12
_rtEnd$ = 20
?SetClockTimeLoopPoints@CSegment@@QAGJ_J0@Z PROC NEAR	; CSegment::SetClockTimeLoopPoints, COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 398  :     m_rtLoopStart = rtStart;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _rtStart$[ebp]
  00009	89 48 60	 mov	 DWORD PTR [eax+96], ecx
  0000c	8b 55 10	 mov	 edx, DWORD PTR _rtStart$[ebp+4]
  0000f	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 399  :     m_rtLoopEnd = rtEnd;

  00012	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR _rtEnd$[ebp]
  00018	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  0001b	8b 55 18	 mov	 edx, DWORD PTR _rtEnd$[ebp+4]
  0001e	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 400  :     return S_OK;

  00021	33 c0		 xor	 eax, eax

; 401  : }

  00023	5d		 pop	 ebp
  00024	c2 14 00	 ret	 20			; 00000014H
?SetClockTimeLoopPoints@CSegment@@QAGJ_J0@Z ENDP	; CSegment::SetClockTimeLoopPoints
_TEXT	ENDS
PUBLIC	?GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z	; CSegment::GetClockTimeLoopPoints
PUBLIC	??_C@_0BO@JAIPAHKP@?$CFs?3?5Invalid?5pointer?5prtStart?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@MJIALHAM@?$CFs?3?5Invalid?5pointer?5prtEnd?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetClockTimeLength', 00H ; `CSegment::GetClockTimeLoopPoints'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@JAIPAHKP@?$CFs?3?5Invalid?5pointer?5prtStart?6?$AA@
CONST	SEGMENT
??_C@_0BO@JAIPAHKP@?$CFs?3?5Invalid?5pointer?5prtStart?6?$AA@ DB '%s: Inv'
	DB	'alid pointer prtStart', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MJIALHAM@?$CFs?3?5Invalid?5pointer?5prtEnd?6?$AA@
CONST	SEGMENT
??_C@_0BM@MJIALHAM@?$CFs?3?5Invalid?5pointer?5prtEnd?6?$AA@ DB '%s: Inval'
	DB	'id pointer prtEnd', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z
_TEXT	SEGMENT
_this$ = 8
_prtStart$ = 12
_prtEnd$ = 16
?GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z PROC NEAR	; CSegment::GetClockTimeLoopPoints, COMDAT

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 405  : 	V_INAME(IDirectMusicSegment::GetClockTimeLength);
; 406  : 	V_PTR_WRITE(prtStart,REFERENCE_TIME);

  00003	6a 08		 push	 8
  00005	8b 45 0c	 mov	 eax, DWORD PTR _prtStart$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69621
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@JAIPAHKP@?$CFs?3?5Invalid?5pointer?5prtStart?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69621:

; 407  : 	V_PTR_WRITE(prtEnd,REFERENCE_TIME);

  0002b	6a 08		 push	 8
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _prtEnd$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00036	85 c0		 test	 eax, eax
  00038	74 19		 je	 SHORT $L69624
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z@4QBDB
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MJIALHAM@?$CFs?3?5Invalid?5pointer?5prtEnd?6?$AA@
  00044	6a ff		 push	 -1
  00046	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	e8 00 00 00 00	 call	 _DebugBreak@0
$L69624:

; 408  :     *prtStart = m_rtLoopStart;

  00053	8b 55 0c	 mov	 edx, DWORD PTR _prtStart$[ebp]
  00056	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0005c	89 0a		 mov	 DWORD PTR [edx], ecx
  0005e	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00061	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 409  :     *prtEnd = m_rtLoopEnd;

  00064	8b 4d 10	 mov	 ecx, DWORD PTR _prtEnd$[ebp]
  00067	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0006d	89 01		 mov	 DWORD PTR [ecx], eax
  0006f	8b 52 6c	 mov	 edx, DWORD PTR [edx+108]
  00072	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 410  :     return S_OK;

  00075	33 c0		 xor	 eax, eax

; 411  : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?GetClockTimeLoopPoints@CSegment@@QAGJPA_J0@Z ENDP	; CSegment::GetClockTimeLoopPoints
_TEXT	ENDS
PUBLIC	??_C@_0EC@ODGPLPH@Error?3?5GetTrack?5could?5not?5find?5t@ ; `string'
PUBLIC	?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegment::GetTrack
PUBLIC	??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@ ; `string'
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetTrack', 00H		; `CSegment::GetTrack'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@
CONST	SEGMENT
??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@ DB '%s: Inva'
	DB	'lid pointer ppTrack', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@ODGPLPH@Error?3?5GetTrack?5could?5not?5find?5t@
CONST	SEGMENT
??_C@_0EC@ODGPLPH@Error?3?5GetTrack?5could?5not?5find?5t@ DB 'Error: GetT'
	DB	'rack could not find the requested track at index %ld.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT
_hr$ = -8
_pCTrack$ = -4
_this$ = 8
_rType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_ppTrack$ = 24
?GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z PROC NEAR ; CSegment::GetTrack, COMDAT

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 559  : 	V_INAME(IDirectMusicSegment::GetTrack);
; 560  : 	V_PTRPTR_WRITE(ppTrack);

  00006	6a 04		 push	 4
  00008	8b 45 18	 mov	 eax, DWORD PTR _ppTrack$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69637
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69637:

; 561  : 
; 562  : #ifdef DXAPI
; 563  :     if (m_fZombie)
; 564  : 	{
; 565  : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetTrack after the segment has been garbage collected.\n");
; 566  : 		return DMUS_S_GARBAGE_COLLECTED;
; 567  : 	}
; 568  : #endif
; 569  :     
; 570  : 	CTrack* pCTrack;
; 571  :     HRESULT hr;
; 572  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 573  :     pCTrack = GetTrack(rType,dwGroupBits,dwIndex);

  0003b	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 10	 mov	 eax, DWORD PTR _dwGroupBits$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _rType$[ebp]
  00046	51		 push	 ecx
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegment::GetTrack
  0004f	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 574  :     if (pCTrack)

  00052	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00056	74 26		 je	 SHORT $L69640

; 575  :     {
; 576  : 	    *ppTrack = pCTrack->m_pTrack;

  00058	8b 55 18	 mov	 edx, DWORD PTR _ppTrack$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0005e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx

; 577  : 		pCTrack->m_pTrack->AddRef();

  00063	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00066	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0006c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	52		 push	 edx
  00072	ff 50 04	 call	 DWORD PTR [eax+4]

; 578  :         hr = S_OK;

  00075	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 579  :     }
; 580  :     else 

  0007c	eb 1a		 jmp	 SHORT $L69642
$L69640:

; 581  :     {
; 582  :         Trace(2,"Error: GetTrack could not find the requested track at index %ld.\n",dwIndex);

  0007e	8b 4d 14	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00081	51		 push	 ecx
  00082	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EC@ODGPLPH@Error?3?5GetTrack?5could?5not?5find?5t@
  00087	6a 02		 push	 2
  00089	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 583  :         hr = DMUS_E_NOT_FOUND;

  00091	c7 45 f8 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
$L69642:

; 584  :     }
; 585  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00098	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	83 c2 1c	 add	 edx, 28			; 0000001cH
  0009e	52		 push	 edx
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 586  : 	return hr;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 587  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 14 00	 ret	 20			; 00000014H
?GetTrack@CSegment@@UAGJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z ENDP ; CSegment::GetTrack
_TEXT	ENDS
PUBLIC	??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@	; `string'
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
EXTRN	__imp__RtlAssert@16:NEAR
;	COMDAT ??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\dmsegobj.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
CONST	SEGMENT
??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@ DB 'pCTrack->m_pTrack', 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z
_TEXT	SEGMENT
_this$ = -8
_pCTrack$ = -4
_rType$ = 8
_dwGroupBits$ = 12
_dwIndex$ = 16
?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z PROC NEAR ; CSegment::GetTrack, COMDAT
; _this$ = ecx

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 594  : 	CTrack* pCTrack;
; 595  : 	pCTrack = m_TrackList.GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 44	 add	 ecx, 68			; 00000044H
  0000f	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69656:

; 596  : 	while( pCTrack )

  00017	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0001b	74 71		 je	 SHORT $L69657

; 597  : 	{
; 598  : 		ASSERT(pCTrack->m_pTrack);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00020	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00024	75 17		 jne	 SHORT $L69658
  00026	6a 00		 push	 0
  00028	68 56 02 00 00	 push	 598			; 00000256H
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69658:

; 599  : 		if( pCTrack->m_dwGroupBits & dwGroupBits )

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00040	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00043	23 55 0c	 and	 edx, DWORD PTR _dwGroupBits$[ebp]
  00046	85 d2		 test	 edx, edx
  00048	74 37		 je	 SHORT $L69661

; 600  : 		{
; 601  : 			if( (GUID_NULL == rType) || (pCTrack->m_guidClassID == rType))

  0004a	8b 45 08	 mov	 eax, DWORD PTR _rType$[ebp]
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  00053	e8 00 00 00 00	 call	 _==@8
  00058	85 c0		 test	 eax, eax
  0005a	75 14		 jne	 SHORT $L69664
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _rType$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00063	83 c2 04	 add	 edx, 4
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _==@8
  0006c	85 c0		 test	 eax, eax
  0006e	74 11		 je	 SHORT $L69661
$L69664:

; 602  : 			{
; 603  : 				if( 0 == dwIndex )

  00070	83 7d 10 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00074	75 02		 jne	 SHORT $L69665

; 604  : 				{
; 605  :                     break;

  00076	eb 16		 jmp	 SHORT $L69657
$L69665:

; 606  : 				}
; 607  : 				dwIndex--;

  00078	8b 45 10	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0007b	83 e8 01	 sub	 eax, 1
  0007e	89 45 10	 mov	 DWORD PTR _dwIndex$[ebp], eax
$L69661:

; 608  : 			}
; 609  : 		}
; 610  : 		pCTrack = pCTrack->GetNext();

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00084	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00089	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 611  : 	}

  0008c	eb 89		 jmp	 SHORT $L69656
$L69657:

; 612  : 	return pCTrack;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]

; 613  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z ENDP	; CSegment::GetTrack
_TEXT	ENDS
PUBLIC	?IsTempoSource@CSegment@@QAEHXZ			; CSegment::IsTempoSource
PUBLIC	?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z ; CSegment::GetTrackByParam
EXTRN	_GUID_TempoParam:BYTE
; Function compile flags: /Odt
;	COMDAT ?IsTempoSource@CSegment@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8
_fHasTempo$ = -4
?IsTempoSource@CSegment@@QAEHXZ PROC NEAR		; CSegment::IsTempoSource, COMDAT
; _this$ = ecx

; 617  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 618  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 619  :     BOOL fHasTempo = (NULL != GetTrackByParam(NULL, GUID_TempoParam,-1,0, FALSE));

  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a ff		 push	 -1
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TempoParam
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z ; CSegment::GetTrackByParam
  0002b	f7 d8		 neg	 eax
  0002d	1b c0		 sbb	 eax, eax
  0002f	f7 d8		 neg	 eax
  00031	89 45 fc	 mov	 DWORD PTR _fHasTempo$[ebp], eax

; 620  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 621  :     return fHasTempo;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _fHasTempo$[ebp]

; 622  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?IsTempoSource@CSegment@@QAEHXZ ENDP			; CSegment::IsTempoSource
_TEXT	ENDS
PUBLIC	??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@CFHKAGAC@?$CFs?3?5Invalid?5pointer?5pdwGroupBits@ ; `string'
PUBLIC	??_C@_0DK@LBJDIHII@Error?3?5GetTrackGroup?5could?5not?5f@ ; `string'
EXTRN	_IsBadCodePtr@4:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetTrackGroup', 00H	; `CSegment::GetTrackGroup'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
CONST	SEGMENT
??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@ DB '%s: Inval'
	DB	'id pointer pTrack', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CFHKAGAC@?$CFs?3?5Invalid?5pointer?5pdwGroupBits@
CONST	SEGMENT
??_C@_0CC@CFHKAGAC@?$CFs?3?5Invalid?5pointer?5pdwGroupBits@ DB '%s: Inval'
	DB	'id pointer pdwGroupBits', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LBJDIHII@Error?3?5GetTrackGroup?5could?5not?5f@
CONST	SEGMENT
??_C@_0DK@LBJDIHII@Error?3?5GetTrackGroup?5could?5not?5f@ DB 'Error: GetT'
	DB	'rackGroup could not find the requested track.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z
_TEXT	SEGMENT
_hr$ = -8
_pCTrack$ = -4
_this$ = 8
_pTrack$ = 12
_pdwGroupBits$ = 16
?GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z PROC NEAR ; CSegment::GetTrackGroup, COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 630  : 	V_INAME(IDirectMusicSegment::GetTrackGroup);
; 631  : 	V_INTERFACE(pTrack);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69678
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69678:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L69682
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L69682:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L69684
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L69684:

; 632  : 	V_PTR_WRITE(pdwGroupBits,DWORD);

  00082	6a 04		 push	 4
  00084	8b 45 10	 mov	 eax, DWORD PTR _pdwGroupBits$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0008d	85 c0		 test	 eax, eax
  0008f	74 19		 je	 SHORT $L69686
  00091	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z@4QBDB
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@CFHKAGAC@?$CFs?3?5Invalid?5pointer?5pdwGroupBits@
  0009b	6a ff		 push	 -1
  0009d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	e8 00 00 00 00	 call	 _DebugBreak@0
$L69686:

; 633  : 
; 634  : #ifdef DXAPI
; 635  :     if (m_fZombie)
; 636  : 	{
; 637  : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetTrackGroup after the segment has been garbage collected.\n");
; 638  : 		return DMUS_S_GARBAGE_COLLECTED;
; 639  : 	}
; 640  : #endif
; 641  :     
; 642  : 	CTrack* pCTrack;
; 643  :     HRESULT hr = DMUS_E_NOT_FOUND;

  000aa	c7 45 f8 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H

; 644  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000b7	51		 push	 ecx
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 645  : 	pCTrack = m_TrackList.GetHead();

  000be	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	83 c1 44	 add	 ecx, 68			; 00000044H
  000c4	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  000c9	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69695:

; 646  : 	while( pCTrack )

  000cc	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  000d0	74 4c		 je	 SHORT $L69696

; 647  : 	{
; 648  : 		ASSERT(pCTrack->m_pTrack);

  000d2	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  000d5	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  000d9	75 17		 jne	 SHORT $L69697
  000db	6a 00		 push	 0
  000dd	68 88 02 00 00	 push	 648			; 00000288H
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  000e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69697:

; 649  : 		if( pCTrack->m_pTrack == pTrack )

  000f2	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000f5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000f8	3b 4d 0c	 cmp	 ecx, DWORD PTR _pTrack$[ebp]
  000fb	75 14		 jne	 SHORT $L69698

; 650  : 		{
; 651  : 			*pdwGroupBits = pCTrack->m_dwGroupBits;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _pdwGroupBits$[ebp]
  00100	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00103	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00106	89 0a		 mov	 DWORD PTR [edx], ecx

; 652  : 			hr = S_OK;

  00108	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 653  :             break;

  0010f	eb 0d		 jmp	 SHORT $L69696
$L69698:

; 654  : 		}
; 655  : 		pCTrack = pCTrack->GetNext();

  00111	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00114	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00119	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 656  : 	}

  0011c	eb ae		 jmp	 SHORT $L69695
$L69696:

; 657  : #ifdef DBG
; 658  :     if (hr == DMUS_E_NOT_FOUND)

  0011e	81 7d f8 61 11
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
  00125	75 0f		 jne	 SHORT $L69704

; 659  :     {
; 660  :         Trace(2,"Error: GetTrackGroup could not find the requested track.\n");

  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@LBJDIHII@Error?3?5GetTrackGroup?5could?5not?5f@
  0012c	6a 02		 push	 2
  0012e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00133	83 c4 08	 add	 esp, 8
$L69704:

; 661  :     }
; 662  : #endif
; 663  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00136	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00139	83 c2 1c	 add	 edx, 28			; 0000001cH
  0013c	52		 push	 edx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 664  : 	return hr;

  00143	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 665  : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 0c 00	 ret	 12			; 0000000cH
?GetTrackGroup@CSegment@@UAGJPAUIDirectMusicTrack@@PAK@Z ENDP ; CSegment::GetTrackGroup
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z
_TEXT	SEGMENT
_this$ = -4
_pCTrack$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_fDontCheck$ = 24
?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z PROC NEAR ; CSegment::GetTrackByParam, COMDAT
; _this$ = ecx

; 669  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 670  : 	// If the caller was already part way through the list, it passes the current
; 671  :     // track. Otherwise, NULL to indicate start at the top.
; 672  :     if (pCTrack)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0000b	74 0d		 je	 SHORT $L69714

; 673  :     {
; 674  :         pCTrack = pCTrack->GetNext();

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00015	89 45 08	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 675  :     }
; 676  :     else

  00018	eb 0e		 jmp	 SHORT $L69717
$L69714:

; 677  :     {
; 678  : 	    pCTrack = m_TrackList.GetHead();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 44	 add	 ecx, 68			; 00000044H
  00020	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00025	89 45 08	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69717:

; 679  :     }
; 680  : 	while( pCTrack )

  00028	83 7d 08 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0002c	0f 84 90 00 00
	00		 je	 $L69718

; 681  : 	{
; 682  : 		ASSERT(pCTrack->m_pTrack);

  00032	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00035	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00039	75 17		 jne	 SHORT $L69719
  0003b	6a 00		 push	 0
  0003d	68 aa 02 00 00	 push	 682			; 000002aaH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69719:

; 683  : 		if( (pCTrack->m_dwGroupBits & dwGroupBits ) && (fDontCheck ||
; 684  :             (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED)))

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00055	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00058	23 55 10	 and	 edx, DWORD PTR _dwGroupBits$[ebp]
  0005b	85 d2		 test	 edx, edx
  0005d	74 53		 je	 SHORT $L69720
  0005f	83 7d 18 00	 cmp	 DWORD PTR _fDontCheck$[ebp], 0
  00063	75 0d		 jne	 SHORT $L69721
  00065	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00068	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006b	83 e1 08	 and	 ecx, 8
  0006e	85 c9		 test	 ecx, ecx
  00070	74 40		 je	 SHORT $L69720
$L69721:

; 685  : 		{
; 686  : 			if( (GUID_NULL == rguidType) || 
; 687  :                 (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))

  00072	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  00075	52		 push	 edx
  00076	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  0007b	e8 00 00 00 00	 call	 _==@8
  00080	85 c0		 test	 eax, eax
  00082	75 1a		 jne	 SHORT $L69724
  00084	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0008b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008e	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00091	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00094	8b 12		 mov	 edx, DWORD PTR [edx]
  00096	51		 push	 ecx
  00097	ff 52 24	 call	 DWORD PTR [edx+36]
  0009a	85 c0		 test	 eax, eax
  0009c	75 14		 jne	 SHORT $L69720
$L69724:

; 688  : 			{
; 689  : 				if( 0 == dwIndex )

  0009e	83 7d 14 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  000a2	75 05		 jne	 SHORT $L69725

; 690  : 				{
; 691  :                     return pCTrack;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000a7	eb 1b		 jmp	 SHORT $L69713
$L69725:

; 692  : 				}
; 693  : 				dwIndex--;

  000a9	8b 45 14	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  000ac	83 e8 01	 sub	 eax, 1
  000af	89 45 14	 mov	 DWORD PTR _dwIndex$[ebp], eax
$L69720:

; 694  : 			}
; 695  : 		}
; 696  : 		pCTrack = pCTrack->GetNext();

  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000b5	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  000ba	89 45 08	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 697  : 	}

  000bd	e9 66 ff ff ff	 jmp	 $L69717
$L69718:

; 698  :     return NULL;

  000c2	33 c0		 xor	 eax, eax
$L69713:

; 699  : }

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 14 00	 ret	 20			; 00000014H
?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z ENDP ; CSegment::GetTrackByParam
_TEXT	ENDS
PUBLIC	?GetTrackByParam@CSegment@@QAEJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z ; CSegment::GetTrackByParam
; Function compile flags: /Odt
;	COMDAT ?GetTrackByParam@CSegment@@QAEJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_pCTrack$ = -4
_rguidType$ = 8
_dwGroupBits$ = 12
_dwIndex$ = 16
_ppTrack$ = 20
?GetTrackByParam@CSegment@@QAEJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z PROC NEAR ; CSegment::GetTrackByParam, COMDAT
; _this$ = ecx

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :     HRESULT hr;
; 718  : 	CTrack* pCTrack;
; 719  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 720  : 	pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,TRUE);

  00016	6a 01		 push	 1
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00023	50		 push	 eax
  00024	6a 00		 push	 0
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z ; CSegment::GetTrackByParam
  0002e	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 721  : 	if (pCTrack)

  00031	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00035	74 26		 je	 SHORT $L69735

; 722  :     {
; 723  : 		*ppTrack = pCTrack->m_pTrack;

  00037	8b 4d 14	 mov	 ecx, DWORD PTR _ppTrack$[ebp]
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  0003d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00040	89 01		 mov	 DWORD PTR [ecx], eax

; 724  : 		pCTrack->m_pTrack->AddRef();

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00045	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00048	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0004b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004e	8b 12		 mov	 edx, DWORD PTR [edx]
  00050	51		 push	 ecx
  00051	ff 52 04	 call	 DWORD PTR [edx+4]

; 725  : 		hr = S_OK;

  00054	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 726  : 	}
; 727  :     else

  0005b	eb 07		 jmp	 SHORT $L69737
$L69735:

; 728  :     {
; 729  :         hr = DMUS_E_NOT_FOUND;

  0005d	c7 45 f8 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
$L69737:

; 730  :         // Don't think we need an error message here since SetParam also does one...
; 731  :         // Trace(1,"Error: Could not find the requested track for SetParam.\n");
; 732  :     }
; 733  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 c0 1c	 add	 eax, 28			; 0000001cH
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 734  : 	return hr;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 735  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 10 00	 ret	 16			; 00000010H
?GetTrackByParam@CSegment@@QAEJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z ENDP ; CSegment::GetTrackByParam
_TEXT	ENDS
PUBLIC	?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z ; CSegment::InsertTrack
;	COMDAT ?__szValidateInterfaceName@?1??InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::InsertTrack', 00H	; `CSegment::InsertTrack'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z
_TEXT	SEGMENT
_this$ = 8
_pTrack$ = 12
_dwGroupBits$ = 16
?InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z PROC NEAR ; CSegment::InsertTrack, COMDAT

; 741  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 742  : 	V_INAME(IDirectMusicSegment::InsertTrack);
; 743  : 	V_INTERFACE(pTrack);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69750
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69750:
  0002b	6a 04		 push	 4
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00030	8b 11		 mov	 edx, DWORD PTR [ecx]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $L69753
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z@4QBDB
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  00046	6a ff		 push	 -1
  00048	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 _DebugBreak@0
$L69753:
  00055	8b 45 0c	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00062	85 c0		 test	 eax, eax
  00064	74 19		 je	 SHORT $L69755
  00066	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z@4QBDB
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  00070	6a ff		 push	 -1
  00072	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	e8 00 00 00 00	 call	 _DebugBreak@0
$L69755:

; 744  : #ifdef DXAPI
; 745  :     if (m_fZombie)
; 746  : 	{
; 747  : 		Trace(2, "Warning: Call of IDirectMusicSegment::InsertTrack after the segment has been garbage collected.\n");
; 748  : 		return DMUS_S_GARBAGE_COLLECTED;
; 749  : 	}
; 750  : #endif	
; 751  :     return InsertTrack(pTrack,dwGroupBits,DMUS_TRACKCONFIG_DEFAULT,0, 0);

  0007f	6a 00		 push	 0
  00081	6a 00		 push	 0
  00083	6a 38		 push	 56			; 00000038H
  00085	8b 45 10	 mov	 eax, DWORD PTR _dwGroupBits$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z ; CSegment::InsertTrack

; 752  : }

  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
?InsertTrack@CSegment@@UAGJPAUIDirectMusicTrack@@K@Z ENDP ; CSegment::InsertTrack
_TEXT	ENDS
PUBLIC	??_C@_0DG@POOIHMED@Error?3?5InsertTrack?5called?5with?5d@ ; `string'
PUBLIC	?Less@CTrack@@QAE_NPAV1@@Z			; CTrack::Less
PUBLIC	?SetNext@AListItem@@QAEXPAV1@@Z			; AListItem::SetNext
PUBLIC	?AddHead@AList@@QAEXPAVAListItem@@@Z		; AList::AddHead
EXTRN	_IID_IDirectMusicTrack8:BYTE
EXTRN	??0CTrack@@QAE@XZ:NEAR				; CTrack::CTrack
;	COMDAT ??_C@_0DG@POOIHMED@Error?3?5InsertTrack?5called?5with?5d@
CONST	SEGMENT
??_C@_0DG@POOIHMED@Error?3?5InsertTrack?5called?5with?5d@ DB 'Error: Inse'
	DB	'rtTrack called with dwGroupBits set to 0.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z
_TEXT	SEGMENT
tv78 = -32
_this$ = -28
$T71944 = -24
_pScan$ = -20
_pPrevTrack$ = -16
_pCTrack$ = -12
_pItem$ = -8
_pPersist$ = -4
_pTrack$ = 8
_dwGroupBits$ = 12
_dwFlags$ = 16
_dwPriority$ = 20
_dwPosition$ = 24
?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z PROC NEAR ; CSegment::InsertTrack, COMDAT
; _this$ = ecx

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 761  : 	CTrack* pCTrack;
; 762  : 	
; 763  : 	if( 0 == dwGroupBits )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _dwGroupBits$[ebp], 0
  0000d	75 19		 jne	 SHORT $L69765

; 764  :     {
; 765  :         Trace(1,"Error: InsertTrack called with dwGroupBits set to 0.\n");

  0000f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@POOIHMED@Error?3?5InsertTrack?5called?5with?5d@
  00014	6a 01		 push	 1
  00016	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0001b	83 c4 08	 add	 esp, 8

; 766  : 		return E_INVALIDARG;

  0001e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00023	e9 a6 01 00 00	 jmp	 $L69763
$L69765:

; 767  :     }
; 768  : 	if( FAILED( pTrack->Init( this ) ))

  00028	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	8b 45 08	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00034	50		 push	 eax
  00035	ff 52 0c	 call	 DWORD PTR [edx+12]
  00038	85 c0		 test	 eax, eax
  0003a	7d 0a		 jge	 SHORT $L69769

; 769  : 	{
; 770  :         TraceI(1,"Error: Track failed to initialize\n");
; 771  : 		return DMUS_E_NOT_INIT;

  0003c	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  00041	e9 88 01 00 00	 jmp	 $L69763
$L69769:

; 772  : 	}
; 773  : 	pCTrack = new CTrack;

  00046	6a 3c		 push	 60			; 0000003cH
  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004d	83 c4 04	 add	 esp, 4
  00050	89 45 e8	 mov	 DWORD PTR $T71944[ebp], eax
  00053	83 7d e8 00	 cmp	 DWORD PTR $T71944[ebp], 0
  00057	74 0d		 je	 SHORT $L71945
  00059	8b 4d e8	 mov	 ecx, DWORD PTR $T71944[ebp]
  0005c	e8 00 00 00 00	 call	 ??0CTrack@@QAE@XZ	; CTrack::CTrack
  00061	89 45 e0	 mov	 DWORD PTR tv78[ebp], eax
  00064	eb 07		 jmp	 SHORT $L71946
$L71945:
  00066	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$L71946:
  0006d	8b 4d e0	 mov	 ecx, DWORD PTR tv78[ebp]
  00070	89 4d f4	 mov	 DWORD PTR _pCTrack$[ebp], ecx

; 774  : 	if( NULL == pCTrack )

  00073	83 7d f4 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00077	75 0a		 jne	 SHORT $L69777

; 775  : 	{
; 776  : 		return E_OUTOFMEMORY;

  00079	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0007e	e9 4b 01 00 00	 jmp	 $L69763
$L69777:

; 777  : 	}
; 778  : 	pCTrack->m_pTrack = pTrack;

  00083	8b 55 f4	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00086	8b 45 08	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00089	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 779  :     pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pCTrack->m_pTrack8);

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0008f	83 c1 18	 add	 ecx, 24			; 00000018H
  00092	51		 push	 ecx
  00093	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  00098	8b 55 08	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  000a0	51		 push	 ecx
  000a1	ff 10		 call	 DWORD PTR [eax]

; 780  :     IPersist *pPersist;
; 781  :     if (S_OK == pTrack->QueryInterface(IID_IPersistStream,(void **) &pPersist))

  000a3	8d 55 fc	 lea	 edx, DWORD PTR _pPersist$[ebp]
  000a6	52		 push	 edx
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  000ac	8b 45 08	 mov	 eax, DWORD PTR _pTrack$[ebp]
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _pTrack$[ebp]
  000b4	52		 push	 edx
  000b5	ff 11		 call	 DWORD PTR [ecx]
  000b7	85 c0		 test	 eax, eax
  000b9	75 1f		 jne	 SHORT $L69783

; 782  :     {
; 783  :         pPersist->GetClassID( &pCTrack->m_guidClassID );

  000bb	8b 45 f4	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000be	83 c0 04	 add	 eax, 4
  000c1	50		 push	 eax
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _pPersist$[ebp]
  000c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c7	8b 45 fc	 mov	 eax, DWORD PTR _pPersist$[ebp]
  000ca	50		 push	 eax
  000cb	ff 52 0c	 call	 DWORD PTR [edx+12]

; 784  :         pPersist->Release();

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _pPersist$[ebp]
  000d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d3	8b 45 fc	 mov	 eax, DWORD PTR _pPersist$[ebp]
  000d6	50		 push	 eax
  000d7	ff 52 08	 call	 DWORD PTR [edx+8]
$L69783:

; 785  :     }
; 786  : 	pCTrack->m_dwGroupBits = dwGroupBits;

  000da	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000dd	8b 55 0c	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  000e0	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 787  :     pCTrack->m_dwFlags = dwFlags;

  000e3	8b 45 f4	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000e6	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  000e9	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 788  :     pCTrack->m_dwPriority = dwPriority;

  000ec	8b 55 f4	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  000ef	8b 45 14	 mov	 eax, DWORD PTR _dwPriority$[ebp]
  000f2	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 789  :     pCTrack->m_dwPosition = dwPosition;

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000f8	8b 55 18	 mov	 edx, DWORD PTR _dwPosition$[ebp]
  000fb	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 790  : 	pTrack->AddRef();

  000fe	8b 45 08	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00101	8b 08		 mov	 ecx, DWORD PTR [eax]
  00103	8b 55 08	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00106	52		 push	 edx
  00107	ff 51 04	 call	 DWORD PTR [ecx+4]

; 791  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0010a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00110	50		 push	 eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 792  :     // Add the track based on position.
; 793  : 	CTrack* pScan = m_TrackList.GetHead();

  00117	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	83 c1 44	 add	 ecx, 68			; 00000044H
  0011d	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00122	89 45 ec	 mov	 DWORD PTR _pScan$[ebp], eax

; 794  : 	CTrack* pPrevTrack = NULL;

  00125	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pPrevTrack$[ebp], 0

; 795  :     for (; pScan; pScan = pScan->GetNext())

  0012c	eb 0b		 jmp	 SHORT $L69786
$L69787:
  0012e	8b 4d ec	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00131	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00136	89 45 ec	 mov	 DWORD PTR _pScan$[ebp], eax
$L69786:
  00139	83 7d ec 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  0013d	74 1d		 je	 SHORT $L69788

; 796  : 	{
; 797  :         if (pCTrack->Less(pScan))

  0013f	8b 4d ec	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00142	51		 push	 ecx
  00143	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00146	e8 00 00 00 00	 call	 ?Less@CTrack@@QAE_NPAV1@@Z ; CTrack::Less
  0014b	0f b6 d0	 movzx	 edx, al
  0014e	85 d2		 test	 edx, edx
  00150	74 02		 je	 SHORT $L69789

; 798  :         {
; 799  :             break;

  00152	eb 08		 jmp	 SHORT $L69788
$L69789:

; 800  :         }
; 801  :         pPrevTrack = pScan;

  00154	8b 45 ec	 mov	 eax, DWORD PTR _pScan$[ebp]
  00157	89 45 f0	 mov	 DWORD PTR _pPrevTrack$[ebp], eax

; 802  :     }

  0015a	eb d2		 jmp	 SHORT $L69787
$L69788:

; 803  :     if (pPrevTrack)

  0015c	83 7d f0 00	 cmp	 DWORD PTR _pPrevTrack$[ebp], 0
  00160	74 1a		 je	 SHORT $L69790

; 804  :     {
; 805  :         pPrevTrack->SetNext(pCTrack);

  00162	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00165	51		 push	 ecx
  00166	8b 4d f0	 mov	 ecx, DWORD PTR _pPrevTrack$[ebp]
  00169	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 806  :         pCTrack->SetNext(pScan);

  0016e	8b 55 ec	 mov	 edx, DWORD PTR _pScan$[ebp]
  00171	52		 push	 edx
  00172	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00175	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 807  :     }
; 808  :     else

  0017a	eb 0f		 jmp	 SHORT $L69791
$L69790:

; 809  :     {
; 810  :         m_TrackList.AddHead( pCTrack );

  0017c	8b 45 f4	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	83 c1 44	 add	 ecx, 68			; 00000044H
  00186	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
$L69791:

; 811  :     }
; 812  : 	
; 813  : 	// send notifications to track
; 814  : 	CNotificationItem* pItem = m_NotificationList.GetHead();

  0018b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	83 c1 50	 add	 ecx, 80			; 00000050H
  00191	e8 00 00 00 00	 call	 ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
  00196	89 45 f8	 mov	 DWORD PTR _pItem$[ebp], eax
$L69794:

; 815  : 	while( pItem )

  00199	83 7d f8 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0019d	74 20		 je	 SHORT $L69795

; 816  : 	{
; 817  : 		pTrack->AddNotificationType( pItem->guidNotificationType );

  0019f	8b 4d f8	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001a2	83 c1 04	 add	 ecx, 4
  001a5	51		 push	 ecx
  001a6	8b 55 08	 mov	 edx, DWORD PTR _pTrack$[ebp]
  001a9	8b 02		 mov	 eax, DWORD PTR [edx]
  001ab	8b 4d 08	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  001ae	51		 push	 ecx
  001af	ff 50 28	 call	 DWORD PTR [eax+40]

; 818  : 		pItem = pItem->GetNext();

  001b2	8b 4d f8	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001b5	e8 00 00 00 00	 call	 ?GetNext@CNotificationItem@@QAEPAV1@XZ ; CNotificationItem::GetNext
  001ba	89 45 f8	 mov	 DWORD PTR _pItem$[ebp], eax

; 819  : 	}

  001bd	eb da		 jmp	 SHORT $L69794
$L69795:

; 820  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  001bf	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  001c2	83 c2 1c	 add	 edx, 28			; 0000001cH
  001c5	52		 push	 edx
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 821  : 	return S_OK;

  001cc	33 c0		 xor	 eax, eax
$L69763:

; 822  : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c2 14 00	 ret	 20			; 00000014H
?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z ENDP ; CSegment::InsertTrack
_TEXT	ENDS
PUBLIC	??_C@_0FA@FPCABBFI@Warning?3?5RemoveTrack?5failed?5beca@ ; `string'
PUBLIC	??_GCTrack@@QAEPAXI@Z				; CTrack::`scalar deleting destructor'
;	COMDAT ?__szValidateInterfaceName@?1??RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::RemoveTrack', 00H	; `CSegment::RemoveTrack'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0FA@FPCABBFI@Warning?3?5RemoveTrack?5failed?5beca@
CONST	SEGMENT
??_C@_0FA@FPCABBFI@Warning?3?5RemoveTrack?5failed?5beca@ DB 'Warning: Rem'
	DB	'oveTrack failed because the requested track is not in the seg'
	DB	'ment.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT
tv133 = -20
$T71951 = -16
$T71950 = -12
_hr$ = -8
_pCTrackTemp$ = -4
_this$ = 8
_pTrack$ = 12
?RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z PROC NEAR ; CSegment::RemoveTrack, COMDAT

; 826  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 827  : 	V_INAME(IDirectMusicSegment::RemoveTrack);
; 828  : 	V_INTERFACE(pTrack);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69804
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69804:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L69807
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L69807:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L69809
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HOMDEOJD@?$CFs?3?5Invalid?5pointer?5pTrack?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L69809:

; 829  : #ifdef DXAPI
; 830  :     if (m_fZombie)
; 831  : 	{
; 832  : 		Trace(2, "Warning: Call of IDirectMusicSegment::RemoveTrack after the segment has been garbage collected.\n");
; 833  : 		return DMUS_S_GARBAGE_COLLECTED;
; 834  : 	}
; 835  : #endif
; 836  :     
; 837  : 	HRESULT hr = S_FALSE;

  00082	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1

; 838  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00089	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 839  : 	CTrack* pCTrackTemp;
; 840  : 	pCTrackTemp = m_TrackList.GetHead();

  00096	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 44	 add	 ecx, 68			; 00000044H
  0009c	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  000a1	89 45 fc	 mov	 DWORD PTR _pCTrackTemp$[ebp], eax
$L69814:

; 841  : 	while( pCTrackTemp )

  000a4	83 7d fc 00	 cmp	 DWORD PTR _pCTrackTemp$[ebp], 0
  000a8	74 58		 je	 SHORT $L69815

; 842  : 	{
; 843  : 		if( pTrack == pCTrackTemp->m_pTrack )

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrackTemp$[ebp]
  000ad	8b 55 0c	 mov	 edx, DWORD PTR _pTrack$[ebp]
  000b0	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  000b3	75 40		 jne	 SHORT $L69816

; 844  : 		{
; 845  : 			hr = S_OK;

  000b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 846  : 			m_TrackList.Remove( pCTrackTemp );

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _pCTrackTemp$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	83 c1 44	 add	 ecx, 68			; 00000044H
  000c6	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove

; 847  : 			delete pCTrackTemp;

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrackTemp$[ebp]
  000ce	89 4d f0	 mov	 DWORD PTR $T71951[ebp], ecx
  000d1	8b 55 f0	 mov	 edx, DWORD PTR $T71951[ebp]
  000d4	89 55 f4	 mov	 DWORD PTR $T71950[ebp], edx
  000d7	83 7d f4 00	 cmp	 DWORD PTR $T71950[ebp], 0
  000db	74 0f		 je	 SHORT $L71952
  000dd	6a 01		 push	 1
  000df	8b 4d f4	 mov	 ecx, DWORD PTR $T71950[ebp]
  000e2	e8 00 00 00 00	 call	 ??_GCTrack@@QAEPAXI@Z
  000e7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000ea	eb 07		 jmp	 SHORT $L71953
$L71952:
  000ec	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$L71953:

; 848  : 			break;

  000f3	eb 0d		 jmp	 SHORT $L69815
$L69816:

; 849  : 		}
; 850  : 		pCTrackTemp = pCTrackTemp->GetNext();

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrackTemp$[ebp]
  000f8	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  000fd	89 45 fc	 mov	 DWORD PTR _pCTrackTemp$[ebp], eax

; 851  : 	}

  00100	eb a2		 jmp	 SHORT $L69814
$L69815:

; 852  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00102	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00105	83 c0 1c	 add	 eax, 28			; 0000001cH
  00108	50		 push	 eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 853  : #ifdef DBG
; 854  :     if (hr == S_FALSE)

  0010f	83 7d f8 01	 cmp	 DWORD PTR _hr$[ebp], 1
  00113	75 0f		 jne	 SHORT $L69821

; 855  :     {
; 856  :         Trace(1,"Warning: RemoveTrack failed because the requested track is not in the segment.\n");

  00115	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@FPCABBFI@Warning?3?5RemoveTrack?5failed?5beca@
  0011a	6a 01		 push	 1
  0011c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00121	83 c4 08	 add	 esp, 8
$L69821:

; 857  :     }
; 858  : #endif
; 859  : 	return hr;

  00124	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 860  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 08 00	 ret	 8
?RemoveTrack@CSegment@@UAGJPAUIDirectMusicTrack@@@Z ENDP ; CSegment::RemoveTrack
_TEXT	ENDS
PUBLIC	?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z ; CSegment::CreateSegmentState
EXTRN	??0CSegState@@QAE@XZ:NEAR			; CSegState::CSegState
EXTRN	?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z:NEAR ; CSegState::PrivateInit
EXTRN	?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z:NEAR ; CSegState::InitRoute
EXTRN	_IID_IDirectMusicSegmentState:BYTE
; Function compile flags: /Odt
;	COMDAT ?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z
_TEXT	SEGMENT
tv69 = -28
_this$ = -24
$T71957 = -20
_dwTempID$69847 = -16
_pState$ = -12
_pCTrack$ = -8
_pSegmentState$ = -4
_ppSegState$ = 8
_pPerformance$ = 12
_pAudioPath$ = 16
_dwFlags$ = 20
?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z PROC NEAR ; CSegment::CreateSegmentState, COMDAT
; _this$ = ecx

; 868  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 	IDirectMusicSegmentState* pSegmentState;
; 870  :     CSegState *pState = new CSegState;

  00009	68 38 01 00 00	 push	 312			; 00000138H
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 ec	 mov	 DWORD PTR $T71957[ebp], eax
  00019	83 7d ec 00	 cmp	 DWORD PTR $T71957[ebp], 0
  0001d	74 0d		 je	 SHORT $L71958
  0001f	8b 4d ec	 mov	 ecx, DWORD PTR $T71957[ebp]
  00022	e8 00 00 00 00	 call	 ??0CSegState@@QAE@XZ	; CSegState::CSegState
  00027	89 45 e4	 mov	 DWORD PTR tv69[ebp], eax
  0002a	eb 07		 jmp	 SHORT $L71959
$L71958:
  0002c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L71959:
  00033	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]
  00036	89 45 f4	 mov	 DWORD PTR _pState$[ebp], eax

; 871  :     if (pState)

  00039	83 7d f4 00	 cmp	 DWORD PTR _pState$[ebp], 0
  0003d	74 34		 je	 SHORT $L69834

; 872  :     {
; 873  : 	    pState->QueryInterface( IID_IDirectMusicSegmentState,
; 874  :             (void**)&pSegmentState);

  0003f	8d 4d fc	 lea	 ecx, DWORD PTR _pSegmentState$[ebp]
  00042	51		 push	 ecx
  00043	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegmentState
  00048	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  0004b	8b 02		 mov	 eax, DWORD PTR [edx]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  00050	51		 push	 ecx
  00051	ff 10		 call	 DWORD PTR [eax]

; 875  :         pState->m_dwVersion = m_dwVersion;

  00053	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  00056	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 88 bc 03 00
	00		 mov	 ecx, DWORD PTR [eax+956]
  0005f	89 8a 08 01 00
	00		 mov	 DWORD PTR [edx+264], ecx

; 876  :         pState->Release();

  00065	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  0006d	51		 push	 ecx
  0006e	ff 50 08	 call	 DWORD PTR [eax+8]

; 877  :     }
; 878  :     else

  00071	eb 0a		 jmp	 SHORT $L69836
$L69834:

; 879  :     {
; 880  :         return E_OUTOFMEMORY;

  00073	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00078	e9 5d 01 00 00	 jmp	 $L69829
$L69836:

; 881  :     }
; 882  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0007d	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00080	83 c2 1c	 add	 edx, 28			; 0000001cH
  00083	52		 push	 edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 883  : 	if( FAILED( m_TrackList.CreateCopyWithBlankState(&pState->m_TrackList)))

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _pState$[ebp]
  0008d	83 c0 44	 add	 eax, 68			; 00000044H
  00090	50		 push	 eax
  00091	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	83 c1 44	 add	 ecx, 68			; 00000044H
  00097	e8 00 00 00 00	 call	 ?CreateCopyWithBlankState@CTrackList@@QAEJPAV1@@Z ; CTrackList::CreateCopyWithBlankState
  0009c	85 c0		 test	 eax, eax
  0009e	7d 23		 jge	 SHORT $L69839

; 884  : 	{
; 885  :         LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000a0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000a6	51		 push	 ecx
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 886  :         pState->Release();

  000ad	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  000b0	8b 02		 mov	 eax, DWORD PTR [edx]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  000b5	51		 push	 ecx
  000b6	ff 50 08	 call	 DWORD PTR [eax+8]

; 887  : 		return E_OUTOFMEMORY;

  000b9	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  000be	e9 17 01 00 00	 jmp	 $L69829
$L69839:

; 888  : 	}
; 889  : 	// set the segstate's parent and performance
; 890  : 	pState->PrivateInit( this, pPerformance );

  000c3	8b 55 0c	 mov	 edx, DWORD PTR _pPerformance$[ebp]
  000c6	52		 push	 edx
  000c7	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  000ce	e8 00 00 00 00	 call	 ?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z ; CSegState::PrivateInit

; 891  : 
; 892  :     if (m_pGraph)

  000d3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  000da	74 1d		 je	 SHORT $L69841

; 893  :     {
; 894  :         m_pGraph->Clone((IDirectMusicGraph **) &pState->m_pGraph);

  000dc	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  000df	83 c2 40	 add	 edx, 64			; 00000040H
  000e2	52		 push	 edx
  000e3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000e9	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  000ef	83 c0 0c	 add	 eax, 12			; 0000000cH
  000f2	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000f5	50		 push	 eax
  000f6	ff 51 0c	 call	 DWORD PTR [ecx+12]
$L69841:

; 895  :     }
; 896  :     pState->InitRoute(pAudioPath);

  000f9	8b 55 10	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  000fc	52		 push	 edx
  000fd	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  00100	e8 00 00 00 00	 call	 ?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z ; CSegState::InitRoute

; 897  : 	CTrack* pCTrack = pState->m_TrackList.GetHead();

  00105	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  00108	83 c1 44	 add	 ecx, 68			; 00000044H
  0010b	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00110	89 45 f8	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69845:

; 898  : 	while( pCTrack )

  00113	83 7d f8 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00117	0f 84 a6 00 00
	00		 je	 $L69846

; 899  : 	{
; 900  : 		DWORD dwTempID;
; 901  : 		InterlockedIncrement(&g_lNewTrackID);

  0011d	68 00 00 00 00	 push	 OFFSET FLAT:?g_lNewTrackID@@3JA ; g_lNewTrackID
  00122	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 902  : 		dwTempID = g_lNewTrackID;

  00127	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_lNewTrackID@@3JA ; g_lNewTrackID
  0012c	89 45 f0	 mov	 DWORD PTR _dwTempID$69847[ebp], eax

; 903  :         if (!pState->m_dwFirstTrackID)

  0012f	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  00132	83 b9 0c 01 00
	00 00		 cmp	 DWORD PTR [ecx+268], 0
  00139	75 0c		 jne	 SHORT $L69848

; 904  :             pState->m_dwFirstTrackID = dwTempID;

  0013b	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  0013e	8b 45 f0	 mov	 eax, DWORD PTR _dwTempID$69847[ebp]
  00141	89 82 0c 01 00
	00		 mov	 DWORD PTR [edx+268], eax
$L69848:

; 905  :         pState->m_dwLastTrackID = dwTempID;

  00147	8b 4d f4	 mov	 ecx, DWORD PTR _pState$[ebp]
  0014a	8b 55 f0	 mov	 edx, DWORD PTR _dwTempID$69847[ebp]
  0014d	89 91 10 01 00
	00		 mov	 DWORD PTR [ecx+272], edx

; 906  : 		ASSERT(pCTrack->m_pTrack);

  00153	8b 45 f8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00156	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0015a	75 17		 jne	 SHORT $L69849
  0015c	6a 00		 push	 0
  0015e	68 8a 03 00 00	 push	 906			; 0000038aH
  00163	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  00168	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69849:

; 907  : 		if( FAILED(pCTrack->m_pTrack->InitPlay(
; 908  : 			pSegmentState, (IDirectMusicPerformance *) pPerformance, 
; 909  :             &pCTrack->m_pTrackState, dwTempID, dwFlags )))

  00173	8b 4d 14	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00176	51		 push	 ecx
  00177	8b 55 f0	 mov	 edx, DWORD PTR _dwTempID$69847[ebp]
  0017a	52		 push	 edx
  0017b	8b 45 f8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0017e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00181	50		 push	 eax
  00182	8b 4d 0c	 mov	 ecx, DWORD PTR _pPerformance$[ebp]
  00185	51		 push	 ecx
  00186	8b 55 fc	 mov	 edx, DWORD PTR _pSegmentState$[ebp]
  00189	52		 push	 edx
  0018a	8b 45 f8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0018d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00190	8b 55 f8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00193	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00196	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00198	50		 push	 eax
  00199	ff 51 10	 call	 DWORD PTR [ecx+16]
  0019c	85 c0		 test	 eax, eax
  0019e	7d 0a		 jge	 SHORT $L69852

; 910  : 		{
; 911  : 			pCTrack->m_pTrackState = NULL;

  001a0	8b 55 f8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  001a3	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$L69852:

; 912  : 		}
; 913  : 		pCTrack->m_dwVirtualID = dwTempID;

  001aa	8b 45 f8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  001ad	8b 4d f0	 mov	 ecx, DWORD PTR _dwTempID$69847[ebp]
  001b0	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 914  : 		pCTrack = pCTrack->GetNext();

  001b3	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  001b6	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  001bb	89 45 f8	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 915  : 	}

  001be	e9 50 ff ff ff	 jmp	 $L69845
$L69846:

; 916  : 	*ppSegState = pState;

  001c3	8b 55 08	 mov	 edx, DWORD PTR _ppSegState$[ebp]
  001c6	8b 45 f4	 mov	 eax, DWORD PTR _pState$[ebp]
  001c9	89 02		 mov	 DWORD PTR [edx], eax

; 917  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  001cb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ce	83 c1 1c	 add	 ecx, 28			; 0000001cH
  001d1	51		 push	 ecx
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 918  : 	return S_OK; 

  001d8	33 c0		 xor	 eax, eax
$L69829:

; 919  : }

  001da	8b e5		 mov	 esp, ebp
  001dc	5d		 pop	 ebp
  001dd	c2 10 00	 ret	 16			; 00000010H
?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z ENDP ; CSegment::CreateSegmentState
_TEXT	ENDS
PUBLIC	?InitPlay@CSegment@@QAGJPAPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@K@Z ; CSegment::InitPlay
; Function compile flags: /Odt
;	COMDAT ?InitPlay@CSegment@@QAGJPAPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@K@Z
_TEXT	SEGMENT
_this$ = 8
_ppSegState$ = 12
_pPerformance$ = 16
_dwFlags$ = 20
?InitPlay@CSegment@@QAGJPAPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@K@Z PROC NEAR ; CSegment::InitPlay, COMDAT

; 937  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 938  : #ifdef DXAPI
; 939  : 	V_INAME(IDirectMusicSegment::InitPlay);
; 940  : 	V_INTERFACE(pPerformance);
; 941  : 	V_PTRPTR_WRITE(ppSegState);
; 942  : 
; 943  :     if (m_dwVersion)
; 944  :     {
; 945  :         return E_NOTIMPL;
; 946  :     }
; 947  : 
; 948  : 	IDirectMusicSegmentState* pSegmentState;
; 949  :     CSegState *pState = new CSegState;
; 950  :     if (pState)
; 951  :     {
; 952  : 	    pState->QueryInterface( IID_IDirectMusicSegmentState,
; 953  :             (void**)&pSegmentState);
; 954  :         pState->m_dwVersion = m_dwVersion;
; 955  :         pState->Release();
; 956  :         if (pPerformance)
; 957  :         {
; 958  :             // QI addref's the performance but we want only a weak refrenece with the segment state
; 959  :             HRESULT hr = pPerformance->QueryInterface(IID_CPerformance,(void **) &pState->m_pPerformance);
; 960  :             if(FAILED(hr))
; 961  :             {
; 962  :                 return E_FAIL;
; 963  :             }
; 964  : 
; 965  :             pPerformance->Release();
; 966  :         }
; 967  :     }
; 968  :     else
; 969  :     {
; 970  :         return E_OUTOFMEMORY;
; 971  :     }
; 972  : 	*ppSegState = pSegmentState;
; 973  : #endif
; 974  :     return S_OK;

  00003	33 c0		 xor	 eax, eax

; 975  : }

  00005	5d		 pop	 ebp
  00006	c2 10 00	 ret	 16			; 00000010H
?InitPlay@CSegment@@QAGJPAPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@K@Z ENDP ; CSegment::InitPlay
_TEXT	ENDS
PUBLIC	??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@ ; `string'
PUBLIC	??_C@_0EE@FGIKBJAM@Error?3?5GetGraph?5failed?5because?5s@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetGraph', 00H		; `CSegment::GetGraph'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@
CONST	SEGMENT
??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@ DB '%s: Inva'
	DB	'lid pointer ppGraph', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FGIKBJAM@Error?3?5GetGraph?5failed?5because?5s@
CONST	SEGMENT
??_C@_0EE@FGIKBJAM@Error?3?5GetGraph?5failed?5because?5s@ DB 'Error: GetG'
	DB	'raph failed because segment does not have a tool graph.', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
_this$ = 8
_ppGraph$ = 12
?GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z PROC NEAR ; CSegment::GetGraph, COMDAT

; 980  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 981  : 	V_INAME(IDirectMusicSegment::GetGraph);
; 982  : 	V_PTRPTR_WRITE(ppGraph);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69868
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69868:

; 983  : #ifdef DXAPI
; 984  :     if (m_fZombie)
; 985  : 	{
; 986  : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetGraph after the segment has been garbage collected.\n");
; 987  : 		return DMUS_S_GARBAGE_COLLECTED;
; 988  : 	}
; 989  : #endif	
; 990  : 	if( NULL == m_pGraph )

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  00032	75 16		 jne	 SHORT $L69870

; 991  :     {
; 992  :         Trace(2,"Error: GetGraph failed because segment does not have a tool graph.\n");

  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EE@FGIKBJAM@Error?3?5GetGraph?5failed?5because?5s@
  00039	6a 02		 push	 2
  0003b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00040	83 c4 08	 add	 esp, 8

; 993  : 		return DMUS_E_NOT_FOUND;

  00043	b8 61 11 78 88	 mov	 eax, -2005397151	; 88781161H
  00048	eb 39		 jmp	 SHORT $L69864
$L69870:

; 994  :     }
; 995  : 	ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0004a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	83 c2 1c	 add	 edx, 28			; 0000001cH
  00050	52		 push	 edx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 996  : 	*ppGraph = m_pGraph;

  00057	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00060	89 10		 mov	 DWORD PTR [eax], edx

; 997  : 	m_pGraph->AddRef();

  00062	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00068	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0006e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00070	50		 push	 eax
  00071	ff 51 04	 call	 DWORD PTR [ecx+4]

; 998  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00074	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00077	83 c2 1c	 add	 edx, 28			; 0000001cH
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 999  : 	return S_OK;

  00081	33 c0		 xor	 eax, eax
$L69864:

; 1000 : }

  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?GetGraph@CSegment@@UAGJPAPAUIDirectMusicGraph@@@Z ENDP	; CSegment::GetGraph
_TEXT	ENDS
PUBLIC	??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::SetGraph', 00H		; `CSegment::SetGraph'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
CONST	SEGMENT
??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@ DB '%s: Inval'
	DB	'id pointer pGraph', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
_this$ = 8
_pGraph$ = 12
?SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z PROC NEAR ; CSegment::SetGraph, COMDAT

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 	V_INAME(IDirectMusicSegment::SetGraph);
; 1008 : 	V_INTERFACE_OPT(pGraph);

  00003	83 7d 0c 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  00007	74 7c		 je	 SHORT $L69883
  00009	6a 04		 push	 4
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $L69885
  00018	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z@4QBDB
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
  00022	6a ff		 push	 -1
  00024	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	e8 00 00 00 00	 call	 _DebugBreak@0
$L69885:
  00031	6a 04		 push	 4
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003e	85 c0		 test	 eax, eax
  00040	74 19		 je	 SHORT $L69889
  00042	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z@4QBDB
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
  0004c	6a ff		 push	 -1
  0004e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	e8 00 00 00 00	 call	 _DebugBreak@0
$L69889:
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00068	85 c0		 test	 eax, eax
  0006a	74 19		 je	 SHORT $L69883
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z@4QBDB
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
  00076	6a ff		 push	 -1
  00078	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	e8 00 00 00 00	 call	 _DebugBreak@0
$L69883:

; 1009 : #ifdef DXAPI
; 1010 :     if (m_fZombie)
; 1011 : 	{
; 1012 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetGraph after the segment has been garbage collected.\n");
; 1013 : 		return DMUS_S_GARBAGE_COLLECTED;
; 1014 : 	}
; 1015 : #endif	
; 1016 : 	ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00085	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00088	83 c0 1c	 add	 eax, 28			; 0000001cH
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1017 : 	if( m_pGraph )

  00092	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  00099	74 12		 je	 SHORT $L69892

; 1018 : 	{
; 1019 : 		m_pGraph->Release();

  0009b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	52		 push	 edx
  000aa	ff 50 08	 call	 DWORD PTR [eax+8]
$L69892:

; 1020 : 	}
; 1021 : 	m_pGraph = (CGraph *) pGraph;

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 55 0c	 mov	 edx, DWORD PTR _pGraph$[ebp]
  000b3	89 51 4c	 mov	 DWORD PTR [ecx+76], edx

; 1022 : 	if( pGraph )

  000b6	83 7d 0c 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  000ba	74 0c		 je	 SHORT $L69894

; 1023 : 	{
; 1024 : 		pGraph->AddRef();

  000bc	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  000bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c1	8b 55 0c	 mov	 edx, DWORD PTR _pGraph$[ebp]
  000c4	52		 push	 edx
  000c5	ff 51 04	 call	 DWORD PTR [ecx+4]
$L69894:

; 1025 : 	}
; 1026 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000c8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	83 c0 1c	 add	 eax, 28			; 0000001cH
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1027 : 	return S_OK;

  000d5	33 c0		 xor	 eax, eax

; 1028 : }

  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
?SetGraph@CSegment@@UAGJPAUIDirectMusicGraph@@@Z ENDP	; CSegment::SetGraph
_TEXT	ENDS
PUBLIC	?SetClockTimeDuration@CSegment@@QAEJ_J@Z	; CSegment::SetClockTimeDuration
; Function compile flags: /Odt
;	COMDAT ?SetClockTimeDuration@CSegment@@QAEJ_J@Z
_TEXT	SEGMENT
_this$ = -4
_rtDuration$ = 8
?SetClockTimeDuration@CSegment@@QAEJ_J@Z PROC NEAR	; CSegment::SetClockTimeDuration, COMDAT
; _this$ = ecx

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1033 :     m_rtLength = rtDuration;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _rtDuration$[ebp]
  0000d	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _rtDuration$[ebp+4]
  00013	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 1034 :     return S_OK;

  00016	33 c0		 xor	 eax, eax

; 1035 : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?SetClockTimeDuration@CSegment@@QAEJ_J@Z ENDP		; CSegment::SetClockTimeDuration
_TEXT	ENDS
PUBLIC	?SetFlags@CSegment@@QAEJK@Z			; CSegment::SetFlags
; Function compile flags: /Odt
;	COMDAT ?SetFlags@CSegment@@QAEJK@Z
_TEXT	SEGMENT
_this$ = -4
_dwFlags$ = 8
?SetFlags@CSegment@@QAEJK@Z PROC NEAR			; CSegment::SetFlags, COMDAT
; _this$ = ecx

; 1039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1040 :     m_dwSegFlags = dwFlags;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0000d	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 1041 :     return S_OK;

  00010	33 c0		 xor	 eax, eax

; 1042 : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?SetFlags@CSegment@@QAEJK@Z ENDP			; CSegment::SetFlags
_TEXT	ENDS
PUBLIC	?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z ; CSegment::FindNotification
; Function compile flags: /Odt
;	COMDAT ?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -8
_pItem$ = -4
_rguidNotification$ = 8
?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z PROC NEAR ; CSegment::FindNotification, COMDAT
; _this$ = ecx

; 1048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1049 : 	CNotificationItem* pItem;
; 1050 : 
; 1051 : 	pItem = m_NotificationList.GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 50	 add	 ecx, 80			; 00000050H
  0000f	e8 00 00 00 00	 call	 ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
$L69912:

; 1052 : 	while(pItem)

  00017	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0001b	74 23		 je	 SHORT $L69913

; 1053 : 	{
; 1054 : 		if( rguidNotification == pItem->guidNotificationType )

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _==@8
  0002d	85 c0		 test	 eax, eax
  0002f	74 02		 je	 SHORT $L69914

; 1055 : 		{
; 1056 : 			break;

  00031	eb 0d		 jmp	 SHORT $L69913
$L69914:

; 1057 : 		}
; 1058 : 		pItem = pItem->GetNext();

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetNext@CNotificationItem@@QAEPAV1@XZ ; CNotificationItem::GetNext
  0003b	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax

; 1059 : 	}

  0003e	eb d7		 jmp	 SHORT $L69912
$L69913:

; 1060 : 	return pItem;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]

; 1061 : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z ENDP ; CSegment::FindNotification
_TEXT	ENDS
PUBLIC	?AddNotificationTypeToAllTracks@CSegment@@QAEXABU_GUID@@@Z ; CSegment::AddNotificationTypeToAllTracks
; Function compile flags: /Odt
;	COMDAT ?AddNotificationTypeToAllTracks@CSegment@@QAEXABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -8
_pTrack$ = -4
_rguidNotification$ = 8
?AddNotificationTypeToAllTracks@CSegment@@QAEXABU_GUID@@@Z PROC NEAR ; CSegment::AddNotificationTypeToAllTracks, COMDAT
; _this$ = ecx

; 1064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1065 : 	CTrack* pTrack;
; 1066 : 
; 1067 : 	// add the notify to the tracks
; 1068 : 	pTrack = m_TrackList.GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 44	 add	 ecx, 68			; 00000044H
  0000f	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax
$L69921:

; 1069 : 	while( pTrack )

  00017	83 7d fc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  0001b	74 23		 je	 SHORT $L69918

; 1070 : 	{
; 1071 : 		pTrack->m_pTrack->AddNotificationType( rguidNotification );

  0001d	8b 45 08	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	8b 45 fc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0002a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002d	8b 12		 mov	 edx, DWORD PTR [edx]
  0002f	51		 push	 ecx
  00030	ff 52 28	 call	 DWORD PTR [edx+40]

; 1072 : 		pTrack = pTrack->GetNext();

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  0003b	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1073 : 	}

  0003e	eb d7		 jmp	 SHORT $L69921
$L69918:

; 1074 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?AddNotificationTypeToAllTracks@CSegment@@QAEXABU_GUID@@@Z ENDP ; CSegment::AddNotificationTypeToAllTracks
_TEXT	ENDS
PUBLIC	?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z ; CSegment::RemoveNotificationTypeFromAllTracks
; Function compile flags: /Odt
;	COMDAT ?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -8
_pTrack$ = -4
_rguidNotification$ = 8
?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z PROC NEAR ; CSegment::RemoveNotificationTypeFromAllTracks, COMDAT
; _this$ = ecx

; 1077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1078 : 	CTrack* pTrack;
; 1079 : 
; 1080 : 	// add the notify to the tracks
; 1081 : 	pTrack = m_TrackList.GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 44	 add	 ecx, 68			; 00000044H
  0000f	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax
$L69929:

; 1082 : 	while( pTrack )

  00017	83 7d fc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  0001b	74 23		 je	 SHORT $L69926

; 1083 : 	{
; 1084 : 		pTrack->m_pTrack->RemoveNotificationType( rguidNotification );

  0001d	8b 45 08	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	8b 45 fc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0002a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002d	8b 12		 mov	 edx, DWORD PTR [edx]
  0002f	51		 push	 ecx
  00030	ff 52 2c	 call	 DWORD PTR [edx+44]

; 1085 : 		pTrack = pTrack->GetNext();

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  0003b	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1086 : 	}

  0003e	eb d7		 jmp	 SHORT $L69929
$L69926:

; 1087 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z ENDP ; CSegment::RemoveNotificationTypeFromAllTracks
_TEXT	ENDS
PUBLIC	?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::AddNotificationType
PUBLIC	??0CNotificationItem@@QAE@XZ			; CNotificationItem::CNotificationItem
PUBLIC	?Cat@AList@@QAEXPAVAListItem@@@Z		; AList::Cat
; Function compile flags: /Odt
;	COMDAT ?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z
_TEXT	SEGMENT
tv78 = -20
_this$ = -16
$T71987 = -12
_hr$ = -8
_pItem$ = -4
_rguidNotification$ = 8
_fFromPerformance$ = 12
?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z PROC NEAR ; CSegment::AddNotificationType, COMDAT
; _this$ = ecx

; 1091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 : 	CNotificationItem* pItem;
; 1093 : 	HRESULT hr = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1094 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00010	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 1c	 add	 eax, 28			; 0000001cH
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1095 : 	pItem = FindNotification( rguidNotification );

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z ; CSegment::FindNotification
  00029	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax

; 1096 :     if (pItem)

  0002c	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00030	74 20		 je	 SHORT $L69939

; 1097 : 	{
; 1098 :         // If the item was installed previously, but by
; 1099 :         // a difference source (performance vs. app)
; 1100 :         // then treat this as a normal addition.
; 1101 :         // Otherwise, indicate that the same operation 
; 1102 :         // was done twice.
; 1103 :         if (pItem->fFromPerformance == fFromPerformance)

  00032	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  00035	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00038	3b 45 0c	 cmp	 eax, DWORD PTR _fFromPerformance$[ebp]
  0003b	75 09		 jne	 SHORT $L69940

; 1104 :         {
; 1105 :             hr = S_FALSE;

  0003d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1

; 1106 :         }
; 1107 :         else

  00044	eb 0a		 jmp	 SHORT $L69942
$L69940:

; 1108 :         {
; 1109 :             // Clear the fFromPerformance flag since this has
; 1110 :             // now been added by the app and the performance.
; 1111 :             pItem->fFromPerformance = FALSE;

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00049	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L69942:

; 1112 :         }
; 1113 : 	}
; 1114 :     else

  00050	eb 7f		 jmp	 SHORT $L69943
$L69939:

; 1115 :     {
; 1116 :         pItem = new CNotificationItem;

  00052	6a 18		 push	 24			; 00000018H
  00054	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 f4	 mov	 DWORD PTR $T71987[ebp], eax
  0005f	83 7d f4 00	 cmp	 DWORD PTR $T71987[ebp], 0
  00063	74 0d		 je	 SHORT $L71988
  00065	8b 4d f4	 mov	 ecx, DWORD PTR $T71987[ebp]
  00068	e8 00 00 00 00	 call	 ??0CNotificationItem@@QAE@XZ
  0006d	89 45 ec	 mov	 DWORD PTR tv78[ebp], eax
  00070	eb 07		 jmp	 SHORT $L71989
$L71988:
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$L71989:
  00079	8b 55 ec	 mov	 edx, DWORD PTR tv78[ebp]
  0007c	89 55 fc	 mov	 DWORD PTR _pItem$[ebp], edx

; 1117 : 		if( NULL == pItem )

  0007f	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00083	75 09		 jne	 SHORT $L69946

; 1118 : 		{
; 1119 : 			hr = E_OUTOFMEMORY;

  00085	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 1120 : 		}
; 1121 : 		else

  0008c	eb 43		 jmp	 SHORT $L69943
$L69946:

; 1122 : 		{
; 1123 :             pItem->fFromPerformance = fFromPerformance;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _fFromPerformance$[ebp]
  00094	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1124 : 			pItem->guidNotificationType = rguidNotification;

  00097	8b 55 08	 mov	 edx, DWORD PTR _rguidNotification$[ebp]
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  0009d	83 c0 04	 add	 eax, 4
  000a0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
  000a4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000aa	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000ad	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000b0	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000b3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1125 : 			m_NotificationList.Cat( pItem );

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	83 c1 50	 add	 ecx, 80			; 00000050H
  000c0	e8 00 00 00 00	 call	 ?Cat@AList@@QAEXPAVAListItem@@@Z ; AList::Cat

; 1126 : 			AddNotificationTypeToAllTracks( rguidNotification );

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?AddNotificationTypeToAllTracks@CSegment@@QAEXABU_GUID@@@Z ; CSegment::AddNotificationTypeToAllTracks
$L69943:

; 1127 : 		}
; 1128 :     }
; 1129 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000d1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	83 c2 1c	 add	 edx, 28			; 0000001cH
  000d7	52		 push	 edx
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1130 : 	return hr;

  000de	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1131 : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z ENDP	; CSegment::AddNotificationType
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CNotificationItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CNotificationItem@@QAE@XZ PROC NEAR			; CNotificationItem::CNotificationItem, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CNotificationItem@@QAE@XZ ENDP			; CNotificationItem::CNotificationItem
_TEXT	ENDS
PUBLIC	??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ ; `string'
PUBLIC	??_C@_0GJ@GBKIELAO@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??AddNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??AddNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::AddNotificationType', 00H ; `CSegment::AddNotificationType'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT
??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ DB '%'
	DB	's: Invalid pointer (void*)&rguidNotification', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@GBKIELAO@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0GJ@GBKIELAO@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Cal'
	DB	'l of IDirectMusicSegment::AddNotificationType after the segme'
	DB	'nt has been garbage collected.', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AddNotificationType@CSegment@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_rguidNotification$ = 12
?AddNotificationType@CSegment@@UAGJABU_GUID@@@Z PROC NEAR ; CSegment::AddNotificationType, COMDAT

; 1135 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1136 : 	V_INAME(IDirectMusicSegment::AddNotificationType);
; 1137 : 	V_REFGUID(rguidNotification);

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69959
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??AddNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69959:

; 1138 : 
; 1139 :     if (m_fZombie)

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	0f b6 91 c0 03
	00 00		 movzx	 edx, BYTE PTR [ecx+960]
  00035	85 d2		 test	 edx, edx
  00037	74 16		 je	 SHORT $L69961

; 1140 : 	{
; 1141 : 		Trace(2, "Warning: Call of IDirectMusicSegment::AddNotificationType after the segment has been garbage collected.\n");

  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GJ@GBKIELAO@Warning?3?5Call?5of?5IDirectMusicSeg@
  0003e	6a 02		 push	 2
  00040	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00045	83 c4 08	 add	 esp, 8

; 1142 : 		return DMUS_S_GARBAGE_COLLECTED;

  00048	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  0004d	eb 0e		 jmp	 SHORT $L69954
$L69961:

; 1143 : 	}
; 1144 : 	
; 1145 : 	return AddNotificationType(rguidNotification,FALSE);

  0004f	6a 00		 push	 0
  00051	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::AddNotificationType
$L69954:

; 1146 : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?AddNotificationType@CSegment@@UAGJABU_GUID@@@Z ENDP	; CSegment::AddNotificationType
_TEXT	ENDS
PUBLIC	?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::RemoveNotificationType
PUBLIC	??_C@_0GA@LHGCACMA@Warning?3?5Unable?5to?5remove?5reques@ ; `string'
PUBLIC	?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::RemoveHead
;	COMDAT ??_C@_0GA@LHGCACMA@Warning?3?5Unable?5to?5remove?5reques@
CONST	SEGMENT
??_C@_0GA@LHGCACMA@Warning?3?5Unable?5to?5remove?5reques@ DB 'Warning: Un'
	DB	'able to remove requested notification from segment, it was no'
	DB	't currently installed.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z
_TEXT	SEGMENT
_this$ = -24
$T72000 = -20
$T71999 = -16
_TempList$69976 = -12
_hr$ = -8
_pItem$ = -4
_rguidNotification$ = 8
_fFromPerformance$ = 12
?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z PROC NEAR ; CSegment::RemoveNotificationType, COMDAT
; _this$ = ecx

; 1150 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1151 : 
; 1152 : 	CNotificationItem* pItem;
; 1153 :     HRESULT hr = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1154 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00010	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 1c	 add	 eax, 28			; 0000001cH
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1155 : 	if( GUID_NULL == rguidNotification )

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  00020	51		 push	 ecx
  00021	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  00026	e8 00 00 00 00	 call	 _==@8
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 80 00 00
	00		 je	 $L69975

; 1156 : 	{
; 1157 :         CNotificationList TempList;

  00033	8d 4d f4	 lea	 ecx, DWORD PTR _TempList$69976[ebp]
  00036	e8 00 00 00 00	 call	 ??0CNotificationList@@QAE@XZ
$L69978:

; 1158 : 		while( pItem = m_NotificationList.RemoveHead() )

  0003b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 50	 add	 ecx, 80			; 00000050H
  00041	e8 00 00 00 00	 call	 ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::RemoveHead
  00046	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
  00049	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0004d	74 40		 je	 SHORT $L69985

; 1159 : 		{
; 1160 :             // If this is being called on an item that was installed by the
; 1161 :             // performance OR we are calling this directly from the app,
; 1162 :             // go ahead and remove. However, do not remove in the specific
; 1163 :             // case where the app installed the notification and the performance
; 1164 :             // is clearing notifications. 
; 1165 :             if (pItem->fFromPerformance || !fFromPerformance) 

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  00052	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00056	75 06		 jne	 SHORT $L69981
  00058	83 7d 0c 00	 cmp	 DWORD PTR _fFromPerformance$[ebp], 0
  0005c	75 23		 jne	 SHORT $L69980
$L69981:

; 1166 :             {
; 1167 : 			    RemoveNotificationTypeFromAllTracks( pItem->guidNotificationType );

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00061	83 c0 04	 add	 eax, 4
  00064	50		 push	 eax
  00065	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z ; CSegment::RemoveNotificationTypeFromAllTracks

; 1168 :                 delete pItem;

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00070	89 4d f0	 mov	 DWORD PTR $T71999[ebp], ecx
  00073	8b 55 f0	 mov	 edx, DWORD PTR $T71999[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007c	83 c4 04	 add	 esp, 4

; 1169 :             }
; 1170 :             else

  0007f	eb 0c		 jmp	 SHORT $L69983
$L69980:

; 1171 :             {
; 1172 :                 TempList.AddHead(pItem);

  00081	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00084	50		 push	 eax
  00085	8d 4d f4	 lea	 ecx, DWORD PTR _TempList$69976[ebp]
  00088	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
$L69983:

; 1173 :             }
; 1174 : 		}

  0008d	eb ac		 jmp	 SHORT $L69978
$L69985:

; 1175 :         // Now, put the saved notifications back.
; 1176 :         while (pItem = TempList.RemoveHead())

  0008f	8d 4d f4	 lea	 ecx, DWORD PTR _TempList$69976[ebp]
  00092	e8 00 00 00 00	 call	 ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::RemoveHead
  00097	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
  0009a	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0009e	74 11		 je	 SHORT $L69986

; 1177 :         {
; 1178 :             m_NotificationList.AddHead(pItem);

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	83 c1 50	 add	 ecx, 80			; 00000050H
  000aa	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead

; 1179 :         }

  000af	eb de		 jmp	 SHORT $L69985
$L69986:

; 1180 : 	}
; 1181 : 	else if( pItem = FindNotification( rguidNotification ))

  000b1	eb 5a		 jmp	 SHORT $L69987
$L69975:
  000b3	8b 55 08	 mov	 edx, DWORD PTR _rguidNotification$[ebp]
  000b6	52		 push	 edx
  000b7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z ; CSegment::FindNotification
  000bf	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
  000c2	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  000c6	74 2f		 je	 SHORT $L69988

; 1182 : 	{
; 1183 : 		m_NotificationList.Remove( pItem );

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	83 c1 50	 add	 ecx, 80			; 00000050H
  000d2	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove

; 1184 : 		delete pItem;

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000da	89 4d ec	 mov	 DWORD PTR $T72000[ebp], ecx
  000dd	8b 55 ec	 mov	 edx, DWORD PTR $T72000[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e6	83 c4 04	 add	 esp, 4

; 1185 : 		RemoveNotificationTypeFromAllTracks( rguidNotification );	

  000e9	8b 45 08	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	e8 00 00 00 00	 call	 ?RemoveNotificationTypeFromAllTracks@CSegment@@QAEXABU_GUID@@@Z ; CSegment::RemoveNotificationTypeFromAllTracks

; 1186 : 	}
; 1187 :     else

  000f5	eb 16		 jmp	 SHORT $L69987
$L69988:

; 1188 :     {
; 1189 :         Trace(2,"Warning: Unable to remove requested notification from segment, it was not currently installed.\n");

  000f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GA@LHGCACMA@Warning?3?5Unable?5to?5remove?5reques@
  000fc	6a 02		 push	 2
  000fe	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00103	83 c4 08	 add	 esp, 8

; 1190 :         hr = S_FALSE;

  00106	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L69987:

; 1191 :     }
; 1192 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0010d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1193 : 	return hr;

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1194 : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 08 00	 ret	 8
?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z ENDP ; CSegment::RemoveNotificationType
_TEXT	ENDS
PUBLIC	??_C@_0GM@JGDHBIOO@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::RemoveNotificationType', 00H ; `CSegment::RemoveNotificationType'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0GM@JGDHBIOO@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0GM@JGDHBIOO@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Cal'
	DB	'l of IDirectMusicSegment::RemoveNotificationType after the se'
	DB	'gment has been garbage collected.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_rguidNotification$ = 12
?RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z PROC NEAR ; CSegment::RemoveNotificationType, COMDAT

; 1198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1199 : 	V_INAME(IDirectMusicSegment::RemoveNotificationType);
; 1200 : 	V_REFGUID(rguidNotification);

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70001
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70001:

; 1201 : 
; 1202 :     if (m_fZombie)

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	0f b6 91 c0 03
	00 00		 movzx	 edx, BYTE PTR [ecx+960]
  00035	85 d2		 test	 edx, edx
  00037	74 16		 je	 SHORT $L70002

; 1203 : 	{
; 1204 : 		Trace(2, "Warning: Call of IDirectMusicSegment::RemoveNotificationType after the segment has been garbage collected.\n");

  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GM@JGDHBIOO@Warning?3?5Call?5of?5IDirectMusicSeg@
  0003e	6a 02		 push	 2
  00040	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00045	83 c4 08	 add	 esp, 8

; 1205 : 		return DMUS_S_GARBAGE_COLLECTED;

  00048	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  0004d	eb 0e		 jmp	 SHORT $L69996
$L70002:

; 1206 : 	}
; 1207 : 
; 1208 :     return RemoveNotificationType(rguidNotification,FALSE);

  0004f	6a 00		 push	 0
  00051	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::RemoveNotificationType
$L69996:

; 1209 : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?RemoveNotificationType@CSegment@@UAGJABU_GUID@@@Z ENDP	; CSegment::RemoveNotificationType
_TEXT	ENDS
PUBLIC	??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ ; `string'
PUBLIC	??_C@_0FO@BJBDGCNH@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
PUBLIC	??_C@_0DD@GDEBGBFJ@Warning?3?5Segment?5GetParam?5failed@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetParam', 00H		; `CSegment::GetParam'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT
??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ DB '%'
	DB	's: Invalid pointer (void*)&rguidType', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@BJBDGCNH@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0FO@BJBDGCNH@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Cal'
	DB	'l of IDirectMusicSegment::GetParam after the segment has been'
	DB	' garbage collected.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GDEBGBFJ@Warning?3?5Segment?5GetParam?5failed@
CONST	SEGMENT
??_C@_0DD@GDEBGBFJ@Warning?3?5Segment?5GetParam?5failed@ DB 'Warning: Seg'
	DB	'ment GetParam failed to find a track.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z
_TEXT	SEGMENT
_prtNext$70039 = -28
_rtNext$70038 = -24
_fMultipleTry$ = -12
_hr$ = -8
_pCTrack$ = -4
_this$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_mtTime$ = 24
_pmtNext$ = 28
_pParam$ = 32
?GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z PROC NEAR	; CSegment::GetParam, COMDAT

; 1227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1228 : 	V_INAME(IDirectMusicSegment::GetParam);
; 1229 : 	V_REFGUID(rguidType);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70021
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70021:

; 1230 : 
; 1231 :     if (m_fZombie)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	0f b6 91 c0 03
	00 00		 movzx	 edx, BYTE PTR [ecx+960]
  00038	85 d2		 test	 edx, edx
  0003a	74 19		 je	 SHORT $L70023

; 1232 : 	{
; 1233 : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetParam after the segment has been garbage collected.\n");

  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FO@BJBDGCNH@Warning?3?5Call?5of?5IDirectMusicSeg@
  00041	6a 02		 push	 2
  00043	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00048	83 c4 08	 add	 esp, 8

; 1234 : 		return DMUS_S_GARBAGE_COLLECTED;

  0004b	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  00050	e9 61 01 00 00	 jmp	 $L70016
$L70023:

; 1235 : 	}
; 1236 : 
; 1237 : 	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;

  00055	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1238 :     BOOL fMultipleTry = FALSE;

  0005c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fMultipleTry$[ebp], 0

; 1239 :     if (dwIndex == DMUS_SEG_ANYTRACK)

  00063	81 7d 14 00 00
	00 80		 cmp	 DWORD PTR _dwIndex$[ebp], -2147483648 ; 80000000H
  0006a	75 0e		 jne	 SHORT $L70032

; 1240 :     {
; 1241 :         dwIndex = 0;

  0006c	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0

; 1242 :         // App must be using IDirectMusicSegment8 interface for this to be enabled...
; 1243 :         // Nah, nobody would ever have a use for an index that high, so this is safe.
; 1244 :         fMultipleTry = TRUE; // (m_dwVersion > 2);

  00073	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fMultipleTry$[ebp], 1
$L70032:

; 1245 :     }
; 1246 :     CTrack* pCTrack;
; 1247 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0007a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1248 : 	pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,FALSE);

  00087	6a 00		 push	 0
  00089	8b 4d 14	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 10	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  00090	52		 push	 edx
  00091	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00094	50		 push	 eax
  00095	6a 00		 push	 0
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z ; CSegment::GetTrackByParam
  0009f	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L70035:

; 1249 : 	while (pCTrack)

  000a2	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  000a6	0f 84 e2 00 00
	00		 je	 $L70036

; 1250 :     {
; 1251 :         if (pCTrack->m_pTrack8)

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000af	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000b3	74 50		 je	 SHORT $L70037

; 1252 :         {
; 1253 :             REFERENCE_TIME rtNext, *prtNext;
; 1254 :             // We need to store the next time in a 64 bit pointer. But, don't
; 1255 :             // make 'em fill it in unless the caller requested it. 
; 1256 :             if (pmtNext)

  000b5	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  000b9	74 08		 je	 SHORT $L70040

; 1257 :             {
; 1258 :                 prtNext = &rtNext;

  000bb	8d 55 e8	 lea	 edx, DWORD PTR _rtNext$70038[ebp]
  000be	89 55 e4	 mov	 DWORD PTR _prtNext$70039[ebp], edx

; 1259 :             }
; 1260 :             else

  000c1	eb 07		 jmp	 SHORT $L70041
$L70040:

; 1261 :             {
; 1262 :                 prtNext = NULL;

  000c3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _prtNext$70039[ebp], 0
$L70041:

; 1263 :             }
; 1264 : 		    hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
; 1265 :                 NULL, 0 );

  000ca	6a 00		 push	 0
  000cc	6a 00		 push	 0
  000ce	8b 45 20	 mov	 eax, DWORD PTR _pParam$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d e4	 mov	 ecx, DWORD PTR _prtNext$70039[ebp]
  000d5	51		 push	 ecx
  000d6	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  000d9	99		 cdq
  000da	52		 push	 edx
  000db	50		 push	 eax
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  000df	52		 push	 edx
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000e3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  000e9	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000ec	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ee	50		 push	 eax
  000ef	ff 51 38	 call	 DWORD PTR [ecx+56]
  000f2	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1266 :             if (pmtNext)

  000f5	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  000f9	74 08		 je	 SHORT $L70042

; 1267 :             {
; 1268 :                 *pmtNext = (MUSIC_TIME) rtNext;

  000fb	8b 55 e8	 mov	 edx, DWORD PTR _rtNext$70038[ebp]
  000fe	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00101	89 10		 mov	 DWORD PTR [eax], edx
$L70042:

; 1269 :             }
; 1270 :         }
; 1271 :         else

  00103	eb 51		 jmp	 SHORT $L70044
$L70037:

; 1272 :         {
; 1273 :             hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );

  00105	8b 4d 20	 mov	 ecx, DWORD PTR _pParam$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 1c	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  0010c	52		 push	 edx
  0010d	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00110	50		 push	 eax
  00111	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  00114	51		 push	 ecx
  00115	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00118	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0011e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00121	8b 00		 mov	 eax, DWORD PTR [eax]
  00123	52		 push	 edx
  00124	ff 50 1c	 call	 DWORD PTR [eax+28]
  00127	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1274 : 		    if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))

  0012a	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  0012e	74 26		 je	 SHORT $L70044
  00130	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  00133	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00136	74 10		 je	 SHORT $L70046
  00138	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0013b	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0013e	2b 45 18	 sub	 eax, DWORD PTR _mtTime$[ebp]
  00141	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  00144	39 01		 cmp	 DWORD PTR [ecx], eax
  00146	7e 0e		 jle	 SHORT $L70044
$L70046:

; 1275 : 		    {
; 1276 : 			    *pmtNext = m_mtLength - mtTime;

  00148	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0014b	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0014e	2b 45 18	 sub	 eax, DWORD PTR _mtTime$[ebp]
  00151	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  00154	89 01		 mov	 DWORD PTR [ecx], eax
$L70044:

; 1277 : 		    }
; 1278 :         }
; 1279 :         // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
; 1280 :         if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))

  00156	83 7d f4 00	 cmp	 DWORD PTR _fMultipleTry$[ebp], 0
  0015a	74 26		 je	 SHORT $L70051
  0015c	81 7d f8 61 11
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
  00163	75 1d		 jne	 SHORT $L70051

; 1281 :         {
; 1282 :             pCTrack = GetTrackByParam( pCTrack, rguidType, dwGroupBits, 0, FALSE);

  00165	6a 00		 push	 0
  00167	6a 00		 push	 0
  00169	8b 55 10	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  0016c	52		 push	 edx
  0016d	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00170	50		 push	 eax
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00174	51		 push	 ecx
  00175	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegment@@QAEPAVCTrack@@PAV2@ABU_GUID@@KKH@Z ; CSegment::GetTrackByParam
  0017d	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1283 :         }
; 1284 :         else

  00180	eb 07		 jmp	 SHORT $L70052
$L70051:

; 1285 :         {
; 1286 :             pCTrack = NULL;

  00182	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pCTrack$[ebp], 0
$L70052:

; 1287 :         }
; 1288 : 	}

  00189	e9 14 ff ff ff	 jmp	 $L70035
$L70036:

; 1289 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0018e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00191	83 c2 1c	 add	 edx, 28			; 0000001cH
  00194	52		 push	 edx
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1290 : #ifdef DBG
; 1291 :     if (hr == DMUS_E_TRACK_NOT_FOUND)

  0019b	81 7d f8 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  001a2	75 0f		 jne	 SHORT $L70054

; 1292 :     {
; 1293 :         Trace(2,"Warning: Segment GetParam failed to find a track.\n");

  001a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@GDEBGBFJ@Warning?3?5Segment?5GetParam?5failed@
  001a9	6a 02		 push	 2
  001ab	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001b0	83 c4 08	 add	 esp, 8
$L70054:

; 1294 :     }
; 1295 : #endif
; 1296 : 	return hr;

  001b3	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L70016:

; 1297 : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 1c 00	 ret	 28			; 0000001cH
?GetParam@CSegment@@UAGJABU_GUID@@KKJPAJPAX@Z ENDP	; CSegment::GetParam
_TEXT	ENDS
PUBLIC	??_C@_0FO@GNGHBGLK@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
PUBLIC	??_C@_0DP@MHEHIJLM@Warning?3?5Segment?5SetParam?5failed@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::SetParam', 00H		; `CSegment::SetParam'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0FO@GNGHBGLK@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0FO@GNGHBGLK@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Cal'
	DB	'l of IDirectMusicSegment::SetParam after the segment has been'
	DB	' garbage collected.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MHEHIJLM@Warning?3?5Segment?5SetParam?5failed@
CONST	SEGMENT
??_C@_0DP@MHEHIJLM@Warning?3?5Segment?5SetParam?5failed@ DB 'Warning: Seg'
	DB	'ment SetParam failed to find the requested track.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z
_TEXT	SEGMENT
_pTrack$ = -16
_hr$ = -12
_dwMax$ = -8
_dwCounter$ = -4
_this$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_mtTime$ = 24
_pParam$ = 28
?SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z PROC NEAR	; CSegment::SetParam, COMDAT

; 1312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1313 : 	V_INAME(IDirectMusicSegment::SetParam);
; 1314 : 	V_REFGUID(rguidType);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70068
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70068:

; 1315 : 
; 1316 :     if (m_fZombie)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	0f b6 91 c0 03
	00 00		 movzx	 edx, BYTE PTR [ecx+960]
  00038	85 d2		 test	 edx, edx
  0003a	74 19		 je	 SHORT $L70069

; 1317 : 	{
; 1318 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetParam after the segment has been garbage collected.\n");

  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FO@GNGHBGLK@Warning?3?5Call?5of?5IDirectMusicSeg@
  00041	6a 02		 push	 2
  00043	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00048	83 c4 08	 add	 esp, 8

; 1319 : 		return DMUS_S_GARBAGE_COLLECTED;

  0004b	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  00050	e9 9d 00 00 00	 jmp	 $L70063
$L70069:

; 1320 : 	}
; 1321 :     ENTER_API_CRITICAL_SECTION;
; 1322 : 	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;

  00055	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1323 : 	IDirectMusicTrack* pTrack;
; 1324 :     DWORD dwCounter = dwIndex;

  0005c	8b 45 14	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0005f	89 45 fc	 mov	 DWORD PTR _dwCounter$[ebp], eax

; 1325 :     DWORD dwMax = dwIndex;

  00062	8b 4d 14	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00065	89 4d f8	 mov	 DWORD PTR _dwMax$[ebp], ecx

; 1326 :     if (dwIndex == DMUS_SEG_ALLTRACKS)

  00068	81 7d 14 00 00
	00 80		 cmp	 DWORD PTR _dwIndex$[ebp], -2147483648 ; 80000000H
  0006f	75 0e		 jne	 SHORT $L70082

; 1327 :     {
; 1328 :         dwCounter = 0;

  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCounter$[ebp], 0

; 1329 :         dwMax = DMUS_SEG_ALLTRACKS;

  00078	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _dwMax$[ebp], -2147483648 ; 80000000H
$L70082:

; 1330 :     }
; 1331 :     while (SUCCEEDED( GetTrackByParam( rguidType, dwGroupBits, dwCounter, &pTrack )))

  0007f	8d 55 f0	 lea	 edx, DWORD PTR _pTrack$[ebp]
  00082	52		 push	 edx
  00083	8b 45 fc	 mov	 eax, DWORD PTR _dwCounter$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 10	 mov	 ecx, DWORD PTR _dwGroupBits$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  0008e	52		 push	 edx
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegment@@QAEJABU_GUID@@KKPAPAUIDirectMusicTrack@@@Z ; CSegment::GetTrackByParam
  00097	85 c0		 test	 eax, eax
  00099	7c 3c		 jl	 SHORT $L70083

; 1332 : 	{
; 1333 : 		hr = pTrack->SetParam( rguidType, mtTime, pParam );

  0009b	8b 45 1c	 mov	 eax, DWORD PTR _pParam$[ebp]
  0009e	50		 push	 eax
  0009f	8b 4d 18	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000a2	51		 push	 ecx
  000a3	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  000a6	52		 push	 edx
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _pTrack$[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	8b 55 f0	 mov	 edx, DWORD PTR _pTrack$[ebp]
  000af	52		 push	 edx
  000b0	ff 51 20	 call	 DWORD PTR [ecx+32]
  000b3	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1334 : 		pTrack->Release();

  000b6	8b 45 f0	 mov	 eax, DWORD PTR _pTrack$[ebp]
  000b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bb	8b 55 f0	 mov	 edx, DWORD PTR _pTrack$[ebp]
  000be	52		 push	 edx
  000bf	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1335 :         dwCounter++;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _dwCounter$[ebp]
  000c5	83 c0 01	 add	 eax, 1
  000c8	89 45 fc	 mov	 DWORD PTR _dwCounter$[ebp], eax

; 1336 :         if (dwCounter > dwMax) break;

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _dwCounter$[ebp]
  000ce	3b 4d f8	 cmp	 ecx, DWORD PTR _dwMax$[ebp]
  000d1	76 02		 jbe	 SHORT $L70085
  000d3	eb 02		 jmp	 SHORT $L70083
$L70085:

; 1337 : 	}

  000d5	eb a8		 jmp	 SHORT $L70082
$L70083:

; 1338 : #ifdef DBG
; 1339 :     if (hr == DMUS_E_TRACK_NOT_FOUND)

  000d7	81 7d f4 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  000de	75 0f		 jne	 SHORT $L70087

; 1340 :     {
; 1341 :         Trace(2,"Warning: Segment SetParam failed to find the requested track.\n");

  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@MHEHIJLM@Warning?3?5Segment?5SetParam?5failed@
  000e5	6a 02		 push	 2
  000e7	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ec	83 c4 08	 add	 esp, 8
$L70087:

; 1342 :     }
; 1343 : #endif
; 1344 :     LEAVE_API_CRITICAL_SECTION;
; 1345 : 	return hr;

  000ef	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]
$L70063:

; 1346 : }

  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 18 00	 ret	 24			; 00000018H
?SetParam@CSegment@@UAGJABU_GUID@@KKJPAX@Z ENDP		; CSegment::SetParam
_TEXT	ENDS
PUBLIC	??_C@_0EP@BJBAKHPF@Warning?3?5dwReadhead?5is?5less?5than@ ; `string'
PUBLIC	??_C@_0DO@CFOHLKLL@Segment?3?3SetWavePlaybackParams?3?5@ ; `string'
PUBLIC	??_C@_0GB@MOMCJDPJ@?$CB?$CIdwFlags?5?$CG?5?$CIDMUS_WAVEF_OFF?$CJ?$CJ?5?$CG?$CG@ ; `string'
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
EXTRN	_GUID_WavePlayParams:BYTE
;	COMDAT ??_C@_0EP@BJBAKHPF@Warning?3?5dwReadhead?5is?5less?5than@
CONST	SEGMENT
??_C@_0EP@BJBAKHPF@Warning?3?5dwReadhead?5is?5less?5than@ DB 'Warning: dw'
	DB	'Readhead is less than minimum required. dwReadAhead reset to '
	DB	'%d ms', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CFOHLKLL@Segment?3?3SetWavePlaybackParams?3?5@
CONST	SEGMENT
??_C@_0DO@CFOHLKLL@Segment?3?3SetWavePlaybackParams?3?5@ DB 'Segment::Set'
	DB	'WavePlaybackParams: Specified flags not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@MOMCJDPJ@?$CB?$CIdwFlags?5?$CG?5?$CIDMUS_WAVEF_OFF?$CJ?$CJ?5?$CG?$CG@
CONST	SEGMENT
??_C@_0GB@MOMCJDPJ@?$CB?$CIdwFlags?5?$CG?5?$CIDMUS_WAVEF_OFF?$CJ?$CJ?5?$CG?$CG@ DB '!'
	DB	'(dwFlags & (DMUS_WAVEF_OFF)) && "Segment::SetWavePlaybackPara'
	DB	'ms: Specified flags not supported"', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetWavePlaybackParams@CSegment@@UAGJKK@Z
_TEXT	SEGMENT
tv78 = -20
_ioParams$ = -16
_this$ = 8
_dwFlags$ = 12
_dwReadAhead$ = 16
?SetWavePlaybackParams@CSegment@@UAGJKK@Z PROC NEAR	; CSegment::SetWavePlaybackParams, COMDAT

; 1350 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1351 :     DMUS_IO_WAVE_HEADER ioParams;
; 1352 : #if DBG
; 1353 :     if (dwReadAhead < DMUS_READAHEAD_MIN) {

  00006	83 7d 10 32	 cmp	 DWORD PTR _dwReadAhead$[ebp], 50 ; 00000032H
  0000a	73 11		 jae	 SHORT $L70095

; 1354 :         Trace(1,"Warning: dwReadhead is less than minimum required. dwReadAhead reset to %d ms\n",DMUS_READAHEAD_MIN);

  0000c	6a 32		 push	 50			; 00000032H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@BJBAKHPF@Warning?3?5dwReadhead?5is?5less?5than@
  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70095:

; 1355 :     }    
; 1356 : #endif
; 1357 : 
; 1358 :     assert(!(dwFlags & (DMUS_WAVEF_OFF)) && "Segment::SetWavePlaybackParams: Specified flags not supported");

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	75 09		 jne	 SHORT $L72013
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:??_C@_0DO@CFOHLKLL@Segment?3?3SetWavePlaybackParams?3?5@
  0002c	85 c9		 test	 ecx, ecx
  0002e	75 14		 jne	 SHORT $L72014
$L72013:
  00030	68 4e 05 00 00	 push	 1358			; 0000054eH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GB@MOMCJDPJ@?$CB?$CIdwFlags?5?$CG?5?$CIDMUS_WAVEF_OFF?$CJ?$CJ?5?$CG?$CG@
  0003f	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L72014:

; 1359 :     ioParams.rtReadAhead = max(dwReadAhead * REF_PER_MIL, DMUS_READAHEAD_MIN*REF_PER_MIL);

  00044	8b 45 10	 mov	 eax, DWORD PTR _dwReadAhead$[ebp]
  00047	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  0004d	3d 20 a1 07 00	 cmp	 eax, 500000		; 0007a120H
  00052	76 0e		 jbe	 SHORT $L72015
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _dwReadAhead$[ebp]
  00057	69 c9 10 27 00
	00		 imul	 ecx, 10000		; 00002710H
  0005d	89 4d ec	 mov	 DWORD PTR tv78[ebp], ecx
  00060	eb 07		 jmp	 SHORT $L72016
$L72015:
  00062	c7 45 ec 20 a1
	07 00		 mov	 DWORD PTR tv78[ebp], 500000 ; 0007a120H
$L72016:
  00069	8b 55 ec	 mov	 edx, DWORD PTR tv78[ebp]
  0006c	33 c0		 xor	 eax, eax
  0006e	89 55 f0	 mov	 DWORD PTR _ioParams$[ebp], edx
  00071	89 45 f4	 mov	 DWORD PTR _ioParams$[ebp+4], eax

; 1360 :     ioParams.dwFlags = dwFlags;

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00077	89 4d f8	 mov	 DWORD PTR _ioParams$[ebp+8], ecx

; 1361 : 
; 1362 :     return SetParam(GUID_WavePlayParams,-1,0,0,&ioParams);

  0007a	8d 55 f0	 lea	 edx, DWORD PTR _ioParams$[ebp]
  0007d	52		 push	 edx
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a ff		 push	 -1
  00084	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_WavePlayParams
  00089	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00091	52		 push	 edx
  00092	ff 51 70	 call	 DWORD PTR [ecx+112]

; 1363 : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 0c 00	 ret	 12			; 0000000cH
?SetWavePlaybackParams@CSegment@@UAGJKK@Z ENDP		; CSegment::SetWavePlaybackParams
_TEXT	ENDS
PUBLIC	??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??Download@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Download@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::Download', 00H		; `CSegment::Download'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
CONST	SEGMENT
??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pAudioPath', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Download@CSegment@@UAGJPAUIUnknown@@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_pAudioPath$ = 12
?Download@CSegment@@UAGJPAUIUnknown@@@Z PROC NEAR	; CSegment::Download, COMDAT

; 1368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1369 : 	V_INAME(IDirectMusicSegment::Download);
; 1370 :     V_INTERFACE(pAudioPath);

  00004	6a 04		 push	 4
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L70107
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Download@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70107:
  0002c	6a 04		 push	 4
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L70111
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Download@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L70111:
  00056	8b 45 0c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00063	85 c0		 test	 eax, eax
  00065	74 19		 je	 SHORT $L70113
  00067	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Download@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00071	6a ff		 push	 -1
  00073	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	e8 00 00 00 00	 call	 _DebugBreak@0
$L70113:

; 1371 :     HRESULT hr = S_OK;

  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1372 : 
; 1373 : #ifdef DXAPI
; 1374 :     if (m_fZombie)
; 1375 : 	{
; 1376 : 		Trace(2, "Warning: Call of IDirectMusicSegment::Download after the segment has been garbage collected.\n");
; 1377 : 		return DMUS_S_GARBAGE_COLLECTED;
; 1378 : 	}
; 1379 : 
; 1380 :     // Validate that pAudioPath is either a performance or an audio path 
; 1381 :     IDirectMusicPerformance* pPerf = NULL;
; 1382 :     if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)) )
; 1383 :     {
; 1384 :         IDirectMusicAudioPath* pAP = NULL;
; 1385 :         if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath, (void**)&pAP)) )
; 1386 :         {
; 1387 :             return hr; // nothing to release, since all the QI's failed.
; 1388 :         }
; 1389 :         else
; 1390 :         {
; 1391 :             pAP->Release();
; 1392 :         }
; 1393 :     }
; 1394 :     else
; 1395 :     {
; 1396 :         pPerf->Release();
; 1397 :     }
; 1398 : 
; 1399 :     hr = SetParam(GUID_DownloadToAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
; 1400 :     if (hr == DMUS_E_TRACK_NOT_FOUND)
; 1401 :     {
; 1402 :         Trace(2,"Attempted download to a segment that has no tracks that support downloading (wave and band tracks.)\n");
; 1403 :         hr = S_OK;
; 1404 :     }
; 1405 : #endif
; 1406 :     return hr;

  00087	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1407 : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?Download@CSegment@@UAGJPAUIUnknown@@@Z ENDP		; CSegment::Download
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Unload@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Unload@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::Unload', 00H		; `CSegment::Unload'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Unload@CSegment@@UAGJPAUIUnknown@@@Z
_TEXT	SEGMENT
_this$ = 8
_pAudioPath$ = 12
?Unload@CSegment@@UAGJPAUIUnknown@@@Z PROC NEAR		; CSegment::Unload, COMDAT

; 1411 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1412 : 	V_INAME(IDirectMusicSegment::Unload);
; 1413 :     V_INTERFACE(pAudioPath);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70123
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Unload@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70123:
  0002b	6a 04		 push	 4
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00030	8b 11		 mov	 edx, DWORD PTR [ecx]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $L70126
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Unload@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00046	6a ff		 push	 -1
  00048	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 _DebugBreak@0
$L70126:
  00055	8b 45 0c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00062	85 c0		 test	 eax, eax
  00064	74 19		 je	 SHORT $L70128
  00066	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Unload@CSegment@@UAGJPAUIUnknown@@@Z@4QBDB
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00070	6a ff		 push	 -1
  00072	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	e8 00 00 00 00	 call	 _DebugBreak@0
$L70128:

; 1414 : 
; 1415 :     return S_OK;

  0007f	33 c0		 xor	 eax, eax

; 1416 : 
; 1417 : #ifdef DXAPI
; 1418 :     if (m_fZombie)
; 1419 : 	{
; 1420 : 		Trace(2, "Warning: Call of IDirectMusicSegment::Unload after the segment has been garbage collected.\n");
; 1421 : 		return DMUS_S_GARBAGE_COLLECTED;
; 1422 : 	}
; 1423 : 
; 1424 :     HRESULT hr = SetParam(GUID_UnloadFromAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
; 1425 :     if (hr == DMUS_E_TRACK_NOT_FOUND)
; 1426 :     {
; 1427 :         Trace(2,"Attempted unload from a segment that has no tracks that support downloading (wave and band tracks.)\n");
; 1428 :         hr = S_OK;
; 1429 :     }
; 1430 :     return hr;
; 1431 : #endif //DXAPI
; 1432 : 
; 1433 : }

  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?Unload@CSegment@@UAGJPAUIUnknown@@@Z ENDP		; CSegment::Unload
_TEXT	ENDS
PUBLIC	?SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z	; CSegment::SetTrackConfig
PUBLIC	??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ ; `string'
PUBLIC	??_C@_0ED@IKKOIILC@Error?3?5Segment?5SetTrackConfig?5fa@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::SetTrackConfig', 00H	; `CSegment::SetTrackConfig'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT
??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ DB '%'
	DB	's: Invalid pointer (void*)&rguidTrackClassID', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@IKKOIILC@Error?3?5Segment?5SetTrackConfig?5fa@
CONST	SEGMENT
??_C@_0ED@IKKOIILC@Error?3?5Segment?5SetTrackConfig?5fa@ DB 'Error: Segme'
	DB	'nt SetTrackConfig failed to find the requested track.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z
_TEXT	SEGMENT
_hr$ = -16
_pCTrack$ = -12
_dwMax$ = -8
_dwCounter$ = -4
_this$ = 8
_rguidTrackClassID$ = 12
_dwGroup$ = 16
_dwIndex$ = 20
_dwFlagsOn$ = 24
_dwFlagsOff$ = 28
?SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z PROC NEAR ; CSegment::SetTrackConfig, COMDAT

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1439 : 	V_INAME(IDirectMusicSegment::SetTrackConfig);
; 1440 : 	V_REFGUID(rguidTrackClassID);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidTrackClassID$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70142
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70142:

; 1441 :     if (rguidTrackClassID == GUID_NULL)

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidTrackClassID$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _==@8
  0003c	85 c0		 test	 eax, eax
  0003e	74 0a		 je	 SHORT $L70144

; 1442 :     {
; 1443 :         return E_INVALIDARG;

  00040	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00045	e9 ba 00 00 00	 jmp	 $L70137
$L70144:

; 1444 :     }
; 1445 : #ifdef DXAPI
; 1446 :     if (m_fZombie)
; 1447 : 	{
; 1448 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackConfig after the segment has been garbage collected.\n");
; 1449 : 		return DMUS_S_GARBAGE_COLLECTED;
; 1450 : 	}
; 1451 : #endif
; 1452 :     HRESULT hr = DMUS_E_TRACK_NOT_FOUND;

  0004a	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1453 :     CTrack* pCTrack;
; 1454 :     DWORD dwCounter = dwIndex;

  00051	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00054	89 55 fc	 mov	 DWORD PTR _dwCounter$[ebp], edx

; 1455 :     DWORD dwMax = dwIndex;

  00057	8b 45 14	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0005a	89 45 f8	 mov	 DWORD PTR _dwMax$[ebp], eax

; 1456 :     if (dwIndex == DMUS_SEG_ALLTRACKS)

  0005d	81 7d 14 00 00
	00 80		 cmp	 DWORD PTR _dwIndex$[ebp], -2147483648 ; 80000000H
  00064	75 0e		 jne	 SHORT $L70151

; 1457 :     {
; 1458 :         dwCounter = 0;

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCounter$[ebp], 0

; 1459 :         dwMax = DMUS_SEG_ALLTRACKS;

  0006d	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _dwMax$[ebp], -2147483648 ; 80000000H
$L70151:

; 1460 :     }
; 1461 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4
$L70153:

; 1462 :     while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwCounter))

  00081	8b 55 fc	 mov	 edx, DWORD PTR _dwCounter$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidTrackClassID$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegment::GetTrack
  00095	89 45 f4	 mov	 DWORD PTR _pCTrack$[ebp], eax
  00098	83 7d f4 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0009c	74 3e		 je	 SHORT $L70154

; 1463 :     {
; 1464 :         pCTrack->m_dwFlags &= ~dwFlagsOff;

  0009e	8b 55 1c	 mov	 edx, DWORD PTR _dwFlagsOff$[ebp]
  000a1	f7 d2		 not	 edx
  000a3	8b 45 f4	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000a6	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a9	23 ca		 and	 ecx, edx
  000ab	8b 55 f4	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  000ae	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 1465 :         pCTrack->m_dwFlags |= dwFlagsOn;

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000b4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b7	0b 4d 18	 or	 ecx, DWORD PTR _dwFlagsOn$[ebp]
  000ba	8b 55 f4	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  000bd	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 1466 :         hr = S_OK;

  000c0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1467 :         dwCounter++;

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _dwCounter$[ebp]
  000ca	83 c0 01	 add	 eax, 1
  000cd	89 45 fc	 mov	 DWORD PTR _dwCounter$[ebp], eax

; 1468 :         if (dwCounter > dwMax) break;

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _dwCounter$[ebp]
  000d3	3b 4d f8	 cmp	 ecx, DWORD PTR _dwMax$[ebp]
  000d6	76 02		 jbe	 SHORT $L70156
  000d8	eb 02		 jmp	 SHORT $L70154
$L70156:

; 1469 :     }

  000da	eb a5		 jmp	 SHORT $L70153
$L70154:

; 1470 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000dc	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000df	83 c2 1c	 add	 edx, 28			; 0000001cH
  000e2	52		 push	 edx
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1471 : #ifdef DBG
; 1472 :     if (hr == DMUS_E_TRACK_NOT_FOUND)

  000e9	81 7d f0 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  000f0	75 0f		 jne	 SHORT $L70158

; 1473 :     {
; 1474 :         Trace(1,"Error: Segment SetTrackConfig failed to find the requested track.\n");

  000f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0ED@IKKOIILC@Error?3?5Segment?5SetTrackConfig?5fa@
  000f7	6a 01		 push	 1
  000f9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000fe	83 c4 08	 add	 esp, 8
$L70158:

; 1475 :     }
; 1476 : #endif
; 1477 : 	return hr;

  00101	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
$L70137:

; 1478 : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 18 00	 ret	 24			; 00000018H
?SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z ENDP	; CSegment::SetTrackConfig
_TEXT	ENDS
PUBLIC	?GetTrackConfig@CSegment@@QAEJABU_GUID@@KKPAK@Z	; CSegment::GetTrackConfig
; Function compile flags: /Odt
;	COMDAT ?GetTrackConfig@CSegment@@QAEJABU_GUID@@KKPAK@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_pCTrack$ = -4
_rguidTrackClassID$ = 8
_dwGroup$ = 12
_dwIndex$ = 16
_pdwFlags$ = 20
?GetTrackConfig@CSegment@@QAEJABU_GUID@@KKPAK@Z PROC NEAR ; CSegment::GetTrackConfig, COMDAT
; _this$ = ecx

; 1482 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1483 : 
; 1484 : 	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;

  00009	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1485 :     CTrack* pCTrack;
; 1486 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 1c	 add	 eax, 28			; 0000001cH
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1487 : 	pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex);

  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 0c	 mov	 edx, DWORD PTR _dwGroup$[ebp]
  00024	52		 push	 edx
  00025	8b 45 08	 mov	 eax, DWORD PTR _rguidTrackClassID$[ebp]
  00028	50		 push	 eax
  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?GetTrack@CSegment@@QAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegment::GetTrack
  00031	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1488 : 	if (pCTrack)

  00034	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00038	74 12		 je	 SHORT $L70170

; 1489 :     {
; 1490 :         *pdwFlags = pCTrack->m_dwFlags;

  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _pdwFlags$[ebp]
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00040	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00043	89 01		 mov	 DWORD PTR [ecx], eax

; 1491 :         hr = S_OK;

  00045	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L70170:

; 1492 :     }
; 1493 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1494 : 	return hr;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1495 : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 10 00	 ret	 16			; 00000010H
?GetTrackConfig@CSegment@@QAEJABU_GUID@@KKPAK@Z ENDP	; CSegment::GetTrackConfig
_TEXT	ENDS
PUBLIC	??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@ ; `string'
PUBLIC	??_C@_0FL@FDOOPLA@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
PUBLIC	??_C@_0EK@BGLLPLII@Warning?3?5Insertion?5of?5cloned?5tra@ ; `string'
PUBLIC	??_C@_0DM@KNLAPKHK@Warning?3?5Track?5clone?5failed?0?5clo@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::Clone', 00H		; `CSegment::Clone'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@
CONST	SEGMENT
??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@ DB '%s: In'
	DB	'valid pointer ppSegment', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@FDOOPLA@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0FL@FDOOPLA@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Call'
	DB	' of IDirectMusicSegment::Clone after the segment has been gar'
	DB	'bage collected.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BGLLPLII@Warning?3?5Insertion?5of?5cloned?5tra@
CONST	SEGMENT
??_C@_0EK@BGLLPLII@Warning?3?5Insertion?5of?5cloned?5tra@ DB 'Warning: In'
	DB	'sertion of cloned track failed, cloned segment is incomplete.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@KNLAPKHK@Warning?3?5Track?5clone?5failed?0?5clo@
CONST	SEGMENT
??_C@_0DM@KNLAPKHK@Warning?3?5Track?5clone?5failed?0?5clo@ DB 'Warning: T'
	DB	'rack clone failed, cloned segment is incomplete.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z
_TEXT	SEGMENT
tv91 = -24
$T72032 = -20
_pTrack$ = -16
_hr$ = -12
_pCTrack$ = -8
_pCSegment$ = -4
_this$ = 8
_mtStart$ = 12
_mtEnd$ = 16
_ppSegment$ = 20
?Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z PROC NEAR ; CSegment::Clone, COMDAT

; 1508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1509 : 	V_INAME(IDirectMusicSegment::Clone);
; 1510 : 	V_PTRPTR_WRITE(ppSegment);

  00008	6a 04		 push	 4
  0000a	8b 45 14	 mov	 eax, DWORD PTR _ppSegment$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00013	85 c0		 test	 eax, eax
  00015	74 19		 je	 SHORT $L70181
  00017	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z@4QBDB
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@
  00021	6a ff		 push	 -1
  00023	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	e8 00 00 00 00	 call	 _DebugBreak@0
$L70181:

; 1511 : 
; 1512 :     if (m_fZombie)

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	0f b6 91 c0 03
	00 00		 movzx	 edx, BYTE PTR [ecx+960]
  0003a	85 d2		 test	 edx, edx
  0003c	74 19		 je	 SHORT $L70183

; 1513 : 	{
; 1514 : 		Trace(2, "Warning: Call of IDirectMusicSegment::Clone after the segment has been garbage collected.\n");

  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FL@FDOOPLA@Warning?3?5Call?5of?5IDirectMusicSeg@
  00043	6a 02		 push	 2
  00045	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004a	83 c4 08	 add	 esp, 8

; 1515 : 		return DMUS_S_GARBAGE_COLLECTED;

  0004d	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  00052	e9 98 02 00 00	 jmp	 $L70177
$L70183:

; 1516 : 	}
; 1517 : 
; 1518 : 	CSegment* pCSegment;
; 1519 : 	HRESULT hr = S_OK;

  00057	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1520 : 
; 1521 : 	if( (mtEnd < mtStart) || (mtEnd > m_mtLength) )

  0005e	8b 45 10	 mov	 eax, DWORD PTR _mtEnd$[ebp]
  00061	3b 45 0c	 cmp	 eax, DWORD PTR _mtStart$[ebp]
  00064	7c 0b		 jl	 SHORT $L70193
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	8b 55 10	 mov	 edx, DWORD PTR _mtEnd$[ebp]
  0006c	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  0006f	7e 09		 jle	 SHORT $L70192
$L70193:

; 1522 : 	{
; 1523 : 		mtEnd = m_mtLength;

  00071	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00077	89 4d 10	 mov	 DWORD PTR _mtEnd$[ebp], ecx
$L70192:

; 1524 : 	}
; 1525 : 	if( ( mtEnd == 0 ) && ( mtStart == 0 ))

  0007a	83 7d 10 00	 cmp	 DWORD PTR _mtEnd$[ebp], 0
  0007e	75 0f		 jne	 SHORT $L70194
  00080	83 7d 0c 00	 cmp	 DWORD PTR _mtStart$[ebp], 0
  00084	75 09		 jne	 SHORT $L70194

; 1526 : 	{
; 1527 : 		mtEnd = m_mtLength;

  00086	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0008c	89 45 10	 mov	 DWORD PTR _mtEnd$[ebp], eax
$L70194:

; 1528 : 	}
; 1529 : 	if( (mtStart < 0) || (mtStart > m_mtLength) )

  0008f	83 7d 0c 00	 cmp	 DWORD PTR _mtStart$[ebp], 0
  00093	7c 0b		 jl	 SHORT $L70196
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	8b 55 0c	 mov	 edx, DWORD PTR _mtStart$[ebp]
  0009b	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  0009e	7e 07		 jle	 SHORT $L70195
$L70196:

; 1530 : 	{
; 1531 : 		mtStart = 0;

  000a0	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _mtStart$[ebp], 0
$L70195:

; 1532 : 	}
; 1533 :     pCSegment = new CSegment;

  000a7	68 e0 03 00 00	 push	 992			; 000003e0H
  000ac	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b1	83 c4 04	 add	 esp, 4
  000b4	89 45 ec	 mov	 DWORD PTR $T72032[ebp], eax
  000b7	83 7d ec 00	 cmp	 DWORD PTR $T72032[ebp], 0
  000bb	74 0d		 je	 SHORT $L72033
  000bd	8b 4d ec	 mov	 ecx, DWORD PTR $T72032[ebp]
  000c0	e8 00 00 00 00	 call	 ??0CSegment@@QAE@XZ	; CSegment::CSegment
  000c5	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000c8	eb 07		 jmp	 SHORT $L72034
$L72033:
  000ca	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
$L72034:
  000d1	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  000d4	89 45 fc	 mov	 DWORD PTR _pCSegment$[ebp], eax

; 1534 :     if (pCSegment == NULL) {

  000d7	83 7d fc 00	 cmp	 DWORD PTR _pCSegment$[ebp], 0
  000db	75 0a		 jne	 SHORT $L70199

; 1535 :         return E_OUTOFMEMORY;

  000dd	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  000e2	e9 08 02 00 00	 jmp	 $L70177
$L70199:

; 1536 :     }
; 1537 :     // Addref to 1 and assign to ppSegment.
; 1538 :     pCSegment->AddRef();

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  000ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ec	8b 45 fc	 mov	 eax, DWORD PTR _pCSegment$[ebp]
  000ef	50		 push	 eax
  000f0	ff 52 04	 call	 DWORD PTR [edx+4]

; 1539 :     (*ppSegment) = (IDirectMusicSegment *) pCSegment;

  000f3	8b 4d 14	 mov	 ecx, DWORD PTR _ppSegment$[ebp]
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _pCSegment$[ebp]
  000f9	89 11		 mov	 DWORD PTR [ecx], edx

; 1540 : 	if( m_pGraph )

  000fb	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00102	74 1e		 je	 SHORT $L70202

; 1541 : 	{
; 1542 : 		pCSegment->m_pGraph = m_pGraph;

  00104	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  00107	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0010d	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1543 : 		m_pGraph->AddRef();

  00110	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00116	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00119	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0011c	8b 12		 mov	 edx, DWORD PTR [edx]
  0011e	51		 push	 ecx
  0011f	ff 52 04	 call	 DWORD PTR [edx+4]
$L70202:

; 1544 : 	}
; 1545 :     if (m_pAudioPathConfig)

  00122	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00125	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00129	74 1e		 je	 SHORT $L70203

; 1546 :     {
; 1547 :         pCSegment->m_pAudioPathConfig = m_pAudioPathConfig;

  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  0012e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00131	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00134	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1548 :         m_pAudioPathConfig->AddRef();

  00137	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0013d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00140	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00143	8b 12		 mov	 edx, DWORD PTR [edx]
  00145	51		 push	 ecx
  00146	ff 52 04	 call	 DWORD PTR [edx+4]
$L70203:

; 1549 :     }
; 1550 :     pCSegment->m_dwRepeats = m_dwRepeats;

  00149	8b 45 fc	 mov	 eax, DWORD PTR _pCSegment$[ebp]
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00152	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 1551 :     pCSegment->m_dwResolution = m_dwResolution;

  00155	8b 45 fc	 mov	 eax, DWORD PTR _pCSegment$[ebp]
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0015e	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 1552 :     pCSegment->m_dwSegFlags = m_dwSegFlags;

  00161	8b 45 fc	 mov	 eax, DWORD PTR _pCSegment$[ebp]
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0016a	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 1553 : 	pCSegment->m_mtLength = mtEnd - mtStart;

  0016d	8b 45 10	 mov	 eax, DWORD PTR _mtEnd$[ebp]
  00170	2b 45 0c	 sub	 eax, DWORD PTR _mtStart$[ebp]
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  00176	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 1554 : 	pCSegment->m_rtLength = m_rtLength;

  00179	8b 55 fc	 mov	 edx, DWORD PTR _pCSegment$[ebp]
  0017c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0017f	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00182	89 4a 58	 mov	 DWORD PTR [edx+88], ecx
  00185	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  00188	89 42 5c	 mov	 DWORD PTR [edx+92], eax

; 1555 :     pCSegment->m_mtStart = m_mtStart;

  0018b	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  0018e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00191	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00194	89 41 74	 mov	 DWORD PTR [ecx+116], eax

; 1556 :     pCSegment->m_mtLoopStart = m_mtLoopStart;

  00197	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  0019a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0019d	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  001a0	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 1557 :     pCSegment->m_mtLoopEnd = m_mtLoopEnd;

  001a3	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  001a6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001a9	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  001ac	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 1558 :     pCSegment->m_Info = m_Info;

  001af	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  001b2	81 c6 90 00 00
	00		 add	 esi, 144		; 00000090H
  001b8	8b 7d fc	 mov	 edi, DWORD PTR _pCSegment$[ebp]
  001bb	81 c7 90 00 00
	00		 add	 edi, 144		; 00000090H
  001c1	b9 cb 00 00 00	 mov	 ecx, 203		; 000000cbH
  001c6	f3 a5		 rep movsd

; 1559 :     pCSegment->m_dwVersion = m_dwVersion;

  001c8	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  001cb	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001ce	8b 82 bc 03 00
	00		 mov	 eax, DWORD PTR [edx+956]
  001d4	89 81 bc 03 00
	00		 mov	 DWORD PTR [ecx+956], eax

; 1560 :     pCSegment->m_dwLoadID = m_dwLoadID;

  001da	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  001dd	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001e0	8b 82 c4 03 00
	00		 mov	 eax, DWORD PTR [edx+964]
  001e6	89 81 c4 03 00
	00		 mov	 DWORD PTR [ecx+964], eax

; 1561 :     pCSegment->m_dwPlayID = m_dwPlayID;

  001ec	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  001ef	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f2	8b 82 cc 03 00
	00		 mov	 eax, DWORD PTR [edx+972]
  001f8	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 1562 :     pCSegment->m_dwNextPlayID = m_dwNextPlayID;

  001fe	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  00201	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00204	8b 82 d0 03 00
	00		 mov	 eax, DWORD PTR [edx+976]
  0020a	89 81 d0 03 00
	00		 mov	 DWORD PTR [ecx+976], eax

; 1563 :     pCSegment->m_dwNextPlayFlags = m_dwNextPlayFlags;

  00210	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  00213	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00216	8b 82 d4 03 00
	00		 mov	 eax, DWORD PTR [edx+980]
  0021c	89 81 d4 03 00
	00		 mov	 DWORD PTR [ecx+980], eax

; 1564 : 
; 1565 : 	CTrack* pCTrack;
; 1566 : 	IDirectMusicTrack* pTrack;
; 1567 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00222	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00225	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00228	51		 push	 ecx
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1568 : 	pCTrack = m_TrackList.GetHead();

  0022f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	83 c1 44	 add	 ecx, 68			; 00000044H
  00235	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  0023a	89 45 f8	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L70207:

; 1569 : 	while( pCTrack )

  0023d	83 7d f8 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00241	0f 84 98 00 00
	00		 je	 $L70208

; 1570 : 	{
; 1571 : 		if( SUCCEEDED( pCTrack->m_pTrack->Clone( mtStart, mtEnd, &pTrack )))

  00247	8d 55 f0	 lea	 edx, DWORD PTR _pTrack$[ebp]
  0024a	52		 push	 edx
  0024b	8b 45 10	 mov	 eax, DWORD PTR _mtEnd$[ebp]
  0024e	50		 push	 eax
  0024f	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  00252	51		 push	 ecx
  00253	8b 55 f8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00256	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00259	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0025c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0025f	8b 00		 mov	 eax, DWORD PTR [eax]
  00261	52		 push	 edx
  00262	ff 50 30	 call	 DWORD PTR [eax+48]
  00265	85 c0		 test	 eax, eax
  00267	7c 50		 jl	 SHORT $L70210

; 1572 : 		{
; 1573 : 			if( FAILED( pCSegment->InsertTrack( pTrack, pCTrack->m_dwGroupBits, pCTrack->m_dwFlags, pCTrack->m_dwPriority, pCTrack->m_dwPosition )))

  00269	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0026c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0026f	52		 push	 edx
  00270	8b 45 f8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00273	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00276	51		 push	 ecx
  00277	8b 55 f8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  0027a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0027d	50		 push	 eax
  0027e	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00281	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00284	52		 push	 edx
  00285	8b 45 f0	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00288	50		 push	 eax
  00289	8b 4d fc	 mov	 ecx, DWORD PTR _pCSegment$[ebp]
  0028c	e8 00 00 00 00	 call	 ?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z ; CSegment::InsertTrack
  00291	85 c0		 test	 eax, eax
  00293	7d 16		 jge	 SHORT $L70212

; 1574 : 			{
; 1575 :                 Trace(1,"Warning: Insertion of cloned track failed, cloned segment is incomplete.\n");

  00295	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EK@BGLLPLII@Warning?3?5Insertion?5of?5cloned?5tra@
  0029a	6a 01		 push	 1
  0029c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002a1	83 c4 08	 add	 esp, 8

; 1576 : 				hr = S_FALSE;

  002a4	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L70212:

; 1577 : 			}
; 1578 : 			pTrack->Release();

  002ab	8b 4d f0	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  002ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b0	8b 45 f0	 mov	 eax, DWORD PTR _pTrack$[ebp]
  002b3	50		 push	 eax
  002b4	ff 52 08	 call	 DWORD PTR [edx+8]

; 1579 : 		}
; 1580 : 		else

  002b7	eb 16		 jmp	 SHORT $L70215
$L70210:

; 1581 : 		{
; 1582 :             Trace(1,"Warning: Track clone failed, cloned segment is incomplete.\n");

  002b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@KNLAPKHK@Warning?3?5Track?5clone?5failed?0?5clo@
  002be	6a 01		 push	 1
  002c0	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002c5	83 c4 08	 add	 esp, 8

; 1583 : 			hr = S_FALSE;

  002c8	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L70215:

; 1584 : 		}
; 1585 : 		pCTrack = pCTrack->GetNext();

  002cf	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  002d2	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  002d7	89 45 f8	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1586 : 	}

  002da	e9 5e ff ff ff	 jmp	 $L70207
$L70208:

; 1587 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  002df	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002e2	83 c1 1c	 add	 ecx, 28			; 0000001cH
  002e5	51		 push	 ecx
  002e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1588 : 	return hr;

  002ec	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]
$L70177:

; 1589 : }

  002ef	5f		 pop	 edi
  002f0	5e		 pop	 esi
  002f1	8b e5		 mov	 esp, ebp
  002f3	5d		 pop	 ebp
  002f4	c2 10 00	 ret	 16			; 00000010H
?Clone@CSegment@@UAGJJJPAPAUIDirectMusicSegment@@@Z ENDP ; CSegment::Clone
_TEXT	ENDS
PUBLIC	??_C@_0CH@CFDENOHG@?$CFs?3?5Invalid?5pointer?5ppAudioPathC@ ; `string'
PUBLIC	??_C@_0GI@EGHNDHOM@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
PUBLIC	??_C@_0DO@DJEFHAIL@Warning?3?5No?5embedded?5audiopath?5c@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetAudioPathConfig', 00H ; `CSegment::GetAudioPathConfig'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CH@CFDENOHG@?$CFs?3?5Invalid?5pointer?5ppAudioPathC@
CONST	SEGMENT
??_C@_0CH@CFDENOHG@?$CFs?3?5Invalid?5pointer?5ppAudioPathC@ DB '%s: Inval'
	DB	'id pointer ppAudioPathConfig', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@EGHNDHOM@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0GI@EGHNDHOM@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Cal'
	DB	'l of IDirectMusicSegment::GetAudioPathConfig after the segmen'
	DB	't has been garbage collected.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@DJEFHAIL@Warning?3?5No?5embedded?5audiopath?5c@
CONST	SEGMENT
??_C@_0DO@DJEFHAIL@Warning?3?5No?5embedded?5audiopath?5c@ DB 'Warning: No'
	DB	' embedded audiopath configuration in the segment.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_ppAudioPathConfig$ = 12
?GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z PROC NEAR ; CSegment::GetAudioPathConfig, COMDAT

; 1593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1594 :     V_INAME(IDirectMusicSegment::GetAudioPathConfig);
; 1595 : 	V_PTRPTR_WRITE(ppAudioPathConfig);

  00004	6a 04		 push	 4
  00006	8b 45 0c	 mov	 eax, DWORD PTR _ppAudioPathConfig$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L70225
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@CFDENOHG@?$CFs?3?5Invalid?5pointer?5ppAudioPathC@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70225:

; 1596 : 
; 1597 :     if (m_fZombie)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	0f b6 91 c0 03
	00 00		 movzx	 edx, BYTE PTR [ecx+960]
  00036	85 d2		 test	 edx, edx
  00038	74 16		 je	 SHORT $L70227

; 1598 : 	{
; 1599 : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetAudioPathConfig after the segment has been garbage collected.\n");

  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GI@EGHNDHOM@Warning?3?5Call?5of?5IDirectMusicSeg@
  0003f	6a 02		 push	 2
  00041	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00046	83 c4 08	 add	 esp, 8

; 1600 : 		return DMUS_S_GARBAGE_COLLECTED;

  00049	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  0004e	eb 5b		 jmp	 SHORT $L70221
$L70227:

; 1601 : 	}
; 1602 : 
; 1603 :     HRESULT hr;
; 1604 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00050	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c0 1c	 add	 eax, 28			; 0000001cH
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1605 :     if (m_pAudioPathConfig)

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  00064	74 1f		 je	 SHORT $L70234

; 1606 :     {
; 1607 :         hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);

  00066	8b 55 0c	 mov	 edx, DWORD PTR _ppAudioPathConfig$[ebp]
  00069	52		 push	 edx
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  0006f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00075	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00078	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0007b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	ff 11		 call	 DWORD PTR [ecx]
  00080	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1608 :     }
; 1609 :     else

  00083	eb 16		 jmp	 SHORT $L70236
$L70234:

; 1610 :     {
; 1611 :         Trace(2,"Warning: No embedded audiopath configuration in the segment.\n"); 

  00085	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@DJEFHAIL@Warning?3?5No?5embedded?5audiopath?5c@
  0008a	6a 02		 push	 2
  0008c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00091	83 c4 08	 add	 esp, 8

; 1612 :         hr = DMUS_E_NO_AUDIOPATH_CONFIG;

  00094	c7 45 fc 28 12
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005396952 ; 88781228H
$L70236:

; 1613 :     }
; 1614 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0009b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	83 c2 1c	 add	 edx, 28			; 0000001cH
  000a1	52		 push	 edx
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1615 :     return hr;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L70221:

; 1616 : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
?GetAudioPathConfig@CSegment@@UAGJPAPAUIUnknown@@@Z ENDP ; CSegment::GetAudioPathConfig
_TEXT	ENDS
PUBLIC	?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z ; CSegment::ComposeTransition
PUBLIC	??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@ ; `string'
PUBLIC	??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@EHMDLDHF@?$CFs?3?5Invalid?5pointer?5ppComposedSe@ ; `string'
PUBLIC	??_C@_0FB@MOGMFKFK@Warning?3?5A?5time?5value?5of?5?$CFld?5was@ ; `string'
PUBLIC	??_C@_0FN@HDJJPDEB@Warning?3?5Call?5of?5IDirectMusicSeg@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::Compose', 00H		; `CSegment::Compose'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@
CONST	SEGMENT
??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@ DB '%s: Inval'
	DB	'id pointer pFromSegment', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@
CONST	SEGMENT
??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pToSegment', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHMDLDHF@?$CFs?3?5Invalid?5pointer?5ppComposedSe@
CONST	SEGMENT
??_C@_0CH@EHMDLDHF@?$CFs?3?5Invalid?5pointer?5ppComposedSe@ DB '%s: Inval'
	DB	'id pointer ppComposedSegment', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@MOGMFKFK@Warning?3?5A?5time?5value?5of?5?$CFld?5was@
CONST	SEGMENT
??_C@_0FB@MOGMFKFK@Warning?3?5A?5time?5value?5of?5?$CFld?5was@ DB 'Warnin'
	DB	'g: A time value of %ld was passed to Compose for a segment of'
	DB	' length %ld.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@HDJJPDEB@Warning?3?5Call?5of?5IDirectMusicSeg@
CONST	SEGMENT
??_C@_0FN@HDJJPDEB@Warning?3?5Call?5of?5IDirectMusicSeg@ DB 'Warning: Cal'
	DB	'l of IDirectMusicSegment::Compose after the segment has been '
	DB	'garbage collected.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU2@@Z
_TEXT	SEGMENT
tv253 = -48
tv250 = -40
_dwRepeats$70277 = -32
_mtLoopEnd$70275 = -28
_llTotalLength$70278 = -24
_mtLength$70274 = -12
_mtLoopStart$70276 = -8
_hr$ = -4
_this$ = 8
_mtTime$ = 12
_pFromSegment$ = 16
_pToSegment$ = 20
_ppComposedSegment$ = 24
?Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU2@@Z PROC NEAR ; CSegment::Compose, COMDAT

; 1698 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi

; 1699 :     V_INAME(IDirectMusicSegment::Compose);
; 1700 :     V_INTERFACE_OPT(pFromSegment);

  00007	83 7d 10 00	 cmp	 DWORD PTR _pFromSegment$[ebp], 0
  0000b	74 7c		 je	 SHORT $L70251
  0000d	6a 04		 push	 4
  0000f	8b 45 10	 mov	 eax, DWORD PTR _pFromSegment$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00018	85 c0		 test	 eax, eax
  0001a	74 19		 je	 SHORT $L70253
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@
  00026	6a ff		 push	 -1
  00028	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	e8 00 00 00 00	 call	 _DebugBreak@0
$L70253:
  00035	6a 04		 push	 4
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _pFromSegment$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00042	85 c0		 test	 eax, eax
  00044	74 19		 je	 SHORT $L70257
  00046	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@
  00050	6a ff		 push	 -1
  00052	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	e8 00 00 00 00	 call	 _DebugBreak@0
$L70257:
  0005f	8b 45 10	 mov	 eax, DWORD PTR _pFromSegment$[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0006c	85 c0		 test	 eax, eax
  0006e	74 19		 je	 SHORT $L70251
  00070	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JLCHGAGK@?$CFs?3?5Invalid?5pointer?5pFromSegment@
  0007a	6a ff		 push	 -1
  0007c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	e8 00 00 00 00	 call	 _DebugBreak@0
$L70251:

; 1701 :     V_INTERFACE_OPT(pToSegment);

  00089	83 7d 14 00	 cmp	 DWORD PTR _pToSegment$[ebp], 0
  0008d	74 7c		 je	 SHORT $L70260
  0008f	6a 04		 push	 4
  00091	8b 45 14	 mov	 eax, DWORD PTR _pToSegment$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0009a	85 c0		 test	 eax, eax
  0009c	74 19		 je	 SHORT $L70262
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@
  000a8	6a ff		 push	 -1
  000aa	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	e8 00 00 00 00	 call	 _DebugBreak@0
$L70262:
  000b7	6a 04		 push	 4
  000b9	8b 4d 14	 mov	 ecx, DWORD PTR _pToSegment$[ebp]
  000bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000c4	85 c0		 test	 eax, eax
  000c6	74 19		 je	 SHORT $L70266
  000c8	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@
  000d2	6a ff		 push	 -1
  000d4	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	e8 00 00 00 00	 call	 _DebugBreak@0
$L70266:
  000e1	8b 45 14	 mov	 eax, DWORD PTR _pToSegment$[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  000ee	85 c0		 test	 eax, eax
  000f0	74 19		 je	 SHORT $L70260
  000f2	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  000f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GHAONICA@?$CFs?3?5Invalid?5pointer?5pToSegment?6?$AA@
  000fc	6a ff		 push	 -1
  000fe	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 _DebugBreak@0
$L70260:

; 1702 : 	V_PTRPTR_WRITE_OPT(ppComposedSegment);

  0010b	83 7d 18 00	 cmp	 DWORD PTR _ppComposedSegment$[ebp], 0
  0010f	74 28		 je	 SHORT $L70269
  00111	6a 04		 push	 4
  00113	8b 45 18	 mov	 eax, DWORD PTR _ppComposedSegment$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0011c	85 c0		 test	 eax, eax
  0011e	74 19		 je	 SHORT $L70269
  00120	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU3@@Z@4QBDB
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@EHMDLDHF@?$CFs?3?5Invalid?5pointer?5ppComposedSe@
  0012a	6a ff		 push	 -1
  0012c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
  00134	e8 00 00 00 00	 call	 _DebugBreak@0
$L70269:

; 1703 : #ifdef DBG
; 1704 :     if (pFromSegment)

  00139	83 7d 10 00	 cmp	 DWORD PTR _pFromSegment$[ebp], 0
  0013d	0f 84 93 00 00
	00		 je	 $L70273

; 1705 :     {
; 1706 :         MUSIC_TIME mtLength, mtLoopEnd, mtLoopStart;
; 1707 :         DWORD dwRepeats;
; 1708 :         // To calculate the full length, we need to access the loop parameters.
; 1709 :         pFromSegment->GetLoopPoints(&mtLoopStart,&mtLoopEnd);

  00143	8d 4d e4	 lea	 ecx, DWORD PTR _mtLoopEnd$70275[ebp]
  00146	51		 push	 ecx
  00147	8d 55 f8	 lea	 edx, DWORD PTR _mtLoopStart$70276[ebp]
  0014a	52		 push	 edx
  0014b	8b 45 10	 mov	 eax, DWORD PTR _pFromSegment$[ebp]
  0014e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00150	8b 55 10	 mov	 edx, DWORD PTR _pFromSegment$[ebp]
  00153	52		 push	 edx
  00154	ff 51 30	 call	 DWORD PTR [ecx+48]

; 1710 :         pFromSegment->GetRepeats(&dwRepeats);

  00157	8d 45 e0	 lea	 eax, DWORD PTR _dwRepeats$70277[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d 10	 mov	 ecx, DWORD PTR _pFromSegment$[ebp]
  0015e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00160	8b 45 10	 mov	 eax, DWORD PTR _pFromSegment$[ebp]
  00163	50		 push	 eax
  00164	ff 52 48	 call	 DWORD PTR [edx+72]

; 1711 :         pFromSegment->GetLength(&mtLength);

  00167	8d 4d f4	 lea	 ecx, DWORD PTR _mtLength$70274[ebp]
  0016a	51		 push	 ecx
  0016b	8b 55 10	 mov	 edx, DWORD PTR _pFromSegment$[ebp]
  0016e	8b 02		 mov	 eax, DWORD PTR [edx]
  00170	8b 4d 10	 mov	 ecx, DWORD PTR _pFromSegment$[ebp]
  00173	51		 push	 ecx
  00174	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1712 :         // If repeats is set to infinite, the total length will be greater than 32 bits.
; 1713 :         LONGLONG llTotalLength = dwRepeats * (mtLoopEnd - mtLoopStart) + mtLength;

  00177	8b 55 e4	 mov	 edx, DWORD PTR _mtLoopEnd$70275[ebp]
  0017a	2b 55 f8	 sub	 edx, DWORD PTR _mtLoopStart$70276[ebp]
  0017d	8b 45 e0	 mov	 eax, DWORD PTR _dwRepeats$70277[ebp]
  00180	0f af c2	 imul	 eax, edx
  00183	03 45 f4	 add	 eax, DWORD PTR _mtLength$70274[ebp]
  00186	33 c9		 xor	 ecx, ecx
  00188	89 45 e8	 mov	 DWORD PTR _llTotalLength$70278[ebp], eax
  0018b	89 4d ec	 mov	 DWORD PTR _llTotalLength$70278[ebp+4], ecx

; 1714 :         if (mtTime >= (llTotalLength & 0x7FFFFFFF)) 

  0018e	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00191	99		 cdq
  00192	8b 4d e8	 mov	 ecx, DWORD PTR _llTotalLength$70278[ebp]
  00195	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0019b	8b 75 ec	 mov	 esi, DWORD PTR _llTotalLength$70278[ebp+4]
  0019e	83 e6 00	 and	 esi, 0
  001a1	89 45 d8	 mov	 DWORD PTR tv250[ebp], eax
  001a4	89 55 dc	 mov	 DWORD PTR tv250[ebp+4], edx
  001a7	89 4d d0	 mov	 DWORD PTR tv253[ebp], ecx
  001aa	89 75 d4	 mov	 DWORD PTR tv253[ebp+4], esi
  001ad	8b 55 dc	 mov	 edx, DWORD PTR tv250[ebp+4]
  001b0	3b 55 d4	 cmp	 edx, DWORD PTR tv253[ebp+4]
  001b3	7c 21		 jl	 SHORT $L70273
  001b5	7f 08		 jg	 SHORT $L72041
  001b7	8b 45 d8	 mov	 eax, DWORD PTR tv250[ebp]
  001ba	3b 45 d0	 cmp	 eax, DWORD PTR tv253[ebp]
  001bd	72 17		 jb	 SHORT $L70273
$L72041:

; 1715 :         {
; 1716 :             Trace(2,"Warning: A time value of %ld was passed to Compose for a segment of length %ld.\n",
; 1717 :                 mtTime, (long) llTotalLength);

  001bf	8b 4d e8	 mov	 ecx, DWORD PTR _llTotalLength$70278[ebp]
  001c2	51		 push	 ecx
  001c3	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  001c6	52		 push	 edx
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FB@MOGMFKFK@Warning?3?5A?5time?5value?5of?5?$CFld?5was@
  001cc	6a 02		 push	 2
  001ce	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001d3	83 c4 10	 add	 esp, 16			; 00000010H
$L70273:

; 1718 :         }
; 1719 :     }
; 1720 : #endif
; 1721 :     if (m_fZombie)

  001d6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001d9	0f b6 88 c0 03
	00 00		 movzx	 ecx, BYTE PTR [eax+960]
  001e0	85 c9		 test	 ecx, ecx
  001e2	74 16		 je	 SHORT $L70282

; 1722 : 	{
; 1723 : 		Trace(2, "Warning: Call of IDirectMusicSegment::Compose after the segment has been garbage collected.\n");

  001e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FN@HDJJPDEB@Warning?3?5Call?5of?5IDirectMusicSeg@
  001e9	6a 02		 push	 2
  001eb	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001f0	83 c4 08	 add	 esp, 8

; 1724 : 		return DMUS_S_GARBAGE_COLLECTED;

  001f3	b8 16 12 78 08	 mov	 eax, 142086678		; 08781216H
  001f8	eb 7e		 jmp	 SHORT $L70248
$L70282:

; 1725 : 	}
; 1726 : 
; 1727 : 	HRESULT hr = S_OK;

  001fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1728 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00201	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00204	83 c2 1c	 add	 edx, 28			; 0000001cH
  00207	52		 push	 edx
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1729 :     ENTER_API_CRITICAL_SECTION;
; 1730 : 	if (ppComposedSegment)

  0020e	83 7d 18 00	 cmp	 DWORD PTR _ppComposedSegment$[ebp], 0
  00212	74 3d		 je	 SHORT $L70290

; 1731 : 	{
; 1732 : 		hr = Clone(0, m_mtLength, ppComposedSegment);

  00214	8b 45 18	 mov	 eax, DWORD PTR _ppComposedSegment$[ebp]
  00217	50		 push	 eax
  00218	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0021e	52		 push	 edx
  0021f	6a 00		 push	 0
  00221	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00224	8b 08		 mov	 ecx, DWORD PTR [eax]
  00226	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00229	52		 push	 edx
  0022a	ff 51 74	 call	 DWORD PTR [ecx+116]
  0022d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1733 : 		if (SUCCEEDED(hr))

  00230	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00234	7c 19		 jl	 SHORT $L70292

; 1734 : 		{
; 1735 : 			hr = ((CSegment*)*ppComposedSegment)->ComposeTransition(mtTime, pFromSegment, pToSegment);

  00236	8b 45 14	 mov	 eax, DWORD PTR _pToSegment$[ebp]
  00239	50		 push	 eax
  0023a	8b 4d 10	 mov	 ecx, DWORD PTR _pFromSegment$[ebp]
  0023d	51		 push	 ecx
  0023e	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00241	52		 push	 edx
  00242	8b 45 18	 mov	 eax, DWORD PTR _ppComposedSegment$[ebp]
  00245	8b 08		 mov	 ecx, DWORD PTR [eax]
  00247	e8 00 00 00 00	 call	 ?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z ; CSegment::ComposeTransition
  0024c	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70292:

; 1736 : 		}
; 1737 : 	}
; 1738 : 	else

  0024f	eb 17		 jmp	 SHORT $L70294
$L70290:

; 1739 : 	{
; 1740 : 		hr = ComposeTransition(mtTime, pFromSegment, pToSegment);

  00251	8b 4d 14	 mov	 ecx, DWORD PTR _pToSegment$[ebp]
  00254	51		 push	 ecx
  00255	8b 55 10	 mov	 edx, DWORD PTR _pFromSegment$[ebp]
  00258	52		 push	 edx
  00259	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0025c	50		 push	 eax
  0025d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00260	e8 00 00 00 00	 call	 ?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z ; CSegment::ComposeTransition
  00265	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70294:

; 1741 : 	}
; 1742 : 
; 1743 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00268	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0026e	51		 push	 ecx
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1744 :     LEAVE_API_CRITICAL_SECTION;
; 1745 : 	return hr;

  00275	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L70248:

; 1746 : }

  00278	5e		 pop	 esi
  00279	8b e5		 mov	 esp, ebp
  0027b	5d		 pop	 ebp
  0027c	c2 14 00	 ret	 20			; 00000014H
?Compose@CSegment@@UAGJJPAUIDirectMusicSegment@@0PAPAU2@@Z ENDP ; CSegment::Compose
_TEXT	ENDS
PUBLIC	?ComposeInternal@CSegment@@QAEJXZ		; CSegment::ComposeInternal
EXTRN	_GUID_TimeSignature:BYTE
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT ?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z
_TEXT	SEGMENT
tv91 = -132
tv83 = -128
_this$ = -124
_pTempTrack$70393 = -120
_pTempTrack8$70394 = -116
_pTempTrack$70387 = -112
_pTempTrack8$70388 = -108
_pStartPadTrack$70343 = -104
_pTempTrack8$70372 = -100
_pEndPadTrack$70344 = -96
_pTrack8$70352 = -92
_pSourceTrack$70345 = -88
_mtEnd$70332 = -84
_mtStart$70330 = -80
_pSourceTrack$70333 = -76
_dwTrackGroup$70328 = -72
_guidClassID$70323 = -68
_pTransTrack2$70322 = -52
_pPersist$70324 = -48
_pTransTrack1$70321 = -44
_mtOldLength$ = -40
_pTrack$ = -36
_hr$ = -32
_mtBar$ = -28
_fTrackPadded$ = -21
_mtToLength$ = -20
_mtEndPad$ = -16
_TimeSig$ = -12
_mtStartPad$ = -4
_mtTime$ = 8
_pFromSegment$ = 12
_pToSegment$ = 16
?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z PROC NEAR ; CSegment::ComposeTransition, COMDAT
; _this$ = ecx

; 1751 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx

; 1752 : 	HRESULT hr = S_OK;

  0000c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1753 : 	bool fTrackPadded = false;

  00013	c6 45 eb 00	 mov	 BYTE PTR _fTrackPadded$[ebp], 0

; 1754 : 
; 1755 : 	// Compute amount of time to pad any tracks that need padding.
; 1756 : 	DMUS_TIMESIGNATURE TimeSig;
; 1757 : 	if (!pFromSegment ||
; 1758 : 		FAILED(pFromSegment->GetParam(GUID_TimeSignature, 0xffffffff, 0, mtTime, NULL, (void*) &TimeSig)))

  00017	83 7d 0c 00	 cmp	 DWORD PTR _pFromSegment$[ebp], 0
  0001b	74 23		 je	 SHORT $L70308
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _TimeSig$[ebp]
  00020	50		 push	 eax
  00021	6a 00		 push	 0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00026	51		 push	 ecx
  00027	6a 00		 push	 0
  00029	6a ff		 push	 -1
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TimeSignature
  00030	8b 55 0c	 mov	 edx, DWORD PTR _pFromSegment$[ebp]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pFromSegment$[ebp]
  00038	51		 push	 ecx
  00039	ff 50 6c	 call	 DWORD PTR [eax+108]
  0003c	85 c0		 test	 eax, eax
  0003e	7d 17		 jge	 SHORT $L70307
$L70308:

; 1759 : 	{
; 1760 : 		TimeSig.mtTime = 0;

  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _TimeSig$[ebp], 0

; 1761 : 		TimeSig.bBeatsPerMeasure = 4;

  00047	c6 45 f8 04	 mov	 BYTE PTR _TimeSig$[ebp+4], 4

; 1762 : 		TimeSig.bBeat = 4;

  0004b	c6 45 f9 04	 mov	 BYTE PTR _TimeSig$[ebp+5], 4

; 1763 : 		TimeSig.wGridsPerBeat = 4;

  0004f	66 c7 45 fa 04
	00		 mov	 WORD PTR _TimeSig$[ebp+6], 4

; 1764 : 	}
; 1765 : 	else // avoid divide-by-zero

  00055	eb 0c		 jmp	 SHORT $L70309
$L70307:

; 1766 : 	{
; 1767 : 		if (!TimeSig.bBeat) TimeSig.bBeat = 4;

  00057	0f b6 55 f9	 movzx	 edx, BYTE PTR _TimeSig$[ebp+5]
  0005b	85 d2		 test	 edx, edx
  0005d	75 04		 jne	 SHORT $L70309
  0005f	c6 45 f9 04	 mov	 BYTE PTR _TimeSig$[ebp+5], 4
$L70309:

; 1768 : 	}
; 1769 : 	MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;

  00063	0f b6 45 f8	 movzx	 eax, BYTE PTR _TimeSig$[ebp+4]
  00067	69 c0 00 0c 00
	00		 imul	 eax, 3072		; 00000c00H
  0006d	0f b6 4d f9	 movzx	 ecx, BYTE PTR _TimeSig$[ebp+5]
  00071	99		 cdq
  00072	f7 f9		 idiv	 ecx
  00074	89 45 e4	 mov	 DWORD PTR _mtBar$[ebp], eax

; 1770 : 	MUSIC_TIME mtStartPad = min(mtBar, mtTime);

  00077	8b 55 e4	 mov	 edx, DWORD PTR _mtBar$[ebp]
  0007a	3b 55 08	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  0007d	7d 08		 jge	 SHORT $L72045
  0007f	8b 45 e4	 mov	 eax, DWORD PTR _mtBar$[ebp]
  00082	89 45 80	 mov	 DWORD PTR tv83[ebp], eax
  00085	eb 06		 jmp	 SHORT $L72046
$L72045:
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0008a	89 4d 80	 mov	 DWORD PTR tv83[ebp], ecx
$L72046:
  0008d	8b 55 80	 mov	 edx, DWORD PTR tv83[ebp]
  00090	89 55 fc	 mov	 DWORD PTR _mtStartPad$[ebp], edx

; 1771 : 	if (!pFromSegment) mtStartPad = 0;

  00093	83 7d 0c 00	 cmp	 DWORD PTR _pFromSegment$[ebp], 0
  00097	75 07		 jne	 SHORT $L70313
  00099	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mtStartPad$[ebp], 0
$L70313:

; 1772 : 	MUSIC_TIME mtToLength = 0;

  000a0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mtToLength$[ebp], 0

; 1773 : 	if (pToSegment) pToSegment->GetLength(&mtToLength);

  000a7	83 7d 10 00	 cmp	 DWORD PTR _pToSegment$[ebp], 0
  000ab	74 10		 je	 SHORT $L70315
  000ad	8d 45 ec	 lea	 eax, DWORD PTR _mtToLength$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d 10	 mov	 ecx, DWORD PTR _pToSegment$[ebp]
  000b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b6	8b 45 10	 mov	 eax, DWORD PTR _pToSegment$[ebp]
  000b9	50		 push	 eax
  000ba	ff 52 1c	 call	 DWORD PTR [edx+28]
$L70315:

; 1774 : 	MUSIC_TIME mtEndPad = min(mtBar, mtToLength);

  000bd	8b 4d e4	 mov	 ecx, DWORD PTR _mtBar$[ebp]
  000c0	3b 4d ec	 cmp	 ecx, DWORD PTR _mtToLength$[ebp]
  000c3	7d 0b		 jge	 SHORT $L72047
  000c5	8b 55 e4	 mov	 edx, DWORD PTR _mtBar$[ebp]
  000c8	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv91[ebp], edx
  000ce	eb 09		 jmp	 SHORT $L72048
$L72047:
  000d0	8b 45 ec	 mov	 eax, DWORD PTR _mtToLength$[ebp]
  000d3	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
$L72048:
  000d9	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv91[ebp]
  000df	89 4d f0	 mov	 DWORD PTR _mtEndPad$[ebp], ecx

; 1775 : 
; 1776 : 	// Instantiate tracks
; 1777 : 	CTrack* pTrack = m_TrackList.GetHead();

  000e2	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	83 c1 44	 add	 ecx, 68			; 00000044H
  000e8	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  000ed	89 45 dc	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1778 :     for (; pTrack; pTrack = pTrack->GetNext())

  000f0	eb 0b		 jmp	 SHORT $L70318
$L70319:
  000f2	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  000f5	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  000fa	89 45 dc	 mov	 DWORD PTR _pTrack$[ebp], eax
$L70318:
  000fd	83 7d dc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  00101	0f 84 19 04 00
	00		 je	 $L70320

; 1779 : 	{
; 1780 : 		pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);

  00107	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0010a	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0010d	83 e0 fc	 and	 eax, -4			; fffffffcH
  00110	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00113	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1781 : 		IDirectMusicTrack* pTransTrack1 = NULL;

  00116	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pTransTrack1$70321[ebp], 0

; 1782 : 		IDirectMusicTrack* pTransTrack2 = NULL;

  0011d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _pTransTrack2$70322[ebp], 0

; 1783 : 		GUID guidClassID;
; 1784 : 		memset(&guidClassID, 0, sizeof(guidClassID));

  00124	6a 10		 push	 16			; 00000010H
  00126	6a 00		 push	 0
  00128	8d 55 bc	 lea	 edx, DWORD PTR _guidClassID$70323[ebp]
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 _memset
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1785 : 		IPersist* pPersist = NULL;

  00134	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pPersist$70324[ebp], 0

; 1786 : 		if (SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)))

  0013b	8d 45 d0	 lea	 eax, DWORD PTR _pPersist$70324[ebp]
  0013e	50		 push	 eax
  0013f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  00144	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00147	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0014a	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0014d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00150	8b 12		 mov	 edx, DWORD PTR [edx]
  00152	51		 push	 ecx
  00153	ff 12		 call	 DWORD PTR [edx]
  00155	85 c0		 test	 eax, eax
  00157	7c 1c		 jl	 SHORT $L70327

; 1787 : 		{
; 1788 : 			pPersist->GetClassID(&guidClassID);

  00159	8d 45 bc	 lea	 eax, DWORD PTR _guidClassID$70323[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d d0	 mov	 ecx, DWORD PTR _pPersist$70324[ebp]
  00160	8b 11		 mov	 edx, DWORD PTR [ecx]
  00162	8b 45 d0	 mov	 eax, DWORD PTR _pPersist$70324[ebp]
  00165	50		 push	 eax
  00166	ff 52 0c	 call	 DWORD PTR [edx+12]

; 1789 : 			pPersist->Release();

  00169	8b 4d d0	 mov	 ecx, DWORD PTR _pPersist$70324[ebp]
  0016c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016e	8b 45 d0	 mov	 eax, DWORD PTR _pPersist$70324[ebp]
  00171	50		 push	 eax
  00172	ff 52 08	 call	 DWORD PTR [edx+8]
$L70327:

; 1790 : 		}
; 1791 : 		DWORD dwTrackGroup = 0;

  00175	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _dwTrackGroup$70328[ebp], 0

; 1792 : 		GetTrackGroup(pTrack->m_pTrack, &dwTrackGroup);

  0017c	8d 4d b8	 lea	 ecx, DWORD PTR _dwTrackGroup$70328[ebp]
  0017f	51		 push	 ecx
  00180	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00183	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00186	50		 push	 eax
  00187	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018c	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	50		 push	 eax
  00190	ff 52 58	 call	 DWORD PTR [edx+88]

; 1793 : 
; 1794 : 		// Get track info
; 1795 : 		if (pTrack->m_dwFlags & COMPOSE_TRANSITION1)

  00193	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00196	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00199	81 e2 00 1c 00
	00		 and	 edx, 7168		; 00001c00H
  0019f	85 d2		 test	 edx, edx
  001a1	0f 84 db 00 00
	00		 je	 $L70329

; 1796 : 		{
; 1797 :             // Clone the appropriate track, with length m_mtLength
; 1798 : 			MUSIC_TIME mtStart = 0;

  001a7	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _mtStart$70330[ebp], 0

; 1799 : 			if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT)

  001ae	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  001b1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001b4	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  001ba	85 c9		 test	 ecx, ecx
  001bc	74 06		 je	 SHORT $L70331

; 1800 : 			{
; 1801 : 				mtStart = mtTime;

  001be	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  001c1	89 55 b0	 mov	 DWORD PTR _mtStart$70330[ebp], edx
$L70331:

; 1802 : 			}
; 1803 : 			MUSIC_TIME mtEnd = mtStart + m_mtLength;

  001c4	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  001c7	8b 4d b0	 mov	 ecx, DWORD PTR _mtStart$70330[ebp]
  001ca	03 48 70	 add	 ecx, DWORD PTR [eax+112]
  001cd	89 4d ac	 mov	 DWORD PTR _mtEnd$70332[ebp], ecx

; 1804 : 			IDirectMusicTrack* pSourceTrack = NULL;

  001d0	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pSourceTrack$70333[ebp], 0

; 1805 : 			if ( (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART) ||
; 1806 : 				 (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT) )

  001d7	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  001da	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  001dd	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  001e2	85 c0		 test	 eax, eax
  001e4	75 10		 jne	 SHORT $L70335
  001e6	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  001e9	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  001ec	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  001f2	85 d2		 test	 edx, edx
  001f4	74 25		 je	 SHORT $L70334
$L70335:

; 1807 : 			{
; 1808 : 				if (pFromSegment)

  001f6	83 7d 0c 00	 cmp	 DWORD PTR _pFromSegment$[ebp], 0
  001fa	74 1d		 je	 SHORT $L70336

; 1809 : 				{
; 1810 : 					hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);

  001fc	8d 45 b4	 lea	 eax, DWORD PTR _pSourceTrack$70333[ebp]
  001ff	50		 push	 eax
  00200	6a 00		 push	 0
  00202	8b 4d b8	 mov	 ecx, DWORD PTR _dwTrackGroup$70328[ebp]
  00205	51		 push	 ecx
  00206	8d 55 bc	 lea	 edx, DWORD PTR _guidClassID$70323[ebp]
  00209	52		 push	 edx
  0020a	8b 45 0c	 mov	 eax, DWORD PTR _pFromSegment$[ebp]
  0020d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020f	8b 55 0c	 mov	 edx, DWORD PTR _pFromSegment$[ebp]
  00212	52		 push	 edx
  00213	ff 51 54	 call	 DWORD PTR [ecx+84]
  00216	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
$L70336:

; 1811 : 				}
; 1812 : 			}
; 1813 : 			else if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

  00219	eb 33		 jmp	 SHORT $L70337
$L70334:
  0021b	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0021e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00221	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00227	85 c9		 test	 ecx, ecx
  00229	74 23		 je	 SHORT $L70337

; 1814 : 			{
; 1815 : 				if (pToSegment)

  0022b	83 7d 10 00	 cmp	 DWORD PTR _pToSegment$[ebp], 0
  0022f	74 1d		 je	 SHORT $L70337

; 1816 : 				{
; 1817 : 					hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);

  00231	8d 55 b4	 lea	 edx, DWORD PTR _pSourceTrack$70333[ebp]
  00234	52		 push	 edx
  00235	6a 00		 push	 0
  00237	8b 45 b8	 mov	 eax, DWORD PTR _dwTrackGroup$70328[ebp]
  0023a	50		 push	 eax
  0023b	8d 4d bc	 lea	 ecx, DWORD PTR _guidClassID$70323[ebp]
  0023e	51		 push	 ecx
  0023f	8b 55 10	 mov	 edx, DWORD PTR _pToSegment$[ebp]
  00242	8b 02		 mov	 eax, DWORD PTR [edx]
  00244	8b 4d 10	 mov	 ecx, DWORD PTR _pToSegment$[ebp]
  00247	51		 push	 ecx
  00248	ff 50 54	 call	 DWORD PTR [eax+84]
  0024b	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
$L70337:

; 1818 : 				}
; 1819 : 			}
; 1820 : 			if (pSourceTrack)

  0024e	83 7d b4 00	 cmp	 DWORD PTR _pSourceTrack$70333[ebp], 0
  00252	74 2e		 je	 SHORT $L70329

; 1821 : 			{
; 1822 : 				hr = pSourceTrack->Clone(mtStart, mtEnd, &pTransTrack1);

  00254	8d 55 d4	 lea	 edx, DWORD PTR _pTransTrack1$70321[ebp]
  00257	52		 push	 edx
  00258	8b 45 ac	 mov	 eax, DWORD PTR _mtEnd$70332[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d b0	 mov	 ecx, DWORD PTR _mtStart$70330[ebp]
  0025f	51		 push	 ecx
  00260	8b 55 b4	 mov	 edx, DWORD PTR _pSourceTrack$70333[ebp]
  00263	8b 02		 mov	 eax, DWORD PTR [edx]
  00265	8b 4d b4	 mov	 ecx, DWORD PTR _pSourceTrack$70333[ebp]
  00268	51		 push	 ecx
  00269	ff 50 30	 call	 DWORD PTR [eax+48]
  0026c	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 1823 : 				pSourceTrack->Release();

  0026f	8b 55 b4	 mov	 edx, DWORD PTR _pSourceTrack$70333[ebp]
  00272	8b 02		 mov	 eax, DWORD PTR [edx]
  00274	8b 4d b4	 mov	 ecx, DWORD PTR _pSourceTrack$70333[ebp]
  00277	51		 push	 ecx
  00278	ff 50 08	 call	 DWORD PTR [eax+8]

; 1824 : 				pSourceTrack = NULL;

  0027b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pSourceTrack$70333[ebp], 0
$L70329:

; 1825 : 			}
; 1826 : 		}
; 1827 : 		if (!pTransTrack1)

  00282	83 7d d4 00	 cmp	 DWORD PTR _pTransTrack1$70321[ebp], 0
  00286	75 15		 jne	 SHORT $L70341

; 1828 : 		{
; 1829 : 			pTransTrack1 = pTrack->m_pTrack;

  00288	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0028b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0028e	89 45 d4	 mov	 DWORD PTR _pTransTrack1$70321[ebp], eax

; 1830 : 			pTransTrack1->AddRef();

  00291	8b 4d d4	 mov	 ecx, DWORD PTR _pTransTrack1$70321[ebp]
  00294	8b 11		 mov	 edx, DWORD PTR [ecx]
  00296	8b 45 d4	 mov	 eax, DWORD PTR _pTransTrack1$70321[ebp]
  00299	50		 push	 eax
  0029a	ff 52 04	 call	 DWORD PTR [edx+4]
$L70341:

; 1831 : 
; 1832 : 		}
; 1833 : 		if (pTransTrack1)

  0029d	83 7d d4 00	 cmp	 DWORD PTR _pTransTrack1$70321[ebp], 0
  002a1	0f 84 6c 02 00
	00		 je	 $L70342

; 1834 : 		{
; 1835 : 			// Pad the track with an extra bar of header and trailer, by cloning header and trailer
; 1836 : 			// tracks (from From and To segments, respectively --- *not* using transition flags) and 
; 1837 : 			// joining them onto the transition segment track.
; 1838 : 			IDirectMusicTrack* pStartPadTrack = NULL;

  002a7	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _pStartPadTrack$70343[ebp], 0

; 1839 : 			IDirectMusicTrack* pEndPadTrack = NULL;

  002ae	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _pEndPadTrack$70344[ebp], 0

; 1840 : 			IDirectMusicTrack* pSourceTrack = NULL;

  002b5	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _pSourceTrack$70345[ebp], 0

; 1841 : 			if (pFromSegment && mtStartPad)

  002bc	83 7d 0c 00	 cmp	 DWORD PTR _pFromSegment$[ebp], 0
  002c0	74 57		 je	 SHORT $L70346
  002c2	83 7d fc 00	 cmp	 DWORD PTR _mtStartPad$[ebp], 0
  002c6	74 51		 je	 SHORT $L70346

; 1842 : 			{
; 1843 : 				hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);

  002c8	8d 4d a8	 lea	 ecx, DWORD PTR _pSourceTrack$70345[ebp]
  002cb	51		 push	 ecx
  002cc	6a 00		 push	 0
  002ce	8b 55 b8	 mov	 edx, DWORD PTR _dwTrackGroup$70328[ebp]
  002d1	52		 push	 edx
  002d2	8d 45 bc	 lea	 eax, DWORD PTR _guidClassID$70323[ebp]
  002d5	50		 push	 eax
  002d6	8b 4d 0c	 mov	 ecx, DWORD PTR _pFromSegment$[ebp]
  002d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  002db	8b 45 0c	 mov	 eax, DWORD PTR _pFromSegment$[ebp]
  002de	50		 push	 eax
  002df	ff 52 54	 call	 DWORD PTR [edx+84]
  002e2	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 1844 : 				if (SUCCEEDED(hr))

  002e5	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002e9	7c 2e		 jl	 SHORT $L70346

; 1845 : 				{
; 1846 : 					pSourceTrack->Clone(mtTime - mtStartPad, mtTime, &pStartPadTrack);

  002eb	8d 4d 98	 lea	 ecx, DWORD PTR _pStartPadTrack$70343[ebp]
  002ee	51		 push	 ecx
  002ef	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  002f2	52		 push	 edx
  002f3	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  002f6	2b 45 fc	 sub	 eax, DWORD PTR _mtStartPad$[ebp]
  002f9	50		 push	 eax
  002fa	8b 4d a8	 mov	 ecx, DWORD PTR _pSourceTrack$70345[ebp]
  002fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ff	8b 45 a8	 mov	 eax, DWORD PTR _pSourceTrack$70345[ebp]
  00302	50		 push	 eax
  00303	ff 52 30	 call	 DWORD PTR [edx+48]

; 1847 : 					pSourceTrack->Release();

  00306	8b 4d a8	 mov	 ecx, DWORD PTR _pSourceTrack$70345[ebp]
  00309	8b 11		 mov	 edx, DWORD PTR [ecx]
  0030b	8b 45 a8	 mov	 eax, DWORD PTR _pSourceTrack$70345[ebp]
  0030e	50		 push	 eax
  0030f	ff 52 08	 call	 DWORD PTR [edx+8]

; 1848 : 					pSourceTrack = NULL;

  00312	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _pSourceTrack$70345[ebp], 0
$L70346:

; 1849 : 				}
; 1850 : 			}
; 1851 : 			if (pToSegment && mtEndPad)

  00319	83 7d 10 00	 cmp	 DWORD PTR _pToSegment$[ebp], 0
  0031d	74 52		 je	 SHORT $L70349
  0031f	83 7d f0 00	 cmp	 DWORD PTR _mtEndPad$[ebp], 0
  00323	74 4c		 je	 SHORT $L70349

; 1852 : 			{
; 1853 : 				hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);

  00325	8d 4d a8	 lea	 ecx, DWORD PTR _pSourceTrack$70345[ebp]
  00328	51		 push	 ecx
  00329	6a 00		 push	 0
  0032b	8b 55 b8	 mov	 edx, DWORD PTR _dwTrackGroup$70328[ebp]
  0032e	52		 push	 edx
  0032f	8d 45 bc	 lea	 eax, DWORD PTR _guidClassID$70323[ebp]
  00332	50		 push	 eax
  00333	8b 4d 10	 mov	 ecx, DWORD PTR _pToSegment$[ebp]
  00336	8b 11		 mov	 edx, DWORD PTR [ecx]
  00338	8b 45 10	 mov	 eax, DWORD PTR _pToSegment$[ebp]
  0033b	50		 push	 eax
  0033c	ff 52 54	 call	 DWORD PTR [edx+84]
  0033f	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 1854 : 				if (SUCCEEDED(hr))

  00342	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00346	7c 29		 jl	 SHORT $L70349

; 1855 : 				{
; 1856 : 					pSourceTrack->Clone(0, mtEndPad, &pEndPadTrack);

  00348	8d 4d a0	 lea	 ecx, DWORD PTR _pEndPadTrack$70344[ebp]
  0034b	51		 push	 ecx
  0034c	8b 55 f0	 mov	 edx, DWORD PTR _mtEndPad$[ebp]
  0034f	52		 push	 edx
  00350	6a 00		 push	 0
  00352	8b 45 a8	 mov	 eax, DWORD PTR _pSourceTrack$70345[ebp]
  00355	8b 08		 mov	 ecx, DWORD PTR [eax]
  00357	8b 55 a8	 mov	 edx, DWORD PTR _pSourceTrack$70345[ebp]
  0035a	52		 push	 edx
  0035b	ff 51 30	 call	 DWORD PTR [ecx+48]

; 1857 : 					pSourceTrack->Release();

  0035e	8b 45 a8	 mov	 eax, DWORD PTR _pSourceTrack$70345[ebp]
  00361	8b 08		 mov	 ecx, DWORD PTR [eax]
  00363	8b 55 a8	 mov	 edx, DWORD PTR _pSourceTrack$70345[ebp]
  00366	52		 push	 edx
  00367	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1858 : 					pSourceTrack = NULL;

  0036a	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _pSourceTrack$70345[ebp], 0
$L70349:

; 1859 : 				}
; 1860 : 			}
; 1861 : 			IDirectMusicTrack8* pTrack8 = NULL;

  00371	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pTrack8$70352[ebp], 0

; 1862 : 			if (pEndPadTrack)

  00378	83 7d a0 00	 cmp	 DWORD PTR _pEndPadTrack$70344[ebp], 0
  0037c	74 68		 je	 SHORT $L70353

; 1863 : 			{
; 1864 : 				if (SUCCEEDED(pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))

  0037e	8d 45 a4	 lea	 eax, DWORD PTR _pTrack8$70352[ebp]
  00381	50		 push	 eax
  00382	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  00387	8b 4d d4	 mov	 ecx, DWORD PTR _pTransTrack1$70321[ebp]
  0038a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0038c	8b 45 d4	 mov	 eax, DWORD PTR _pTransTrack1$70321[ebp]
  0038f	50		 push	 eax
  00390	ff 12		 call	 DWORD PTR [edx]
  00392	85 c0		 test	 eax, eax
  00394	7c 44		 jl	 SHORT $L70356

; 1865 : 				{
; 1866 : 					if (SUCCEEDED(pTrack8->Join(pEndPadTrack, m_mtLength, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))

  00396	6a 00		 push	 0
  00398	8b 4d b8	 mov	 ecx, DWORD PTR _dwTrackGroup$70328[ebp]
  0039b	51		 push	 ecx
  0039c	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  0039f	52		 push	 edx
  003a0	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  003a3	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  003a6	51		 push	 ecx
  003a7	8b 55 a0	 mov	 edx, DWORD PTR _pEndPadTrack$70344[ebp]
  003aa	52		 push	 edx
  003ab	8b 45 a4	 mov	 eax, DWORD PTR _pTrack8$70352[ebp]
  003ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b0	8b 55 a4	 mov	 edx, DWORD PTR _pTrack8$70352[ebp]
  003b3	52		 push	 edx
  003b4	ff 51 44	 call	 DWORD PTR [ecx+68]
  003b7	85 c0		 test	 eax, eax
  003b9	7c 13		 jl	 SHORT $L70359

; 1867 : 					{
; 1868 : 						fTrackPadded = true;

  003bb	c6 45 eb 01	 mov	 BYTE PTR _fTrackPadded$[ebp], 1

; 1869 : 						pTrack->m_dwInternalFlags |= TRACKINTERNAL_END_PADDED;

  003bf	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  003c2	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  003c5	83 c9 02	 or	 ecx, 2
  003c8	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  003cb	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$L70359:

; 1870 : 					}
; 1871 : 					pTrack8->Release();

  003ce	8b 45 a4	 mov	 eax, DWORD PTR _pTrack8$70352[ebp]
  003d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d3	8b 55 a4	 mov	 edx, DWORD PTR _pTrack8$70352[ebp]
  003d6	52		 push	 edx
  003d7	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70356:

; 1872 : 				}
; 1873 : 				pEndPadTrack->Release();

  003da	8b 45 a0	 mov	 eax, DWORD PTR _pEndPadTrack$70344[ebp]
  003dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003df	8b 55 a0	 mov	 edx, DWORD PTR _pEndPadTrack$70344[ebp]
  003e2	52		 push	 edx
  003e3	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70353:

; 1874 : 			}
; 1875 : 			if (SUCCEEDED(hr) && pStartPadTrack)

  003e6	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003ea	0f 8c 98 00 00
	00		 jl	 $L70361
  003f0	83 7d 98 00	 cmp	 DWORD PTR _pStartPadTrack$70343[ebp], 0
  003f4	0f 84 8e 00 00
	00		 je	 $L70361

; 1876 : 			{
; 1877 : 				if (SUCCEEDED(hr = pStartPadTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))

  003fa	8d 45 a4	 lea	 eax, DWORD PTR _pTrack8$70352[ebp]
  003fd	50		 push	 eax
  003fe	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  00403	8b 4d 98	 mov	 ecx, DWORD PTR _pStartPadTrack$70343[ebp]
  00406	8b 11		 mov	 edx, DWORD PTR [ecx]
  00408	8b 45 98	 mov	 eax, DWORD PTR _pStartPadTrack$70343[ebp]
  0040b	50		 push	 eax
  0040c	ff 12		 call	 DWORD PTR [edx]
  0040e	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
  00411	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00415	7c 63		 jl	 SHORT $L70364

; 1878 : 				{
; 1879 : 					if (SUCCEEDED(pTrack8->Join(pTransTrack1, mtStartPad, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))

  00417	6a 00		 push	 0
  00419	8b 4d b8	 mov	 ecx, DWORD PTR _dwTrackGroup$70328[ebp]
  0041c	51		 push	 ecx
  0041d	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  00420	52		 push	 edx
  00421	8b 45 fc	 mov	 eax, DWORD PTR _mtStartPad$[ebp]
  00424	50		 push	 eax
  00425	8b 4d d4	 mov	 ecx, DWORD PTR _pTransTrack1$70321[ebp]
  00428	51		 push	 ecx
  00429	8b 55 a4	 mov	 edx, DWORD PTR _pTrack8$70352[ebp]
  0042c	8b 02		 mov	 eax, DWORD PTR [edx]
  0042e	8b 4d a4	 mov	 ecx, DWORD PTR _pTrack8$70352[ebp]
  00431	51		 push	 ecx
  00432	ff 50 44	 call	 DWORD PTR [eax+68]
  00435	85 c0		 test	 eax, eax
  00437	7c 27		 jl	 SHORT $L70367

; 1880 : 					{
; 1881 : 						fTrackPadded = true;

  00439	c6 45 eb 01	 mov	 BYTE PTR _fTrackPadded$[ebp], 1

; 1882 : 						pTrack->m_dwInternalFlags |= TRACKINTERNAL_START_PADDED;

  0043d	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00440	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00443	83 c8 01	 or	 eax, 1
  00446	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00449	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1883 : 						pTransTrack1->Release();

  0044c	8b 55 d4	 mov	 edx, DWORD PTR _pTransTrack1$70321[ebp]
  0044f	8b 02		 mov	 eax, DWORD PTR [edx]
  00451	8b 4d d4	 mov	 ecx, DWORD PTR _pTransTrack1$70321[ebp]
  00454	51		 push	 ecx
  00455	ff 50 08	 call	 DWORD PTR [eax+8]

; 1884 : 						pTransTrack1 = pStartPadTrack;

  00458	8b 55 98	 mov	 edx, DWORD PTR _pStartPadTrack$70343[ebp]
  0045b	89 55 d4	 mov	 DWORD PTR _pTransTrack1$70321[ebp], edx

; 1885 : 					}
; 1886 : 					else

  0045e	eb 0c		 jmp	 SHORT $L70368
$L70367:

; 1887 : 					{
; 1888 : 						pStartPadTrack->Release();

  00460	8b 45 98	 mov	 eax, DWORD PTR _pStartPadTrack$70343[ebp]
  00463	8b 08		 mov	 ecx, DWORD PTR [eax]
  00465	8b 55 98	 mov	 edx, DWORD PTR _pStartPadTrack$70343[ebp]
  00468	52		 push	 edx
  00469	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70368:

; 1889 : 					}
; 1890 : 					pTrack8->Release();

  0046c	8b 45 a4	 mov	 eax, DWORD PTR _pTrack8$70352[ebp]
  0046f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00471	8b 55 a4	 mov	 edx, DWORD PTR _pTrack8$70352[ebp]
  00474	52		 push	 edx
  00475	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1891 : 				}
; 1892 : 				else

  00478	eb 0c		 jmp	 SHORT $L70369
$L70364:

; 1893 : 				{
; 1894 : 					pStartPadTrack->Release();

  0047a	8b 45 98	 mov	 eax, DWORD PTR _pStartPadTrack$70343[ebp]
  0047d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0047f	8b 55 98	 mov	 edx, DWORD PTR _pStartPadTrack$70343[ebp]
  00482	52		 push	 edx
  00483	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70369:

; 1895 : 				}
; 1896 : 			}
; 1897 :             else if(pStartPadTrack)

  00486	eb 12		 jmp	 SHORT $L70370
$L70361:
  00488	83 7d 98 00	 cmp	 DWORD PTR _pStartPadTrack$70343[ebp], 0
  0048c	74 0c		 je	 SHORT $L70370

; 1898 : 			{
; 1899 : 				pStartPadTrack->Release();

  0048e	8b 45 98	 mov	 eax, DWORD PTR _pStartPadTrack$70343[ebp]
  00491	8b 08		 mov	 ecx, DWORD PTR [eax]
  00493	8b 55 98	 mov	 edx, DWORD PTR _pStartPadTrack$70343[ebp]
  00496	52		 push	 edx
  00497	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70370:

; 1900 : 			}
; 1901 : 
; 1902 : 			// Replace the current track with the instantiated one
; 1903 : 			IDirectMusicTrack8* pTempTrack8 = NULL;

  0049a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _pTempTrack8$70372[ebp], 0

; 1904 : 			pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);

  004a1	8d 45 9c	 lea	 eax, DWORD PTR _pTempTrack8$70372[ebp]
  004a4	50		 push	 eax
  004a5	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  004aa	8b 4d d4	 mov	 ecx, DWORD PTR _pTransTrack1$70321[ebp]
  004ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  004af	8b 45 d4	 mov	 eax, DWORD PTR _pTransTrack1$70321[ebp]
  004b2	50		 push	 eax
  004b3	ff 12		 call	 DWORD PTR [edx]

; 1905 : 			if (pTrack->m_pTrack) pTrack->m_pTrack->Release();

  004b5	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  004b8	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  004bc	74 12		 je	 SHORT $L70374
  004be	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  004c1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  004c4	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  004c7	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  004ca	8b 00		 mov	 eax, DWORD PTR [eax]
  004cc	52		 push	 edx
  004cd	ff 50 08	 call	 DWORD PTR [eax+8]
$L70374:

; 1906 : 			pTrack->m_pTrack = pTransTrack1;

  004d0	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  004d3	8b 55 d4	 mov	 edx, DWORD PTR _pTransTrack1$70321[ebp]
  004d6	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1907 :             pTrack->m_pTrack->Init( this );

  004d9	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  004dc	50		 push	 eax
  004dd	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  004e0	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  004e3	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  004e6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004e9	8b 12		 mov	 edx, DWORD PTR [edx]
  004eb	51		 push	 ecx
  004ec	ff 52 0c	 call	 DWORD PTR [edx+12]

; 1908 : 			if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();

  004ef	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  004f2	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  004f6	74 12		 je	 SHORT $L70375
  004f8	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  004fb	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  004fe	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00501	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00504	8b 12		 mov	 edx, DWORD PTR [edx]
  00506	51		 push	 ecx
  00507	ff 52 08	 call	 DWORD PTR [edx+8]
$L70375:

; 1909 : 			pTrack->m_pTrack8 = pTempTrack8;

  0050a	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0050d	8b 4d 9c	 mov	 ecx, DWORD PTR _pTempTrack8$70372[ebp]
  00510	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L70342:

; 1910 : 		}
; 1911 : 
; 1912 : 		if (FAILED(hr)) break;

  00513	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00517	7d 02		 jge	 SHORT $L70377
  00519	eb 05		 jmp	 SHORT $L70320
$L70377:

; 1913 : 	}

  0051b	e9 d2 fb ff ff	 jmp	 $L70319
$L70320:

; 1914 : 	MUSIC_TIME mtOldLength = m_mtLength;

  00520	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  00523	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00526	89 45 d8	 mov	 DWORD PTR _mtOldLength$[ebp], eax

; 1915 : 	if (fTrackPadded) // any tracks got joined with header/trailer info

  00529	0f b6 4d eb	 movzx	 ecx, BYTE PTR _fTrackPadded$[ebp]
  0052d	85 c9		 test	 ecx, ecx
  0052f	74 12		 je	 SHORT $L70379

; 1916 : 	{
; 1917 :         // pad the length of the segment, to account for the header/trailer
; 1918 : 		m_mtLength += mtStartPad + mtEndPad;

  00531	8b 55 fc	 mov	 edx, DWORD PTR _mtStartPad$[ebp]
  00534	03 55 f0	 add	 edx, DWORD PTR _mtEndPad$[ebp]
  00537	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  0053a	03 50 70	 add	 edx, DWORD PTR [eax+112]
  0053d	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00540	89 51 70	 mov	 DWORD PTR [ecx+112], edx
$L70379:

; 1919 : 	}
; 1920 : 
; 1921 : 	// Compose
; 1922 : 	if (SUCCEEDED(hr))

  00543	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00547	7c 0b		 jl	 SHORT $L70381

; 1923 : 	{
; 1924 : 		hr = ComposeInternal();

  00549	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0054c	e8 00 00 00 00	 call	 ?ComposeInternal@CSegment@@QAEJXZ ; CSegment::ComposeInternal
  00551	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
$L70381:

; 1925 : 	}
; 1926 : 
; 1927 : 	// Back end
; 1928 : 	if (fTrackPadded) // any tracks got joined with header/trailer info

  00554	0f b6 55 eb	 movzx	 edx, BYTE PTR _fTrackPadded$[ebp]
  00558	85 d2		 test	 edx, edx
  0055a	0f 84 ae 01 00
	00		 je	 $L70382

; 1929 : 	{
; 1930 :         // Trim header and trailer from each track that was joined, using Clone.
; 1931 : 		pTrack = m_TrackList.GetHead();

  00560	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00563	83 c1 44	 add	 ecx, 68			; 00000044H
  00566	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  0056b	89 45 dc	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1932 : 		for (; pTrack; pTrack = pTrack->GetNext())

  0056e	eb 0b		 jmp	 SHORT $L70383
$L70384:
  00570	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00573	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00578	89 45 dc	 mov	 DWORD PTR _pTrack$[ebp], eax
$L70383:
  0057b	83 7d dc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  0057f	0f 84 80 01 00
	00		 je	 $L70385

; 1933 : 		{
; 1934 : 			if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_START_PADDED) )

  00585	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00588	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0058c	0f 84 ae 00 00
	00		 je	 $L70386
  00592	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00595	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00598	83 e2 01	 and	 edx, 1
  0059b	85 d2		 test	 edx, edx
  0059d	0f 84 9d 00 00
	00		 je	 $L70386

; 1935 : 			{
; 1936 : 				IDirectMusicTrack* pTempTrack = NULL;

  005a3	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _pTempTrack$70387[ebp], 0

; 1937 : 				IDirectMusicTrack8* pTempTrack8 = NULL;

  005aa	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _pTempTrack8$70388[ebp], 0

; 1938 : 				pTrack->m_pTrack->Clone(mtStartPad, mtOldLength + mtStartPad, &pTempTrack);

  005b1	8d 45 90	 lea	 eax, DWORD PTR _pTempTrack$70387[ebp]
  005b4	50		 push	 eax
  005b5	8b 4d d8	 mov	 ecx, DWORD PTR _mtOldLength$[ebp]
  005b8	03 4d fc	 add	 ecx, DWORD PTR _mtStartPad$[ebp]
  005bb	51		 push	 ecx
  005bc	8b 55 fc	 mov	 edx, DWORD PTR _mtStartPad$[ebp]
  005bf	52		 push	 edx
  005c0	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  005c3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005c6	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  005c9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  005cc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  005ce	50		 push	 eax
  005cf	ff 51 30	 call	 DWORD PTR [ecx+48]

; 1939 : 				pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);

  005d2	8d 55 94	 lea	 edx, DWORD PTR _pTempTrack8$70388[ebp]
  005d5	52		 push	 edx
  005d6	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  005db	8b 45 90	 mov	 eax, DWORD PTR _pTempTrack$70387[ebp]
  005de	8b 08		 mov	 ecx, DWORD PTR [eax]
  005e0	8b 55 90	 mov	 edx, DWORD PTR _pTempTrack$70387[ebp]
  005e3	52		 push	 edx
  005e4	ff 11		 call	 DWORD PTR [ecx]

; 1940 : 				pTrack->m_pTrack->Release();

  005e6	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  005e9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005ec	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  005ef	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  005f2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  005f4	50		 push	 eax
  005f5	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1941 : 				pTrack->m_pTrack = pTempTrack;

  005f8	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  005fb	8b 45 90	 mov	 eax, DWORD PTR _pTempTrack$70387[ebp]
  005fe	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1942 : 				pTrack->m_pTrack->Init( this );

  00601	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00604	51		 push	 ecx
  00605	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00608	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0060b	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  0060e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00611	8b 00		 mov	 eax, DWORD PTR [eax]
  00613	52		 push	 edx
  00614	ff 50 0c	 call	 DWORD PTR [eax+12]

; 1943 : 				if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();

  00617	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  0061a	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0061e	74 12		 je	 SHORT $L70390
  00620	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00623	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00626	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00629	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0062c	8b 00		 mov	 eax, DWORD PTR [eax]
  0062e	52		 push	 edx
  0062f	ff 50 08	 call	 DWORD PTR [eax+8]
$L70390:

; 1944 : 				pTrack->m_pTrack8 = pTempTrack8;

  00632	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00635	8b 55 94	 mov	 edx, DWORD PTR _pTempTrack8$70388[ebp]
  00638	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1945 : 			}
; 1946 : 			else if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_END_PADDED) )

  0063b	e9 b1 00 00 00	 jmp	 $L70391
$L70386:
  00640	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00643	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00647	0f 84 a4 00 00
	00		 je	 $L70391
  0064d	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00650	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00653	83 e2 02	 and	 edx, 2
  00656	85 d2		 test	 edx, edx
  00658	0f 84 93 00 00
	00		 je	 $L70391

; 1947 : 			{
; 1948 : 				IDirectMusicTrack* pTempTrack = NULL;

  0065e	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _pTempTrack$70393[ebp], 0

; 1949 : 				IDirectMusicTrack8* pTempTrack8 = NULL;

  00665	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _pTempTrack8$70394[ebp], 0

; 1950 : 				pTrack->m_pTrack->Clone(0, mtOldLength, &pTempTrack);

  0066c	8d 45 88	 lea	 eax, DWORD PTR _pTempTrack$70393[ebp]
  0066f	50		 push	 eax
  00670	8b 4d d8	 mov	 ecx, DWORD PTR _mtOldLength$[ebp]
  00673	51		 push	 ecx
  00674	6a 00		 push	 0
  00676	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00679	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0067c	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  0067f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00682	8b 00		 mov	 eax, DWORD PTR [eax]
  00684	52		 push	 edx
  00685	ff 50 30	 call	 DWORD PTR [eax+48]

; 1951 : 				pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);

  00688	8d 4d 8c	 lea	 ecx, DWORD PTR _pTempTrack8$70394[ebp]
  0068b	51		 push	 ecx
  0068c	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  00691	8b 55 88	 mov	 edx, DWORD PTR _pTempTrack$70393[ebp]
  00694	8b 02		 mov	 eax, DWORD PTR [edx]
  00696	8b 4d 88	 mov	 ecx, DWORD PTR _pTempTrack$70393[ebp]
  00699	51		 push	 ecx
  0069a	ff 10		 call	 DWORD PTR [eax]

; 1952 : 				pTrack->m_pTrack->Release();

  0069c	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0069f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  006a2	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  006a5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  006a8	8b 00		 mov	 eax, DWORD PTR [eax]
  006aa	52		 push	 edx
  006ab	ff 50 08	 call	 DWORD PTR [eax+8]

; 1953 : 				pTrack->m_pTrack = pTempTrack;

  006ae	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  006b1	8b 55 88	 mov	 edx, DWORD PTR _pTempTrack$70393[ebp]
  006b4	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1954 : 				pTrack->m_pTrack->Init( this );

  006b7	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  006ba	50		 push	 eax
  006bb	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  006be	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  006c1	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  006c4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  006c7	8b 12		 mov	 edx, DWORD PTR [edx]
  006c9	51		 push	 ecx
  006ca	ff 52 0c	 call	 DWORD PTR [edx+12]

; 1955 : 				if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();

  006cd	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  006d0	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  006d4	74 12		 je	 SHORT $L70396
  006d6	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  006d9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006dc	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  006df	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  006e2	8b 12		 mov	 edx, DWORD PTR [edx]
  006e4	51		 push	 ecx
  006e5	ff 52 08	 call	 DWORD PTR [edx+8]
$L70396:

; 1956 : 				pTrack->m_pTrack8 = pTempTrack8;

  006e8	8b 45 dc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  006eb	8b 4d 8c	 mov	 ecx, DWORD PTR _pTempTrack8$70394[ebp]
  006ee	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L70391:

; 1957 : 			}
; 1958 : 			pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);

  006f1	8b 55 dc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  006f4	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  006f7	83 e0 fc	 and	 eax, -4			; fffffffcH
  006fa	8b 4d dc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  006fd	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1959 : 		}

  00700	e9 6b fe ff ff	 jmp	 $L70384
$L70385:

; 1960 :         // Return the length of the segment to its original value. 
; 1961 :  		m_mtLength = mtOldLength;

  00705	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  00708	8b 45 d8	 mov	 eax, DWORD PTR _mtOldLength$[ebp]
  0070b	89 42 70	 mov	 DWORD PTR [edx+112], eax
$L70382:

; 1962 : 	}
; 1963 : 
; 1964 : 	return hr;

  0070e	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]

; 1965 : }

  00711	8b e5		 mov	 esp, ebp
  00713	5d		 pop	 ebp
  00714	c2 0c 00	 ret	 12			; 0000000cH
?ComposeTransition@CSegment@@QAEJJPAUIDirectMusicSegment@@0@Z ENDP ; CSegment::ComposeTransition
_TEXT	ENDS
PUBLIC	??0?$TList@PAVCTrack@@@@QAE@XZ			; TList<CTrack *>::TList<CTrack *>
PUBLIC	??1?$TList@PAVCTrack@@@@QAE@XZ			; TList<CTrack *>::~TList<CTrack *>
PUBLIC	?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ ; TList<CTrack *>::GetHead
PUBLIC	?AddHead@?$TList@PAVCTrack@@@@QAEXPAV?$TListItem@PAVCTrack@@@@@Z ; TList<CTrack *>::AddHead
PUBLIC	??0?$TListItem@PAVCTrack@@@@QAE@ABQAVCTrack@@@Z	; TListItem<CTrack *>::TListItem<CTrack *>
PUBLIC	?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ	; TListItem<CTrack *>::GetNext
PUBLIC	?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z	; TListItem<CTrack *>::SetNext
PUBLIC	?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ ; TListItem<CTrack *>::GetItemValue
; Function compile flags: /Odt
;	COMDAT ?ComposeInternal@CSegment@@QAEJXZ
_TEXT	SEGMENT
tv82 = -80
_this$ = -76
$T72055 = -72
$T72052 = -68
_guidClassId$70528 = -64
_pPersist$70529 = -48
_pOldTrack$70527 = -44
_rpTrack$70521 = -40
_pComposedTrack$70522 = -36
_pTrackItem$70517 = -32
_rpMaster$70509 = -28
_pPrevious$70505 = -24
_pMaster$70504 = -20
_pTrackItem$70454 = -16
_pTrack$ = -12
_hr$ = -8
_TrackList$ = -4
?ComposeInternal@CSegment@@QAEJXZ PROC NEAR		; CSegment::ComposeInternal, COMDAT
; _this$ = ecx

; 1968 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 1969 : 	HRESULT hr = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1970 : 	TList<CTrack*> TrackList;

  00010	8d 4d fc	 lea	 ecx, DWORD PTR _TrackList$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$TList@PAVCTrack@@@@QAE@XZ ; TList<CTrack *>::TList<CTrack *>

; 1971 : 	// Find the composing tracks and put them in priority order
; 1972 : 	CTrack* pTrack = m_TrackList.GetHead();

  00018	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 44	 add	 ecx, 68			; 00000044H
  0001e	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00023	89 45 f4	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1973 :     for (; pTrack; pTrack = pTrack->GetNext())

  00026	eb 0b		 jmp	 SHORT $L70450
$L70451:
  00028	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  0002b	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00030	89 45 f4	 mov	 DWORD PTR _pTrack$[ebp], eax
$L70450:
  00033	83 7d f4 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  00037	0f 84 d7 00 00
	00		 je	 $L70452

; 1974 : 	{
; 1975 : 		if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)

  0003d	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00040	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00043	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00049	85 c9		 test	 ecx, ecx
  0004b	0f 84 b6 00 00
	00		 je	 $L70453

; 1976 : 		{
; 1977 : 			TListItem<CTrack*>* pTrackItem = new TListItem<CTrack*>(pTrack);

  00051	6a 08		 push	 8
  00053	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00058	83 c4 04	 add	 esp, 4
  0005b	89 45 bc	 mov	 DWORD PTR $T72052[ebp], eax
  0005e	83 7d bc 00	 cmp	 DWORD PTR $T72052[ebp], 0
  00062	74 11		 je	 SHORT $L72053
  00064	8d 55 f4	 lea	 edx, DWORD PTR _pTrack$[ebp]
  00067	52		 push	 edx
  00068	8b 4d bc	 mov	 ecx, DWORD PTR $T72052[ebp]
  0006b	e8 00 00 00 00	 call	 ??0?$TListItem@PAVCTrack@@@@QAE@ABQAVCTrack@@@Z ; TListItem<CTrack *>::TListItem<CTrack *>
  00070	89 45 b0	 mov	 DWORD PTR tv82[ebp], eax
  00073	eb 07		 jmp	 SHORT $L72054
$L72053:
  00075	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$L72054:
  0007c	8b 45 b0	 mov	 eax, DWORD PTR tv82[ebp]
  0007f	89 45 f0	 mov	 DWORD PTR _pTrackItem$70454[ebp], eax

; 1978 : 			if (!pTrackItem)

  00082	83 7d f0 00	 cmp	 DWORD PTR _pTrackItem$70454[ebp], 0
  00086	75 09		 jne	 SHORT $L70501

; 1979 : 			{
; 1980 : 				hr = E_OUTOFMEMORY;

  00088	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 1981 : 			}
; 1982 : 			else

  0008f	eb 76		 jmp	 SHORT $L70453
$L70501:

; 1983 : 			{
; 1984 : 				TListItem<CTrack*>* pMaster = TrackList.GetHead();

  00091	8d 4d fc	 lea	 ecx, DWORD PTR _TrackList$[ebp]
  00094	e8 00 00 00 00	 call	 ?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ ; TList<CTrack *>::GetHead
  00099	89 45 ec	 mov	 DWORD PTR _pMaster$70504[ebp], eax

; 1985 : 				TListItem<CTrack*>* pPrevious = NULL;

  0009c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pPrevious$70505[ebp], 0

; 1986 : 				for (; pMaster; pMaster = pMaster->GetNext())

  000a3	eb 0b		 jmp	 SHORT $L70506
$L70507:
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _pMaster$70504[ebp]
  000a8	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ ; TListItem<CTrack *>::GetNext
  000ad	89 45 ec	 mov	 DWORD PTR _pMaster$70504[ebp], eax
$L70506:
  000b0	83 7d ec 00	 cmp	 DWORD PTR _pMaster$70504[ebp], 0
  000b4	74 25		 je	 SHORT $L70508

; 1987 : 				{
; 1988 : 					CTrack*& rpMaster = pMaster->GetItemValue();

  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _pMaster$70504[ebp]
  000b9	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ ; TListItem<CTrack *>::GetItemValue
  000be	89 45 e4	 mov	 DWORD PTR _rpMaster$70509[ebp], eax

; 1989 : 					if (pTrack->m_dwPriority > rpMaster->m_dwPriority) break;

  000c1	8b 4d e4	 mov	 ecx, DWORD PTR _rpMaster$70509[ebp]
  000c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c6	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$[ebp]
  000c9	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000cc	3b 4a 2c	 cmp	 ecx, DWORD PTR [edx+44]
  000cf	76 02		 jbe	 SHORT $L70510
  000d1	eb 08		 jmp	 SHORT $L70508
$L70510:

; 1990 : 					pPrevious = pMaster;

  000d3	8b 55 ec	 mov	 edx, DWORD PTR _pMaster$70504[ebp]
  000d6	89 55 e8	 mov	 DWORD PTR _pPrevious$70505[ebp], edx

; 1991 : 				}

  000d9	eb ca		 jmp	 SHORT $L70507
$L70508:

; 1992 : 				if (!pPrevious) // this has higher priority than anything in the list

  000db	83 7d e8 00	 cmp	 DWORD PTR _pPrevious$70505[ebp], 0
  000df	75 0e		 jne	 SHORT $L70511

; 1993 : 				{
; 1994 : 					TrackList.AddHead(pTrackItem);

  000e1	8b 45 f0	 mov	 eax, DWORD PTR _pTrackItem$70454[ebp]
  000e4	50		 push	 eax
  000e5	8d 4d fc	 lea	 ecx, DWORD PTR _TrackList$[ebp]
  000e8	e8 00 00 00 00	 call	 ?AddHead@?$TList@PAVCTrack@@@@QAEXPAV?$TListItem@PAVCTrack@@@@@Z ; TList<CTrack *>::AddHead

; 1995 : 				}
; 1996 : 				else // lower priority than pPrevious, higher than pMaster

  000ed	eb 18		 jmp	 SHORT $L70453
$L70511:

; 1997 : 				{
; 1998 : 					pTrackItem->SetNext(pMaster);

  000ef	8b 4d ec	 mov	 ecx, DWORD PTR _pMaster$70504[ebp]
  000f2	51		 push	 ecx
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR _pTrackItem$70454[ebp]
  000f6	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z ; TListItem<CTrack *>::SetNext

; 1999 : 					pPrevious->SetNext(pTrackItem);

  000fb	8b 55 f0	 mov	 edx, DWORD PTR _pTrackItem$70454[ebp]
  000fe	52		 push	 edx
  000ff	8b 4d e8	 mov	 ecx, DWORD PTR _pPrevious$70505[ebp]
  00102	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z ; TListItem<CTrack *>::SetNext
$L70453:

; 2000 : 				}
; 2001 : 			}
; 2002 : 		}
; 2003 : 		if (FAILED(hr)) break;

  00107	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0010b	7d 02		 jge	 SHORT $L70514
  0010d	eb 05		 jmp	 SHORT $L70452
$L70514:

; 2004 : 	}

  0010f	e9 14 ff ff ff	 jmp	 $L70451
$L70452:

; 2005 : 	// Compose a new track from each from each composing track; put the results
; 2006 : 	// in the segment (remove any existing composed tracks)
; 2007 : 	if (SUCCEEDED(hr))

  00114	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00118	0f 8c 32 01 00
	00		 jl	 $L70516

; 2008 : 	{
; 2009 : 		TListItem<CTrack*>* pTrackItem = TrackList.GetHead();

  0011e	8d 4d fc	 lea	 ecx, DWORD PTR _TrackList$[ebp]
  00121	e8 00 00 00 00	 call	 ?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ ; TList<CTrack *>::GetHead
  00126	89 45 e0	 mov	 DWORD PTR _pTrackItem$70517[ebp], eax

; 2010 : 		for (; pTrackItem; pTrackItem = pTrackItem->GetNext())

  00129	eb 0b		 jmp	 SHORT $L70518
$L70519:
  0012b	8b 4d e0	 mov	 ecx, DWORD PTR _pTrackItem$70517[ebp]
  0012e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ ; TListItem<CTrack *>::GetNext
  00133	89 45 e0	 mov	 DWORD PTR _pTrackItem$70517[ebp], eax
$L70518:
  00136	83 7d e0 00	 cmp	 DWORD PTR _pTrackItem$70517[ebp], 0
  0013a	0f 84 10 01 00
	00		 je	 $L70516

; 2011 : 		{
; 2012 : 			CTrack*& rpTrack = pTrackItem->GetItemValue();

  00140	8b 4d e0	 mov	 ecx, DWORD PTR _pTrackItem$70517[ebp]
  00143	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ ; TListItem<CTrack *>::GetItemValue
  00148	89 45 d8	 mov	 DWORD PTR _rpTrack$70521[ebp], eax

; 2013 : 			IDirectMusicTrack8* pComposedTrack = NULL;

  0014b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pComposedTrack$70522[ebp], 0

; 2014 : 			hr = rpTrack->m_pTrack8->Compose((IDirectMusicSegment*)this, rpTrack->m_dwGroupBits, (IDirectMusicTrack**)&pComposedTrack);

  00152	8d 45 dc	 lea	 eax, DWORD PTR _pComposedTrack$70522[ebp]
  00155	50		 push	 eax
  00156	8b 4d d8	 mov	 ecx, DWORD PTR _rpTrack$70521[ebp]
  00159	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015b	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0015e	50		 push	 eax
  0015f	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	51		 push	 ecx
  00163	8b 55 d8	 mov	 edx, DWORD PTR _rpTrack$70521[ebp]
  00166	8b 02		 mov	 eax, DWORD PTR [edx]
  00168	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0016b	8b 55 d8	 mov	 edx, DWORD PTR _rpTrack$70521[ebp]
  0016e	8b 02		 mov	 eax, DWORD PTR [edx]
  00170	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	52		 push	 edx
  00176	ff 50 40	 call	 DWORD PTR [eax+64]
  00179	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2015 : 			if (SUCCEEDED(hr))

  0017c	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00180	0f 8c bd 00 00
	00		 jl	 $L70526

; 2016 : 			{
; 2017 : 				// Remove any tracks of this type (in the same group) from the segment.
; 2018 : 				IDirectMusicTrack* pOldTrack = NULL;

  00186	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pOldTrack$70527[ebp], 0

; 2019 : 				GUID guidClassId;
; 2020 : 				memset(&guidClassId, 0, sizeof(guidClassId));

  0018d	6a 10		 push	 16			; 00000010H
  0018f	6a 00		 push	 0
  00191	8d 4d c0	 lea	 ecx, DWORD PTR _guidClassId$70528[ebp]
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 _memset
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2021 : 				IPersistStream* pPersist = NULL;

  0019d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pPersist$70529[ebp], 0

; 2022 : 				if (SUCCEEDED(pComposedTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )

  001a4	8d 55 d0	 lea	 edx, DWORD PTR _pPersist$70529[ebp]
  001a7	52		 push	 edx
  001a8	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  001ad	8b 45 dc	 mov	 eax, DWORD PTR _pComposedTrack$70522[ebp]
  001b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b2	8b 55 dc	 mov	 edx, DWORD PTR _pComposedTrack$70522[ebp]
  001b5	52		 push	 edx
  001b6	ff 11		 call	 DWORD PTR [ecx]
  001b8	85 c0		 test	 eax, eax
  001ba	7c 5f		 jl	 SHORT $L70532

; 2023 : 				{
; 2024 : 					if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
; 2025 : 						SUCCEEDED( GetTrack( guidClassId, rpTrack->m_dwGroupBits, 0, &pOldTrack ) ) )

  001bc	8d 45 c0	 lea	 eax, DWORD PTR _guidClassId$70528[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d d0	 mov	 ecx, DWORD PTR _pPersist$70529[ebp]
  001c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c5	8b 45 d0	 mov	 eax, DWORD PTR _pPersist$70529[ebp]
  001c8	50		 push	 eax
  001c9	ff 52 0c	 call	 DWORD PTR [edx+12]
  001cc	85 c0		 test	 eax, eax
  001ce	7c 3f		 jl	 SHORT $L70535
  001d0	8d 4d d4	 lea	 ecx, DWORD PTR _pOldTrack$70527[ebp]
  001d3	51		 push	 ecx
  001d4	6a 00		 push	 0
  001d6	8b 55 d8	 mov	 edx, DWORD PTR _rpTrack$70521[ebp]
  001d9	8b 02		 mov	 eax, DWORD PTR [edx]
  001db	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001de	51		 push	 ecx
  001df	8d 55 c0	 lea	 edx, DWORD PTR _guidClassId$70528[ebp]
  001e2	52		 push	 edx
  001e3	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e8	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  001eb	52		 push	 edx
  001ec	ff 51 54	 call	 DWORD PTR [ecx+84]
  001ef	85 c0		 test	 eax, eax
  001f1	7c 1c		 jl	 SHORT $L70535

; 2026 : 					{
; 2027 : 						RemoveTrack( pOldTrack );

  001f3	8b 45 d4	 mov	 eax, DWORD PTR _pOldTrack$70527[ebp]
  001f6	50		 push	 eax
  001f7	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  001fa	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fc	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  001ff	50		 push	 eax
  00200	ff 52 60	 call	 DWORD PTR [edx+96]

; 2028 : 						pOldTrack->Release();

  00203	8b 4d d4	 mov	 ecx, DWORD PTR _pOldTrack$70527[ebp]
  00206	8b 11		 mov	 edx, DWORD PTR [ecx]
  00208	8b 45 d4	 mov	 eax, DWORD PTR _pOldTrack$70527[ebp]
  0020b	50		 push	 eax
  0020c	ff 52 08	 call	 DWORD PTR [edx+8]
$L70535:

; 2029 : 					}
; 2030 : 					pPersist->Release();

  0020f	8b 4d d0	 mov	 ecx, DWORD PTR _pPersist$70529[ebp]
  00212	8b 11		 mov	 edx, DWORD PTR [ecx]
  00214	8b 45 d0	 mov	 eax, DWORD PTR _pPersist$70529[ebp]
  00217	50		 push	 eax
  00218	ff 52 08	 call	 DWORD PTR [edx+8]
$L70532:

; 2031 : 				}
; 2032 : 				hr = InsertTrack(pComposedTrack, rpTrack->m_dwGroupBits);

  0021b	8b 4d d8	 mov	 ecx, DWORD PTR _rpTrack$70521[ebp]
  0021e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00220	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00223	50		 push	 eax
  00224	8b 4d dc	 mov	 ecx, DWORD PTR _pComposedTrack$70522[ebp]
  00227	51		 push	 ecx
  00228	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  0022b	8b 02		 mov	 eax, DWORD PTR [edx]
  0022d	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	51		 push	 ecx
  00231	ff 50 5c	 call	 DWORD PTR [eax+92]
  00234	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2033 : 				pComposedTrack->Release();

  00237	8b 55 dc	 mov	 edx, DWORD PTR _pComposedTrack$70522[ebp]
  0023a	8b 02		 mov	 eax, DWORD PTR [edx]
  0023c	8b 4d dc	 mov	 ecx, DWORD PTR _pComposedTrack$70522[ebp]
  0023f	51		 push	 ecx
  00240	ff 50 08	 call	 DWORD PTR [eax+8]
$L70526:

; 2034 : 			}
; 2035 : 			if (FAILED(hr)) break;

  00243	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00247	7d 02		 jge	 SHORT $L70537
  00249	eb 05		 jmp	 SHORT $L70516
$L70537:

; 2036 : 		}

  0024b	e9 db fe ff ff	 jmp	 $L70519
$L70516:

; 2037 : 	}
; 2038 : 	return hr;

  00250	8b 55 f8	 mov	 edx, DWORD PTR _hr$[ebp]
  00253	89 55 b8	 mov	 DWORD PTR $T72055[ebp], edx
  00256	8d 4d fc	 lea	 ecx, DWORD PTR _TrackList$[ebp]
  00259	e8 00 00 00 00	 call	 ??1?$TList@PAVCTrack@@@@QAE@XZ ; TList<CTrack *>::~TList<CTrack *>
  0025e	8b 45 b8	 mov	 eax, DWORD PTR $T72055[ebp]

; 2039 : }

  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
?ComposeInternal@CSegment@@QAEJXZ ENDP			; CSegment::ComposeInternal
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetStartPoint@CSegment@@UAGJPAJ@Z
_TEXT	SEGMENT
_this$ = 8
_pmtStart$ = 12
?GetStartPoint@CSegment@@UAGJPAJ@Z PROC NEAR		; CSegment::GetStartPoint, COMDAT

; 2045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2046 : 	V_INAME(IDirectMusicSegment::GetStartPoint);
; 2047 : #ifdef DXAPI
; 2048 :     if (m_fZombie)
; 2049 : 	{
; 2050 : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetStartPoint after the segment has been garbage collected.\n");
; 2051 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2052 : 	}
; 2053 : #endif
; 2054 : 	*pmtStart = m_mtStart;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pmtStart$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00009	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 2055 : 	return S_OK;

  0000e	33 c0		 xor	 eax, eax

; 2056 : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?GetStartPoint@CSegment@@UAGJPAJ@Z ENDP			; CSegment::GetStartPoint
_TEXT	ENDS
PUBLIC	??_C@_0GB@OANALOD@Error?3?5Unable?5to?5set?5start?5point@ ; `string'
;	COMDAT ??_C@_0GB@OANALOD@Error?3?5Unable?5to?5set?5start?5point@
CONST	SEGMENT
??_C@_0GB@OANALOD@Error?3?5Unable?5to?5set?5start?5point@ DB 'Error: Unab'
	DB	'le to set start point %ld because not within the range of the'
	DB	' segment, which is %ld.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetStartPoint@CSegment@@UAGJJ@Z
_TEXT	SEGMENT
_this$ = 8
_mtStart$ = 12
?SetStartPoint@CSegment@@UAGJJ@Z PROC NEAR		; CSegment::SetStartPoint, COMDAT

; 2064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2065 : 	if( (mtStart < 0) || (mtStart >= m_mtLength) )

  00003	83 7d 0c 00	 cmp	 DWORD PTR _mtStart$[ebp], 0
  00007	7c 0b		 jl	 SHORT $L70551
  00009	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  0000f	3b 48 70	 cmp	 ecx, DWORD PTR [eax+112]
  00012	7c 21		 jl	 SHORT $L70550
$L70551:

; 2066 : 	{
; 2067 :         Trace(1,"Error: Unable to set start point %ld because not within the range of the segment, which is %ld.\n",
; 2068 :             mtStart,m_mtLength);

  00014	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  0001e	51		 push	 ecx
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GB@OANALOD@Error?3?5Unable?5to?5set?5start?5point@
  00024	6a 01		 push	 1
  00026	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 2069 : 		return DMUS_E_OUT_OF_RANGE;

  0002e	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00033	eb 0b		 jmp	 SHORT $L70549
$L70550:

; 2070 : 	}
; 2071 : 
; 2072 : #ifdef DXAPI
; 2073 :     if (m_fZombie)
; 2074 : 	{
; 2075 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetStartPoint after the segment has been garbage collected.\n");
; 2076 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2077 : 	}
; 2078 : #endif
; 2079 : 	m_mtStart = mtStart;

  00035	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00038	8b 45 0c	 mov	 eax, DWORD PTR _mtStart$[ebp]
  0003b	89 42 74	 mov	 DWORD PTR [edx+116], eax

; 2080 : 	return S_OK;

  0003e	33 c0		 xor	 eax, eax
$L70549:

; 2081 : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?SetStartPoint@CSegment@@UAGJJ@Z ENDP			; CSegment::SetStartPoint
_TEXT	ENDS
PUBLIC	??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@FIBGFLCL@?$CFs?3?5Invalid?5pointer?5pmtEnd?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetLoopPoints@CSegment@@UAGJPAJ0@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetLoopPoints@CSegment@@UAGJPAJ0@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::GetLoopPoints', 00H	; `CSegment::GetLoopPoints'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
CONST	SEGMENT
??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pmtStart', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FIBGFLCL@?$CFs?3?5Invalid?5pointer?5pmtEnd?6?$AA@
CONST	SEGMENT
??_C@_0BM@FIBGFLCL@?$CFs?3?5Invalid?5pointer?5pmtEnd?6?$AA@ DB '%s: Inval'
	DB	'id pointer pmtEnd', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetLoopPoints@CSegment@@UAGJPAJ0@Z
_TEXT	SEGMENT
_this$ = 8
_pmtStart$ = 12
_pmtEnd$ = 16
?GetLoopPoints@CSegment@@UAGJPAJ0@Z PROC NEAR		; CSegment::GetLoopPoints, COMDAT

; 2088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2089 : 	V_INAME(IDirectMusicSegment::GetLoopPoints);
; 2090 : 	V_PTR_WRITE(pmtStart, MUSIC_TIME);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pmtStart$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70563
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetLoopPoints@CSegment@@UAGJPAJ0@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70563:

; 2091 : 	V_PTR_WRITE(pmtEnd, MUSIC_TIME);

  0002b	6a 04		 push	 4
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _pmtEnd$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00036	85 c0		 test	 eax, eax
  00038	74 19		 je	 SHORT $L70566
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetLoopPoints@CSegment@@UAGJPAJ0@Z@4QBDB
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@FIBGFLCL@?$CFs?3?5Invalid?5pointer?5pmtEnd?6?$AA@
  00044	6a ff		 push	 -1
  00046	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	e8 00 00 00 00	 call	 _DebugBreak@0
$L70566:

; 2092 : #ifdef DXAPI
; 2093 :     if (m_fZombie)
; 2094 : 	{
; 2095 : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetLoopPoints after the segment has been garbage collected.\n");
; 2096 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2097 : 	}
; 2098 : #endif
; 2099 : 	*pmtStart = m_mtLoopStart;

  00053	8b 55 0c	 mov	 edx, DWORD PTR _pmtStart$[ebp]
  00056	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0005c	89 0a		 mov	 DWORD PTR [edx], ecx

; 2100 : 	*pmtEnd = m_mtLoopEnd;

  0005e	8b 55 10	 mov	 edx, DWORD PTR _pmtEnd$[ebp]
  00061	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  00067	89 0a		 mov	 DWORD PTR [edx], ecx

; 2101 : 	return S_OK;

  00069	33 c0		 xor	 eax, eax

; 2102 : }

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
?GetLoopPoints@CSegment@@UAGJPAJ0@Z ENDP		; CSegment::GetLoopPoints
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetLoopPoints@CSegment@@UAGJJJ@Z
_TEXT	SEGMENT
_this$ = 8
_mtStart$ = 12
_mtEnd$ = 16
?SetLoopPoints@CSegment@@UAGJJJ@Z PROC NEAR		; CSegment::SetLoopPoints, COMDAT

; 2110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2111 : #ifdef DXAPI
; 2112 : 	if( (mtStart < 0) || (mtEnd > m_mtLength) || (mtStart > mtEnd) )
; 2113 : 	{
; 2114 :         Trace(1,"Error: Unable to set loop points %ld, %ld because they are not within the range of the segment, which is %ld.\n",
; 2115 :             mtStart,mtStart,mtEnd,m_mtLength);
; 2116 : 		return DMUS_E_OUT_OF_RANGE;
; 2117 : 	}
; 2118 : 
; 2119 :     if (m_fZombie)
; 2120 : 	{
; 2121 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetLoopPoints after the segment has been garbage collected.\n");
; 2122 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2123 : 	}
; 2124 : #endif
; 2125 : 	m_mtLoopStart = mtStart;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  00009	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 2126 : 	m_mtLoopEnd = mtEnd;

  0000c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0000f	8b 45 10	 mov	 eax, DWORD PTR _mtEnd$[ebp]
  00012	89 42 7c	 mov	 DWORD PTR [edx+124], eax

; 2127 : 	return S_OK;

  00015	33 c0		 xor	 eax, eax

; 2128 : }

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?SetLoopPoints@CSegment@@UAGJJJ@Z ENDP			; CSegment::SetLoopPoints
_TEXT	ENDS
PUBLIC	??_C@_0EJ@DKJNJEKL@Error?3?5Bad?5call?5to?5SetPChannelsU@ ; `string'
PUBLIC	??_C@_0CB@EACKAIM@?$CFs?3?5Invalid?5pointer?5paPChannels?6@ ; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0EJ@DKJNJEKL@Error?3?5Bad?5call?5to?5SetPChannelsU@
CONST	SEGMENT
??_C@_0EJ@DKJNJEKL@Error?3?5Bad?5call?5to?5SetPChannelsU@ DB 'Error: Bad '
	DB	'call to SetPChannelsUsed, pointer to PChannel array is NULL.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetPChannelsUsed@CSegment@@UAGJKPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetPChannelsUsed@CSegment@@UAGJKPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::SetPChannelsUsed', 00H	; `CSegment::SetPChannelsUsed'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CB@EACKAIM@?$CFs?3?5Invalid?5pointer?5paPChannels?6@
CONST	SEGMENT
??_C@_0CB@EACKAIM@?$CFs?3?5Invalid?5pointer?5paPChannels?6@ DB '%s: Inval'
	DB	'id pointer paPChannels', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetPChannelsUsed@CSegment@@UAGJKPAK@Z
_TEXT	SEGMENT
$T72075 = -40
$T72074 = -36
$T72073 = -32
$T72072 = -28
$T72071 = -24
_dwCurrent$70599 = -20
_padwTemp$70589 = -16
_dwCount$70595 = -12
_dwTotalNum$70592 = -8
_paNewPChannels$70605 = -4
_this$ = 8
_dwNumPChannels$ = 12
_paPChannels$ = 16
?SetPChannelsUsed@CSegment@@UAGJKPAK@Z PROC NEAR	; CSegment::SetPChannelsUsed, COMDAT

; 2137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 2138 : 	V_INAME(IDirectMusicSegment::SetPChannelsUsed);
; 2139 : #ifdef DXAPI
; 2140 :     if (m_fZombie)
; 2141 : 	{
; 2142 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetPChannelsUsed after the segment has been garbage collected.\n");
; 2143 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2144 : 	}
; 2145 : #endif
; 2146 : 	if( dwNumPChannels )

  00007	83 7d 0c 00	 cmp	 DWORD PTR _dwNumPChannels$[ebp], 0
  0000b	0f 84 de 01 00
	00		 je	 $L70582

; 2147 : 	{
; 2148 : 		if( NULL == paPChannels )

  00011	83 7d 10 00	 cmp	 DWORD PTR _paPChannels$[ebp], 0
  00015	75 19		 jne	 SHORT $L70583

; 2149 : 		{
; 2150 :             Trace(1,"Error: Bad call to SetPChannelsUsed, pointer to PChannel array is NULL.\n");

  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EJ@DKJNJEKL@Error?3?5Bad?5call?5to?5SetPChannelsU@
  0001c	6a 01		 push	 1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 08	 add	 esp, 8

; 2151 : 			return E_INVALIDARG;

  00026	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002b	e9 c1 01 00 00	 jmp	 $L70579
$L70583:

; 2152 : 		}
; 2153 : 		V_BUFPTR_READ(paPChannels, sizeof(DWORD)*dwNumPChannels);

  00030	8b 45 0c	 mov	 eax, DWORD PTR _dwNumPChannels$[ebp]
  00033	c1 e0 02	 shl	 eax, 2
  00036	50		 push	 eax
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _paPChannels$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00040	85 c0		 test	 eax, eax
  00042	74 19		 je	 SHORT $L70587
  00044	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetPChannelsUsed@CSegment@@UAGJKPAK@Z@4QBDB
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EACKAIM@?$CFs?3?5Invalid?5pointer?5paPChannels?6@
  0004e	6a ff		 push	 -1
  00050	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	e8 00 00 00 00	 call	 _DebugBreak@0
$L70587:

; 2154 : 
; 2155 : 		DWORD* padwTemp = new DWORD[dwNumPChannels]; // temp array

  0005d	8b 55 0c	 mov	 edx, DWORD PTR _dwNumPChannels$[ebp]
  00060	c1 e2 02	 shl	 edx, 2
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00069	83 c4 04	 add	 esp, 4
  0006c	89 45 e8	 mov	 DWORD PTR $T72071[ebp], eax
  0006f	8b 45 e8	 mov	 eax, DWORD PTR $T72071[ebp]
  00072	89 45 f0	 mov	 DWORD PTR _padwTemp$70589[ebp], eax

; 2156 : 		DWORD dwTotalNum = 0;

  00075	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwTotalNum$70592[ebp], 0

; 2157 : 		if( NULL == padwTemp )

  0007c	83 7d f0 00	 cmp	 DWORD PTR _padwTemp$70589[ebp], 0
  00080	75 0a		 jne	 SHORT $L70593

; 2158 : 		{
; 2159 : 			return E_OUTOFMEMORY;

  00082	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00087	e9 65 01 00 00	 jmp	 $L70579
$L70593:

; 2160 : 		}
; 2161 : 		// count the number of unique PChannels are in the array. That is, the ones
; 2162 : 		// that we don't already have stored.
; 2163 : 		DWORD dwCount;
; 2164 : 		for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )

  0008c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwCount$70595[ebp], 0
  00093	eb 09		 jmp	 SHORT $L70596
$L70597:
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _dwCount$70595[ebp]
  00098	83 c1 01	 add	 ecx, 1
  0009b	89 4d f4	 mov	 DWORD PTR _dwCount$70595[ebp], ecx
$L70596:
  0009e	8b 55 f4	 mov	 edx, DWORD PTR _dwCount$70595[ebp]
  000a1	3b 55 0c	 cmp	 edx, DWORD PTR _dwNumPChannels$[ebp]
  000a4	73 69		 jae	 SHORT $L70598

; 2165 : 		{
; 2166 : 			DWORD dwCurrent;
; 2167 : 			for( dwCurrent = 0; dwCurrent < m_dwNumPChannels; dwCurrent++ )

  000a6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwCurrent$70599[ebp], 0
  000ad	eb 09		 jmp	 SHORT $L70600
$L70601:
  000af	8b 45 ec	 mov	 eax, DWORD PTR _dwCurrent$70599[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 ec	 mov	 DWORD PTR _dwCurrent$70599[ebp], eax
$L70600:
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 55 ec	 mov	 edx, DWORD PTR _dwCurrent$70599[ebp]
  000be	3b 91 80 00 00
	00		 cmp	 edx, DWORD PTR [ecx+128]
  000c4	73 1e		 jae	 SHORT $L70602

; 2168 : 			{
; 2169 : 				if( m_paPChannels[dwCurrent] == paPChannels[dwCount] )

  000c6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000cf	8b 55 ec	 mov	 edx, DWORD PTR _dwCurrent$70599[ebp]
  000d2	8b 45 f4	 mov	 eax, DWORD PTR _dwCount$70595[ebp]
  000d5	8b 75 10	 mov	 esi, DWORD PTR _paPChannels$[ebp]
  000d8	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  000db	3b 0c 86	 cmp	 ecx, DWORD PTR [esi+eax*4]
  000de	75 02		 jne	 SHORT $L70603

; 2170 : 				{
; 2171 : 					// we already track this one
; 2172 : 					break;

  000e0	eb 02		 jmp	 SHORT $L70602
$L70603:

; 2173 : 				}
; 2174 : 			}

  000e2	eb cb		 jmp	 SHORT $L70601
$L70602:

; 2175 : 			if( dwCurrent >= m_dwNumPChannels )

  000e4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	8b 45 ec	 mov	 eax, DWORD PTR _dwCurrent$70599[ebp]
  000ea	3b 82 80 00 00
	00		 cmp	 eax, DWORD PTR [edx+128]
  000f0	72 1b		 jb	 SHORT $L70604

; 2176 : 			{
; 2177 : 				// we're not already tracking this one
; 2178 : 				padwTemp[dwTotalNum] = paPChannels[dwCount];

  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _dwTotalNum$70592[ebp]
  000f5	8b 55 f0	 mov	 edx, DWORD PTR _padwTemp$70589[ebp]
  000f8	8b 45 f4	 mov	 eax, DWORD PTR _dwCount$70595[ebp]
  000fb	8b 75 10	 mov	 esi, DWORD PTR _paPChannels$[ebp]
  000fe	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00101	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 2179 : 				dwTotalNum++;

  00104	8b 4d f8	 mov	 ecx, DWORD PTR _dwTotalNum$70592[ebp]
  00107	83 c1 01	 add	 ecx, 1
  0010a	89 4d f8	 mov	 DWORD PTR _dwTotalNum$70592[ebp], ecx
$L70604:

; 2180 : 			}
; 2181 : 		}

  0010d	eb 86		 jmp	 SHORT $L70597
$L70598:

; 2182 : 		// dwTotalNum equals the total number of new PChannels, and they are indexed
; 2183 : 		// inside adwTemp.
; 2184 : 		DWORD* paNewPChannels = new DWORD[m_dwNumPChannels + dwTotalNum];

  0010f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00112	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  00118	03 45 f8	 add	 eax, DWORD PTR _dwTotalNum$70592[ebp]
  0011b	c1 e0 02	 shl	 eax, 2
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00124	83 c4 04	 add	 esp, 4
  00127	89 45 e4	 mov	 DWORD PTR $T72072[ebp], eax
  0012a	8b 4d e4	 mov	 ecx, DWORD PTR $T72072[ebp]
  0012d	89 4d fc	 mov	 DWORD PTR _paNewPChannels$70605[ebp], ecx

; 2185 : 		if( NULL == paNewPChannels )

  00130	83 7d fc 00	 cmp	 DWORD PTR _paNewPChannels$70605[ebp], 0
  00134	75 1c		 jne	 SHORT $L70608

; 2186 : 		{
; 2187 : 			delete [] padwTemp;

  00136	8b 55 f0	 mov	 edx, DWORD PTR _padwTemp$70589[ebp]
  00139	89 55 e0	 mov	 DWORD PTR $T72073[ebp], edx
  0013c	8b 45 e0	 mov	 eax, DWORD PTR $T72073[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00145	83 c4 04	 add	 esp, 4

; 2188 : 			return E_OUTOFMEMORY;

  00148	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0014d	e9 9f 00 00 00	 jmp	 $L70579
$L70608:

; 2189 : 		}
; 2190 : 		if( m_paPChannels )

  00152	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	83 b9 84 00 00
	00 00		 cmp	 DWORD PTR [ecx+132], 0
  0015c	74 3b		 je	 SHORT $L70611

; 2191 : 		{
; 2192 : 			memcpy( paNewPChannels, m_paPChannels, sizeof(DWORD) * m_dwNumPChannels );

  0015e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00161	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  00167	c1 e0 02	 shl	 eax, 2
  0016a	50		 push	 eax
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00174	52		 push	 edx
  00175	8b 45 fc	 mov	 eax, DWORD PTR _paNewPChannels$70605[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _memcpy
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2193 : 			delete [] m_paPChannels;

  00181	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0018a	89 55 dc	 mov	 DWORD PTR $T72074[ebp], edx
  0018d	8b 45 dc	 mov	 eax, DWORD PTR $T72074[ebp]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00196	83 c4 04	 add	 esp, 4
$L70611:

; 2194 : 		}
; 2195 : 		memcpy( &paNewPChannels[m_dwNumPChannels], padwTemp, sizeof(DWORD) * dwTotalNum );

  00199	8b 4d f8	 mov	 ecx, DWORD PTR _dwTotalNum$70592[ebp]
  0019c	c1 e1 02	 shl	 ecx, 2
  0019f	51		 push	 ecx
  001a0	8b 55 f0	 mov	 edx, DWORD PTR _padwTemp$70589[ebp]
  001a3	52		 push	 edx
  001a4	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  001ad	8b 55 fc	 mov	 edx, DWORD PTR _paNewPChannels$70605[ebp]
  001b0	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _memcpy
  001b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2196 : 		delete [] padwTemp;

  001bc	8b 4d f0	 mov	 ecx, DWORD PTR _padwTemp$70589[ebp]
  001bf	89 4d d8	 mov	 DWORD PTR $T72075[ebp], ecx
  001c2	8b 55 d8	 mov	 edx, DWORD PTR $T72075[ebp]
  001c5	52		 push	 edx
  001c6	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001cb	83 c4 04	 add	 esp, 4

; 2197 : 		m_dwNumPChannels += dwTotalNum;

  001ce	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  001d7	03 4d f8	 add	 ecx, DWORD PTR _dwTotalNum$70592[ebp]
  001da	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001dd	89 8a 80 00 00
	00		 mov	 DWORD PTR [edx+128], ecx

; 2198 : 		m_paPChannels = paNewPChannels;

  001e3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	8b 4d fc	 mov	 ecx, DWORD PTR _paNewPChannels$70605[ebp]
  001e9	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx
$L70582:

; 2199 : 	}
; 2200 : 	return S_OK;

  001ef	33 c0		 xor	 eax, eax
$L70579:

; 2201 : }

  001f1	5e		 pop	 esi
  001f2	8b e5		 mov	 esp, ebp
  001f4	5d		 pop	 ebp
  001f5	c2 0c 00	 ret	 12			; 0000000cH
?SetPChannelsUsed@CSegment@@UAGJKPAK@Z ENDP		; CSegment::SetPChannelsUsed
_TEXT	ENDS
PUBLIC	?CheckNotification@CSegment@@QAEJABU_GUID@@@Z	; CSegment::CheckNotification
; Function compile flags: /Odt
;	COMDAT ?CheckNotification@CSegment@@QAEJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -4
_rguid$ = 8
?CheckNotification@CSegment@@QAEJABU_GUID@@@Z PROC NEAR	; CSegment::CheckNotification, COMDAT
; _this$ = ecx

; 2219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2220 : 	if( NULL == FindNotification( rguid ) )

  00007	8b 45 08	 mov	 eax, DWORD PTR _rguid$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?FindNotification@CSegment@@QAEPAVCNotificationItem@@ABU_GUID@@@Z ; CSegment::FindNotification
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $L70621

; 2221 : 	{
; 2222 : 		return S_FALSE;

  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	eb 02		 jmp	 SHORT $L70620
$L70621:

; 2223 : 	}
; 2224 : 	return S_OK;

  0001e	33 c0		 xor	 eax, eax
$L70620:

; 2225 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?CheckNotification@CSegment@@QAEJABU_GUID@@@Z ENDP	; CSegment::CheckNotification
_TEXT	ENDS
PUBLIC	??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@ ; `string'
EXTRN	_CLSID_DirectMusicSegment:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??GetClassID@CSegment@@UAGJPAU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetClassID@CSegment@@UAGJPAU_GUID@@@Z@4QBDB DB 'C'
	DB	'Segment::GetClassID', 00H			; `CSegment::GetClassID'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
CONST	SEGMENT
??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pClassID', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetClassID@CSegment@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_pClassID$ = 12
?GetClassID@CSegment@@UAGJPAU_GUID@@@Z PROC NEAR	; CSegment::GetClassID, COMDAT

; 2231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2232 : 	V_INAME(CSegment::GetClassID);
; 2233 : 	V_PTR_WRITE(pClassID, CLSID); 

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pClassID$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70631
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClassID@CSegment@@UAGJPAU_GUID@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70631:

; 2234 : #ifdef DXAPI
; 2235 :     if (m_fZombie)
; 2236 : 	{
; 2237 : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetClassID after the segment has been garbage collected.\n");
; 2238 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2239 : 	}
; 2240 : #endif
; 2241 : 	*pClassID = CLSID_DirectMusicSegment;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pClassID$[ebp]
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSegment
  00034	89 11		 mov	 DWORD PTR [ecx], edx
  00036	a1 04 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSegment+4
  0003b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSegment+8
  00044	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00047	a1 0c 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSegment+12
  0004c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2242 : 	return S_OK;

  0004f	33 c0		 xor	 eax, eax

; 2243 : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?GetClassID@CSegment@@UAGJPAU_GUID@@@Z ENDP		; CSegment::GetClassID
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsDirty@CSegment@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?IsDirty@CSegment@@UAGJXZ PROC NEAR			; CSegment::IsDirty, COMDAT

; 2249 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2250 : #ifdef DXAPI
; 2251 :     if (m_fZombie)
; 2252 : 	{
; 2253 : 		Trace(2, "Warning: Call of IDirectMusicSegment::IsDirty after the segment has been garbage collected.\n");
; 2254 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2255 : 	}
; 2256 : #endif
; 2257 : 	return S_FALSE;

  00003	b8 01 00 00 00	 mov	 eax, 1

; 2258 : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?IsDirty@CSegment@@UAGJXZ ENDP				; CSegment::IsDirty
_TEXT	ENDS
PUBLIC	??_C@_0FH@MFHKEMPP@Error?3?5Segment?5unable?5to?5parse?5f@ ; `string'
PUBLIC	?LoadDirectMusicSegment@CSegment@@QAEJPAUIStream@@@Z ; CSegment::LoadDirectMusicSegment
PUBLIC	??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@ ; `string'
EXTRN	_CLSID_DirectMusicWaveTrack:BYTE
EXTRN	_IID_IDirectMusicTrack:BYTE
EXTRN	_IID_IPrivateWaveTrack:BYTE
EXTRN	__allmul:NEAR
EXTRN	_CLSID_DirectSoundWave:BYTE
EXTRN	_IID_IDirectMusicGetLoader:BYTE
EXTRN	_IID_IDirectSoundWave:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??Load@CSegment@@UAGJPAUIStream@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Load@CSegment@@UAGJPAUIStream@@@Z@4QBDB DB 'C'
	DB	'Segment::Load', 00H				; `CSegment::Load'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
CONST	SEGMENT
??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pIStream', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@MFHKEMPP@Error?3?5Segment?5unable?5to?5parse?5f@
CONST	SEGMENT
??_C@_0FH@MFHKEMPP@Error?3?5Segment?5unable?5to?5parse?5f@ DB 'Error: Seg'
	DB	'ment unable to parse file. Must be segment, midi, wave, or rm'
	DB	'i file format.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CSegment@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT
_rt$70737 = -928
_pPrivateWave$70733 = -916
_pWaveTrack$70727 = -912
_pObject$70722 = -908
_descWave$70711 = -904
_pGetLoader$70713 = -52
_pLoader$70712 = -48
_pIPS$70704 = -44
_pWave$70697 = -40
_lFileLength$70672 = -36
_li$ = -32
_hr$ = -24
_dwRead$ = -20
_ul$ = -16
_dwSavedPos$ = -8
_type$ = -4
_this$ = 8
_pIStream$ = 12
?Load@CSegment@@UAGJPAUIStream@@@Z PROC NEAR		; CSegment::Load, COMDAT

; 2266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 03 00
	00		 sub	 esp, 928		; 000003a0H

; 2267 : 	V_INAME(CSegment::Load);
; 2268 : 	V_INTERFACE(pIStream);

  00009	6a 04		 push	 4
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $L70645
  00018	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CSegment@@UAGJPAUIStream@@@Z@4QBDB
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00022	6a ff		 push	 -1
  00024	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	e8 00 00 00 00	 call	 _DebugBreak@0
$L70645:
  00031	6a 04		 push	 4
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003e	85 c0		 test	 eax, eax
  00040	74 19		 je	 SHORT $L70648
  00042	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CSegment@@UAGJPAUIStream@@@Z@4QBDB
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  0004c	6a ff		 push	 -1
  0004e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	e8 00 00 00 00	 call	 _DebugBreak@0
$L70648:
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00068	85 c0		 test	 eax, eax
  0006a	74 19		 je	 SHORT $L70650
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CSegment@@UAGJPAUIStream@@@Z@4QBDB
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00076	6a ff		 push	 -1
  00078	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	e8 00 00 00 00	 call	 _DebugBreak@0
$L70650:

; 2269 : #ifdef DXAPI
; 2270 :     if (m_fZombie)
; 2271 : 	{
; 2272 : 		Trace(2, "Warning: Call of IDirectMusicSegment::Load after the segment has been garbage collected.\n");
; 2273 : 		return DMUS_S_GARBAGE_COLLECTED;
; 2274 : 	}
; 2275 : #endif
; 2276 : 	// Save stream's current position
; 2277 : 	LARGE_INTEGER li;
; 2278 :     ULARGE_INTEGER ul;
; 2279 : 
; 2280 :     li.HighPart = 0;

  00085	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 2281 :     li.LowPart = 0;

  0008c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _li$[ebp], 0

; 2282 : 
; 2283 :     HRESULT hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);

  00093	8d 45 f0	 lea	 eax, DWORD PTR _ul$[ebp]
  00096	50		 push	 eax
  00097	6a 01		 push	 1
  00099	8b 4d e4	 mov	 ecx, DWORD PTR _li$[ebp+4]
  0009c	51		 push	 ecx
  0009d	8b 55 e0	 mov	 edx, DWORD PTR _li$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  000a9	52		 push	 edx
  000aa	ff 51 14	 call	 DWORD PTR [ecx+20]
  000ad	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2284 :     
; 2285 : 	if(FAILED(hr))

  000b0	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	7d 08		 jge	 SHORT $L70655

; 2286 : 	{
; 2287 : 		return hr;	

  000b6	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
  000b9	e9 03 05 00 00	 jmp	 $L70641
$L70655:

; 2288 :     }
; 2289 : 	
; 2290 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  000be	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	83 c0 18	 add	 eax, 24			; 00000018H
  000c4	50		 push	 eax
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2291 :     Clear(false);

  000cb	6a 00		 push	 0
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	83 e9 04	 sub	 ecx, 4
  000d3	e8 00 00 00 00	 call	 ?Clear@CSegment@@QAEX_N@Z ; CSegment::Clear

; 2292 : 
; 2293 : 	DWORD dwSavedPos = ul.LowPart;

  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _ul$[ebp]
  000db	89 4d f8	 mov	 DWORD PTR _dwSavedPos$[ebp], ecx

; 2294 :     
; 2295 : 	// Read first 4 bytes to determine what type of stream we
; 2296 : 	// have been passed
; 2297 : 
; 2298 : 	FOURCC type;
; 2299 : 	DWORD dwRead;
; 2300 : 	hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

  000de	8d 55 ec	 lea	 edx, DWORD PTR _dwRead$[ebp]
  000e1	52		 push	 edx
  000e2	6a 04		 push	 4
  000e4	8d 45 fc	 lea	 eax, DWORD PTR _type$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  000eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ed	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  000f0	50		 push	 eax
  000f1	ff 52 0c	 call	 DWORD PTR [edx+12]
  000f4	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2301 : 	
; 2302 : 	if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))

  000f7	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fb	0f 8c 8c 04 00
	00		 jl	 $L70662
  00101	83 7d ec 04	 cmp	 DWORD PTR _dwRead$[ebp], 4
  00105	0f 85 82 04 00
	00		 jne	 $L70662

; 2303 : 	{
; 2304 : 		// Check for a RIFF file
; 2305 : 		if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))

  0010b	81 7d fc 52 49
	46 46		 cmp	 DWORD PTR _type$[ebp], 1179011410 ; 46464952H
  00112	0f 85 5d 04 00
	00		 jne	 $L70671

; 2306 : 		{
; 2307 :             long lFileLength = 0;

  00118	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _lFileLength$70672[ebp], 0

; 2308 :             pIStream->Read(&lFileLength, sizeof(long), &dwRead);

  0011f	8d 4d ec	 lea	 ecx, DWORD PTR _dwRead$[ebp]
  00122	51		 push	 ecx
  00123	6a 04		 push	 4
  00125	8d 55 dc	 lea	 edx, DWORD PTR _lFileLength$70672[ebp]
  00128	52		 push	 edx
  00129	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0012c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012e	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00131	52		 push	 edx
  00132	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 2309 : 			// Check to see if what type of RIFF file we have
; 2310 : 			hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

  00135	8d 45 ec	 lea	 eax, DWORD PTR _dwRead$[ebp]
  00138	50		 push	 eax
  00139	6a 04		 push	 4
  0013b	8d 4d fc	 lea	 ecx, DWORD PTR _type$[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00142	8b 02		 mov	 eax, DWORD PTR [edx]
  00144	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00147	51		 push	 ecx
  00148	ff 50 0c	 call	 DWORD PTR [eax+12]
  0014b	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2311 : 
; 2312 : 			if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))

  0014e	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00152	0f 8c 14 04 00
	00		 jl	 $L70677
  00158	83 7d ec 04	 cmp	 DWORD PTR _dwRead$[ebp], 4
  0015c	0f 85 0a 04 00
	00		 jne	 $L70677

; 2313 : 			{
; 2314 : 				if(type == DMUS_FOURCC_SEGMENT_FORM)	// We have a DirectMusic segment

  00162	81 7d fc 44 4d
	53 47		 cmp	 DWORD PTR _type$[ebp], 1196641604 ; 47534d44H
  00169	75 3f		 jne	 SHORT $L70686

; 2315 : 				{
; 2316 : 					// Since we now know what type of stream we need to 
; 2317 : 					// seek back to saved position
; 2318 : 					li.HighPart = 0;

  0016b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 2319 : 					li.LowPart = dwSavedPos;

  00172	8b 55 f8	 mov	 edx, DWORD PTR _dwSavedPos$[ebp]
  00175	89 55 e0	 mov	 DWORD PTR _li$[ebp], edx

; 2320 : 					hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

  00178	6a 00		 push	 0
  0017a	6a 00		 push	 0
  0017c	8b 45 e4	 mov	 eax, DWORD PTR _li$[ebp+4]
  0017f	50		 push	 eax
  00180	8b 4d e0	 mov	 ecx, DWORD PTR _li$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00187	8b 02		 mov	 eax, DWORD PTR [edx]
  00189	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0018c	51		 push	 ecx
  0018d	ff 50 14	 call	 DWORD PTR [eax+20]
  00190	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2321 : 
; 2322 : 					hr = LoadDirectMusicSegment(pIStream);

  00193	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00196	52		 push	 edx
  00197	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	83 e9 04	 sub	 ecx, 4
  0019d	e8 00 00 00 00	 call	 ?LoadDirectMusicSegment@CSegment@@QAEJPAUIStream@@@Z ; CSegment::LoadDirectMusicSegment
  001a2	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2323 : 				}
; 2324 : #ifdef DXAPI
; 2325 : 				else if(type == FOURCC_SECTION_FORM)	// We have section
; 2326 : 				{
; 2327 : 					// Since we now know what type of stream we need to seek back to saved position
; 2328 : 					li.HighPart = 0;
; 2329 : 					li.LowPart = dwSavedPos;
; 2330 : 					hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);
; 2331 : 					
; 2332 : 					// Create Section
; 2333 : 					IDMSection* pSection;
; 2334 : 					if(SUCCEEDED(hr))
; 2335 : 					{
; 2336 : 						hr = DirectMusicCreateInstance(CLSID_DMSection,
; 2337 : 												NULL,
; 2338 : 												IID_IDMSection,
; 2339 : 												(void**)&pSection);
; 2340 : 					}
; 2341 : 
; 2342 : 					if(SUCCEEDED(hr))
; 2343 : 					{
; 2344 : 						// Load Section
; 2345 : 						IPersistStream* pIPersistStream;
; 2346 : 						hr = pSection->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
; 2347 : 								
; 2348 : 						if(SUCCEEDED(hr))
; 2349 : 						{
; 2350 : 							hr = pIPersistStream->Load(pIStream);
; 2351 : 							pIPersistStream->Release();
; 2352 : 						}
; 2353 : 
; 2354 : 						if(SUCCEEDED(hr))
; 2355 : 						{
; 2356 : 							HRESULT hrTemp = pSection->CreateSegment(static_cast<IDirectMusicSegment*>(this));
; 2357 : 							if (hrTemp != S_OK)
; 2358 : 							{
; 2359 : 								hr = hrTemp;
; 2360 : 							}
; 2361 : 						}
; 2362 : 						
; 2363 : 						pSection->Release();
; 2364 : 					}
; 2365 : 				}
; 2366 : 				else if(type == DMUS_FOURCC_RMID_FORM)	// We have an RMID MIDI file
; 2367 : 				{ 
; 2368 :                     IDirectMusicCollection *pCollection = NULL;
; 2369 :                     BOOL fLoadedMIDI = FALSE;
; 2370 :                     // Since it's a RIFF file, it could have more than one top level chunk.
; 2371 :                     while (SUCCEEDED(hr) && (lFileLength > 8))
; 2372 :                     {
; 2373 : 					    FOURCC dwType = 0;	
; 2374 : 					    DWORD dwRead;
; 2375 :                         DWORD dwLength;
; 2376 : 					    pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
; 2377 :                         hr = pIStream->Read(&dwLength, sizeof(DWORD), &dwRead);
; 2378 :                         lFileLength -= 8;
; 2379 :                         if (FAILED(hr))
; 2380 :                         {
; 2381 :                             break;
; 2382 :                         }
; 2383 :                         ULARGE_INTEGER ulPosition;  // Memorize start of chunk.
; 2384 :                         LARGE_INTEGER liStart;
; 2385 :                         liStart.QuadPart = 0;
; 2386 :                         hr = pIStream->Seek(liStart, STREAM_SEEK_CUR, &ulPosition);
; 2387 :                         liStart.QuadPart = ulPosition.QuadPart;
; 2388 :                         if (dwType == DMUS_FOURCC_data_FORM)
; 2389 :                         {   // Get MIDI file header.
; 2390 : 					        hr = pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
; 2391 : 					        if(SUCCEEDED(hr) && (dwType == mmioFOURCC( 'M', 'T', 'h', 'd' )))
; 2392 : 						    {
; 2393 : 							    // Since we now know what type of stream we need to seek back to saved position
; 2394 : 							    hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
; 2395 : 
; 2396 : 							    if(SUCCEEDED(hr))
; 2397 : 							    {
; 2398 : 								    hr = CreateSegmentFromMIDIStream(pIStream, 
; 2399 : 				 												     static_cast<IDirectMusicSegment*>(this));
; 2400 : 							    }
; 2401 :                                 if (SUCCEEDED(hr)) fLoadedMIDI = TRUE;
; 2402 : 						    }
; 2403 :                         }
; 2404 :                         else if ((dwType == mmioFOURCC( 'R', 'I', 'F', 'F' ) ||
; 2405 :                             (dwType == mmioFOURCC( 'L', 'I', 'S', 'T' ))))
; 2406 :                         {
; 2407 :                             pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
; 2408 :                             if (dwType == DMUS_FOURCC_DLS_FORM)
; 2409 :                             {
; 2410 :                                 hr = DirectMusicCreateInstance(CLSID_DirectMusicCollection,
; 2411 : 										NULL,
; 2412 : 										IID_IDirectMusicCollection,
; 2413 : 										(void**)&pCollection);
; 2414 :                                 if (SUCCEEDED(hr))
; 2415 :                                 {
; 2416 :                                     IPersistStream* pIPS;
; 2417 : 				                    hr = pCollection->QueryInterface( IID_IPersistStream, (void**)&pIPS );
; 2418 : 				                    if (SUCCEEDED(hr))
; 2419 : 				                    {
; 2420 :             							// We need to seek back to start of chunk
; 2421 :                                         liStart.QuadPart -= 8;
; 2422 : 							            pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
; 2423 : 
; 2424 : 					                    hr = pIPS->Load( pIStream );
; 2425 : 					                    pIPS->Release();
; 2426 :                                     }
; 2427 :                                     if (FAILED(hr))
; 2428 :                                     {
; 2429 :                                         pCollection->Release();
; 2430 :                                         pCollection = NULL;
; 2431 :                                     }
; 2432 :                                 }
; 2433 :                             }
; 2434 :                         }
; 2435 :                         if (SUCCEEDED(hr))
; 2436 :                         {
; 2437 :                             if (dwLength & 1) ++dwLength;
; 2438 :                             ulPosition.QuadPart += dwLength; // Point to start of next chunk.
; 2439 :                             liStart.QuadPart = ulPosition.QuadPart;
; 2440 :                             hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
; 2441 :                             lFileLength -= dwLength; // Decrement amount left in file.
; 2442 :                         }
; 2443 :                     }
; 2444 :                     if (pCollection)
; 2445 :                     {
; 2446 :                         if (fLoadedMIDI)
; 2447 :                         {
; 2448 :                             SetParam(GUID_ConnectToDLSCollection,-1,0,0,(void *) pCollection);
; 2449 :                         }
; 2450 :                         pCollection->Release();
; 2451 :                     }
; 2452 :                 }
; 2453 : #endif
; 2454 :                 else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file

  001a5	e9 c0 03 00 00	 jmp	 $L70687
$L70686:
  001aa	81 7d fc 57 41
	56 45		 cmp	 DWORD PTR _type$[ebp], 1163280727 ; 45564157H
  001b1	0f 85 b3 03 00
	00		 jne	 $L70687

; 2455 :                 {
; 2456 :                     IDirectSoundWave* pWave = NULL;

  001b7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pWave$70697[ebp], 0

; 2457 :                     // Seek back to saved position
; 2458 :                     li.HighPart = 0;

  001be	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 2459 :                     li.LowPart = dwSavedPos;

  001c5	8b 45 f8	 mov	 eax, DWORD PTR _dwSavedPos$[ebp]
  001c8	89 45 e0	 mov	 DWORD PTR _li$[ebp], eax

; 2460 :                     hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

  001cb	6a 00		 push	 0
  001cd	6a 00		 push	 0
  001cf	8b 4d e4	 mov	 ecx, DWORD PTR _li$[ebp+4]
  001d2	51		 push	 ecx
  001d3	8b 55 e0	 mov	 edx, DWORD PTR _li$[ebp]
  001d6	52		 push	 edx
  001d7	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  001da	8b 08		 mov	 ecx, DWORD PTR [eax]
  001dc	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  001df	52		 push	 edx
  001e0	ff 51 14	 call	 DWORD PTR [ecx+20]
  001e3	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2461 : 
; 2462 :                     // Check to see if this wave is embedded
; 2463 :                     if (dwSavedPos == 0)

  001e6	83 7d f8 00	 cmp	 DWORD PTR _dwSavedPos$[ebp], 0
  001ea	0f 85 85 00 00
	00		 jne	 $L70698

; 2464 :                     {
; 2465 :                         // CoCreate the wave and load it from the stream
; 2466 :                         if (SUCCEEDED(hr))

  001f0	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001f4	7c 7a		 jl	 SHORT $L70700

; 2467 :                         {
; 2468 :                             hr = DirectMusicCreateInstance(CLSID_DirectSoundWave,
; 2469 :                                     NULL,
; 2470 :                                     IID_IDirectSoundWave,
; 2471 :                                     (void**)&pWave);

  001f6	8d 45 d8	 lea	 eax, DWORD PTR _pWave$70697[ebp]
  001f9	50		 push	 eax
  001fa	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectSoundWave
  001ff	6a 00		 push	 0
  00201	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectSoundWave
  00206	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
  0020b	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2472 : 
; 2473 :                             if (SUCCEEDED(hr))

  0020e	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00212	7c 5c		 jl	 SHORT $L70700

; 2474 :                             {
; 2475 :                                 IPersistStream* pIPS = NULL;

  00214	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pIPS$70704[ebp], 0

; 2476 : 
; 2477 :                                 hr = pWave->QueryInterface(IID_IPersistStream, (void**)&pIPS);

  0021b	8d 4d d4	 lea	 ecx, DWORD PTR _pIPS$70704[ebp]
  0021e	51		 push	 ecx
  0021f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  00224	8b 55 d8	 mov	 edx, DWORD PTR _pWave$70697[ebp]
  00227	8b 02		 mov	 eax, DWORD PTR [edx]
  00229	8b 4d d8	 mov	 ecx, DWORD PTR _pWave$70697[ebp]
  0022c	51		 push	 ecx
  0022d	ff 10		 call	 DWORD PTR [eax]
  0022f	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2478 :                                 if (SUCCEEDED(hr))

  00232	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00236	7c 1f		 jl	 SHORT $L70707

; 2479 :                                 {
; 2480 :                                     hr = pIPS->Load( pIStream );

  00238	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  0023b	52		 push	 edx
  0023c	8b 45 d4	 mov	 eax, DWORD PTR _pIPS$70704[ebp]
  0023f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00241	8b 55 d4	 mov	 edx, DWORD PTR _pIPS$70704[ebp]
  00244	52		 push	 edx
  00245	ff 51 14	 call	 DWORD PTR [ecx+20]
  00248	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2481 :                                     pIPS->Release();

  0024b	8b 45 d4	 mov	 eax, DWORD PTR _pIPS$70704[ebp]
  0024e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00250	8b 55 d4	 mov	 edx, DWORD PTR _pIPS$70704[ebp]
  00253	52		 push	 edx
  00254	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70707:

; 2482 :                                 }
; 2483 : 
; 2484 :                                 if (FAILED(hr))

  00257	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0025b	7d 13		 jge	 SHORT $L70700

; 2485 :                                 {
; 2486 :                                     pWave->Release();

  0025d	8b 45 d8	 mov	 eax, DWORD PTR _pWave$70697[ebp]
  00260	8b 08		 mov	 ecx, DWORD PTR [eax]
  00262	8b 55 d8	 mov	 edx, DWORD PTR _pWave$70697[ebp]
  00265	52		 push	 edx
  00266	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2487 :                                     pWave = NULL;

  00269	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pWave$70697[ebp], 0
$L70700:

; 2488 :                                 }
; 2489 :                             }
; 2490 :                         }
; 2491 :                     }
; 2492 :                     else

  00270	e9 9b 01 00 00	 jmp	 $L70710
$L70698:

; 2493 :                     {
; 2494 :                         // Have the loader load the wave object from the stream
; 2495 :                         DMUS_OBJECTDESC descWave;
; 2496 :                         ZeroMemory(&descWave, sizeof(descWave));

  00275	68 50 03 00 00	 push	 848			; 00000350H
  0027a	6a 00		 push	 0
  0027c	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR _descWave$70711[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 _memset
  00288	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2497 :                         descWave.dwSize = sizeof(descWave);

  0028b	c7 85 78 fc ff
	ff 50 03 00 00	 mov	 DWORD PTR _descWave$70711[ebp], 848 ; 00000350H

; 2498 :                         descWave.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;

  00295	c7 85 7c fc ff
	ff 02 08 00 00	 mov	 DWORD PTR _descWave$70711[ebp+4], 2050 ; 00000802H

; 2499 :                         descWave.guidClass = CLSID_DirectSoundWave;

  0029f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectSoundWave
  002a5	89 8d 90 fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+24], ecx
  002ab	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectSoundWave+4
  002b1	89 95 94 fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+28], edx
  002b7	a1 08 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectSoundWave+8
  002bc	89 85 98 fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+32], eax
  002c2	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectSoundWave+12
  002c8	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+36], ecx

; 2500 :                         descWave.pStream = pIStream;

  002ce	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  002d1	89 55 c4	 mov	 DWORD PTR _descWave$70711[ebp+844], edx

; 2501 :                         IDirectMusicLoader *pLoader = NULL;

  002d4	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pLoader$70712[ebp], 0

; 2502 :                         IDirectMusicGetLoader *pGetLoader = NULL;

  002db	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _pGetLoader$70713[ebp], 0

; 2503 :                         hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pGetLoader);

  002e2	8d 45 cc	 lea	 eax, DWORD PTR _pGetLoader$70713[ebp]
  002e5	50		 push	 eax
  002e6	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGetLoader
  002eb	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  002f3	50		 push	 eax
  002f4	ff 12		 call	 DWORD PTR [edx]
  002f6	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2504 :                         if (SUCCEEDED(hr))

  002f9	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002fd	0f 8c 0d 01 00
	00		 jl	 $L70710

; 2505 :                         {
; 2506 :                             if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))

  00303	8d 4d d0	 lea	 ecx, DWORD PTR _pLoader$70712[ebp]
  00306	51		 push	 ecx
  00307	8b 55 cc	 mov	 edx, DWORD PTR _pGetLoader$70713[ebp]
  0030a	8b 02		 mov	 eax, DWORD PTR [edx]
  0030c	8b 4d cc	 mov	 ecx, DWORD PTR _pGetLoader$70713[ebp]
  0030f	51		 push	 ecx
  00310	ff 50 0c	 call	 DWORD PTR [eax+12]
  00313	85 c0		 test	 eax, eax
  00315	0f 8c e9 00 00
	00		 jl	 $L70718

; 2507 :                             {
; 2508 :                                 hr = pLoader->GetObject(&descWave, IID_IDirectSoundWave, (void **)&pWave);

  0031b	8d 55 d8	 lea	 edx, DWORD PTR _pWave$70697[ebp]
  0031e	52		 push	 edx
  0031f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectSoundWave
  00324	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR _descWave$70711[ebp]
  0032a	50		 push	 eax
  0032b	8b 4d d0	 mov	 ecx, DWORD PTR _pLoader$70712[ebp]
  0032e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00330	8b 45 d0	 mov	 eax, DWORD PTR _pLoader$70712[ebp]
  00333	50		 push	 eax
  00334	ff 52 0c	 call	 DWORD PTR [edx+12]
  00337	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2509 :                                 descWave.pStream = NULL;

  0033a	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _descWave$70711[ebp+844], 0

; 2510 :                                 descWave.dwValidData &= ~DMUS_OBJ_STREAM;

  00341	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR _descWave$70711[ebp+4]
  00347	81 e1 ff f7 ff
	ff		 and	 ecx, -2049		; fffff7ffH
  0034d	89 8d 7c fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+4], ecx

; 2511 :                                 if (SUCCEEDED(hr))

  00353	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00357	0f 8c 9b 00 00
	00		 jl	 $L70721

; 2512 :                                 {
; 2513 :                                     IDirectMusicObject* pObject = NULL;

  0035d	c7 85 74 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pObject$70722[ebp], 0

; 2514 :                                     hr = pWave->QueryInterface(IID_IDirectMusicObject, (void **)&pObject);

  00367	8d 95 74 fc ff
	ff		 lea	 edx, DWORD PTR _pObject$70722[ebp]
  0036d	52		 push	 edx
  0036e	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicObject
  00373	8b 45 d8	 mov	 eax, DWORD PTR _pWave$70697[ebp]
  00376	8b 08		 mov	 ecx, DWORD PTR [eax]
  00378	8b 55 d8	 mov	 edx, DWORD PTR _pWave$70697[ebp]
  0037b	52		 push	 edx
  0037c	ff 11		 call	 DWORD PTR [ecx]
  0037e	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2515 :                                     if (SUCCEEDED(hr))

  00381	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00385	7c 71		 jl	 SHORT $L70721

; 2516 :                                     {
; 2517 :                                         // set this object to be a segment with the same GUID
; 2518 :                                         pObject->GetDescriptor(&descWave);

  00387	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR _descWave$70711[ebp]
  0038d	50		 push	 eax
  0038e	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR _pObject$70722[ebp]
  00394	8b 11		 mov	 edx, DWORD PTR [ecx]
  00396	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _pObject$70722[ebp]
  0039c	50		 push	 eax
  0039d	ff 52 0c	 call	 DWORD PTR [edx+12]

; 2519 :                                         descWave.guidClass = CLSID_DirectMusicSegment;

  003a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectMusicSegment
  003a6	89 8d 90 fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+24], ecx
  003ac	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSegment+4
  003b2	89 95 94 fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+28], edx
  003b8	a1 08 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSegment+8
  003bd	89 85 98 fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+32], eax
  003c3	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectMusicSegment+12
  003c9	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _descWave$70711[ebp+36], ecx

; 2520 :                                         SetDescriptor(&descWave);

  003cf	8d 95 78 fc ff
	ff		 lea	 edx, DWORD PTR _descWave$70711[ebp]
  003d5	52		 push	 edx
  003d6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003d9	83 c0 04	 add	 eax, 4
  003dc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003df	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003e2	50		 push	 eax
  003e3	ff 52 10	 call	 DWORD PTR [edx+16]

; 2521 :                                         pObject->Release();

  003e6	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _pObject$70722[ebp]
  003ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ee	8b 95 74 fc ff
	ff		 mov	 edx, DWORD PTR _pObject$70722[ebp]
  003f4	52		 push	 edx
  003f5	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70721:

; 2522 :                                     }
; 2523 :                                 }
; 2524 :                                 pLoader->Release();

  003f8	8b 45 d0	 mov	 eax, DWORD PTR _pLoader$70712[ebp]
  003fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fd	8b 55 d0	 mov	 edx, DWORD PTR _pLoader$70712[ebp]
  00400	52		 push	 edx
  00401	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70718:

; 2525 :                             }
; 2526 :                             pGetLoader->Release();

  00404	8b 45 cc	 mov	 eax, DWORD PTR _pGetLoader$70713[ebp]
  00407	8b 08		 mov	 ecx, DWORD PTR [eax]
  00409	8b 55 cc	 mov	 edx, DWORD PTR _pGetLoader$70713[ebp]
  0040c	52		 push	 edx
  0040d	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70710:

; 2527 :                         }
; 2528 :                     }
; 2529 : 
; 2530 :                     if (pWave)

  00410	83 7d d8 00	 cmp	 DWORD PTR _pWave$70697[ebp], 0
  00414	0f 84 50 01 00
	00		 je	 $L70687

; 2531 :                     {
; 2532 : 
; 2533 : 					    // CoCreate a wave track
; 2534 : 					    IDirectMusicTrack* pWaveTrack = NULL;

  0041a	c7 85 70 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pWaveTrack$70727[ebp], 0

; 2535 : 					    if (SUCCEEDED(hr))

  00424	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00428	7c 1b		 jl	 SHORT $L70729

; 2536 : 					    {
; 2537 : 						    hr = DirectMusicCreateInstance(CLSID_DirectMusicWaveTrack,
; 2538 : 												    NULL,
; 2539 : 												    IID_IDirectMusicTrack,
; 2540 : 												    (void**)&pWaveTrack);

  0042a	8d 85 70 fc ff
	ff		 lea	 eax, DWORD PTR _pWaveTrack$70727[ebp]
  00430	50		 push	 eax
  00431	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack
  00436	6a 00		 push	 0
  00438	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicWaveTrack
  0043d	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
  00442	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
$L70729:

; 2541 : 					    }
; 2542 : 
; 2543 : 					    // Add the wave object to the wave track, and insert the track in the segment.
; 2544 : 					    if (SUCCEEDED(hr))

  00445	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00449	0f 8c ee 00 00
	00		 jl	 $L70732

; 2545 : 					    {
; 2546 : 						    IPrivateWaveTrack* pPrivateWave = NULL;

  0044f	c7 85 6c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pPrivateWave$70733[ebp], 0

; 2547 : 						    hr = pWaveTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pPrivateWave);

  00459	8d 8d 6c fc ff
	ff		 lea	 ecx, DWORD PTR _pPrivateWave$70733[ebp]
  0045f	51		 push	 ecx
  00460	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPrivateWaveTrack
  00465	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR _pWaveTrack$70727[ebp]
  0046b	8b 02		 mov	 eax, DWORD PTR [edx]
  0046d	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _pWaveTrack$70727[ebp]
  00473	51		 push	 ecx
  00474	ff 10		 call	 DWORD PTR [eax]
  00476	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2548 : 						    if (SUCCEEDED(hr))

  00479	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0047d	0f 8c ba 00 00
	00		 jl	 $L70732

; 2549 : 						    {
; 2550 : 							    REFERENCE_TIME rt = 0;

  00483	c7 85 60 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _rt$70737[ebp], 0
  0048d	c7 85 64 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _rt$70737[ebp+4], 0

; 2551 : 							    hr = pPrivateWave->AddWave(pWave, 0, 0, 0, &rt);

  00497	8d 95 60 fc ff
	ff		 lea	 edx, DWORD PTR _rt$70737[ebp]
  0049d	52		 push	 edx
  0049e	6a 00		 push	 0
  004a0	6a 00		 push	 0
  004a2	6a 00		 push	 0
  004a4	6a 00		 push	 0
  004a6	8b 45 d8	 mov	 eax, DWORD PTR _pWave$70697[ebp]
  004a9	50		 push	 eax
  004aa	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR _pPrivateWave$70733[ebp]
  004b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  004b2	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _pPrivateWave$70733[ebp]
  004b8	50		 push	 eax
  004b9	ff 52 0c	 call	 DWORD PTR [edx+12]
  004bc	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 2552 : 							    if (SUCCEEDED(hr))

  004bf	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  004c3	7c 34		 jl	 SHORT $L70739

; 2553 : 							    {
; 2554 : 								    SetClockTimeDuration(rt * REF_PER_MIL);

  004c5	6a 00		 push	 0
  004c7	68 10 27 00 00	 push	 10000			; 00002710H
  004cc	8b 8d 64 fc ff
	ff		 mov	 ecx, DWORD PTR _rt$70737[ebp+4]
  004d2	51		 push	 ecx
  004d3	8b 95 60 fc ff
	ff		 mov	 edx, DWORD PTR _rt$70737[ebp]
  004d9	52		 push	 edx
  004da	e8 00 00 00 00	 call	 __allmul
  004df	52		 push	 edx
  004e0	50		 push	 eax
  004e1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  004e4	83 e9 04	 sub	 ecx, 4
  004e7	e8 00 00 00 00	 call	 ?SetClockTimeDuration@CSegment@@QAEJ_J@Z ; CSegment::SetClockTimeDuration

; 2555 : 								    SetFlags(DMUS_SEGIOF_REFLENGTH);

  004ec	6a 01		 push	 1
  004ee	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  004f1	83 e9 04	 sub	 ecx, 4
  004f4	e8 00 00 00 00	 call	 ?SetFlags@CSegment@@QAEJK@Z ; CSegment::SetFlags
$L70739:

; 2556 : 							    }
; 2557 : 							    InsertTrack(pWaveTrack, 1);

  004f9	6a 01		 push	 1
  004fb	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _pWaveTrack$70727[ebp]
  00501	50		 push	 eax
  00502	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00505	83 e9 04	 sub	 ecx, 4
  00508	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0050b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0050e	51		 push	 ecx
  0050f	ff 50 5c	 call	 DWORD PTR [eax+92]

; 2558 : 							    SetTrackConfig(CLSID_DirectMusicWaveTrack, 1, 0, DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME,0);

  00512	6a 00		 push	 0
  00514	6a 78		 push	 120			; 00000078H
  00516	6a 00		 push	 0
  00518	6a 01		 push	 1
  0051a	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicWaveTrack
  0051f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00522	83 e9 04	 sub	 ecx, 4
  00525	51		 push	 ecx
  00526	e8 00 00 00 00	 call	 ?SetTrackConfig@CSegment@@QAGJABU_GUID@@KKKK@Z ; CSegment::SetTrackConfig

; 2559 : 							    pPrivateWave->Release();

  0052b	8b 95 6c fc ff
	ff		 mov	 edx, DWORD PTR _pPrivateWave$70733[ebp]
  00531	8b 02		 mov	 eax, DWORD PTR [edx]
  00533	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR _pPrivateWave$70733[ebp]
  00539	51		 push	 ecx
  0053a	ff 50 08	 call	 DWORD PTR [eax+8]
$L70732:

; 2560 : 						    }
; 2561 : 					    }
; 2562 : 
; 2563 : 					    // Clean up anything that's still hanging around
; 2564 : 					    if (pWaveTrack) pWaveTrack->Release();

  0053d	83 bd 70 fc ff
	ff 00		 cmp	 DWORD PTR _pWaveTrack$70727[ebp], 0
  00544	74 12		 je	 SHORT $L70740
  00546	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR _pWaveTrack$70727[ebp]
  0054c	8b 02		 mov	 eax, DWORD PTR [edx]
  0054e	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _pWaveTrack$70727[ebp]
  00554	51		 push	 ecx
  00555	ff 50 08	 call	 DWORD PTR [eax+8]
$L70740:

; 2565 : 					    if (pWave) pWave->Release();

  00558	83 7d d8 00	 cmp	 DWORD PTR _pWave$70697[ebp], 0
  0055c	74 0c		 je	 SHORT $L70687
  0055e	8b 55 d8	 mov	 edx, DWORD PTR _pWave$70697[ebp]
  00561	8b 02		 mov	 eax, DWORD PTR [edx]
  00563	8b 4d d8	 mov	 ecx, DWORD PTR _pWave$70697[ebp]
  00566	51		 push	 ecx
  00567	ff 50 08	 call	 DWORD PTR [eax+8]
$L70687:

; 2566 :                     }
; 2567 : 				}
; 2568 : 			}
; 2569 : 			else

  0056a	eb 07		 jmp	 SHORT $L70742
$L70677:

; 2570 : 			{
; 2571 : 				hr = DMUS_E_CANNOTREAD;

  0056c	c7 45 e8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70742:

; 2572 : 			}
; 2573 : 		}
; 2574 : #ifdef DXAPI
; 2575 :         // Check for a template file
; 2576 : 		else if(type == mmioFOURCC('L', 'P', 'T', 's'))
; 2577 : 		{
; 2578 : 			// Since we now know what type of stream we need to seek back to saved position
; 2579 : 			li.HighPart = 0;
; 2580 : 			li.LowPart = dwSavedPos;
; 2581 : 			hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);
; 2582 : 			
; 2583 : 			// Create Template
; 2584 : 			IDMTempl* pTemplate;
; 2585 : 			if(SUCCEEDED(hr))
; 2586 : 			{
; 2587 : 				hr = DirectMusicCreateInstance(CLSID_DMTempl,
; 2588 : 										NULL,
; 2589 : 										IID_IDMTempl,
; 2590 : 										(void**)&pTemplate);
; 2591 : 			}
; 2592 : 
; 2593 : 			if(SUCCEEDED(hr))
; 2594 : 			{
; 2595 : 				// Load Template
; 2596 : 				IPersistStream* pIPersistStream;
; 2597 : 				hr = pTemplate->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
; 2598 : 						
; 2599 : 				if(SUCCEEDED(hr))
; 2600 : 				{
; 2601 : 					hr = pIPersistStream->Load(pIStream);
; 2602 : 					pIPersistStream->Release();
; 2603 : 				}
; 2604 : 
; 2605 : 				if(SUCCEEDED(hr))
; 2606 : 				{
; 2607 : 					hr = pTemplate->CreateSegment(static_cast<IDirectMusicSegment*>(this));
; 2608 : 				}
; 2609 : 				
; 2610 : 				pTemplate->Release();
; 2611 : 			}
; 2612 : 		}		
; 2613 : 		// Check for normal MIDI file
; 2614 : 		else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
; 2615 : 	    {
; 2616 : 			// Since we now know what type of stream we need to seek back to saved position
; 2617 : 			li.HighPart = 0;
; 2618 : 			li.LowPart = dwSavedPos;
; 2619 : 			hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);
; 2620 : 
; 2621 : 			if(SUCCEEDED(hr))
; 2622 : 			{
; 2623 : 				hr = CreateSegmentFromMIDIStream(pIStream, 
; 2624 : 				 								 static_cast<IDirectMusicSegment*>(this));
; 2625 : 			}	
; 2626 : 		}
; 2627 : #endif
; 2628 : 		else

  00573	eb 16		 jmp	 SHORT $L70744
$L70671:

; 2629 : 		{
; 2630 : 			// Not a DirectMusic Segment file, MIDI file or section or 
; 2631 : 			// template; unsupported
; 2632 :             Trace(1,"Error: Segment unable to parse file. Must be segment, midi, wave, or rmi file format.\n");

  00575	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FH@MFHKEMPP@Error?3?5Segment?5unable?5to?5parse?5f@
  0057a	6a 01		 push	 1
  0057c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00581	83 c4 08	 add	 esp, 8

; 2633 : 			hr = DMUS_E_UNSUPPORTED_STREAM;

  00584	c7 45 e8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70744:

; 2634 : 		}
; 2635 : 	}
; 2636 : 	else

  0058b	eb 07		 jmp	 SHORT $L70747
$L70662:

; 2637 : 	{
; 2638 : 		hr = DMUS_E_CANNOTREAD;

  0058d	c7 45 e8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70747:

; 2639 : 	}
; 2640 : 	if( SUCCEEDED(hr) )

  00594	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00598	7c 17		 jl	 SHORT $L70750

; 2641 : 	{
; 2642 : 		m_Info.m_dwValidData |= DMUS_OBJ_LOADED;		

  0059a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0059d	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  005a3	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  005a8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  005ab	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax
$L70750:

; 2643 : 	}
; 2644 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  005b1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  005b4	83 c2 18	 add	 edx, 24			; 00000018H
  005b7	52		 push	 edx
  005b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2645 : 	return hr;

  005be	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
$L70641:

; 2646 : }

  005c1	8b e5		 mov	 esp, ebp
  005c3	5d		 pop	 ebp
  005c4	c2 08 00	 ret	 8
?Load@CSegment@@UAGJPAUIStream@@@Z ENDP			; CSegment::Load
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Save@CSegment@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT
_this$ = 8
_pIStream$ = 12
_fClearDirty$ = 16
?Save@CSegment@@UAGJPAUIStream@@H@Z PROC NEAR		; CSegment::Save, COMDAT

; 2650 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2651 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2652 : }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?Save@CSegment@@UAGJPAUIStream@@H@Z ENDP		; CSegment::Save
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSizeMax@CSegment@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_this$ = 8
_pcbSize$ = 12
?GetSizeMax@CSegment@@UAGJPAT_ULARGE_INTEGER@@@Z PROC NEAR ; CSegment::GetSizeMax, COMDAT

; 2655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2656 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2657 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?GetSizeMax@CSegment@@UAGJPAT_ULARGE_INTEGER@@@Z ENDP	; CSegment::GetSizeMax
_TEXT	ENDS
PUBLIC	??_C@_08ELKFENNM@pIStream?$AA@			; `string'
PUBLIC	?LoadTrack@CSegment@@QAEJPAVCRiffParser@@@Z	; CSegment::LoadTrack
PUBLIC	?LoadGraph@CSegment@@QAEJPAVCRiffParser@@PAPAVCGraph@@@Z ; CSegment::LoadGraph
PUBLIC	?LoadAudioPath@CSegment@@QAEJPAUIStream@@@Z	; CSegment::LoadAudioPath
PUBLIC	??_C@_0BN@IEHOMPKI@Error?3?5Unknown?5file?5format?4?6?$AA@ ; `string'
EXTRN	?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z:NEAR	; CInfo::ReadChunk
EXTRN	_CLSID_DirectMusicContainer:BYTE
EXTRN	_IID_IDirectMusicContainer:BYTE
EXTRN	??0CRiffParser@@QAE@PAUIStream@@@Z:NEAR		; CRiffParser::CRiffParser
EXTRN	?NextChunk@CRiffParser@@QAEHPAJ@Z:NEAR		; CRiffParser::NextChunk
EXTRN	?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z:NEAR	; CRiffParser::EnterList
EXTRN	?LeaveList@CRiffParser@@QAEXXZ:NEAR		; CRiffParser::LeaveList
EXTRN	?SeekBack@CRiffParser@@QAEJXZ:NEAR		; CRiffParser::SeekBack
EXTRN	?SeekForward@CRiffParser@@QAEJXZ:NEAR		; CRiffParser::SeekForward
EXTRN	?Read@CRiffParser@@QAEJPAXK@Z:NEAR		; CRiffParser::Read
;	COMDAT ??_C@_08ELKFENNM@pIStream?$AA@
CONST	SEGMENT
??_C@_08ELKFENNM@pIStream?$AA@ DB 'pIStream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IEHOMPKI@Error?3?5Unknown?5file?5format?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@IEHOMPKI@Error?3?5Unknown?5file?5format?4?6?$AA@ DB 'Error: Unk'
	DB	'nown file format.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadDirectMusicSegment@CSegment@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT
tv146 = -1076
tv84 = -1072
_this$ = -1068
_Desc$70881 = -1064
_hr$70884 = -212
_pGetLoader$70883 = -208
_pLoader$70882 = -204
_ioSegHdr$70801 = -200
_ckNext$70782 = -144
_pContainer$70784 = -108
_ckChild$70783 = -104
_hr$ = -68
_Parser$ = -64
_ckMain$ = -32
_pIStream$ = 8
?LoadDirectMusicSegment@CSegment@@QAEJPAUIStream@@@Z PROC NEAR ; CSegment::LoadDirectMusicSegment, COMDAT
; _this$ = ecx

; 2660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 04 00
	00		 sub	 esp, 1076		; 00000434H
  00009	89 8d d4 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2661 : 	// Argument validation
; 2662 : 	assert(pIStream);

  0000f	83 7d 08 00	 cmp	 DWORD PTR _pIStream$[ebp], 0
  00013	75 14		 jne	 SHORT $L72098
  00015	68 66 0a 00 00	 push	 2662			; 00000a66H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08ELKFENNM@pIStream?$AA@
  00024	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L72098:

; 2663 : 	CRiffParser Parser(pIStream);

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0002c	51		 push	 ecx
  0002d	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00030	e8 00 00 00 00	 call	 ??0CRiffParser@@QAE@PAUIStream@@@Z ; CRiffParser::CRiffParser

; 2664 :     RIFFIO ckMain;
; 2665 :     HRESULT hr = S_OK;

  00035	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2666 :     Parser.EnterList(&ckMain);  

  0003c	8d 55 e0	 lea	 edx, DWORD PTR _ckMain$[ebp]
  0003f	52		 push	 edx
  00040	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00043	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList

; 2667 :     if (Parser.NextChunk(&hr))

  00048	8d 45 bc	 lea	 eax, DWORD PTR _hr$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0004f	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00054	85 c0		 test	 eax, eax
  00056	0f 84 c1 04 00
	00		 je	 $L70772

; 2668 :     {
; 2669 :         if (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM)

  0005c	81 7d e8 44 4d
	53 47		 cmp	 DWORD PTR _ckMain$[ebp+8], 1196641604 ; 47534d44H
  00063	0f 85 9e 04 00
	00		 jne	 $L70781

; 2670 :         {
; 2671 :     	    RIFFIO ckNext;    // Descends into the next chunk.
; 2672 : 	        RIFFIO ckChild;   // For scanning through children lists.
; 2673 :             IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.

  00069	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _pContainer$70784[ebp], 0

; 2674 :             Parser.EnterList(&ckNext);

  00070	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ckNext$70782[ebp]
  00076	51		 push	 ecx
  00077	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0007a	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70786:

; 2675 : 	        while(Parser.NextChunk(&hr))

  0007f	8d 55 bc	 lea	 edx, DWORD PTR _hr$[ebp]
  00082	52		 push	 edx
  00083	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00086	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 58 04 00
	00		 je	 $L70787

; 2676 : 	        {
; 2677 : 		        switch(ckNext.ckid)
; 2678 : 		        {

  00093	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _ckNext$70782[ebp]
  00099	89 85 d0 fb ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  0009f	81 bd d0 fb ff
	ff 64 61 74 65	 cmp	 DWORD PTR tv84[ebp], 1702125924 ; 65746164H
  000a9	77 45		 ja	 SHORT $L72100
  000ab	81 bd d0 fb ff
	ff 64 61 74 65	 cmp	 DWORD PTR tv84[ebp], 1702125924 ; 65746164H
  000b5	0f 84 e0 01 00
	00		 je	 $L70817
  000bb	81 bd d0 fb ff
	ff 52 49 46 46	 cmp	 DWORD PTR tv84[ebp], 1179011410 ; 46464952H
  000c5	0f 84 f4 01 00
	00		 je	 $L70850
  000cb	81 bd d0 fb ff
	ff 4c 49 53 54	 cmp	 DWORD PTR tv84[ebp], 1414744396 ; 5453494cH
  000d5	0f 84 e4 01 00
	00		 je	 $L70850
  000db	81 bd d0 fb ff
	ff 67 75 69 64	 cmp	 DWORD PTR tv84[ebp], 1684632935 ; 64697567H
  000e5	0f 84 b0 01 00
	00		 je	 $L70817
  000eb	e9 f6 03 00 00	 jmp	 $L70789
$L72100:
  000f0	81 bd d0 fb ff
	ff 63 61 74 67	 cmp	 DWORD PTR tv84[ebp], 1735680355 ; 67746163H
  000fa	0f 84 9b 01 00
	00		 je	 $L70817
  00100	81 bd d0 fb ff
	ff 73 65 67 68	 cmp	 DWORD PTR tv84[ebp], 1751606643 ; 68676573H
  0010a	74 15		 je	 SHORT $L70800
  0010c	81 bd d0 fb ff
	ff 76 65 72 73	 cmp	 DWORD PTR tv84[ebp], 1936876918 ; 73726576H
  00116	0f 84 7f 01 00
	00		 je	 $L70817
  0011c	e9 c5 03 00 00	 jmp	 $L70789
$L70800:

; 2679 :                 case DMUS_FOURCC_SEGMENT_CHUNK:
; 2680 : 				    DMUS_IO_SEGMENT_HEADER ioSegHdr;
; 2681 :                     ioSegHdr.rtLoopStart = 0;

  00121	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+40], 0
  0012b	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+44], 0

; 2682 :                     ioSegHdr.rtLoopEnd = 0;

  00135	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+48], 0
  0013f	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+52], 0

; 2683 :                     ioSegHdr.rtLength = 0;

  00149	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+24], 0
  00153	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+28], 0

; 2684 :                     ioSegHdr.dwFlags = 0;

  0015d	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioSegHdr$70801[ebp+32], 0

; 2685 : 				    hr = Parser.Read(&ioSegHdr, sizeof(DMUS_IO_SEGMENT_HEADER));

  00167	6a 38		 push	 56			; 00000038H
  00169	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _ioSegHdr$70801[ebp]
  0016f	51		 push	 ecx
  00170	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00173	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00178	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2686 : 				    if(SUCCEEDED(hr))

  0017b	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0017f	0f 8c 11 01 00
	00		 jl	 $L70804

; 2687 : 				    {
; 2688 : 					    m_dwResolution = ioSegHdr.dwResolution;

  00185	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0018b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _ioSegHdr$70801[ebp+20]
  00191	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 2689 : 					    m_mtLength = ioSegHdr.mtLength;

  00194	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _ioSegHdr$70801[ebp+4]
  001a0	89 51 70	 mov	 DWORD PTR [ecx+112], edx

; 2690 : 					    m_mtStart = ioSegHdr.mtPlayStart;

  001a3	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001a9	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _ioSegHdr$70801[ebp+8]
  001af	89 48 74	 mov	 DWORD PTR [eax+116], ecx

; 2691 : 					    m_mtLoopStart = ioSegHdr.mtLoopStart;

  001b2	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001b8	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _ioSegHdr$70801[ebp+12]
  001be	89 42 78	 mov	 DWORD PTR [edx+120], eax

; 2692 : 					    m_mtLoopEnd = ioSegHdr.mtLoopEnd;

  001c1	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _ioSegHdr$70801[ebp+16]
  001cd	89 51 7c	 mov	 DWORD PTR [ecx+124], edx

; 2693 : 					    m_dwRepeats = ioSegHdr.dwRepeats;

  001d0	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001d6	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ioSegHdr$70801[ebp]
  001dc	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 2694 :                         m_dwSegFlags = ioSegHdr.dwFlags;

  001df	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001e5	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _ioSegHdr$70801[ebp+32]
  001eb	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 2695 :                         if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)

  001ee	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  001f7	83 e2 01	 and	 edx, 1
  001fa	85 d2		 test	 edx, edx
  001fc	74 1a		 je	 SHORT $L70805

; 2696 :                         {
; 2697 :                             m_rtLength = ioSegHdr.rtLength;

  001fe	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00204	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _ioSegHdr$70801[ebp+24]
  0020a	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  0020d	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ioSegHdr$70801[ebp+28]
  00213	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 2698 :                         }
; 2699 :                         else

  00216	eb 14		 jmp	 SHORT $L70806
$L70805:

; 2700 :                         {
; 2701 :                             m_rtLength = 0; 

  00218	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0021e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
  00225	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0
$L70806:

; 2702 :                         }
; 2703 :                         if (m_dwSegFlags & DMUS_SEGIOF_REFLOOP)

  0022c	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00232	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00235	83 e2 02	 and	 edx, 2
  00238	85 d2		 test	 edx, edx
  0023a	74 32		 je	 SHORT $L70807

; 2704 :                         {
; 2705 :                             m_rtLoopStart = ioSegHdr.rtLoopStart;

  0023c	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00242	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _ioSegHdr$70801[ebp+40]
  00248	89 48 60	 mov	 DWORD PTR [eax+96], ecx
  0024b	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _ioSegHdr$70801[ebp+44]
  00251	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 2706 :                             m_rtLoopEnd = ioSegHdr.rtLoopEnd;

  00254	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0025a	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _ioSegHdr$70801[ebp+48]
  00260	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00263	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _ioSegHdr$70801[ebp+52]
  00269	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 2707 :                         }
; 2708 :                         else

  0026c	eb 28		 jmp	 SHORT $L70804
$L70807:

; 2709 :                         {
; 2710 :                             m_rtLoopStart = m_rtLoopEnd = 0;

  0026e	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00274	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0
  0027b	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
  00282	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00288	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0
  0028f	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0
$L70804:

; 2711 :                         }
; 2712 : 				    }
; 2713 : 				    break;

  00296	e9 4b 02 00 00	 jmp	 $L70789
$L70817:

; 2714 : 			    case DMUS_FOURCC_GUID_CHUNK:
; 2715 : 			    case DMUS_FOURCC_VERSION_CHUNK:
; 2716 : 			    case DMUS_FOURCC_CATEGORY_CHUNK:
; 2717 : 			    case DMUS_FOURCC_DATE_CHUNK:
; 2718 :                     hr = m_Info.ReadChunk(&Parser,ckNext.ckid);

  0029b	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _ckNext$70782[ebp]
  002a1	52		 push	 edx
  002a2	8d 45 c0	 lea	 eax, DWORD PTR _Parser$[ebp]
  002a5	50		 push	 eax
  002a6	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ac	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  002b2	e8 00 00 00 00	 call	 ?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z ; CInfo::ReadChunk
  002b7	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2719 :                     break;

  002ba	e9 27 02 00 00	 jmp	 $L70789
$L70850:

; 2720 : 			    case FOURCC_LIST:
; 2721 :                 case FOURCC_RIFF:
; 2722 : 				    switch(ckNext.fccType)
; 2723 : 				    {

  002bf	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _ckNext$70782[ebp+8]
  002c5	89 8d cc fb ff
	ff		 mov	 DWORD PTR tv146[ebp], ecx
  002cb	81 bd cc fb ff
	ff 55 4e 46 4f	 cmp	 DWORD PTR tv146[ebp], 1330007637 ; 4f464e55H
  002d5	77 2d		 ja	 SHORT $L72099
  002d7	81 bd cc fb ff
	ff 55 4e 46 4f	 cmp	 DWORD PTR tv146[ebp], 1330007637 ; 4f464e55H
  002e1	74 46		 je	 SHORT $L70871
  002e3	81 bd cc fb ff
	ff 44 4d 54 47	 cmp	 DWORD PTR tv146[ebp], 1196707140 ; 47544d44H
  002ed	0f 84 b3 01 00
	00		 je	 $L70929
  002f3	81 bd cc fb ff
	ff 44 4d 43 4e	 cmp	 DWORD PTR tv146[ebp], 1313033540 ; 4e434d44H
  002fd	74 4e		 je	 SHORT $L70880
  002ff	e9 e2 01 00 00	 jmp	 $L70789
$L72099:
  00304	81 bd cc fb ff
	ff 44 4d 41 50	 cmp	 DWORD PTR tv146[ebp], 1346456900 ; 50414d44H
  0030e	0f 84 b0 01 00
	00		 je	 $L70938
  00314	81 bd cc fb ff
	ff 74 72 6b 6c	 cmp	 DWORD PTR tv146[ebp], 1818980980 ; 6c6b7274H
  0031e	0f 84 36 01 00
	00		 je	 $L70900
  00324	e9 bd 01 00 00	 jmp	 $L70789
$L70871:

; 2724 : 					    case DMUS_FOURCC_UNFO_LIST:
; 2725 :                             hr = m_Info.ReadChunk(&Parser,ckNext.fccType);

  00329	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ckNext$70782[ebp+8]
  0032f	52		 push	 edx
  00330	8d 45 c0	 lea	 eax, DWORD PTR _Parser$[ebp]
  00333	50		 push	 eax
  00334	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0033a	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00340	e8 00 00 00 00	 call	 ?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z ; CInfo::ReadChunk
  00345	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2726 : /*                            Parser.EnterList(&ckChild);
; 2727 :                             while (Parser.NextChunk(&hr))
; 2728 : 						    {
; 2729 : 							    switch( ckChild.ckid )
; 2730 : 							    {
; 2731 : 								    case DMUS_FOURCC_UNAM_CHUNK:
; 2732 : 								    {
; 2733 : 									    hr = Parser.Read(&m_wszName, sizeof(m_wszName));
; 2734 : 									    if(SUCCEEDED(hr) )
; 2735 : 									    {
; 2736 : 										    m_dwValidData |= DMUS_OBJ_NAME;
; 2737 : 									    }
; 2738 : 									    break;
; 2739 : 								    }
; 2740 : 								    default:
; 2741 : 									    break;
; 2742 : 							    }
; 2743 : 						    }
; 2744 :                             Parser.LeaveList();*/
; 2745 : 						    break;

  00348	e9 99 01 00 00	 jmp	 $L70789
$L70880:

; 2746 :                         case DMUS_FOURCC_CONTAINER_FORM:
; 2747 :                             // An embedded container RIFF chunk which includes a bunch
; 2748 :                             // of objects referenced by the segment. This should precede the
; 2749 :                             // tracks and gets loaded prior to the tracks. Loading this
; 2750 :                             // causes all of its objects to get SetObject'd in the loader,
; 2751 :                             // so they later get pulled in as requested by the tracks.
; 2752 :                             // After the tracks are loaded, the loader references are
; 2753 :                             // released by a call to release the IDirectMusicContainer.
; 2754 :                             {
; 2755 :                                 DMUS_OBJECTDESC Desc;
; 2756 :                                 IDirectMusicLoader *pLoader;
; 2757 :                                 IDirectMusicGetLoader *pGetLoader;
; 2758 :                                 HRESULT hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);

  0034d	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _pGetLoader$70883[ebp]
  00353	51		 push	 ecx
  00354	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGetLoader
  00359	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  0035c	8b 02		 mov	 eax, DWORD PTR [edx]
  0035e	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00361	51		 push	 ecx
  00362	ff 10		 call	 DWORD PTR [eax]
  00364	89 85 2c ff ff
	ff		 mov	 DWORD PTR _hr$70884[ebp], eax

; 2759 :                                 if (SUCCEEDED(hr))

  0036a	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR _hr$70884[ebp], 0
  00371	0f 8c de 00 00
	00		 jl	 $L70887

; 2760 :                                 {
; 2761 :                                     if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))

  00377	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _pLoader$70882[ebp]
  0037d	52		 push	 edx
  0037e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _pGetLoader$70883[ebp]
  00384	8b 08		 mov	 ecx, DWORD PTR [eax]
  00386	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _pGetLoader$70883[ebp]
  0038c	52		 push	 edx
  0038d	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00390	85 c0		 test	 eax, eax
  00392	0f 8c ab 00 00
	00		 jl	 $L70889

; 2762 :                                     {
; 2763 :                                    	    // Move back stream's current position
; 2764 :                                         Parser.SeekBack();

  00398	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0039b	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 2765 :                                         Desc.dwSize = sizeof(Desc);

  003a0	c7 85 d8 fb ff
	ff 50 03 00 00	 mov	 DWORD PTR _Desc$70881[ebp], 848 ; 00000350H

; 2766 :                                         Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;

  003aa	c7 85 dc fb ff
	ff 02 08 00 00	 mov	 DWORD PTR _Desc$70881[ebp+4], 2050 ; 00000802H

; 2767 :                                         Desc.guidClass = CLSID_DirectMusicContainer;

  003b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicContainer
  003b9	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _Desc$70881[ebp+24], eax
  003bf	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectMusicContainer+4
  003c5	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _Desc$70881[ebp+28], ecx
  003cb	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicContainer+8
  003d1	89 95 f8 fb ff
	ff		 mov	 DWORD PTR _Desc$70881[ebp+32], edx
  003d7	a1 0c 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicContainer+12
  003dc	89 85 fc fb ff
	ff		 mov	 DWORD PTR _Desc$70881[ebp+36], eax

; 2768 :                                         Desc.pStream = pIStream;

  003e2	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  003e5	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _Desc$70881[ebp+844], ecx

; 2769 :                                         pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);

  003eb	8d 55 94	 lea	 edx, DWORD PTR _pContainer$70784[ebp]
  003ee	52		 push	 edx
  003ef	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicContainer
  003f4	8d 85 d8 fb ff
	ff		 lea	 eax, DWORD PTR _Desc$70881[ebp]
  003fa	50		 push	 eax
  003fb	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _pLoader$70882[ebp]
  00401	8b 11		 mov	 edx, DWORD PTR [ecx]
  00403	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _pLoader$70882[ebp]
  00409	50		 push	 eax
  0040a	ff 52 0c	 call	 DWORD PTR [edx+12]

; 2770 :                                         if (pContainer)

  0040d	83 7d 94 00	 cmp	 DWORD PTR _pContainer$70784[ebp], 0
  00411	74 16		 je	 SHORT $L70891

; 2771 :                                         {
; 2772 :                                             // Don't cache the container object! We want it and the
; 2773 :                                             // objects it references to go away when the segment is done loading.
; 2774 : #ifdef DXAPI
; 2775 :                                             IDirectMusicObject *pObject = NULL;
; 2776 :                                             pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
; 2777 :                                             if (pObject)
; 2778 :                                             {
; 2779 :                                                 pLoader->ReleaseObject(pObject);
; 2780 :                                                 pObject->Release();
; 2781 :                                             }
; 2782 : #else
; 2783 :                                             pLoader->ReleaseObjectByUnknown(pContainer);

  00413	8b 4d 94	 mov	 ecx, DWORD PTR _pContainer$70784[ebp]
  00416	51		 push	 ecx
  00417	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _pLoader$70882[ebp]
  0041d	8b 02		 mov	 eax, DWORD PTR [edx]
  0041f	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _pLoader$70882[ebp]
  00425	51		 push	 ecx
  00426	ff 50 20	 call	 DWORD PTR [eax+32]
$L70891:

; 2784 : #endif
; 2785 :                                         }
; 2786 :                                         // Now, seek to the end of this chunk.
; 2787 :                                         Parser.SeekForward();

  00429	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0042c	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward

; 2788 :                                         pLoader->Release();

  00431	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _pLoader$70882[ebp]
  00437	8b 02		 mov	 eax, DWORD PTR [edx]
  00439	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _pLoader$70882[ebp]
  0043f	51		 push	 ecx
  00440	ff 50 08	 call	 DWORD PTR [eax+8]
$L70889:

; 2789 :                                     }
; 2790 :                                     pGetLoader->Release();

  00443	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _pGetLoader$70883[ebp]
  00449	8b 02		 mov	 eax, DWORD PTR [edx]
  0044b	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _pGetLoader$70883[ebp]
  00451	51		 push	 ecx
  00452	ff 50 08	 call	 DWORD PTR [eax+8]
$L70887:

; 2791 :                                 }
; 2792 :                             }
; 2793 :                             break;

  00455	e9 8c 00 00 00	 jmp	 $L70789
$L70900:

; 2794 : 					    case DMUS_FOURCC_TRACK_LIST:
; 2795 :                             Parser.EnterList(&ckChild);

  0045a	8d 55 98	 lea	 edx, DWORD PTR _ckChild$70783[ebp]
  0045d	52		 push	 edx
  0045e	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00461	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70902:

; 2796 :                             while(Parser.NextChunk(&hr))

  00466	8d 45 bc	 lea	 eax, DWORD PTR _hr$[ebp]
  00469	50		 push	 eax
  0046a	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0046d	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00472	85 c0		 test	 eax, eax
  00474	74 26		 je	 SHORT $L70903

; 2797 : 	                        {	
; 2798 : 		                        if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_TRACK_FORM))

  00476	81 7d 98 52 49
	46 46		 cmp	 DWORD PTR _ckChild$70783[ebp], 1179011410 ; 46464952H
  0047d	75 1b		 jne	 SHORT $L70920
  0047f	81 7d a0 44 4d
	54 4b		 cmp	 DWORD PTR _ckChild$70783[ebp+8], 1263816004 ; 4b544d44H
  00486	75 12		 jne	 SHORT $L70920

; 2799 :                                 {
; 2800 : 			                        hr = LoadTrack(&Parser);

  00488	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0048b	51		 push	 ecx
  0048c	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00492	e8 00 00 00 00	 call	 ?LoadTrack@CSegment@@QAEJPAVCRiffParser@@@Z ; CSegment::LoadTrack
  00497	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax
$L70920:

; 2801 : 		                        }
; 2802 : 	                        }

  0049a	eb ca		 jmp	 SHORT $L70902
$L70903:

; 2803 :                             Parser.LeaveList();

  0049c	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0049f	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2804 : 						    break;

  004a4	eb 40		 jmp	 SHORT $L70789
$L70929:

; 2805 :     				    case DMUS_FOURCC_TOOLGRAPH_FORM:
; 2806 : 						    hr = LoadGraph(&Parser,&m_pGraph);

  004a6	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004ac	83 c2 4c	 add	 edx, 76			; 0000004cH
  004af	52		 push	 edx
  004b0	8d 45 c0	 lea	 eax, DWORD PTR _Parser$[ebp]
  004b3	50		 push	 eax
  004b4	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004ba	e8 00 00 00 00	 call	 ?LoadGraph@CSegment@@QAEJPAVCRiffParser@@PAPAVCGraph@@@Z ; CSegment::LoadGraph
  004bf	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2807 : 						    break;

  004c2	eb 22		 jmp	 SHORT $L70789
$L70938:

; 2808 :                         case DMUS_FOURCC_AUDIOPATH_FORM:
; 2809 :                             // Move back to start of this chunk.
; 2810 :                             Parser.SeekBack();

  004c4	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  004c7	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 2811 :                             hr = LoadAudioPath(pIStream);

  004cc	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  004cf	51		 push	 ecx
  004d0	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004d6	e8 00 00 00 00	 call	 ?LoadAudioPath@CSegment@@QAEJPAUIStream@@@Z ; CSegment::LoadAudioPath
  004db	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2812 :                             // Now, seek to the end of this chunk.
; 2813 :                             Parser.SeekForward();

  004de	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  004e1	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward
$L70789:

; 2814 :                             break;
; 2815 : 				    }
; 2816 : 				    break;
; 2817 : 		        }
; 2818 :             }

  004e6	e9 94 fb ff ff	 jmp	 $L70786
$L70787:

; 2819 :             Parser.LeaveList();

  004eb	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  004ee	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2820 :             if (pContainer)

  004f3	83 7d 94 00	 cmp	 DWORD PTR _pContainer$70784[ebp], 0
  004f7	74 0c		 je	 SHORT $L70939

; 2821 :             {
; 2822 :                 pContainer->Release();

  004f9	8b 55 94	 mov	 edx, DWORD PTR _pContainer$70784[ebp]
  004fc	8b 02		 mov	 eax, DWORD PTR [edx]
  004fe	8b 4d 94	 mov	 ecx, DWORD PTR _pContainer$70784[ebp]
  00501	51		 push	 ecx
  00502	ff 50 08	 call	 DWORD PTR [eax+8]
$L70939:

; 2823 :             }
; 2824 :         }
; 2825 :         else 

  00505	eb 16		 jmp	 SHORT $L70772
$L70781:

; 2826 :         {
; 2827 :             Trace(1,"Error: Unknown file format.\n");

  00507	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@IEHOMPKI@Error?3?5Unknown?5file?5format?4?6?$AA@
  0050c	6a 01		 push	 1
  0050e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00513	83 c4 08	 add	 esp, 8

; 2828 :             hr = DMUS_E_DESCEND_CHUNK_FAIL;

  00516	c7 45 bc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70772:

; 2829 :         }
; 2830 :     }
; 2831 :     Parser.LeaveList();

  0051d	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00520	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2832 : #ifdef DXAPI
; 2833 :     if (SUCCEEDED(hr) && Parser.ComponentFailed())
; 2834 :     {
; 2835 :         Trace(1,"Warning: Segment successfully loaded but one or more tracks within it did not.\n");
; 2836 :         hr = DMUS_S_PARTIALLOAD;
; 2837 :     }
; 2838 : #endif
; 2839 : 	return hr;

  00525	8b 45 bc	 mov	 eax, DWORD PTR _hr$[ebp]

; 2840 : }

  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c2 04 00	 ret	 4
?LoadDirectMusicSegment@CSegment@@QAEJPAUIStream@@@Z ENDP ; CSegment::LoadDirectMusicSegment
_TEXT	ENDS
PUBLIC	?CreateTrack@CSegment@@QAEJAAU_DMUS_IO_TRACK_HEADER@@KKPAUIStream@@@Z ; CSegment::CreateTrack
PUBLIC	??_C@_0CJ@EACLOAKF@Error?3?5Invalid?5track?5header?5in?5S@ ; `string'
PUBLIC	??_C@_0EK@MMOCDHEO@Error?3?5Invalid?5track?5in?5Segment?5@ ; `string'
PUBLIC	?GetStream@CRiffParser@@QAEPAUIStream@@XZ	; CRiffParser::GetStream
;	COMDAT ??_C@_0CJ@EACLOAKF@Error?3?5Invalid?5track?5header?5in?5S@
CONST	SEGMENT
??_C@_0CJ@EACLOAKF@Error?3?5Invalid?5track?5header?5in?5S@ DB 'Error: Inv'
	DB	'alid track header in Segment.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@MMOCDHEO@Error?3?5Invalid?5track?5in?5Segment?5@
CONST	SEGMENT
??_C@_0EK@MMOCDHEO@Error?3?5Invalid?5track?5in?5Segment?5@ DB 'Error: Inv'
	DB	'alid track in Segment - track header is not before track data'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadTrack@CSegment@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT
_this$ = -88
_hr$ = -84
_ioTrackExtrasHdr$ = -80
_ioTrackHdr$ = -72
_ckNext$ = -40
_fHeaderRead$ = -4
_pParser$ = 8
?LoadTrack@CSegment@@QAEJPAVCRiffParser@@@Z PROC NEAR	; CSegment::LoadTrack, COMDAT
; _this$ = ecx

; 2843 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 2844 :     BOOL fHeaderRead = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fHeaderRead$[ebp], 0

; 2845 : 
; 2846 : 	DMUS_IO_TRACK_HEADER ioTrackHdr;
; 2847 :     DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
; 2848 :     ioTrackExtrasHdr.dwPriority = 0;

  00010	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _ioTrackExtrasHdr$[ebp+4], 0

; 2849 :     ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;

  00017	c7 45 b0 38 00
	00 00		 mov	 DWORD PTR _ioTrackExtrasHdr$[ebp], 56 ; 00000038H

; 2850 :     ioTrackHdr.ckid = 0;

  0001e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ioTrackHdr$[ebp+24], 0

; 2851 :     ioTrackHdr.fccType = 0;

  00025	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _ioTrackHdr$[ebp+28], 0

; 2852 :     ioTrackHdr.dwPosition = 0;

  0002c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _ioTrackHdr$[ebp+16], 0

; 2853 : 
; 2854 : 	RIFFIO ckNext;
; 2855 : 	HRESULT hr = S_OK;

  00033	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2856 :     pParser->EnterList(&ckNext);

  0003a	8d 45 d8	 lea	 eax, DWORD PTR _ckNext$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00041	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70954:

; 2857 :     while(pParser->NextChunk(&hr))

  00046	8d 4d ac	 lea	 ecx, DWORD PTR _hr$[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0004d	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00052	85 c0		 test	 eax, eax
  00054	0f 84 d9 00 00
	00		 je	 $L70955

; 2858 : 	{	
; 2859 :         if (ckNext.ckid == DMUS_FOURCC_TRACK_CHUNK)

  0005a	81 7d d8 74 72
	6b 68		 cmp	 DWORD PTR _ckNext$[ebp], 1751872116 ; 686b7274H
  00061	75 3f		 jne	 SHORT $L70964

; 2860 :         {
; 2861 :             fHeaderRead = TRUE;

  00063	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fHeaderRead$[ebp], 1

; 2862 : 		    hr = pParser->Read(&ioTrackHdr, sizeof(DMUS_IO_TRACK_HEADER));

  0006a	6a 20		 push	 32			; 00000020H
  0006c	8d 55 b8	 lea	 edx, DWORD PTR _ioTrackHdr$[ebp]
  0006f	52		 push	 edx
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00073	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00078	89 45 ac	 mov	 DWORD PTR _hr$[ebp], eax

; 2863 : 		    if(ioTrackHdr.ckid == 0 && ioTrackHdr.fccType == NULL)

  0007b	83 7d d0 00	 cmp	 DWORD PTR _ioTrackHdr$[ebp+24], 0
  0007f	75 1c		 jne	 SHORT $L70966
  00081	83 7d d4 00	 cmp	 DWORD PTR _ioTrackHdr$[ebp+28], 0
  00085	75 16		 jne	 SHORT $L70966

; 2864 : 		    {
; 2865 :                 Trace(1,"Error: Invalid track header in Segment.\n");

  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@EACLOAKF@Error?3?5Invalid?5track?5header?5in?5S@
  0008c	6a 01		 push	 1
  0008e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00093	83 c4 08	 add	 esp, 8

; 2866 : 			    hr = DMUS_E_INVALID_TRACK_HDR;

  00096	c7 45 ac 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70966:

; 2867 : 		    }
; 2868 :         }
; 2869 :         else if (ckNext.ckid == DMUS_FOURCC_TRACK_EXTRAS_CHUNK)

  0009d	e9 8c 00 00 00	 jmp	 $L70969
$L70964:
  000a2	81 7d d8 74 72
	6b 78		 cmp	 DWORD PTR _ckNext$[ebp], 2020307572 ; 786b7274H
  000a9	75 13		 jne	 SHORT $L70978

; 2870 :         {
; 2871 : 		    hr = pParser->Read(&ioTrackExtrasHdr, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER));

  000ab	6a 08		 push	 8
  000ad	8d 45 b0	 lea	 eax, DWORD PTR _ioTrackExtrasHdr$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000b4	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  000b9	89 45 ac	 mov	 DWORD PTR _hr$[ebp], eax

; 2872 :         }
; 2873 :         else if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))

  000bc	eb 70		 jmp	 SHORT $L70969
$L70978:

; 2874 : 		    && ckNext.fccType == ioTrackHdr.fccType) ||
; 2875 :             (ckNext.ckid == ioTrackHdr.ckid))

  000be	81 7d d8 4c 49
	53 54		 cmp	 DWORD PTR _ckNext$[ebp], 1414744396 ; 5453494cH
  000c5	74 09		 je	 SHORT $L71000
  000c7	81 7d d8 52 49
	46 46		 cmp	 DWORD PTR _ckNext$[ebp], 1179011410 ; 46464952H
  000ce	75 08		 jne	 SHORT $L70999
$L71000:
  000d0	8b 4d e0	 mov	 ecx, DWORD PTR _ckNext$[ebp+8]
  000d3	3b 4d d4	 cmp	 ecx, DWORD PTR _ioTrackHdr$[ebp+28]
  000d6	74 08		 je	 SHORT $L70998
$L70999:
  000d8	8b 55 d8	 mov	 edx, DWORD PTR _ckNext$[ebp]
  000db	3b 55 d0	 cmp	 edx, DWORD PTR _ioTrackHdr$[ebp+24]
  000de	75 4e		 jne	 SHORT $L70969
$L70998:

; 2876 : 		{
; 2877 :             if (fHeaderRead)

  000e0	83 7d fc 00	 cmp	 DWORD PTR _fHeaderRead$[ebp], 0
  000e4	74 32		 je	 SHORT $L71001

; 2878 : 		    {	
; 2879 :                 // Okay, this is the chunk we are looking for.
; 2880 :                 // Seek back to start of chunk.
; 2881 :                 pParser->SeekBack();

  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000e9	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 2882 : #ifdef DXAPI
; 2883 :                 // Let the parser know it's okay to fail this.
; 2884 :                 pParser->EnteringComponent();
; 2885 : #endif
; 2886 : 			    hr = CreateTrack(ioTrackHdr, ioTrackExtrasHdr.dwFlags, ioTrackExtrasHdr.dwPriority, pParser->GetStream());

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000f1	e8 00 00 00 00	 call	 ?GetStream@CRiffParser@@QAEPAUIStream@@XZ ; CRiffParser::GetStream
  000f6	50		 push	 eax
  000f7	8b 45 b4	 mov	 eax, DWORD PTR _ioTrackExtrasHdr$[ebp+4]
  000fa	50		 push	 eax
  000fb	8b 4d b0	 mov	 ecx, DWORD PTR _ioTrackExtrasHdr$[ebp]
  000fe	51		 push	 ecx
  000ff	8d 55 b8	 lea	 edx, DWORD PTR _ioTrackHdr$[ebp]
  00102	52		 push	 edx
  00103	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?CreateTrack@CSegment@@QAEJAAU_DMUS_IO_TRACK_HEADER@@KKPAUIStream@@@Z ; CSegment::CreateTrack
  0010b	89 45 ac	 mov	 DWORD PTR _hr$[ebp], eax

; 2887 :                 // Now, make sure we are at the end of the chunk.
; 2888 :                 pParser->SeekForward();

  0010e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00111	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward

; 2889 :             }
; 2890 :             else

  00116	eb 16		 jmp	 SHORT $L70969
$L71001:

; 2891 :             {
; 2892 :                 Trace(1,"Error: Invalid track in Segment - track header is not before track data.\n");

  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EK@MMOCDHEO@Error?3?5Invalid?5track?5in?5Segment?5@
  0011d	6a 01		 push	 1
  0011f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00124	83 c4 08	 add	 esp, 8

; 2893 : 			    hr = DMUS_E_TRACK_HDR_NOT_FIRST_CK;

  00127	c7 45 ac 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70969:

; 2894 : 		    }	
; 2895 : 
; 2896 :         }
; 2897 : 	}

  0012e	e9 13 ff ff ff	 jmp	 $L70954
$L70955:

; 2898 :     pParser->LeaveList();

  00133	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00136	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2899 : 	return hr;

  0013b	8b 45 ac	 mov	 eax, DWORD PTR _hr$[ebp]

; 2900 : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 04 00	 ret	 4
?LoadTrack@CSegment@@QAEJPAVCRiffParser@@@Z ENDP	; CSegment::LoadTrack
_TEXT	ENDS
PUBLIC	??_C@_07KCKPANJI@pStream?$AA@			; `string'
;	COMDAT ??_C@_07KCKPANJI@pStream?$AA@
CONST	SEGMENT
??_C@_07KCKPANJI@pStream?$AA@ DB 'pStream', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateTrack@CSegment@@QAEJAAU_DMUS_IO_TRACK_HEADER@@KKPAUIStream@@@Z
_TEXT	SEGMENT
_this$ = -20
_hr$ = -16
_hrTrack$ = -12
_pDMTrack$ = -8
_pIPersistStream$ = -4
_ioTrackHdr$ = 8
_dwFlags$ = 12
_dwPriority$ = 16
_pStream$ = 20
?CreateTrack@CSegment@@QAEJAAU_DMUS_IO_TRACK_HEADER@@KKPAUIStream@@@Z PROC NEAR ; CSegment::CreateTrack, COMDAT
; _this$ = ecx

; 2903 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2904 : 	assert(pStream);

  00009	83 7d 14 00	 cmp	 DWORD PTR _pStream$[ebp], 0
  0000d	75 14		 jne	 SHORT $L72107
  0000f	68 58 0b 00 00	 push	 2904			; 00000b58H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KCKPANJI@pStream?$AA@
  0001e	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L72107:

; 2905 : 
; 2906 : 	IDirectMusicTrack* pDMTrack = NULL;

  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDMTrack$[ebp], 0

; 2907 : 	HRESULT hrTrack = S_OK;

  0002a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hrTrack$[ebp], 0

; 2908 : 	HRESULT hr = DirectMusicCreateInstance(ioTrackHdr.guidClassID,
; 2909 : 								  NULL,
; 2910 : 								  IID_IDirectMusicTrack,
; 2911 : 								  (void**)&pDMTrack);

  00031	8d 4d f8	 lea	 ecx, DWORD PTR _pDMTrack$[ebp]
  00034	51		 push	 ecx
  00035	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack
  0003a	6a 00		 push	 0
  0003c	8b 55 08	 mov	 edx, DWORD PTR _ioTrackHdr$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
  00045	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 2912 : 
; 2913 :     IPersistStream *pIPersistStream = NULL;

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pIPersistStream$[ebp], 0

; 2914 : 	
; 2915 : 	if(SUCCEEDED(hr))

  0004f	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00053	7c 17		 jl	 SHORT $L71021

; 2916 : 	{
; 2917 : 		hr = pDMTrack->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

  00055	8d 45 fc	 lea	 eax, DWORD PTR _pIPersistStream$[ebp]
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _pDMTrack$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	8b 45 f8	 mov	 eax, DWORD PTR _pDMTrack$[ebp]
  00066	50		 push	 eax
  00067	ff 12		 call	 DWORD PTR [edx]
  00069	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L71021:

; 2918 : 	}
; 2919 : 
; 2920 : 	if(SUCCEEDED(hr))

  0006c	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00070	7c 19		 jl	 SHORT $L71024

; 2921 : 	{
; 2922 : 		hr = hrTrack = pIPersistStream->Load(pStream);

  00072	8b 4d 14	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 fc	 mov	 edx, DWORD PTR _pIPersistStream$[ebp]
  00079	8b 02		 mov	 eax, DWORD PTR [edx]
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _pIPersistStream$[ebp]
  0007e	51		 push	 ecx
  0007f	ff 50 14	 call	 DWORD PTR [eax+20]
  00082	89 45 f4	 mov	 DWORD PTR _hrTrack$[ebp], eax
  00085	8b 55 f4	 mov	 edx, DWORD PTR _hrTrack$[ebp]
  00088	89 55 f0	 mov	 DWORD PTR _hr$[ebp], edx
$L71024:

; 2923 : 	}
; 2924 : 
; 2925 : 	if(SUCCEEDED(hr))

  0008b	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008f	7c 25		 jl	 SHORT $L71026

; 2926 : 	{
; 2927 : 		hr = InsertTrack(pDMTrack, ioTrackHdr.dwGroup, dwFlags, dwPriority, ioTrackHdr.dwPosition);

  00091	8b 45 08	 mov	 eax, DWORD PTR _ioTrackHdr$[ebp]
  00094	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00097	51		 push	 ecx
  00098	8b 55 10	 mov	 edx, DWORD PTR _dwPriority$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _ioTrackHdr$[ebp]
  000a3	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a6	52		 push	 edx
  000a7	8b 45 f8	 mov	 eax, DWORD PTR _pDMTrack$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?InsertTrack@CSegment@@QAEJPAUIDirectMusicTrack@@KKKK@Z ; CSegment::InsertTrack
  000b3	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L71026:

; 2928 : 	}
; 2929 : 
; 2930 : 	if(pIPersistStream)

  000b6	83 7d fc 00	 cmp	 DWORD PTR _pIPersistStream$[ebp], 0
  000ba	74 0c		 je	 SHORT $L71027

; 2931 : 	{
; 2932 : 		pIPersistStream->Release();

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _pIPersistStream$[ebp]
  000bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c1	8b 45 fc	 mov	 eax, DWORD PTR _pIPersistStream$[ebp]
  000c4	50		 push	 eax
  000c5	ff 52 08	 call	 DWORD PTR [edx+8]
$L71027:

; 2933 : 	}
; 2934 : 	
; 2935 : 	if(pDMTrack)

  000c8	83 7d f8 00	 cmp	 DWORD PTR _pDMTrack$[ebp], 0
  000cc	74 0c		 je	 SHORT $L71028

; 2936 : 	{
; 2937 : 		pDMTrack->Release();

  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _pDMTrack$[ebp]
  000d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d3	8b 45 f8	 mov	 eax, DWORD PTR _pDMTrack$[ebp]
  000d6	50		 push	 eax
  000d7	ff 52 08	 call	 DWORD PTR [edx+8]
$L71028:

; 2938 : 	}
; 2939 : 
; 2940 : 	if (hr == S_OK && hrTrack != S_OK)

  000da	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000de	75 0c		 jne	 SHORT $L71031
  000e0	83 7d f4 00	 cmp	 DWORD PTR _hrTrack$[ebp], 0
  000e4	74 06		 je	 SHORT $L71031

; 2941 : 	{
; 2942 : 		hr = hrTrack;

  000e6	8b 4d f4	 mov	 ecx, DWORD PTR _hrTrack$[ebp]
  000e9	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx
$L71031:

; 2943 : 	}
; 2944 : 	return hr;

  000ec	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 2945 : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 10 00	 ret	 16			; 00000010H
?CreateTrack@CSegment@@QAEJAAU_DMUS_IO_TRACK_HEADER@@KKPAUIStream@@@Z ENDP ; CSegment::CreateTrack
_TEXT	ENDS
EXTRN	??0CGraph@@QAE@XZ:NEAR				; CGraph::CGraph
EXTRN	?Load@CGraph@@QAEJPAVCRiffParser@@@Z:NEAR	; CGraph::Load
; Function compile flags: /Odt
;	COMDAT ?LoadGraph@CSegment@@QAEJPAVCRiffParser@@PAPAVCGraph@@@Z
_TEXT	SEGMENT
tv69 = -20
_this$ = -16
$T72111 = -12
_pGraph$ = -8
_hr$ = -4
_pParser$ = 8
_ppGraph$ = 12
?LoadGraph@CSegment@@QAEJPAVCRiffParser@@PAPAVCGraph@@@Z PROC NEAR ; CSegment::LoadGraph, COMDAT
; _this$ = ecx

; 2948 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2949 :     CGraph *pGraph = new CGraph;

  00009	68 70 03 00 00	 push	 880			; 00000370H
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 f4	 mov	 DWORD PTR $T72111[ebp], eax
  00019	83 7d f4 00	 cmp	 DWORD PTR $T72111[ebp], 0
  0001d	74 0d		 je	 SHORT $L72112
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR $T72111[ebp]
  00022	e8 00 00 00 00	 call	 ??0CGraph@@QAE@XZ	; CGraph::CGraph
  00027	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  0002a	eb 07		 jmp	 SHORT $L72113
$L72112:
  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L72113:
  00033	8b 45 ec	 mov	 eax, DWORD PTR tv69[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _pGraph$[ebp], eax

; 2950 :     if (pGraph == NULL) {

  00039	83 7d f8 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  0003d	75 07		 jne	 SHORT $L71040

; 2951 :         return E_OUTOFMEMORY;

  0003f	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00044	eb 4c		 jmp	 SHORT $L71036
$L71040:

; 2952 :     }
; 2953 : 
; 2954 :     HRESULT hr = pGraph->Load(pParser);

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  0004d	e8 00 00 00 00	 call	 ?Load@CGraph@@QAEJPAVCRiffParser@@@Z ; CGraph::Load
  00052	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 2955 : 
; 2956 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00055	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00058	83 c2 1c	 add	 edx, 28			; 0000001cH
  0005b	52		 push	 edx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2957 : 	if(*ppGraph)

  00062	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  00065	83 38 00	 cmp	 DWORD PTR [eax], 0
  00068	74 10		 je	 SHORT $L71043

; 2958 : 	{
; 2959 : 		(*ppGraph)->Release();

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _ppGraph$[ebp]
  0006d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	8b 12		 mov	 edx, DWORD PTR [edx]
  00076	51		 push	 ecx
  00077	ff 52 08	 call	 DWORD PTR [edx+8]
$L71043:

; 2960 : 	}
; 2961 : 	*ppGraph = pGraph;

  0007a	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx

; 2962 : 	LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00082	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00085	83 c2 1c	 add	 edx, 28			; 0000001cH
  00088	52		 push	 edx
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2963 : 	
; 2964 : 	return hr;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L71036:

; 2965 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?LoadGraph@CSegment@@QAEJPAVCRiffParser@@PAPAVCGraph@@@Z ENDP ; CSegment::LoadGraph
_TEXT	ENDS
PUBLIC	??_C@_0DJ@BFOKDOGK@Segment?5failed?5loading?5embedded?5@ ; `string'
EXTRN	??0CAudioPathConfig@@QAE@XZ:NEAR		; CAudioPathConfig::CAudioPathConfig
;	COMDAT ??_C@_0DJ@BFOKDOGK@Segment?5failed?5loading?5embedded?5@
CONST	SEGMENT
??_C@_0DJ@BFOKDOGK@Segment?5failed?5loading?5embedded?5@ DB 'Segment fail'
	DB	'ed loading embedded AudioPath Configuration', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadAudioPath@CSegment@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT
tv74 = -20
_this$ = -16
$T72118 = -12
_pPath$ = -8
_hr$ = -4
_pStream$ = 8
?LoadAudioPath@CSegment@@QAEJPAUIStream@@@Z PROC NEAR	; CSegment::LoadAudioPath, COMDAT
; _this$ = ecx

; 2968 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2969 : 	assert(pStream);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pStream$[ebp], 0
  0000d	75 14		 jne	 SHORT $L72117
  0000f	68 99 0b 00 00	 push	 2969			; 00000b99H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KCKPANJI@pStream?$AA@
  0001e	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L72117:

; 2970 : 
; 2971 :     CAudioPathConfig *pPath = new CAudioPathConfig;

  00023	68 6c 03 00 00	 push	 876			; 0000036cH
  00028	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f4	 mov	 DWORD PTR $T72118[ebp], eax
  00033	83 7d f4 00	 cmp	 DWORD PTR $T72118[ebp], 0
  00037	74 0d		 je	 SHORT $L72119
  00039	8b 4d f4	 mov	 ecx, DWORD PTR $T72118[ebp]
  0003c	e8 00 00 00 00	 call	 ??0CAudioPathConfig@@QAE@XZ ; CAudioPathConfig::CAudioPathConfig
  00041	89 45 ec	 mov	 DWORD PTR tv74[ebp], eax
  00044	eb 07		 jmp	 SHORT $L72120
$L72119:
  00046	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L72120:
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv74[ebp]
  00050	89 4d f8	 mov	 DWORD PTR _pPath$[ebp], ecx

; 2972 :     if (pPath == NULL) {

  00053	83 7d f8 00	 cmp	 DWORD PTR _pPath$[ebp], 0
  00057	75 0a		 jne	 SHORT $L71052

; 2973 :         return E_OUTOFMEMORY;

  00059	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0005e	e9 82 00 00 00	 jmp	 $L71047
$L71052:

; 2974 :     }
; 2975 : 
; 2976 :     HRESULT hr = pPath->Load(pStream);

  00063	8b 55 08	 mov	 edx, DWORD PTR _pStream$[ebp]
  00066	52		 push	 edx
  00067	8b 45 f8	 mov	 eax, DWORD PTR _pPath$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _pPath$[ebp]
  0006f	52		 push	 edx
  00070	ff 51 14	 call	 DWORD PTR [ecx+20]
  00073	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 2977 : 
; 2978 :     if (FAILED(hr))

  00076	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007a	7d 0f		 jge	 SHORT $L71056

; 2979 :     {
; 2980 :         Trace(1,"Segment failed loading embedded AudioPath Configuration\n");

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BFOKDOGK@Segment?5failed?5loading?5embedded?5@
  00081	6a 01		 push	 1
  00083	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00088	83 c4 08	 add	 esp, 8
$L71056:

; 2981 :     }
; 2982 : 
; 2983 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2984 : 	if(m_pAudioPathConfig)

  00098	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  0009f	74 12		 je	 SHORT $L71058

; 2985 : 	{
; 2986 : 		m_pAudioPathConfig->Release();

  000a1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  000ad	8b 00		 mov	 eax, DWORD PTR [eax]
  000af	52		 push	 edx
  000b0	ff 50 08	 call	 DWORD PTR [eax+8]
$L71058:

; 2987 : 	}
; 2988 : 	m_pAudioPathConfig = pPath;

  000b3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _pPath$[ebp]
  000b9	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 2989 :     if (m_dwVersion < 8) m_dwVersion = 8;

  000bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	83 b8 bc 03 00
	00 08		 cmp	 DWORD PTR [eax+956], 8
  000c6	73 0d		 jae	 SHORT $L71059
  000c8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	c7 81 bc 03 00
	00 08 00 00 00	 mov	 DWORD PTR [ecx+956], 8
$L71059:

; 2990 : 	LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000d5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	83 c2 1c	 add	 edx, 28			; 0000001cH
  000db	52		 push	 edx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2991 : 	
; 2992 : 	return hr;

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L71047:

; 2993 : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
?LoadAudioPath@CSegment@@QAEJPAUIStream@@@Z ENDP	; CSegment::LoadAudioPath
_TEXT	ENDS
PUBLIC	??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@ ; `string'
PUBLIC	??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@ ; `string'
PUBLIC	??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@ ; `string'
EXTRN	?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z:NEAR ; CInfo::GetDescriptor
;	COMDAT ?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB DB 'C'
	DB	'Segment::GetDescriptor', 00H		; `CSegment::GetDescriptor'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@
CONST	SEGMENT
??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@ DB '%s: Invali'
	DB	'd pointer pDesc', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
CONST	SEGMENT
??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@ DB 'offsetof(DM'
	DB	'US_OBJECTDESC, dwSize) == 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@ DB '%s@%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
CONST	SEGMENT
??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@ DB '%s: p'
	DB	'Desc does not point to as much memory as pDesc->dwSize indica'
	DB	'tes', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
CONST	SEGMENT
??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@ DB '%'
	DB	's: pDesc->dwSize is too small', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_this$ = 8
_pDesc$ = 12
?GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CSegment::GetDescriptor, COMDAT

; 2999 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3000 : 	// Argument validation
; 3001 : 	V_INAME(CSegment::GetDescriptor);
; 3002 :     V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

  00003	68 50 03 00 00	 push	 848			; 00000350H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71067
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71067:

; 3003 : #ifdef DXAPI
; 3004 :     if (m_fZombie)
; 3005 : 	{
; 3006 : 		Trace(2, "Warning: Call of IDirectMusicSegment::GetDescriptor after the segment has been garbage collected.\n");
; 3007 : 		return DMUS_S_GARBAGE_COLLECTED;
; 3008 : 	}
; 3009 : #endif
; 3010 :     if (pDesc->dwSize)

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00031	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00034	0f 84 a3 00 00
	00		 je	 $L71069

; 3011 :     {
; 3012 : 	    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

  0003a	33 d2		 xor	 edx, edx
  0003c	85 d2		 test	 edx, edx
  0003e	74 23		 je	 SHORT $L71072
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
  00045	68 c4 0b 00 00	 push	 3012			; 00000bc4H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
  00054	6a ff		 push	 -1
  00056	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005b	83 c4 14	 add	 esp, 20			; 00000014H
  0005e	e8 00 00 00 00	 call	 _DebugBreak@0
$L71072:
  00063	6a 04		 push	 4
  00065	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0006e	85 c0		 test	 eax, eax
  00070	74 19		 je	 SHORT $L71076
  00072	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  0007c	6a ff		 push	 -1
  0007e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 _DebugBreak@0
$L71076:
  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0008e	81 39 50 03 00
	00		 cmp	 DWORD PTR [ecx], 848	; 00000350H
  00094	73 19		 jae	 SHORT $L71079
  00096	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
  000a0	6a ff		 push	 -1
  000a2	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	e8 00 00 00 00	 call	 _DebugBreak@0
$L71079:
  000af	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
  000b4	50		 push	 eax
  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  000be	85 c0		 test	 eax, eax
  000c0	74 19		 je	 SHORT $L71081
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  000cc	6a ff		 push	 -1
  000ce	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	e8 00 00 00 00	 call	 _DebugBreak@0
$L71081:

; 3013 :     }
; 3014 :     else

  000db	eb 09		 jmp	 SHORT $L71082
$L71069:

; 3015 :     {
; 3016 :         pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

  000dd	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000e0	c7 02 50 03 00
	00		 mov	 DWORD PTR [edx], 848	; 00000350H
$L71082:

; 3017 :     }
; 3018 : 
; 3019 :     return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicSegment);

  000e6	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicSegment
  000eb	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  000f8	e8 00 00 00 00	 call	 ?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z ; CInfo::GetDescriptor

; 3020 : }

  000fd	5d		 pop	 ebp
  000fe	c2 08 00	 ret	 8
?GetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z ENDP ; CSegment::GetDescriptor
_TEXT	ENDS
EXTRN	?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z:NEAR ; CInfo::SetDescriptor
;	COMDAT ?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB DB 'C'
	DB	'Segment::SetDescriptor', 00H		; `CSegment::SetDescriptor'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_this$ = 8
_pDesc$ = 12
?SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CSegment::SetDescriptor, COMDAT

; 3023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3024 : 	// Argument validation
; 3025 : 	V_INAME(CSegment::SetDescriptor);
; 3026 :     V_PTR_READ(pDesc, DMUS_OBJECTDESC);

  00003	68 50 03 00 00	 push	 848			; 00000350H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71091
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71091:

; 3027 : #ifdef DXAPI
; 3028 :     if (m_fZombie)
; 3029 : 	{
; 3030 : 		Trace(2, "Warning: Call of IDirectMusicSegment::SetDescriptor after the segment has been garbage collected.\n");
; 3031 : 		return DMUS_S_GARBAGE_COLLECTED;
; 3032 : 	}
; 3033 : #endif
; 3034 : 	if (pDesc->dwSize)

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00031	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00034	0f 84 a1 00 00
	00		 je	 $L71092

; 3035 :     {
; 3036 : 	    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

  0003a	33 d2		 xor	 edx, edx
  0003c	85 d2		 test	 edx, edx
  0003e	74 23		 je	 SHORT $L71095
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
  00045	68 dc 0b 00 00	 push	 3036			; 00000bdcH
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
  00054	6a ff		 push	 -1
  00056	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005b	83 c4 14	 add	 esp, 20			; 00000014H
  0005e	e8 00 00 00 00	 call	 _DebugBreak@0
$L71095:
  00063	6a 04		 push	 4
  00065	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0006e	85 c0		 test	 eax, eax
  00070	74 19		 je	 SHORT $L71097
  00072	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  0007c	6a ff		 push	 -1
  0007e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 _DebugBreak@0
$L71097:
  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0008e	81 39 50 03 00
	00		 cmp	 DWORD PTR [ecx], 848	; 00000350H
  00094	73 19		 jae	 SHORT $L71099
  00096	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
  000a0	6a ff		 push	 -1
  000a2	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	e8 00 00 00 00	 call	 _DebugBreak@0
$L71099:
  000af	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
  000b4	50		 push	 eax
  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000be	85 c0		 test	 eax, eax
  000c0	74 19		 je	 SHORT $L71092
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  000cc	6a ff		 push	 -1
  000ce	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	e8 00 00 00 00	 call	 _DebugBreak@0
$L71092:

; 3037 :     }
; 3038 : 	
; 3039 : 	return m_Info.SetDescriptor(pDesc);

  000db	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000de	52		 push	 edx
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  000e8	e8 00 00 00 00	 call	 ?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z ; CInfo::SetDescriptor

; 3040 : }

  000ed	5d		 pop	 ebp
  000ee	c2 08 00	 ret	 8
?SetDescriptor@CSegment@@UAGJPAU_DMUS_OBJECTDESC@@@Z ENDP ; CSegment::SetDescriptor
_TEXT	ENDS
PUBLIC	??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@CALKDLEC@Error?3?5Segment?5unable?5to?5parse?5f@ ; `string'
EXTRN	?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z:NEAR ; CInfo::ParseDescriptor
;	COMDAT ?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB DB 'C'
	DB	'Segment::ParseDescriptor', 00H		; `CSegment::ParseDescriptor'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@
CONST	SEGMENT
??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@ DB '%s: Inva'
	DB	'lid pointer pStream', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CALKDLEC@Error?3?5Segment?5unable?5to?5parse?5f@
CONST	SEGMENT
??_C@_0DH@CALKDLEC@Error?3?5Segment?5unable?5to?5parse?5f@ DB 'Error: Seg'
	DB	'ment unable to parse file - unknown format.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_pObject$71187 = -44
_li$ = -40
_hr$ = -32
_dwRead$ = -28
_ul$ = -24
_dwSavedPos$ = -12
_hret$ = -8
_type$ = -4
_this$ = 8
_pStream$ = 12
_pDesc$ = 16
?ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CSegment::ParseDescriptor, COMDAT

; 3043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 3044 : 	V_INAME(CSegment::ParseDescriptor);
; 3045 : 	V_INTERFACE(pStream);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71109
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71109:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L71113
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L71113:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L71115
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NCKFGNEN@?$CFs?3?5Invalid?5pointer?5pStream?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L71115:

; 3046 :     V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

  00082	68 50 03 00 00	 push	 848			; 00000350H
  00087	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00090	85 c0		 test	 eax, eax
  00092	74 19		 je	 SHORT $L71117
  00094	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@MFAHELOI@?$CFs?3?5Invalid?5pointer?5pDesc?6?$AA@
  0009e	6a ff		 push	 -1
  000a0	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	e8 00 00 00 00	 call	 _DebugBreak@0
$L71117:

; 3047 :     if (pDesc->dwSize)

  000ad	8b 4d 10	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000b0	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000b3	0f 84 a3 00 00
	00		 je	 $L71118

; 3048 :     {
; 3049 : 	    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

  000b9	33 d2		 xor	 edx, edx
  000bb	85 d2		 test	 edx, edx
  000bd	74 23		 je	 SHORT $L71121
  000bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
  000c4	68 e9 0b 00 00	 push	 3049			; 00000be9H
  000c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@GONKBKOB@c?3?2xbox?2private?2windows?2directx?2@
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
  000d3	6a ff		 push	 -1
  000d5	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000da	83 c4 14	 add	 esp, 20			; 00000014H
  000dd	e8 00 00 00 00	 call	 _DebugBreak@0
$L71121:
  000e2	6a 04		 push	 4
  000e4	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000ed	85 c0		 test	 eax, eax
  000ef	74 19		 je	 SHORT $L71123
  000f1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  000fb	6a ff		 push	 -1
  000fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	e8 00 00 00 00	 call	 _DebugBreak@0
$L71123:
  0010a	8b 4d 10	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0010d	81 39 50 03 00
	00		 cmp	 DWORD PTR [ecx], 848	; 00000350H
  00113	73 19		 jae	 SHORT $L71125
  00115	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
  0011f	6a ff		 push	 -1
  00121	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH
  00129	e8 00 00 00 00	 call	 _DebugBreak@0
$L71125:
  0012e	8b 55 10	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00131	8b 02		 mov	 eax, DWORD PTR [edx]
  00133	50		 push	 eax
  00134	8b 4d 10	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0013d	85 c0		 test	 eax, eax
  0013f	74 19		 je	 SHORT $L71126
  00141	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00146	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  0014b	6a ff		 push	 -1
  0014d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
  00155	e8 00 00 00 00	 call	 _DebugBreak@0
$L71126:

; 3050 :     }
; 3051 :     else

  0015a	eb 09		 jmp	 SHORT $L71127
$L71118:

; 3052 :     {
; 3053 :         pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

  0015c	8b 55 10	 mov	 edx, DWORD PTR _pDesc$[ebp]
  0015f	c7 02 50 03 00
	00		 mov	 DWORD PTR [edx], 848	; 00000350H
$L71127:

; 3054 :     }
; 3055 : #ifdef DXAPI
; 3056 :     if (m_fZombie)
; 3057 : 	{
; 3058 : 		Trace(2, "Warning: Call of IDirectMusicSegment::ParseDescriptor after the segment has been garbage collected.\n");
; 3059 : 		return DMUS_S_GARBAGE_COLLECTED;
; 3060 : 	}
; 3061 : #endif
; 3062 : 	HRESULT hret = E_FAIL;

  00165	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hret$[ebp], -2147467259 ; 80004005H

; 3063 : 	// Save stream's current position
; 3064 : 	LARGE_INTEGER li;
; 3065 :     ULARGE_INTEGER ul;
; 3066 : 
; 3067 :     li.HighPart = 0;

  0016c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 3068 :     li.LowPart = 0;

  00173	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _li$[ebp], 0

; 3069 : 
; 3070 :     HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ul);

  0017a	8d 45 e8	 lea	 eax, DWORD PTR _ul$[ebp]
  0017d	50		 push	 eax
  0017e	6a 01		 push	 1
  00180	8b 4d dc	 mov	 ecx, DWORD PTR _li$[ebp+4]
  00183	51		 push	 ecx
  00184	8b 55 d8	 mov	 edx, DWORD PTR _li$[ebp]
  00187	52		 push	 edx
  00188	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  0018b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018d	8b 55 0c	 mov	 edx, DWORD PTR _pStream$[ebp]
  00190	52		 push	 edx
  00191	ff 51 14	 call	 DWORD PTR [ecx+20]
  00194	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 3071 :     
; 3072 : 	if(FAILED(hr))

  00197	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0019b	7d 08		 jge	 SHORT $L71135

; 3073 : 	{
; 3074 : 		return hr;	

  0019d	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  001a0	e9 d3 01 00 00	 jmp	 $L71105
$L71135:

; 3075 :     }
; 3076 : 	pDesc->dwValidData = 0;

  001a5	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  001a8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3077 : 	DWORD dwSavedPos = ul.LowPart;

  001af	8b 4d e8	 mov	 ecx, DWORD PTR _ul$[ebp]
  001b2	89 4d f4	 mov	 DWORD PTR _dwSavedPos$[ebp], ecx

; 3078 :     
; 3079 : 	// Read first 4 bytes to determine what type of stream we
; 3080 : 	// have been passed
; 3081 : 
; 3082 : 	FOURCC type;
; 3083 : 	DWORD dwRead;
; 3084 : 	hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);

  001b5	8d 55 e4	 lea	 edx, DWORD PTR _dwRead$[ebp]
  001b8	52		 push	 edx
  001b9	6a 04		 push	 4
  001bb	8d 45 fc	 lea	 eax, DWORD PTR _type$[ebp]
  001be	50		 push	 eax
  001bf	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  001c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c4	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  001c7	50		 push	 eax
  001c8	ff 52 0c	 call	 DWORD PTR [edx+12]
  001cb	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 3085 : 	
; 3086 : 	if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))

  001ce	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001d2	0f 8c 49 01 00
	00		 jl	 $L71142
  001d8	83 7d e4 04	 cmp	 DWORD PTR _dwRead$[ebp], 4
  001dc	0f 85 3f 01 00
	00		 jne	 $L71142

; 3087 : 	{
; 3088 : 		// Check for a RIFF file
; 3089 : 		if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))

  001e2	81 7d fc 52 49
	46 46		 cmp	 DWORD PTR _type$[ebp], 1179011410 ; 46464952H
  001e9	0f 85 32 01 00
	00		 jne	 $L71142

; 3090 : 		{
; 3091 : 			// Check to see if what type of RIFF file we have
; 3092 : 			li.HighPart = 0;

  001ef	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 3093 : 			li.LowPart = dwSavedPos + 8; // Length needed to seek to form type of RIFF chunk

  001f6	8b 4d f4	 mov	 ecx, DWORD PTR _dwSavedPos$[ebp]
  001f9	83 c1 08	 add	 ecx, 8
  001fc	89 4d d8	 mov	 DWORD PTR _li$[ebp], ecx

; 3094 : 
; 3095 : 			hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);

  001ff	6a 00		 push	 0
  00201	6a 00		 push	 0
  00203	8b 55 dc	 mov	 edx, DWORD PTR _li$[ebp+4]
  00206	52		 push	 edx
  00207	8b 45 d8	 mov	 eax, DWORD PTR _li$[ebp]
  0020a	50		 push	 eax
  0020b	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00213	50		 push	 eax
  00214	ff 52 14	 call	 DWORD PTR [edx+20]
  00217	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 3096 : 			if(SUCCEEDED(hr))

  0021a	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0021e	7c 19		 jl	 SHORT $L71153

; 3097 : 			{
; 3098 : 				hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);

  00220	8d 4d e4	 lea	 ecx, DWORD PTR _dwRead$[ebp]
  00223	51		 push	 ecx
  00224	6a 04		 push	 4
  00226	8d 55 fc	 lea	 edx, DWORD PTR _type$[ebp]
  00229	52		 push	 edx
  0022a	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	8b 55 0c	 mov	 edx, DWORD PTR _pStream$[ebp]
  00232	52		 push	 edx
  00233	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00236	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
$L71153:

; 3099 : 			}
; 3100 : 
; 3101 : 			if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))

  00239	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0023d	0f 8c de 00 00
	00		 jl	 $L71142
  00243	83 7d e4 04	 cmp	 DWORD PTR _dwRead$[ebp], 4
  00247	0f 85 d4 00 00
	00		 jne	 $L71142

; 3102 : 			{
; 3103 : 				if(type == DMUS_FOURCC_SEGMENT_FORM)	// We have a DirectMusic segment

  0024d	81 7d fc 44 4d
	53 47		 cmp	 DWORD PTR _type$[ebp], 1196641604 ; 47534d44H
  00254	75 53		 jne	 SHORT $L71166

; 3104 : 				{
; 3105 : 					// Since we now know what type of stream we need to 
; 3106 : 					// seek back to saved position
; 3107 : 					li.HighPart = 0;

  00256	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 3108 : 					li.LowPart = dwSavedPos;

  0025d	8b 45 f4	 mov	 eax, DWORD PTR _dwSavedPos$[ebp]
  00260	89 45 d8	 mov	 DWORD PTR _li$[ebp], eax

; 3109 : 					hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);

  00263	6a 00		 push	 0
  00265	6a 00		 push	 0
  00267	8b 4d dc	 mov	 ecx, DWORD PTR _li$[ebp+4]
  0026a	51		 push	 ecx
  0026b	8b 55 d8	 mov	 edx, DWORD PTR _li$[ebp]
  0026e	52		 push	 edx
  0026f	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00272	8b 08		 mov	 ecx, DWORD PTR [eax]
  00274	8b 55 0c	 mov	 edx, DWORD PTR _pStream$[ebp]
  00277	52		 push	 edx
  00278	ff 51 14	 call	 DWORD PTR [ecx+20]
  0027b	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 3110 : 					if( SUCCEEDED(hr) ) // should always succeed.

  0027e	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00282	7c 23		 jl	 SHORT $L71168

; 3111 : 					{
; 3112 :                         hret = m_Info.ParseDescriptor(pStream,pDesc,DMUS_FOURCC_SEGMENT_FORM,CLSID_DirectMusicSegment);

  00284	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicSegment
  00289	68 44 4d 53 47	 push	 1196641604		; 47534d44H
  0028e	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00291	50		 push	 eax
  00292	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00295	51		 push	 ecx
  00296	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00299	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  0029f	e8 00 00 00 00	 call	 ?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z ; CInfo::ParseDescriptor
  002a4	89 45 f8	 mov	 DWORD PTR _hret$[ebp], eax
$L71168:

; 3113 : 					}
; 3114 : 				}
; 3115 : #ifdef DXAPI
; 3116 :                 else if(type == FOURCC_SECTION_FORM)	// We have section
; 3117 : 				{			
; 3118 : 					long lTemp;
; 3119 : 					hr = pStream->Read(&lTemp, sizeof(long), &dwRead);
; 3120 : 					if( lTemp == mmioFOURCC('s','e','c','n') )
; 3121 : 					{
; 3122 : 						hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // length
; 3123 : 						hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // time
; 3124 : 						if( SUCCEEDED(hr) && (dwRead == sizeof(long) ))
; 3125 : 						{
; 3126 : 							hr = pStream->Read(&pDesc->wszName, sizeof(wchar_t)*16, &dwRead);
; 3127 : 							if(SUCCEEDED(hr) && (dwRead == sizeof(wchar_t)*16))
; 3128 : 							{
; 3129 : 								pDesc->dwValidData |= DMUS_OBJ_NAME;
; 3130 : 							}
; 3131 : 						}
; 3132 : 						hret = S_OK;
; 3133 : 					}
; 3134 : 				}
; 3135 : #endif
; 3136 : 				else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file

  002a7	eb 78		 jmp	 SHORT $L71142
$L71166:
  002a9	81 7d fc 57 41
	56 45		 cmp	 DWORD PTR _type$[ebp], 1163280727 ; 45564157H
  002b0	75 6f		 jne	 SHORT $L71142

; 3137 : 				{
; 3138 :                     // Create a wave object and have it parse the file.
; 3139 :                     IDirectMusicObject *pObject;
; 3140 :                     hret = DirectMusicCreateInstance(CLSID_DirectSoundWave,NULL,
; 3141 :                         IID_IDirectMusicObject,(void **) &pObject);

  002b2	8d 55 d4	 lea	 edx, DWORD PTR _pObject$71187[ebp]
  002b5	52		 push	 edx
  002b6	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicObject
  002bb	6a 00		 push	 0
  002bd	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectSoundWave
  002c2	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
  002c7	89 45 f8	 mov	 DWORD PTR _hret$[ebp], eax

; 3142 :                     if(SUCCEEDED(hret))

  002ca	83 7d f8 00	 cmp	 DWORD PTR _hret$[ebp], 0
  002ce	7c 51		 jl	 SHORT $L71142

; 3143 :                     {
; 3144 : 					    // seek back to saved position
; 3145 : 					    li.HighPart = 0;

  002d0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 3146 : 					    li.LowPart = dwSavedPos;

  002d7	8b 45 f4	 mov	 eax, DWORD PTR _dwSavedPos$[ebp]
  002da	89 45 d8	 mov	 DWORD PTR _li$[ebp], eax

; 3147 : 					    hret = pStream->Seek(li, STREAM_SEEK_SET, NULL);

  002dd	6a 00		 push	 0
  002df	6a 00		 push	 0
  002e1	8b 4d dc	 mov	 ecx, DWORD PTR _li$[ebp+4]
  002e4	51		 push	 ecx
  002e5	8b 55 d8	 mov	 edx, DWORD PTR _li$[ebp]
  002e8	52		 push	 edx
  002e9	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  002ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ee	8b 55 0c	 mov	 edx, DWORD PTR _pStream$[ebp]
  002f1	52		 push	 edx
  002f2	ff 51 14	 call	 DWORD PTR [ecx+20]
  002f5	89 45 f8	 mov	 DWORD PTR _hret$[ebp], eax

; 3148 :                         if (SUCCEEDED(hret))

  002f8	83 7d f8 00	 cmp	 DWORD PTR _hret$[ebp], 0
  002fc	7c 17		 jl	 SHORT $L71192

; 3149 :                         {
; 3150 :                             hret = pObject->ParseDescriptor(pStream,pDesc);

  002fe	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00301	50		 push	 eax
  00302	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00305	51		 push	 ecx
  00306	8b 55 d4	 mov	 edx, DWORD PTR _pObject$71187[ebp]
  00309	8b 02		 mov	 eax, DWORD PTR [edx]
  0030b	8b 4d d4	 mov	 ecx, DWORD PTR _pObject$71187[ebp]
  0030e	51		 push	 ecx
  0030f	ff 50 14	 call	 DWORD PTR [eax+20]
  00312	89 45 f8	 mov	 DWORD PTR _hret$[ebp], eax
$L71192:

; 3151 :                         }
; 3152 :                         pObject->Release();

  00315	8b 55 d4	 mov	 edx, DWORD PTR _pObject$71187[ebp]
  00318	8b 02		 mov	 eax, DWORD PTR [edx]
  0031a	8b 4d d4	 mov	 ecx, DWORD PTR _pObject$71187[ebp]
  0031d	51		 push	 ecx
  0031e	ff 50 08	 call	 DWORD PTR [eax+8]
$L71142:

; 3153 :                     }
; 3154 : 				}
; 3155 : #ifdef DXAPI
; 3156 : 				// Check to see if we have a MIDI file
; 3157 : 				else
; 3158 : 				{
; 3159 : 					li.HighPart = 0;
; 3160 : 					li.LowPart = dwSavedPos + 20; // Length needed to seek to start of normal MIDI file
; 3161 : 									 // contained within the Riff chunk
; 3162 : 
; 3163 : 					FOURCC type;	
; 3164 : 					DWORD dwRead;
; 3165 : 
; 3166 : 					hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
; 3167 : 					
; 3168 : 					if(SUCCEEDED(hr))
; 3169 : 					{
; 3170 : 						hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
; 3171 : 					}
; 3172 : 
; 3173 : 					if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
; 3174 : 					{
; 3175 : 						if(type == mmioFOURCC( 'M', 'T', 'h', 'd' ))
; 3176 : 						{
; 3177 : 							hret = S_OK;
; 3178 : 						}
; 3179 : 					}
; 3180 : 				}
; 3181 : #endif
; 3182 : 			}
; 3183 : 		}
; 3184 : #ifdef DXAPI
; 3185 : 		// Check for a template file
; 3186 : 		else if(type == mmioFOURCC('L', 'P', 'T', 's'))
; 3187 : 		{
; 3188 : 			hret = S_OK;
; 3189 : 		}
; 3190 : 		// Check for normal MIDI file
; 3191 : 		else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
; 3192 : 	    {
; 3193 : 			hret = S_OK;
; 3194 : 		}
; 3195 : #endif
; 3196 :     }
; 3197 :     if (SUCCEEDED(hret))

  00321	83 7d f8 00	 cmp	 DWORD PTR _hret$[ebp], 0
  00325	7c 36		 jl	 SHORT $L71194

; 3198 :     {
; 3199 :         pDesc->dwValidData |= DMUS_OBJ_CLASS;

  00327	8b 55 10	 mov	 edx, DWORD PTR _pDesc$[ebp]
  0032a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0032d	83 c8 02	 or	 eax, 2
  00330	8b 4d 10	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00333	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3200 : 		pDesc->guidClass = CLSID_DirectMusicSegment;

  00336	8b 55 10	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00339	83 c2 18	 add	 edx, 24			; 00000018H
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSegment
  00341	89 02		 mov	 DWORD PTR [edx], eax
  00343	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectMusicSegment+4
  00349	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0034c	a1 08 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSegment+8
  00351	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00354	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectMusicSegment+12
  0035a	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$L71194:

; 3201 :     }
; 3202 : #ifdef DBG
; 3203 :     if (hret == E_FAIL)

  0035d	81 7d f8 05 40
	00 80		 cmp	 DWORD PTR _hret$[ebp], -2147467259 ; 80004005H
  00364	75 0f		 jne	 SHORT $L71196

; 3204 :     {
; 3205 :         Trace(1,"Error: Segment unable to parse file - unknown format.\n");

  00366	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CALKDLEC@Error?3?5Segment?5unable?5to?5parse?5f@
  0036b	6a 01		 push	 1
  0036d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00372	83 c4 08	 add	 esp, 8
$L71196:

; 3206 :     }
; 3207 : #endif
; 3208 : 	return hret;

  00375	8b 45 f8	 mov	 eax, DWORD PTR _hret$[ebp]
$L71105:

; 3209 : }

  00378	8b e5		 mov	 esp, ebp
  0037a	5d		 pop	 ebp
  0037b	c2 0c 00	 ret	 12			; 0000000cH
?ParseDescriptor@CSegment@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z ENDP ; CSegment::ParseDescriptor
_TEXT	ENDS
PUBLIC	?Clear@CSegmentList@@QAEXXZ			; CSegmentList::Clear
PUBLIC	?RemoveHead@CSegmentList@@QAEPAVCSegment@@XZ	; CSegmentList::RemoveHead
; Function compile flags: /Odt
;	COMDAT ?Clear@CSegmentList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8
_pSeg$ = -4
?Clear@CSegmentList@@QAEXXZ PROC NEAR			; CSegmentList::Clear, COMDAT
; _this$ = ecx

; 3212 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L71203:

; 3213 :     CSegment *pSeg;
; 3214 :     while (pSeg = RemoveHead())

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CSegmentList@@QAEPAVCSegment@@XZ ; CSegmentList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pSeg$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pSeg$[ebp], 0
  00018	74 28		 je	 SHORT $L71200

; 3215 :     {
; 3216 :         pSeg->SetNext(NULL);

  0001a	6a 00		 push	 0
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0001f	83 c1 10	 add	 ecx, 16			; 00000010H
  00022	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 3217 :         pSeg->m_pSong = NULL;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0002a	c7 80 c8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+968], 0

; 3218 :         pSeg->Release();

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00037	8b 11		 mov	 edx, DWORD PTR [ecx]
  00039	8b 45 fc	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0003c	50		 push	 eax
  0003d	ff 52 08	 call	 DWORD PTR [edx+8]

; 3219 :     }

  00040	eb c7		 jmp	 SHORT $L71203
$L71200:

; 3220 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?Clear@CSegmentList@@QAEXXZ ENDP			; CSegmentList::Clear
_TEXT	ENDS
PUBLIC	??0PrivateTempo@@QAE@XZ				; PrivateTempo::PrivateTempo
PUBLIC	?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z	; CSegment::MusicToReferenceTime
PUBLIC	?ConvertToReference@@YG_JJN@Z			; ConvertToReference
EXTRN	_GUID_PrivateTempoParam:BYTE
EXTRN	__fltused:NEAR
; Function compile flags: /Odt
;	COMDAT ?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z
_TEXT	SEGMENT
_this$ = -68
_dbl$ = -64
_hr$ = -52
_Tempo$ = -48
_mtTempo$ = -20
_rtTempo$ = -16
_mtNext$ = -4
_mtTime$ = 8
_prtTime$ = 12
?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z PROC NEAR	; CSegment::MusicToReferenceTime, COMDAT
; _this$ = ecx

; 3247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 3248 :     double dbl = 120;

  00009	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _dbl$[ebp], 0
  00010	c7 45 c4 00 00
	5e 40		 mov	 DWORD PTR _dbl$[ebp+4], 1079902208 ; 405e0000H

; 3249 :     MUSIC_TIME mtTempo = 0;

  00017	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mtTempo$[ebp], 0

; 3250 :     REFERENCE_TIME rtTempo = 0;

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rtTempo$[ebp], 0
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rtTempo$[ebp+4], 0

; 3251 :     MUSIC_TIME mtNext = 0;

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mtNext$[ebp], 0

; 3252 :     PrivateTempo Tempo;

  00033	8d 4d d0	 lea	 ecx, DWORD PTR _Tempo$[ebp]
  00036	e8 00 00 00 00	 call	 ??0PrivateTempo@@QAE@XZ	; PrivateTempo::PrivateTempo
$L71230:

; 3253 :     HRESULT hr;
; 3254 : 
; 3255 :     do
; 3256 :     {
; 3257 :         hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );

  0003b	8d 45 d0	 lea	 eax, DWORD PTR _Tempo$[ebp]
  0003e	50		 push	 eax
  0003f	8d 4d fc	 lea	 ecx, DWORD PTR _mtNext$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 ec	 mov	 edx, DWORD PTR _mtTempo$[ebp]
  00046	52		 push	 edx
  00047	6a 00		 push	 0
  00049	6a ff		 push	 -1
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PrivateTempoParam
  00050	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00058	52		 push	 edx
  00059	ff 51 6c	 call	 DWORD PTR [ecx+108]
  0005c	89 45 cc	 mov	 DWORD PTR _hr$[ebp], eax

; 3258 :         if (hr == S_OK)

  0005f	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00063	75 4b		 jne	 SHORT $L71231

; 3259 :         {
; 3260 :             dbl = Tempo.dblTempo;

  00065	8b 45 d0	 mov	 eax, DWORD PTR _Tempo$[ebp]
  00068	89 45 c0	 mov	 DWORD PTR _dbl$[ebp], eax
  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _Tempo$[ebp+4]
  0006e	89 4d c4	 mov	 DWORD PTR _dbl$[ebp+4], ecx

; 3261 :             if (Tempo.fLast || mtTempo + mtNext >= mtTime) break;

  00071	0f b6 55 e0	 movzx	 edx, BYTE PTR _Tempo$[ebp+16]
  00075	85 d2		 test	 edx, edx
  00077	75 0b		 jne	 SHORT $L71237
  00079	8b 45 ec	 mov	 eax, DWORD PTR _mtTempo$[ebp]
  0007c	03 45 fc	 add	 eax, DWORD PTR _mtNext$[ebp]
  0007f	3b 45 08	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00082	7c 02		 jl	 SHORT $L71236
$L71237:
  00084	eb 30		 jmp	 SHORT $L71232
$L71236:

; 3262 :             rtTempo += ConvertToReference(mtNext, dbl);

  00086	8b 4d c4	 mov	 ecx, DWORD PTR _dbl$[ebp+4]
  00089	51		 push	 ecx
  0008a	8b 55 c0	 mov	 edx, DWORD PTR _dbl$[ebp]
  0008d	52		 push	 edx
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _mtNext$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?ConvertToReference@@YG_JJN@Z ; ConvertToReference
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _rtTempo$[ebp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b 45 f4	 mov	 eax, DWORD PTR _rtTempo$[ebp+4]
  0009f	13 c2		 adc	 eax, edx
  000a1	89 4d f0	 mov	 DWORD PTR _rtTempo$[ebp], ecx
  000a4	89 45 f4	 mov	 DWORD PTR _rtTempo$[ebp+4], eax

; 3263 :             mtTempo += mtNext;

  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _mtTempo$[ebp]
  000aa	03 4d fc	 add	 ecx, DWORD PTR _mtNext$[ebp]
  000ad	89 4d ec	 mov	 DWORD PTR _mtTempo$[ebp], ecx
$L71231:

; 3264 :         }
; 3265 : 
; 3266 :     } while (hr == S_OK);

  000b0	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	74 85		 je	 SHORT $L71230
$L71232:

; 3267 : 
; 3268 :     *prtTime = rtTempo + ConvertToReference(mtTime - mtTempo, dbl);

  000b6	8b 55 c4	 mov	 edx, DWORD PTR _dbl$[ebp+4]
  000b9	52		 push	 edx
  000ba	8b 45 c0	 mov	 eax, DWORD PTR _dbl$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000c1	2b 4d ec	 sub	 ecx, DWORD PTR _mtTempo$[ebp]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 ?ConvertToReference@@YG_JJN@Z ; ConvertToReference
  000ca	8b 4d f0	 mov	 ecx, DWORD PTR _rtTempo$[ebp]
  000cd	03 c8		 add	 ecx, eax
  000cf	8b 45 f4	 mov	 eax, DWORD PTR _rtTempo$[ebp+4]
  000d2	13 c2		 adc	 eax, edx
  000d4	8b 55 0c	 mov	 edx, DWORD PTR _prtTime$[ebp]
  000d7	89 0a		 mov	 DWORD PTR [edx], ecx
  000d9	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3269 :     return S_OK;

  000dc	33 c0		 xor	 eax, eax

; 3270 : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z ENDP	; CSegment::MusicToReferenceTime
_TEXT	ENDS
EXTRN	__alldiv:NEAR
EXTRN	__ftol2:NEAR
; Function compile flags: /Odt
;	COMDAT ?ConvertToReference@@YG_JJN@Z
_TEXT	SEGMENT
_rtTemp$ = -8
_mtSpan$ = 8
_dblTempo$ = 12
?ConvertToReference@@YG_JJN@Z PROC NEAR			; ConvertToReference, COMDAT

; 3223 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3224 :     REFERENCE_TIME rtTemp = mtSpan;

  00006	8b 45 08	 mov	 eax, DWORD PTR _mtSpan$[ebp]
  00009	99		 cdq
  0000a	89 45 f8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  0000d	89 55 fc	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 3225 :     rtTemp *= 600000000;

  00010	6a 00		 push	 0
  00012	68 00 46 c3 23	 push	 600000000		; 23c34600H
  00017	8b 45 fc	 mov	 eax, DWORD PTR _rtTemp$[ebp+4]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _rtTemp$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 __allmul
  00024	89 45 f8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  00027	89 55 fc	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 3226 :     rtTemp += (DMUS_PPQ / 2);

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _rtTemp$[ebp]
  0002d	81 c2 80 01 00
	00		 add	 edx, 384		; 00000180H
  00033	8b 45 fc	 mov	 eax, DWORD PTR _rtTemp$[ebp+4]
  00036	83 d0 00	 adc	 eax, 0
  00039	89 55 f8	 mov	 DWORD PTR _rtTemp$[ebp], edx
  0003c	89 45 fc	 mov	 DWORD PTR _rtTemp$[ebp+4], eax

; 3227 :     rtTemp /= DMUS_PPQ;

  0003f	6a 00		 push	 0
  00041	68 00 03 00 00	 push	 768			; 00000300H
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _rtTemp$[ebp+4]
  00049	51		 push	 ecx
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _rtTemp$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 __alldiv
  00053	89 45 f8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  00056	89 55 fc	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 3228 :     rtTemp = (REFERENCE_TIME)(rtTemp / dblTempo);

  00059	df 6d f8	 fild	 QWORD PTR _rtTemp$[ebp]
  0005c	dc 75 0c	 fdiv	 QWORD PTR _dblTempo$[ebp]
  0005f	e8 00 00 00 00	 call	 __ftol2
  00064	89 45 f8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  00067	89 55 fc	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 3229 :     return rtTemp;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _rtTemp$[ebp]
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _rtTemp$[ebp+4]

; 3230 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 0c 00	 ret	 12			; 0000000cH
?ConvertToReference@@YG_JJN@Z ENDP			; ConvertToReference
_TEXT	ENDS
PUBLIC	?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z	; CSegment::ReferenceToMusicTime
PUBLIC	?ConvertToMusic@@YGJ_JN@Z			; ConvertToMusic
; Function compile flags: /Odt
;	COMDAT ?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z
_TEXT	SEGMENT
_this$ = -76
_rtNext$71257 = -72
_dbl$ = -64
_hr$ = -52
_Tempo$ = -48
_mtTempo$ = -20
_rtTempo$ = -16
_mtNext$ = -4
_rtTime$ = 8
_pmtTime$ = 16
?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z PROC NEAR	; CSegment::ReferenceToMusicTime, COMDAT
; _this$ = ecx

; 3273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 3274 :     double dbl = 120;

  00009	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _dbl$[ebp], 0
  00010	c7 45 c4 00 00
	5e 40		 mov	 DWORD PTR _dbl$[ebp+4], 1079902208 ; 405e0000H

; 3275 :     MUSIC_TIME mtTempo = 0;

  00017	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mtTempo$[ebp], 0

; 3276 :     REFERENCE_TIME rtTempo = 0;

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rtTempo$[ebp], 0
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rtTempo$[ebp+4], 0

; 3277 :     MUSIC_TIME mtNext = 0;

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mtNext$[ebp], 0

; 3278 :     PrivateTempo Tempo;

  00033	8d 4d d0	 lea	 ecx, DWORD PTR _Tempo$[ebp]
  00036	e8 00 00 00 00	 call	 ??0PrivateTempo@@QAE@XZ	; PrivateTempo::PrivateTempo
$L71251:

; 3279 :     HRESULT hr;
; 3280 : 
; 3281 :     do
; 3282 :     {
; 3283 :         hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );

  0003b	8d 45 d0	 lea	 eax, DWORD PTR _Tempo$[ebp]
  0003e	50		 push	 eax
  0003f	8d 4d fc	 lea	 ecx, DWORD PTR _mtNext$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 ec	 mov	 edx, DWORD PTR _mtTempo$[ebp]
  00046	52		 push	 edx
  00047	6a 00		 push	 0
  00049	6a ff		 push	 -1
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PrivateTempoParam
  00050	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  00058	52		 push	 edx
  00059	ff 51 6c	 call	 DWORD PTR [ecx+108]
  0005c	89 45 cc	 mov	 DWORD PTR _hr$[ebp], eax

; 3284 :         if (hr == S_OK)

  0005f	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00063	75 5e		 jne	 SHORT $L71252

; 3285 :         {
; 3286 :             REFERENCE_TIME rtNext = rtTempo + ConvertToReference(mtNext, dbl);

  00065	8b 45 c4	 mov	 eax, DWORD PTR _dbl$[ebp+4]
  00068	50		 push	 eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR _dbl$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _mtNext$[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 ?ConvertToReference@@YG_JJN@Z ; ConvertToReference
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _rtTempo$[ebp]
  00079	03 c8		 add	 ecx, eax
  0007b	8b 45 f4	 mov	 eax, DWORD PTR _rtTempo$[ebp+4]
  0007e	13 c2		 adc	 eax, edx
  00080	89 4d b8	 mov	 DWORD PTR _rtNext$71257[ebp], ecx
  00083	89 45 bc	 mov	 DWORD PTR _rtNext$71257[ebp+4], eax

; 3287 :             dbl = Tempo.dblTempo;

  00086	8b 4d d0	 mov	 ecx, DWORD PTR _Tempo$[ebp]
  00089	89 4d c0	 mov	 DWORD PTR _dbl$[ebp], ecx
  0008c	8b 55 d4	 mov	 edx, DWORD PTR _Tempo$[ebp+4]
  0008f	89 55 c4	 mov	 DWORD PTR _dbl$[ebp+4], edx

; 3288 :             if (Tempo.fLast || rtNext >= rtTime) break;

  00092	0f b6 45 e0	 movzx	 eax, BYTE PTR _Tempo$[ebp+16]
  00096	85 c0		 test	 eax, eax
  00098	75 12		 jne	 SHORT $L71259
  0009a	8b 4d bc	 mov	 ecx, DWORD PTR _rtNext$71257[ebp+4]
  0009d	3b 4d 0c	 cmp	 ecx, DWORD PTR _rtTime$[ebp+4]
  000a0	7c 0c		 jl	 SHORT $L71258
  000a2	7f 08		 jg	 SHORT $L71259
  000a4	8b 55 b8	 mov	 edx, DWORD PTR _rtNext$71257[ebp]
  000a7	3b 55 08	 cmp	 edx, DWORD PTR _rtTime$[ebp]
  000aa	72 02		 jb	 SHORT $L71258
$L71259:
  000ac	eb 1f		 jmp	 SHORT $L71253
$L71258:

; 3289 :             rtTempo = rtNext;

  000ae	8b 45 b8	 mov	 eax, DWORD PTR _rtNext$71257[ebp]
  000b1	89 45 f0	 mov	 DWORD PTR _rtTempo$[ebp], eax
  000b4	8b 4d bc	 mov	 ecx, DWORD PTR _rtNext$71257[ebp+4]
  000b7	89 4d f4	 mov	 DWORD PTR _rtTempo$[ebp+4], ecx

; 3290 :             mtTempo += mtNext;

  000ba	8b 55 ec	 mov	 edx, DWORD PTR _mtTempo$[ebp]
  000bd	03 55 fc	 add	 edx, DWORD PTR _mtNext$[ebp]
  000c0	89 55 ec	 mov	 DWORD PTR _mtTempo$[ebp], edx
$L71252:

; 3291 :         }
; 3292 : 
; 3293 :     } while (hr == S_OK);

  000c3	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c7	0f 84 6e ff ff
	ff		 je	 $L71251
$L71253:

; 3294 : 
; 3295 :     *pmtTime = mtTempo + ConvertToMusic(rtTime - rtTempo, dbl);

  000cd	8b 45 c4	 mov	 eax, DWORD PTR _dbl$[ebp+4]
  000d0	50		 push	 eax
  000d1	8b 4d c0	 mov	 ecx, DWORD PTR _dbl$[ebp]
  000d4	51		 push	 ecx
  000d5	8b 55 08	 mov	 edx, DWORD PTR _rtTime$[ebp]
  000d8	2b 55 f0	 sub	 edx, DWORD PTR _rtTempo$[ebp]
  000db	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  000de	1b 45 f4	 sbb	 eax, DWORD PTR _rtTempo$[ebp+4]
  000e1	50		 push	 eax
  000e2	52		 push	 edx
  000e3	e8 00 00 00 00	 call	 ?ConvertToMusic@@YGJ_JN@Z ; ConvertToMusic
  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _mtTempo$[ebp]
  000eb	03 c8		 add	 ecx, eax
  000ed	8b 55 10	 mov	 edx, DWORD PTR _pmtTime$[ebp]
  000f0	89 0a		 mov	 DWORD PTR [edx], ecx

; 3296 :     return S_OK;

  000f2	33 c0		 xor	 eax, eax

; 3297 : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 0c 00	 ret	 12			; 0000000cH
?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z ENDP	; CSegment::ReferenceToMusicTime
_TEXT	ENDS
PUBLIC	??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@ ; `string'
;	COMDAT ??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@
CONST	SEGMENT
??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@ DB 'Warning: Re'
	DB	'ference to Music time conversion with very large ref time res'
	DB	'ulted in max music time.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertToMusic@@YGJ_JN@Z
_TEXT	SEGMENT
tv150 = -8
_rtSpan$ = 8
_dblTempo$ = 16
?ConvertToMusic@@YGJ_JN@Z PROC NEAR			; ConvertToMusic, COMDAT

; 3233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3234 :     rtSpan *= DMUS_PPQ;

  00006	6a 00		 push	 0
  00008	68 00 03 00 00	 push	 768			; 00000300H
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _rtSpan$[ebp+4]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _rtSpan$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 __allmul
  0001a	89 45 08	 mov	 DWORD PTR _rtSpan$[ebp], eax
  0001d	89 55 0c	 mov	 DWORD PTR _rtSpan$[ebp+4], edx

; 3235 :     rtSpan = (REFERENCE_TIME)(rtSpan * dblTempo);

  00020	df 6d 08	 fild	 QWORD PTR _rtSpan$[ebp]
  00023	dc 4d 10	 fmul	 QWORD PTR _dblTempo$[ebp]
  00026	e8 00 00 00 00	 call	 __ftol2
  0002b	89 45 08	 mov	 DWORD PTR _rtSpan$[ebp], eax
  0002e	89 55 0c	 mov	 DWORD PTR _rtSpan$[ebp+4], edx

; 3236 :     rtSpan += 300000000;

  00031	8b 55 08	 mov	 edx, DWORD PTR _rtSpan$[ebp]
  00034	81 c2 00 a3 e1
	11		 add	 edx, 300000000		; 11e1a300H
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _rtSpan$[ebp+4]
  0003d	83 d0 00	 adc	 eax, 0
  00040	89 55 08	 mov	 DWORD PTR _rtSpan$[ebp], edx
  00043	89 45 0c	 mov	 DWORD PTR _rtSpan$[ebp+4], eax

; 3237 :     rtSpan /= 600000000;

  00046	6a 00		 push	 0
  00048	68 00 46 c3 23	 push	 600000000		; 23c34600H
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _rtSpan$[ebp+4]
  00050	51		 push	 ecx
  00051	8b 55 08	 mov	 edx, DWORD PTR _rtSpan$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 __alldiv
  0005a	89 45 08	 mov	 DWORD PTR _rtSpan$[ebp], eax
  0005d	89 55 0c	 mov	 DWORD PTR _rtSpan$[ebp+4], edx

; 3238 :     if ( rtSpan & 0xFFFFFFFF00000000 )

  00060	8b 45 08	 mov	 eax, DWORD PTR _rtSpan$[ebp]
  00063	83 e0 00	 and	 eax, 0
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _rtSpan$[ebp+4]
  00069	89 45 f8	 mov	 DWORD PTR tv150[ebp], eax
  0006c	89 4d fc	 mov	 DWORD PTR tv150[ebp+4], ecx
  0006f	8b 55 f8	 mov	 edx, DWORD PTR tv150[ebp]
  00072	0b 55 fc	 or	 edx, DWORD PTR tv150[ebp+4]
  00075	85 d2		 test	 edx, edx
  00077	74 1d		 je	 SHORT $L71216

; 3239 :     {
; 3240 :         Trace(3,"Warning: Reference to Music time conversion with very large ref time resulted in max music time.\n");

  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@
  0007e	6a 03		 push	 3
  00080	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00085	83 c4 08	 add	 esp, 8

; 3241 :         rtSpan = 0x7FFFFFFF;

  00088	c7 45 08 ff ff
	ff 7f		 mov	 DWORD PTR _rtSpan$[ebp], 2147483647 ; 7fffffffH
  0008f	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _rtSpan$[ebp+4], 0
$L71216:

; 3242 :     }
; 3243 :     return (MUSIC_TIME) (rtSpan & 0xFFFFFFFF);

  00096	8b 45 08	 mov	 eax, DWORD PTR _rtSpan$[ebp]
  00099	8b 4d 0c	 mov	 ecx, DWORD PTR _rtSpan$[ebp+4]
  0009c	83 e1 00	 and	 ecx, 0

; 3244 : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 10 00	 ret	 16			; 00000010H
?ConvertToMusic@@YGJ_JN@Z ENDP				; ConvertToMusic
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.h
_TEXT	ENDS
;	COMDAT ??0?$TList@PAVCTrack@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TList@PAVCTrack@@@@QAE@XZ PROC NEAR		; TList<CTrack *>::TList<CTrack *>, COMDAT
; _this$ = ecx

; 55   :     TList() {m_pHead=NULL;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$TList@PAVCTrack@@@@QAE@XZ ENDP			; TList<CTrack *>::TList<CTrack *>
_TEXT	ENDS
PUBLIC	?Delete@?$TListItem@PAVCTrack@@@@SGXPAV1@@Z	; TListItem<CTrack *>::Delete
; Function compile flags: /Odt
;	COMDAT ??1?$TList@PAVCTrack@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TList@PAVCTrack@@@@QAE@XZ PROC NEAR		; TList<CTrack *>::~TList<CTrack *>, COMDAT
; _this$ = ecx

; 57   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		//if (m_pHead != NULL) delete m_pHead;
; 59   : 		TListItem<T>::Delete(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Delete@?$TListItem@PAVCTrack@@@@SGXPAV1@@Z ; TListItem<CTrack *>::Delete

; 60   : 	} // new destructor

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$TList@PAVCTrack@@@@QAE@XZ ENDP			; TList<CTrack *>::~TList<CTrack *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ PROC NEAR ; TList<CTrack *>::GetHead, COMDAT
; _this$ = ecx

; 61   :     TListItem<T> *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@?$TList@PAVCTrack@@@@QBEPAV?$TListItem@PAVCTrack@@@@XZ ENDP ; TList<CTrack *>::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@PAVCTrack@@@@QAEXPAV?$TListItem@PAVCTrack@@@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@?$TList@PAVCTrack@@@@QAEXPAV?$TListItem@PAVCTrack@@@@@Z PROC NEAR ; TList<CTrack *>::AddHead, COMDAT
; _this$ = ecx

; 80   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : //            assert(pItem!=NULL);
; 82   :             pItem->SetNext(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00010	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z ; TListItem<CTrack *>::SetNext

; 83   :             m_pHead=pItem;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 84   :         }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?AddHead@?$TList@PAVCTrack@@@@QAEXPAV?$TListItem@PAVCTrack@@@@@Z ENDP ; TList<CTrack *>::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@PAVCTrack@@@@QAE@ABQAVCTrack@@@Z
_TEXT	SEGMENT
_this$ = -4
_item$ = 8
??0?$TListItem@PAVCTrack@@@@QAE@ABQAVCTrack@@@Z PROC NEAR ; TListItem<CTrack *>::TListItem<CTrack *>, COMDAT
; _this$ = ecx

; 31   :     TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0?$TListItem@PAVCTrack@@@@QAE@ABQAVCTrack@@@Z ENDP	; TListItem<CTrack *>::TListItem<CTrack *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ PROC NEAR	; TListItem<CTrack *>::GetNext, COMDAT
; _this$ = ecx

; 32   :     TListItem<T> *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetNext@?$TListItem@PAVCTrack@@@@QBEPAV1@XZ ENDP	; TListItem<CTrack *>::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z PROC NEAR	; TListItem<CTrack *>::SetNext, COMDAT
; _this$ = ecx

; 33   :     void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNext@?$TListItem@PAVCTrack@@@@QAEXPAV1@@Z ENDP	; TListItem<CTrack *>::SetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ PROC NEAR ; TListItem<CTrack *>::GetItemValue, COMDAT
; _this$ = ecx

; 40   :     T& GetItemValue() { return m_Tinfo; }  // additional member function

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?GetItemValue@?$TListItem@PAVCTrack@@@@QAEAAPAVCTrack@@XZ ENDP ; TListItem<CTrack *>::GetItemValue
_TEXT	ENDS
PUBLIC	??_G?$TListItem@PAVCTrack@@@@QAEPAXI@Z		; TListItem<CTrack *>::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.cpp
;	COMDAT ?Delete@?$TListItem@PAVCTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT
tv70 = -20
$T72177 = -16
$T72176 = -12
_pScan$ = -8
_pNext$ = -4
_pFirst$ = 8
?Delete@?$TListItem@PAVCTrack@@@@SGXPAV1@@Z PROC NEAR	; TListItem<CTrack *>::Delete, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 29   : 	TListItem<T>* pScan = pFirst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pFirst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 30   : 	TListItem<T>* pNext = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0
$L71395:

; 31   : 	while (pScan)

  00013	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00017	74 39		 je	 SHORT $L71391

; 32   : 	{
; 33   : 		pNext = pScan->m_pNext;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 55 fc	 mov	 DWORD PTR _pNext$[ebp], edx

; 34   : 		delete pScan;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T72177[ebp], eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T72177[ebp]
  0002b	89 4d f4	 mov	 DWORD PTR $T72176[ebp], ecx
  0002e	83 7d f4 00	 cmp	 DWORD PTR $T72176[ebp], 0
  00032	74 0f		 je	 SHORT $L72178
  00034	6a 01		 push	 1
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T72176[ebp]
  00039	e8 00 00 00 00	 call	 ??_G?$TListItem@PAVCTrack@@@@QAEPAXI@Z
  0003e	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00041	eb 07		 jmp	 SHORT $L72179
$L72178:
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L72179:

; 35   : 		pScan = pNext;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 36   : 	}

  00050	eb c1		 jmp	 SHORT $L71395
$L71391:

; 37   : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Delete@?$TListItem@PAVCTrack@@@@SGXPAV1@@Z ENDP	; TListItem<CTrack *>::Delete
_TEXT	ENDS
PUBLIC	??1?$TListItem@PAVCTrack@@@@QAE@XZ		; TListItem<CTrack *>::~TListItem<CTrack *>
; Function compile flags: /Odt
;	COMDAT ??_G?$TListItem@PAVCTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_G?$TListItem@PAVCTrack@@@@QAEPAXI@Z PROC NEAR	; TListItem<CTrack *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$TListItem@PAVCTrack@@@@QAE@XZ ; TListItem<CTrack *>::~TListItem<CTrack *>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L71404
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L71404:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$TListItem@PAVCTrack@@@@QAEPAXI@Z ENDP		; TListItem<CTrack *>::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$TListItem@PAVCTrack@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TListItem@PAVCTrack@@@@QAE@XZ PROC NEAR		; TListItem<CTrack *>::~TListItem<CTrack *>, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	//if (m_pNext != NULL) { delete m_pNext; }
; 22   : 	// IMPORTANT: user of the list is required to delete content first!
; 23   : 	//ZeroMemory(&m_Tinfo, sizeof(T));
; 24   : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$TListItem@PAVCTrack@@@@QAE@XZ ENDP			; TListItem<CTrack *>::~TListItem<CTrack *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CSegment@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; CSegment::QueryInterface, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z ; CSegment::QueryInterface
?QueryInterface@CSegment@@W3AGJABU_GUID@@PAPAX@Z ENDP	; CSegment::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CSegment@@W3AGKXZ PROC NEAR			; CSegment::AddRef, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CSegment@@UAGKXZ ; CSegment::AddRef
?AddRef@CSegment@@W3AGKXZ ENDP				; CSegment::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@W3AGKXZ
_TEXT	SEGMENT
?Release@CSegment@@W3AGKXZ PROC NEAR			; CSegment::Release, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CSegment@@UAGKXZ ; CSegment::Release
?Release@CSegment@@W3AGKXZ ENDP				; CSegment::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CSegment@@W7AGJABU_GUID@@PAPAX@Z PROC NEAR ; CSegment::QueryInterface, COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z ; CSegment::QueryInterface
?QueryInterface@CSegment@@W7AGJABU_GUID@@PAPAX@Z ENDP	; CSegment::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@CSegment@@W7AGKXZ PROC NEAR			; CSegment::AddRef, COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CSegment@@UAGKXZ ; CSegment::AddRef
?AddRef@CSegment@@W7AGKXZ ENDP				; CSegment::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@W7AGKXZ
_TEXT	SEGMENT
?Release@CSegment@@W7AGKXZ PROC NEAR			; CSegment::Release, COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?Release@CSegment@@UAGKXZ ; CSegment::Release
?Release@CSegment@@W7AGKXZ ENDP				; CSegment::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegment@@WM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CSegment@@WM@AGJABU_GUID@@PAPAX@Z PROC NEAR ; CSegment::QueryInterface, COMDAT
  00000	83 6c 24 04 0c	 sub	 DWORD PTR [esp+4], 12	; 0000000cH
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CSegment@@UAGJABU_GUID@@PAPAX@Z ; CSegment::QueryInterface
?QueryInterface@CSegment@@WM@AGJABU_GUID@@PAPAX@Z ENDP	; CSegment::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CSegment@@WM@AGKXZ
_TEXT	SEGMENT
?AddRef@CSegment@@WM@AGKXZ PROC NEAR			; CSegment::AddRef, COMDAT
  00000	83 6c 24 04 0c	 sub	 DWORD PTR [esp+4], 12	; 0000000cH
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CSegment@@UAGKXZ ; CSegment::AddRef
?AddRef@CSegment@@WM@AGKXZ ENDP				; CSegment::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CSegment@@WM@AGKXZ
_TEXT	SEGMENT
?Release@CSegment@@WM@AGKXZ PROC NEAR			; CSegment::Release, COMDAT
  00000	83 6c 24 04 0c	 sub	 DWORD PTR [esp+4], 12	; 0000000cH
  00005	e9 00 00 00 00	 jmp	 ?Release@CSegment@@UAGKXZ ; CSegment::Release
?Release@CSegment@@WM@AGKXZ ENDP			; CSegment::Release
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AListItem@@QAE@XZ PROC NEAR				; AListItem::AListItem, COMDAT
; _this$ = ecx

; 17   :     AListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AListItem@@QAE@XZ ENDP				; AListItem::AListItem
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@AListItem@@QAEXPAV1@@Z PROC NEAR		; AListItem::SetNext, COMDAT
; _this$ = ecx

; 19   :     void SetNext(AListItem *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNext@AListItem@@QAEXPAV1@@Z ENDP			; AListItem::SetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AList@@QAE@XZ PROC NEAR				; AList::AList, COMDAT
; _this$ = ecx

; 34   :     AList() {m_pHead=NULL;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AList@@QAE@XZ ENDP					; AList::AList
_TEXT	ENDS
EXTRN	?Cat@AListItem@@QAEPAV1@PAV1@@Z:NEAR		; AListItem::Cat
; Function compile flags: /Odt
;	COMDAT ?Cat@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Cat@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::Cat, COMDAT
; _this$ = ecx

; 41   :     void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	e8 00 00 00 00	 call	 ?Cat@AListItem@@QAEPAV1@PAV1@@Z ; AListItem::Cat
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Cat@AList@@QAEXPAVAListItem@@@Z ENDP			; AList::Cat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::AddHead, COMDAT
; _this$ = ecx

; 51   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :             if (pItem!=NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 16		 je	 SHORT $L32730

; 53   :             {
; 54   :                 pItem->SetNext(m_pHead);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 55   :                 m_pHead=pItem;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00021	89 02		 mov	 DWORD PTR [edx], eax
$L32730:

; 56   :             }
; 57   :         };

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?AddHead@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::AddHead
_TEXT	ENDS
EXTRN	?Remove@AListItem@@QAEPAV1@PAV1@@Z:NEAR		; AListItem::Remove
; Function compile flags: /Odt
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Remove@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::Remove, COMDAT
; _this$ = ecx

; 60   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   :             if (pItem != NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 13		 je	 SHORT $L32733

; 62   :             {
; 63   :                 m_pHead=m_pHead->Remove(pItem);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	e8 00 00 00 00	 call	 ?Remove@AListItem@@QAEPAV1@PAV1@@Z ; AListItem::Remove
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	89 02		 mov	 DWORD PTR [edx], eax
$L32733:

; 64   :             }
; 65   :         };

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?Remove@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::Remove
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??_U@YAPAXI@Z PROC NEAR					; operator new[], COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 24   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_U@YAPAXI@Z ENDP					; operator new[]
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??_V@YAXPAX@Z PROC NEAR					; operator delete[], COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 29   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_V@YAXPAX@Z ENDP					; operator delete[]
_TEXT	ENDS
PUBLIC	?GetNext@AListItem@@QBEPAV1@XZ			; AListItem::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?GetNext@CTrack@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CTrack@@QAEPAV1@XZ PROC NEAR			; CTrack::GetNext, COMDAT
; _this$ = ecx

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 		return (CTrack*)AListItem::GetNext();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext

; 25   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CTrack@@QAEPAV1@XZ ENDP			; CTrack::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@AListItem@@QBEPAV1@XZ PROC NEAR		; AListItem::GetNext, COMDAT
; _this$ = ecx

; 18   :     AListItem *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNext@AListItem@@QBEPAV1@XZ ENDP			; AListItem::GetNext
_TEXT	ENDS
PUBLIC	_!=@8
EXTRN	_CLSID_DirectMusicSysExTrack:BYTE
EXTRN	_CLSID_DirectMusicBandTrack:BYTE
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?Less@CTrack@@QAE_NPAV1@@Z
_TEXT	SEGMENT
tv88 = -8
_this$ = -4
_pCTrack$ = 8
?Less@CTrack@@QAE_NPAV1@@Z PROC NEAR			; CTrack::Less, COMDAT
; _this$ = ecx

; 27   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   :         // Give the sysex track priority over any other track at the same position,
; 29   :         // and the band track priority over any track but the sysex track. 
; 30   :         return
; 31   :             ( m_dwPosition < pCTrack->m_dwPosition ||
; 32   :               (m_dwPosition == pCTrack->m_dwPosition && 
; 33   :                m_guidClassID == CLSID_DirectMusicSysExTrack) ||
; 34   :               (m_dwPosition == pCTrack->m_dwPosition && 
; 35   :                m_guidClassID == CLSID_DirectMusicBandTrack &&
; 36   :                pCTrack->m_guidClassID != CLSID_DirectMusicSysExTrack) );

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0000f	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00012	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  00015	72 64		 jb	 SHORT $L72253
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0001d	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00020	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  00023	75 15		 jne	 SHORT $L72252
  00025	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicSysExTrack
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _==@8
  00036	85 c0		 test	 eax, eax
  00038	75 41		 jne	 SHORT $L72253
$L72252:
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 55 08	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00040	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00043	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  00046	75 2a		 jne	 SHORT $L72254
  00048	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicBandTrack
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _==@8
  00059	85 c0		 test	 eax, eax
  0005b	74 15		 je	 SHORT $L72254
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicSysExTrack
  00062	8b 55 08	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00065	83 c2 04	 add	 edx, 4
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _!=@8
  0006e	85 c0		 test	 eax, eax
  00070	75 09		 jne	 SHORT $L72253
$L72254:
  00072	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
  00079	eb 07		 jmp	 SHORT $L72255
$L72253:
  0007b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
$L72255:
  00082	8a 45 f8	 mov	 al, BYTE PTR tv88[ebp]

; 37   :     }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?Less@CTrack@@QAE_NPAV1@@Z ENDP				; CTrack::Less
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
_TEXT	ENDS
;	COMDAT _!=@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_!=@8	PROC NEAR					; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  :     return !(guidOne == guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _==@8
  00010	f7 d8		 neg	 eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax

; 195  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_!=@8	ENDP
_TEXT	ENDS
PUBLIC	?GetHead@AList@@QBEPAVAListItem@@XZ		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?GetHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CTrackList@@QAEPAVCTrack@@XZ PROC NEAR		; CTrackList::GetHead, COMDAT
; _this$ = ecx

; 58   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		return (CTrack*)AList::GetHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead

; 60   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CTrackList@@QAEPAVCTrack@@XZ ENDP		; CTrackList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetHead, COMDAT
; _this$ = ecx

; 35   :     AListItem *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetHead
_TEXT	ENDS
PUBLIC	?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ	; CTrackList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?Clear@CTrackList@@QAEXXZ
_TEXT	SEGMENT
tv71 = -20
_this$ = -16
$T72269 = -12
$T72268 = -8
_pTrack$ = -4
?Clear@CTrackList@@QAEXXZ PROC NEAR			; CTrackList::Clear, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
$L40796:

; 71   : 		CTrack* pTrack;
; 72   : 		while( pTrack = RemoveHead() )

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  00018	74 2a		 je	 SHORT $L40793

; 73   : 		{
; 74   : 			delete pTrack;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR $T72269[ebp], eax
  00020	8b 4d f4	 mov	 ecx, DWORD PTR $T72269[ebp]
  00023	89 4d f8	 mov	 DWORD PTR $T72268[ebp], ecx
  00026	83 7d f8 00	 cmp	 DWORD PTR $T72268[ebp], 0
  0002a	74 0f		 je	 SHORT $L72270
  0002c	6a 01		 push	 1
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T72268[ebp]
  00031	e8 00 00 00 00	 call	 ??_GCTrack@@QAEPAXI@Z
  00036	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00039	eb 07		 jmp	 SHORT $L72271
$L72270:
  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L72271:

; 75   : 		}

  00042	eb c5		 jmp	 SHORT $L40796
$L40793:

; 76   : 	}

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Clear@CTrackList@@QAEXXZ ENDP				; CTrackList::Clear
_TEXT	ENDS
PUBLIC	?RemoveHead@AList@@QAEPAVAListItem@@XZ		; AList::RemoveHead
; Function compile flags: /Odt
;	COMDAT ?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ PROC NEAR	; CTrackList::RemoveHead, COMDAT
; _this$ = ecx

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return (CTrack*)AList::RemoveHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead

; 64   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ ENDP		; CTrackList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@AList@@QAEPAVAListItem@@XZ PROC NEAR	; AList::RemoveHead, COMDAT
; _this$ = ecx

; 71   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 72   :             AListItem *li;
; 73   :             li = m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 74   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L32744

; 75   :             {
; 76   :                 m_pHead = m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 77   :                 li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L32744:

; 78   :             }
; 79   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 80   :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@AList@@QAEPAVAListItem@@XZ ENDP		; AList::RemoveHead
_TEXT	ENDS
EXTRN	??1CTrack@@QAE@XZ:NEAR				; CTrack::~CTrack
; Function compile flags: /Odt
;	COMDAT ??_GCTrack@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCTrack@@QAEPAXI@Z PROC NEAR				; CTrack::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTrack@@QAE@XZ	; CTrack::~CTrack
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L40803
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L40803:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCTrack@@QAEPAXI@Z ENDP				; CTrack::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\ntfylist.h
_TEXT	ENDS
;	COMDAT ?GetNext@CNotificationItem@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CNotificationItem@@QAEPAV1@XZ PROC NEAR	; CNotificationItem::GetNext, COMDAT
; _this$ = ecx

; 16   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 17   : 		return (CNotificationItem*)AListItem::GetNext();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext

; 18   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CNotificationItem@@QAEPAV1@XZ ENDP		; CNotificationItem::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ PROC NEAR ; CNotificationList::GetHead, COMDAT
; _this$ = ecx

; 28   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		return (CNotificationItem*)AList::GetHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead

; 30   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ENDP ; CNotificationList::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ PROC NEAR ; CNotificationList::RemoveHead, COMDAT
; _this$ = ecx

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		return (CNotificationItem*)AList::RemoveHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead

; 34   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ENDP ; CNotificationList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dmstrm.h
_TEXT	ENDS
;	COMDAT ?GetStream@CRiffParser@@QAEPAUIStream@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStream@CRiffParser@@QAEPAUIStream@@XZ PROC NEAR	; CRiffParser::GetStream, COMDAT
; _this$ = ecx

; 96   :     IStream *   GetStream() { return m_pStream; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetStream@CRiffParser@@QAEPAUIStream@@XZ ENDP		; CRiffParser::GetStream
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CInfo@@QAE@XZ PROC NEAR				; CInfo::CInfo, COMDAT
; _this$ = ecx

; 111  :     CInfo() { Init(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Init@CInfo@@QAEXXZ	; CInfo::Init
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CInfo@@QAE@XZ ENDP					; CInfo::CInfo
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xboxutil.h
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT
___formal$ = 8
?DeleteCriticalSection@@YGXPAX@Z PROC NEAR		; DeleteCriticalSection, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   : }

  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
?DeleteCriticalSection@@YGXPAX@Z ENDP			; DeleteCriticalSection
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsegobj.h
_TEXT	ENDS
;	COMDAT ?RemoveHead@CSegmentList@@QAEPAVCSegment@@XZ
_TEXT	SEGMENT
tv69 = -12
tv66 = -8
_this$ = -4
?RemoveHead@CSegmentList@@QAEPAVCSegment@@XZ PROC NEAR	; CSegmentList::RemoveHead, COMDAT
; _this$ = ecx

; 211  :     CSegment* RemoveHead() {return (CSegment *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  00011	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00018	74 0b		 je	 SHORT $L72302
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001d	83 e8 10	 sub	 eax, 16			; 00000010H
  00020	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L72303
$L72302:
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L72303:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?RemoveHead@CSegmentList@@QAEPAVCSegment@@XZ ENDP	; CSegmentList::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\tempotrk.h
_TEXT	ENDS
;	COMDAT ??0PrivateTempo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0PrivateTempo@@QAE@XZ PROC NEAR			; PrivateTempo::PrivateTempo, COMDAT
; _this$ = ecx

; 18   :     PrivateTempo() : dblTempo(120.), mtTime(0), mtDelta(0), fLast(false) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	c7 40 04 00 00
	5e 40		 mov	 DWORD PTR [eax+4], 1079902208 ; 405e0000H
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??0PrivateTempo@@QAE@XZ ENDP				; PrivateTempo::PrivateTempo
_TEXT	ENDS
END
