; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\dmperf.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BC@JDIJJIMM@CPerformance?5?$CFlx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@FKIBIHNF@DM?5PMSG?5queue?5early?5queue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@MEHJMEJ@DM?5PMSG?5queue?5near?5time?5queue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@ONDJHKEG@DM?5PMSG?5queue?5on?5time?5queue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@FGONGJL@DM?5PMSG?5queue?5tempo?5map?5queue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@OCBKJPHM@DM?5PMSG?5queue?5old?5tempo?5map?5queu@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@OCJDPEPJ@DM?5PMSG?5queue?5notification?5queue@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@HGHNOMKD@DM?5PMSG?5queue?5time?5sig?5queue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IDPHDPLE@DM?5Out?3?5Notes?5Per?5Second?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNBEGFCO@DM?5Out?3?5Waves?5Per?5Second?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@JAIOCEJE@DM?5Out?3?5Curve?5Generated?5Events?5P@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICACJKMA@DM?5Out?3?5SysEx?5Per?5Second?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@POEOGGKN@DM?5Out?3?5Raw?5MIDI?5Events?5Per?5Seco@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@MCCJCJEO@?$HOCPerformance?5?$CFlx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0ED@EHENEGMG@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FH@IBOAECGJ@Error?$CB?5We?8ve?5been?5in?5the?5realtim@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MHOFNGKM@pEvent?9?$DOpNext?5?$DN?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@EMJFMCPP@?$CB?$CIpSegStNode?9?$DOm_dwPlaySegFlags?5?$CG@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@PHPGNDLB@m_OnTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFlags@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@KAECAIIH@m_NearTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFla@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@BIDGCOH@dmperf?3?5queueing?5primary?5seg?1DMU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@JDNMBECK@?$CB?$CIpSeg?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@ICDGAFCL@Current?5Primary?5segment?5has?5not?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@DKFLICIG@m_SegStateQueues?$FLSQ_PRI_PLAY?$FN?4Ge@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKDIBAJO@Queuing?52ndary?5seg?5time?5?$CFld?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@FMCOOANF@Warning?3?5Computing?5curve?5time?5sl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@MJFLJMOA@Error?5dequeing?5event?5for?5flushin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@HJCDHGLG@DM?5Worker?3?5Track?5Playback?5?$CIMilsP@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@EBDOGOG@DM?5Worker?3?5MIDI?5Process?5?$CIMilsPer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@CEAFEFFF@?$CFs?3?5Invalid?5pointer?5ppDirectMusi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@KGHBFIKH@?$CFs?3?5Invalid?5pointer?5ppDirectSoun@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@HENHECCJ@Error?3?5InitAudio?5called?5on?5an?5al@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@MNLLPNCN@Warning?3?5Default?5synth?5choice?5ha@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@EJJPIBFI@Warning?3?5Features?5flags?5has?5been@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@JAPGDOLO@Warning?3?5Sample?5rate?5has?5been?5ch@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@MKDNBMAL@Warning?3?5Number?5of?5requested?5voi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@GDKLNKDJ@Error?3?5Unable?5to?5play?5segment?0?5r@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FE@CECAKFA@Error?3?5Unable?5to?5play?5segment?0?5r@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EK@HFOOBOAG@Error?3?5Unable?5to?5play?5segment?5be@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@MKDFHMPO@Error?3?5Can?5not?5play?5segment?5beca@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@FFKFHOKE@Error?3?5Audiopath?5can?8t?5be?5used?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@FAPEFEL@Error?3?5No?5segment?5?9?5nothing?5to?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@JFGFJCDJ@Error?3?5Embedded?5audiopath?5failed@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@HKONIOHL@Error?3?5Can?5not?5play?5segment?5on?5i@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MGJJPPFG@Error?3?5No?5audiopath?5to?5play?5segm@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DACIMFKH@Error?3?5No?5segment?5to?5play?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0HH@NOBOKFIC@Error?3?5Invalid?5segment?5object?5pa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@JNGHOFGH@Error?3?5Must?5pass?5either?5a?5segmen@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@OFGFJIEM@Error?3?5Invalid?5segment?5or?5song?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@EGKKGOCA@Error?3?5Invalid?5transition?5passed@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@HJGGCODG@Error?3?5Invalid?5audiopath?5passed?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@NCCCEEPA@Error?3?5Invalid?5audiopath?5?9?5not?5c@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FO@KKMIOIMC@Error?3?5Failure?5setting?5default?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@ICBNMMBJ@Error?3?5Invalid?5audiopath?5?9?5not?5c@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EEKCPIIC@?$CFs?3?5Invalid?5pointer?5ppAudioPath?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@DFONJGHO@Warning?3?5No?5default?5audiopath?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@NCIDCFPG@?$CFs?3?5Invalid?5pointer?5ppNewPath?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@BMDMNOHG@Error?3?5Audiopath?5creation?5failed@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GB@GEIFAAMI@Warning?3?5Creating?5a?5standard?5aud@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@MMNNHIEN@Error?3?5?$CFld?5is?5not?5a?5valid?5predef@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@LBFDOJPJ@Error?3?5Performance?5not?5initializ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@NCDPDAOO@StopExing?5?$CFlx?5at?5time?5?$CFld?0?5flags@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@HMEHGHPP@DMUS_SEGF_REFTIME?5is?5not?5Support@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@LGDDGIOF@?$CB?$CIdwFlags?5?$CG?5DMUS_SEGF_REFTIME?$CJ?5?$CG@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@BILGJMLG@Stopping?5Segment?5?$CFlx?0?5SegState?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@NGMKGFAE@Error?3?5Pointer?5in?5SegState?5param@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@ICEJHAPA@Error?3?5Pointer?5in?5Segment?5parame@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@FOEGMPGD@Unable?5to?5find?5a?5segment?5state?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@FDLOAGBG@?$CFs?3?5Invalid?5pointer?5pdwMilliSeco@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@EEFNAMEA@?$CFs?3?5Invalid?5pointer?5pDMUS_PMSG?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EB@PPKACEMH@Error?3?5Unable?5to?5Send?5PMsg?5becau@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@LAGHLOB@Warning?3?5PMsg?5size?5field?5has?5bee@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GF@JBLNGFFF@Error?3?5Attempt?5to?5send?5an?5improp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IA@IMHPKDCD@Error?3?5Unable?5to?5send?5PMsg?5becau@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@BCDPLJMF@Rearrangement?5of?5times?5in?5messag@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@MHNFOPIF@Error?3?5Out?5of?5memory?$DL?5Tempo?5map?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GE@BACJCOHH@Error?3?5Unable?5to?5convert?5music?5t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@BCCCMJCI@?$CFs?3?5Invalid?5pointer?5pmtTime?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GE@OLABMEDD@Error?3?5Unable?5to?5convert?5referen@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@NOBNKMFL@Error?3?5Time?5parameter?5passed?5to?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@OGOCOFJA@?$CFs?3?5Invalid?5pointer?5prtResolved?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@NPHAMOAE@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FF@IJFMBAKP@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@BIIMPMFB@?$CFs?3?5Invalid?5pointer?5prtNow?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@IJBKBAHG@?$CFs?3?5Invalid?5pointer?5pmtNow?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EL@HEOBICH@Error?3?5GetTime?$CI?$CJ?5failed?5because?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FC@CGECENDB@Error?3?5GetLatencyTime?$CI?$CJ?5failed?5b@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@EKFEBJIF@Error?3?5GetQueueTime?$CI?$CJ?5failed?5bec@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPMPOKKI@cb?5?$DO?$DN?5sizeof?$CIPRIV_PMSG?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@KCKMCHDC@?$CFs?3?5Invalid?5pointer?5ppCopyPMSG?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@BPEIHJHJ@?$CFs?3?5Invalid?5pointer?5pSourcePMSG?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EBBFLPLC@DM?5allocated?5PMSGs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CNKHGELJ@DM?5active?5PMSGs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JACIILDB@DM?5cached?5PMSGs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LDFHGMM@DM?5allocation?5rate?5PMSGs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@MKBIHCAB@?$CFs?3?5Invalid?5pointer?5ppPMSG?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@LLFAGKFK@cb?5is?5?$CFd?5but?5must?5be?5at?5least?5si@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@PNFDFEEC@Attempt?5to?5allocate?5PMSG?5of?5size@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@KHJHODCD@Error?5?9?5previously?5freed?5PMsg?5ha@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DDIHCOKC@?$CFs?3?5Invalid?5pointer?5pPMSG?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@CKCJBHIN@Error?5?9?9?9?5Attempt?5to?5free?5a?5PMsg@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@FFGEFLCP@Attempt?5to?5free?5a?5PMsg?5that?5is?5c@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@BFAEEGCJ@Error?3?5Performance?5does?5not?5curr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@DIPCKGIK@?$CFs?3?5Invalid?5pointer?5ppNotificati@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05ICFJNKJO@pPriv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FJ@PAEGHHCI@Warning?3?5Unable?5to?5remove?5reques@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@GOEGCFB@dwIndex?5?$DM?5PCHANNEL_BLOCKSIZE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@MLOBAHAL@Error?3?5Unable?5to?5allocated?5dynam@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@BFDFDHJM@ChannelBlock?5?$CFlx?0?5Free?5?$CFld?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@DEFICNBN@?7Port?5?$CFld?0?5Group?3?5?$CFld?0?5MIDI?3?5?$CFld@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@MIOFNNJP@pdwIndex?5?$CG?$CG?5pdwGroup?5?$CG?$CG?5pdwMChan@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@HEDCPHMP@Error?3?5PChannel?5?$CFld?5has?5not?5been@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@EPLKJNPH@?$CFs?3?5Invalid?5pointer?5ppPort?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@KBPMEOHD@?$CFs?3?5Invalid?5pointer?5pdwGroup?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NJMOJABB@?$CFs?3?5Invalid?5pointer?5pdwMChannel?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EO@NCOGNNDB@Error?3?5Invalidate?$CI?$CJ?5failed?5becau@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@FLOGGMPC@ReSend?5Dirty?5PMsg?5?$FL3?$FN?5?$CFd?5?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@PLMGLDO@?$CFs?3?5Invalid?5pointer?5pmtNext?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@IFKLLGJK@Error?3?5GetParam?$CI?$CJ?5failed?5because@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@BIEEPMLC@Couldn?8t?5find?5SegState?5in?5GetPar@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@PMAJEBNC@Error?3?5Null?5pointer?5for?5time?5sig@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@IBANBBLM@Error?3?5Null?5pointer?5for?5tempo?5pa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@FKGBLCKC@Error?3?5SetParam?$CI?$CJ?5failed?5because@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@NMKGDHBB@Error?3?5SetParam?5failed?5because?5t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GM@BGEGCLPI@Error?3?5GetGlobalParam?$CI?$CJ?5failed?5b@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@OCDJIEKL@Warning?3?5GetGlobalParam?$CI?$CJ?5failed@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@IPKJGLPP@Error?3?5Attempt?5to?5set?5global?5tem@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@DBNAGDNA@Error?3?5Attempt?5to?5set?5global?5vol@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0HF@LGHJJIB@Error?3?5Attempt?5to?5set?5global?5par@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@KPAIOJCO@Play?5note?5failed?5on?5unassigned?5P@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@NENCKBIH@Play?5curve?5failed?5on?5unassigned?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@NPAKGIMN@Play?5MIDI?5failed?5on?5unassigned?5P@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@MHMNIDNE@Play?5SysEx?5failed?5on?5unassigned?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@NBCGDOIB@Play?5Patch?5failed?5on?5unassigned?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKABIODL@dwMChannel?5?$DM?516?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OEBCMAMD@pPerf?5?$DN?$DN?5this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@FDPGNHJG@?$CFs?3?5Invalid?5pointer?5pdwDeliveryT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@CCINKPEL@?$CFs?3?5Invalid?5pointer?5pdwNumElemen@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@GOOBPBH@note?3?5?$CFd?5root?3?5?$CFd?5scale?3?5?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@LLNFPEMM@shifted?5note?3?5?$CFd?5shifted?5scale?3?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@CCDOAEII@?$CFs?3?5Invalid?5pointer?5pChord?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@MBABIGFP@?$CFs?3?5Invalid?5pointer?5pwMusicValue@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GN@DNOCFEOA@Error?3?5MIDIToMusic?5conversion?5fa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GC@GBMAAGGG@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GE@PGBKAKLP@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GG@CCLPDFFN@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GA@HLFPPIBN@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0JA@CPGAIEHN@Error?3?5Unable?5to?5convert?5MIDI?5va@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@BNPKJPGL@?$CFs?3?5Invalid?5pointer?5pbMIDIValue?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FK@DFDKHCLP@Error?3?5Unable?5to?5convert?5Music?5v@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@LIJCFGNJ@Warning?3?5MIDIToMusic?5unable?5to?5c@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@ONMLMHBI@Warning?3?5MusicToMIDI?5had?5to?5bump@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FI@GOIHIAAE@Warning?3?5MusicToMIDI?5had?5to?5bump@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@PEJFPBBM@?$CFs?3?5Invalid?5pointer?5pTimeSig?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEDHCBOL@?$CFs?3?5Invalid?5pointer?5pwMeasure?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@PJPJFDFA@?$CFs?3?5Invalid?5pointer?5pbBeat?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@KCGGACOO@?$CFs?3?5Invalid?5pointer?5pbGrid?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBHHHLEA@?$CFs?3?5Invalid?5pointer?5pnOffset?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ?Clear@CChannelBlockList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CChannelMap@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CChannelMap@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CParamMerger@@QAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CParamMerger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VolumeToMidi@CParamMerger@@SGEJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeMidiVolume@CParamMerger@@QAEEKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVolumeStart@CParamMerger@@QAEEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeValue@CParamMerger@@QAEJKJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeTranspose@CParamMerger@@QAEFKF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeData@CParamMerger@@AAEJKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMergeParam@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedValue@CParamMerger@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPitchMerger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CChannelBlock@@QAEXKKKG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPMsgZone@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPMsgZone@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeAll@CPMsgZone@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@CPMsgZone@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocZone@CPMsgZone@@AAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPerformance@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicPerformance@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicTool@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicGraph@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicPerformanceP@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CChannelBlockList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSegStateList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAudioPathList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNotificationList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPentiumTime@@YGXPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateDebugParams@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPerformance@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPMsgZone@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseDown@CPerformance@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GGlobalData@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPerformance@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DequeueAllSegments@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Realtime@@YGXPAXPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Realtime@CPerformance@@AAEXPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Transport@@YGXPAXPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Transport@CPerformance@@AAEXPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextPMsg@CPerformance@@AAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessEarlyPMsgs@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CPerformance@@AAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLatency@CPerformance@@AAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ManageControllingTracks@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSig@CPerformance@@AAEXJPAU_DMUS_TIMESIG_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResolveTime@CPerformance@@AAEJJKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RecomputeCurveEnd@@YGHPAU_DMUS_CURVE_PMSG@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChordUpdateEventQueues@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateThreads@CPerformance@@AAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitAudioX@CPerformance@@UAGJKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CPerformance@@QAGJPAPAUIDirectMusic@@PAUIDirectSound@@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSegmentForTransition@CPerformance@@AAEPAVCSegState@@KJPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearMusicStoppedNotification@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAudioPath@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetAllControllers@CPerformance@@AAEX_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPrepareTime@CPerformance@@QAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrepareTime@CPerformance@@QAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBumperLength@CPerformance@@QAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBumperLength@CPerformance@@QAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTempoMap@CPerformance@@AAEXNJ_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEventToTempoMap@CPerformance@@AAEXPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncrementTempoMap@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustTime@CPerformance@@QAGJ_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CPerformance@@UAGJPA_JPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLatencyTime@CPerformance@@UAGJPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetQueueTime@CPerformance@@UAGJPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocPMsg@CPerformance@@AAEJKPAPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DMRegisterPMsgPerformanceCounters@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DMUnregisterPMsgPerformanceCounters@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetControlSegTime@CPerformance@@QAEJJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPriSegTime@CPerformance@@QAEJJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNotificationHandle@CPerformance@@QAGJPAX_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNotificationTypeToAllSegments@CPerformance@@AAEXABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNotificationItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveUnusedPorts@CPerformance@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPort@CPerformance@@QAEJPAUIDirectMusicPort@@PAU_GUID@@PAU_DMUS_PORTPARAMS8@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignPChannelBlock@CPerformance@@AAEJKKKG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CChannelBlock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CChannelMap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignPChannel@CPerformance@@AAEJKKKKG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignPChannelBlock@CPerformance@@QAGJKPAUIDirectMusicPort@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignPChannel@CPerformance@@QAGJKPAUIDirectMusicPort@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleasePChannel@CPerformance@@AAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSynth@CPerformance@@UAGJPAPAUIDirectMusicSynthX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocVChannel@CPerformance@@AAEJKKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocVChannelBlock@CPerformance@@AAEJKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceAllChannelMaps@CPerformance@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPortAndFlags@CPerformance@@UAGJKPAPAUIDirectMusicPort@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invalidate@CPerformance@@UAGJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CPerformance@@UAGJPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackMidi@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackSysEx@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackPatch@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMsgDeliveryType@CPerformance@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMediaTypes@CPerformance@@UAGJPAPAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shutdown@CPerformance@@QAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTool@CPerformance@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTool@CPerformance@@UAGJKPAPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveTool@CPerformance@@UAGJPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BitCount@@YGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InScale@@YG_NEEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanupScale@@YGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PatternMatch@@YGKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FixScale@@YGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThreeOctave@@YGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRootToScale@@YGKEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SubtractRootFromScale@@YGKEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChordFromScale@@YGKEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvertChord@@YGKEEKAA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OldMusicValueToNote@@YGEGDJDJD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OldNoteToMusicValue@@YGGEJDJD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicValueOctave@@YGFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicValueAccidentals@@YGFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BitsInChord@@YGFK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicValueIntervals@@YGFGEPAU_DMUS_SUBCHORD@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicValueChord@@YGFGEPAU_DMUS_SUBCHORD@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UPrivateTempo@@@@QAE@ABUPrivateTempo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UPrivateTempo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@WM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@WM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@WM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetMsgDeliveryType@CPerformance@@UAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dwSearchOrder@?BC@??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4PAKA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sdwSearchForMelodic@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?sdwSearchForDrums@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?sdwSearchForAll@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Cat@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU3@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetQueueTime@CPerformance@@UAGJPA_J@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetLatencyTime@CPerformance@@UAGJPA_J@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetTime@CPerformance@@UAGJPA_JPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0PrivateTempo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetBumperLength@CPerformance@@QAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetPrepareTime@CPerformance@@QAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetNext@CChannelBlock@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?abGMReset@?9??ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z@4PAEA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetCount@AList@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsMember@CAudioPathList@@QAEHPAVCAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsActive@CAudioPath@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NoPorts@CAudioPath@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _!=@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetNext@CTrack@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTail@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTail@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrev@AList@@QBEPAVAListItem@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CSegState@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@AList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WakeUp@CWorker@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1GlobalData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??CloseDown@CPerformance@@UAGJXZ@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Release@IDirectSound@@QAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CNotificationItem@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7IDirectMusicPerformanceP@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetID@CSegStateList@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicPerformanceP@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicGraph@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicTool@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicPerformance@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CParamMerger@@AAEXPAVCMergeParam@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CMergeParam@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CParamMerger@@AAEPAVCMergeParam@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?m_lMIDIToDB@CParamMerger@@0PAFA		; CParamMerger::m_lMIDIToDB
PUBLIC	?m_lDBToMIDI@CParamMerger@@0PAEA		; CParamMerger::m_lDBToMIDI
_DATA	SEGMENT
_ganCT_Linear DW 00H
	DW	064H
	DW	0c8H
	DW	012cH
	DW	0190H
	DW	01f4H
	DW	0258H
	DW	02bcH
	DW	0320H
	DW	0384H
	DW	03e8H
	DW	044cH
	DW	04b0H
	DW	0514H
	DW	0578H
	DW	05dcH
	DW	0640H
	DW	06a4H
	DW	0708H
	DW	076cH
	DW	07d0H
	DW	0834H
	DW	0898H
	DW	08fcH
	DW	0960H
	DW	09c4H
	DW	0a28H
	DW	0a8cH
	DW	0af0H
	DW	0b54H
	DW	0bb8H
	DW	0c1cH
	DW	0c80H
	DW	0ce4H
	DW	0d48H
	DW	0dacH
	DW	0e10H
	DW	0e74H
	DW	0ed8H
	DW	0f3cH
	DW	0fa0H
	DW	01004H
	DW	01068H
	DW	010ccH
	DW	01130H
	DW	01194H
	DW	011f8H
	DW	0125cH
	DW	012c0H
	DW	01324H
	DW	01388H
	DW	013ecH
	DW	01450H
	DW	014b4H
	DW	01518H
	DW	0157cH
	DW	015e0H
	DW	01644H
	DW	016a8H
	DW	0170cH
	DW	01770H
	DW	017d4H
	DW	01838H
	DW	0189cH
	DW	01900H
	DW	01964H
	DW	019c8H
	DW	01a2cH
	DW	01a90H
	DW	01af4H
	DW	01b58H
	DW	01bbcH
	DW	01c20H
	DW	01c84H
	DW	01ce8H
	DW	01d4cH
	DW	01db0H
	DW	01e14H
	DW	01e78H
	DW	01edcH
	DW	01f40H
	DW	01fa4H
	DW	02008H
	DW	0206cH
	DW	020d0H
	DW	02134H
	DW	02198H
	DW	021fcH
	DW	02260H
	DW	022c4H
	DW	02328H
	DW	0238cH
	DW	023f0H
	DW	02454H
	DW	024b8H
	DW	0251cH
	DW	02580H
	DW	025e4H
	DW	02648H
	DW	026acH
	DW	02710H
	DW	02774H
	DW	027d8H
	DW	0283cH
	DW	028a0H
	DW	02904H
	DW	02968H
	DW	029ccH
	DW	02a30H
	DW	02a94H
	DW	02af8H
	DW	02b5cH
	DW	02bc0H
	DW	02c24H
	DW	02c88H
	DW	02cecH
	DW	02d50H
	DW	02db4H
	DW	02e18H
	DW	02e7cH
	DW	02ee0H
	DW	02f44H
	DW	02fa8H
	DW	0300cH
	DW	03070H
	DW	030d4H
	DW	03138H
	DW	0319cH
	DW	03200H
	DW	03264H
	DW	032c8H
	DW	0332cH
	DW	03390H
	DW	033f4H
	DW	03458H
	DW	034bcH
	DW	03520H
	DW	03584H
	DW	035e8H
	DW	0364cH
	DW	036b0H
	DW	03714H
	DW	03778H
	DW	037dcH
	DW	03840H
	DW	038a4H
	DW	03908H
	DW	0396cH
	DW	039d0H
	DW	03a34H
	DW	03a98H
	DW	03afcH
	DW	03b60H
	DW	03bc4H
	DW	03c28H
	DW	03c8cH
	DW	03cf0H
	DW	03d54H
	DW	03db8H
	DW	03e1cH
	DW	03e80H
	DW	03ee4H
	DW	03f48H
	DW	03facH
	DW	04010H
	DW	04074H
	DW	040d8H
	DW	0413cH
	DW	041a0H
	DW	04204H
	DW	04268H
	DW	042ccH
	DW	04330H
	DW	04394H
	DW	043f8H
	DW	0445cH
	DW	044c0H
	DW	04524H
	DW	04588H
	DW	045ecH
	DW	04650H
	DW	046b4H
	DW	04718H
	DW	0477cH
	DW	047e0H
	DW	04844H
	DW	048a8H
	DW	0490cH
	DW	04970H
	DW	049d4H
	DW	04a38H
	DW	04a9cH
	DW	04b00H
	ORG $+6
_ganCT_Sine DW	00H
	DW	01H
	DW	05H
	DW	0bH
	DW	014H
	DW	020H
	DW	02eH
	DW	03eH
	DW	052H
	DW	067H
	DW	080H
	DW	09bH
	DW	0b8H
	DW	0d8H
	DW	0faH
	DW	011fH
	DW	0147H
	DW	0171H
	DW	019dH
	DW	01ccH
	DW	01fdH
	DW	0231H
	DW	0267H
	DW	029fH
	DW	02daH
	DW	0318H
	DW	0357H
	DW	0399H
	DW	03deH
	DW	0424H
	DW	046dH
	DW	04b8H
	DW	0506H
	DW	0555H
	DW	05a7H
	DW	05fbH
	DW	0651H
	DW	06aaH
	DW	0704H
	DW	0761H
	DW	07bfH
	DW	0820H
	DW	0883H
	DW	08e7H
	DW	094eH
	DW	09b6H
	DW	0a21H
	DW	0a8dH
	DW	0afbH
	DW	0b6bH
	DW	0bddH
	DW	0c51H
	DW	0cc6H
	DW	0d3dH
	DW	0db5H
	DW	0e30H
	DW	0eabH
	DW	0f29H
	DW	0fa8H
	DW	01028H
	DW	010aaH
	DW	0112dH
	DW	011b2H
	DW	01238H
	DW	012bfH
	DW	01348H
	DW	013d2H
	DW	0145dH
	DW	014eaH
	DW	01577H
	DW	01606H
	DW	01695H
	DW	01726H
	DW	017b7H
	DW	0184aH
	DW	018ddH
	DW	01972H
	DW	01a07H
	DW	01a9dH
	DW	01b33H
	DW	01bcbH
	DW	01c63H
	DW	01cfcH
	DW	01d95H
	DW	01e2fH
	DW	01ec9H
	DW	01f64H
	DW	01fffH
	DW	0209aH
	DW	02136H
	DW	021d3H
	DW	0226fH
	DW	0230cH
	DW	023a8H
	DW	02445H
	DW	024e2H
	DW	02580H
	DW	0261dH
	DW	026baH
	DW	02757H
	DW	027f3H
	DW	02890H
	DW	0292cH
	DW	029c9H
	DW	02a65H
	DW	02b00H
	DW	02b9bH
	DW	02c36H
	DW	02cd0H
	DW	02d6aH
	DW	02e03H
	DW	02e9cH
	DW	02f34H
	DW	02fccH
	DW	03062H
	DW	030f8H
	DW	0318dH
	DW	03222H
	DW	032b5H
	DW	03348H
	DW	033d9H
	DW	0346aH
	DW	034f9H
	DW	03588H
	DW	03615H
	DW	036a2H
	DW	0372dH
	DW	037b7H
	DW	0383fH
	DW	038c7H
	DW	0394dH
	DW	039d2H
	DW	03a55H
	DW	03ad7H
	DW	03b57H
	DW	03bd6H
	DW	03c54H
	DW	03ccfH
	DW	03d4aH
	DW	03dc2H
	DW	03e39H
	DW	03eaeH
	DW	03f22H
	DW	03f94H
	DW	04004H
	DW	04072H
	DW	040deH
	DW	04149H
	DW	041b1H
	DW	04218H
	DW	0427cH
	DW	042dfH
	DW	04340H
	DW	0439eH
	DW	043fbH
	DW	04455H
	DW	044aeH
	DW	04504H
	DW	04558H
	DW	045aaH
	DW	045f9H
	DW	04647H
	DW	04692H
	DW	046dbH
	DW	04721H
	DW	04766H
	DW	047a8H
	DW	047e7H
	DW	04825H
	DW	04860H
	DW	04898H
	DW	048ceH
	DW	04902H
	DW	04933H
	DW	04962H
	DW	0498eH
	DW	049b8H
	DW	049e0H
	DW	04a05H
	DW	04a27H
	DW	04a47H
	DW	04a64H
	DW	04a7fH
	DW	04a98H
	DW	04aadH
	DW	04ac1H
	DW	04ad1H
	DW	04adfH
	DW	04aebH
	DW	04af4H
	DW	04afaH
	DW	04afeH
	DW	04b00H
	ORG $+6
_ganCT_Log DW	00H
	DW	017dH
	DW	02ebH
	DW	0449H
	DW	0598H
	DW	06dbH
	DW	0812H
	DW	093eH
	DW	0a5fH
	DW	0b76H
	DW	0c85H
	DW	0d8bH
	DW	0e89H
	DW	0f7fH
	DW	0106fH
	DW	01157H
	DW	0123aH
	DW	01316H
	DW	013edH
	DW	014beH
	DW	0158bH
	DW	01652H
	DW	01715H
	DW	017d3H
	DW	0188dH
	DW	01943H
	DW	019f5H
	DW	01aa3H
	DW	01b4eH
	DW	01bf5H
	DW	01c99H
	DW	01d3aH
	DW	01dd8H
	DW	01e73H
	DW	01f0bH
	DW	01fa0H
	DW	02033H
	DW	020c3H
	DW	02151H
	DW	021dcH
	DW	02265H
	DW	022ecH
	DW	02371H
	DW	023f4H
	DW	02474H
	DW	024f3H
	DW	02570H
	DW	025ebH
	DW	02664H
	DW	026dbH
	DW	02751H
	DW	027c5H
	DW	02837H
	DW	028a8H
	DW	02918H
	DW	02986H
	DW	029f2H
	DW	02a5dH
	DW	02ac7H
	DW	02b30H
	DW	02b97H
	DW	02bfdH
	DW	02c61H
	DW	02cc5H
	DW	02d27H
	DW	02d88H
	DW	02de8H
	DW	02e47H
	DW	02ea5H
	DW	02f02H
	DW	02f5eH
	DW	02fb8H
	DW	03012H
	DW	0306bH
	DW	030c3H
	DW	0311aH
	DW	03170H
	DW	031c5H
	DW	0321aH
	DW	0326dH
	DW	032c0H
	DW	03312H
	DW	03363H
	DW	033b3H
	DW	03403H
	DW	03452H
	DW	034a0H
	DW	034edH
	DW	0353aH
	DW	03586H
	DW	035d1H
	DW	0361bH
	DW	03665H
	DW	036aeH
	DW	036f7H
	DW	0373fH
	DW	03786H
	DW	037cdH
	DW	03813H
	DW	03859H
	DW	0389eH
	DW	038e2H
	DW	03926H
	DW	0396aH
	DW	039acH
	DW	039efH
	DW	03a30H
	DW	03a72H
	DW	03ab2H
	DW	03af3H
	DW	03b32H
	DW	03b72H
	DW	03bb0H
	DW	03befH
	DW	03c2dH
	DW	03c6aH
	DW	03ca7H
	DW	03ce3H
	DW	03d1fH
	DW	03d5bH
	DW	03d96H
	DW	03dd1H
	DW	03e0bH
	DW	03e45H
	DW	03e7fH
	DW	03eb8H
	DW	03ef1H
	DW	03f29H
	DW	03f61H
	DW	03f99H
	DW	03fd0H
	DW	04007H
	DW	0403eH
	DW	04074H
	DW	040aaH
	DW	040dfH
	DW	04115H
	DW	04149H
	DW	0417eH
	DW	041b2H
	DW	041e6H
	DW	04219H
	DW	0424dH
	DW	04280H
	DW	042b2H
	DW	042e4H
	DW	04316H
	DW	04348H
	DW	04379H
	DW	043abH
	DW	043dbH
	DW	0440cH
	DW	0443cH
	DW	0446cH
	DW	0449cH
	DW	044cbH
	DW	044faH
	DW	04529H
	DW	04558H
	DW	04586H
	DW	045b4H
	DW	045e2H
	DW	04610H
	DW	0463dH
	DW	0466aH
	DW	04697H
	DW	046c4H
	DW	046f0H
	DW	0471cH
	DW	04748H
	DW	04774H
	DW	0479fH
	DW	047cbH
	DW	047f6H
	DW	04820H
	DW	0484bH
	DW	04875H
	DW	048a0H
	DW	048caH
	DW	048f3H
	DW	0491dH
	DW	04946H
	DW	0496fH
	DW	04998H
	DW	049c1H
	DW	049e9H
	DW	04a12H
	DW	04a3aH
	DW	04a62H
	DW	04a89H
	DW	04ab1H
	DW	04ad8H
	DW	04b00H
	ORG $+6
_ganCT_Exp DW	00H
	DW	028H
	DW	04fH
	DW	077H
	DW	09eH
	DW	0c6H
	DW	0eeH
	DW	0117H
	DW	013fH
	DW	0168H
	DW	0191H
	DW	01baH
	DW	01e3H
	DW	020dH
	DW	0236H
	DW	0260H
	DW	028bH
	DW	02b5H
	DW	02e0H
	DW	030aH
	DW	0335H
	DW	0361H
	DW	038cH
	DW	03b8H
	DW	03e4H
	DW	0410H
	DW	043cH
	DW	0469H
	DW	0496H
	DW	04c3H
	DW	04f0H
	DW	051eH
	DW	054cH
	DW	057aH
	DW	05a8H
	DW	05d7H
	DW	0606H
	DW	0635H
	DW	0664H
	DW	0694H
	DW	06c4H
	DW	06f4H
	DW	0725H
	DW	0755H
	DW	0787H
	DW	07b8H
	DW	07eaH
	DW	081cH
	DW	084eH
	DW	0880H
	DW	08b3H
	DW	08e7H
	DW	091aH
	DW	094eH
	DW	0982H
	DW	09b7H
	DW	09ebH
	DW	0a21H
	DW	0a56H
	DW	0a8cH
	DW	0ac2H
	DW	0af9H
	DW	0b30H
	DW	0b67H
	DW	0b9fH
	DW	0bd7H
	DW	0c0fH
	DW	0c48H
	DW	0c81H
	DW	0cbbH
	DW	0cf5H
	DW	0d2fH
	DW	0d6aH
	DW	0da5H
	DW	0de1H
	DW	0e1dH
	DW	0e59H
	DW	0e96H
	DW	0ed3H
	DW	0f11H
	DW	0f50H
	DW	0f8eH
	DW	0fceH
	DW	0100dH
	DW	0104eH
	DW	0108eH
	DW	010d0H
	DW	01111H
	DW	01154H
	DW	01196H
	DW	011daH
	DW	0121eH
	DW	01262H
	DW	012a7H
	DW	012edH
	DW	01333H
	DW	0137aH
	DW	013c1H
	DW	01409H
	DW	01452H
	DW	0149bH
	DW	014e5H
	DW	0152fH
	DW	0157aH
	DW	015c6H
	DW	01613H
	DW	01660H
	DW	016aeH
	DW	016fdH
	DW	0174dH
	DW	0179dH
	DW	017eeH
	DW	01840H
	DW	01893H
	DW	018e6H
	DW	0193bH
	DW	01990H
	DW	019e6H
	DW	01a3dH
	DW	01a95H
	DW	01aeeH
	DW	01b48H
	DW	01ba2H
	DW	01bfeH
	DW	01c5bH
	DW	01cb9H
	DW	01d18H
	DW	01d78H
	DW	01dd9H
	DW	01e3bH
	DW	01e9fH
	DW	01f03H
	DW	01f69H
	DW	01fd0H
	DW	02039H
	DW	020a3H
	DW	0210eH
	DW	0217aH
	DW	021e8H
	DW	02258H
	DW	022c9H
	DW	0233bH
	DW	023afH
	DW	02425H
	DW	0249cH
	DW	02515H
	DW	02590H
	DW	0260dH
	DW	0268cH
	DW	0270cH
	DW	0278fH
	DW	02814H
	DW	0289bH
	DW	02924H
	DW	029afH
	DW	02a3dH
	DW	02acdH
	DW	02b60H
	DW	02bf5H
	DW	02c8dH
	DW	02d28H
	DW	02dc6H
	DW	02e67H
	DW	02f0bH
	DW	02fb2H
	DW	0305dH
	DW	0310bH
	DW	031bdH
	DW	03273H
	DW	0332dH
	DW	033ebH
	DW	034aeH
	DW	03575H
	DW	03642H
	DW	03713H
	DW	037eaH
	DW	038c6H
	DW	039a9H
	DW	03a91H
	DW	03b81H
	DW	03c77H
	DW	03d75H
	DW	03e7bH
	DW	03f8aH
	DW	040a1H
	DW	041c2H
	DW	042eeH
	DW	04425H
	DW	04568H
	DW	046b7H
	DW	04815H
	DW	04983H
	DW	04b00H
	ORG $+6
?m_lMIDIToDB@CParamMerger@@0PAFA DW 0da80H		; CParamMerger::m_lMIDIToDB
	DW	0df21H
	DW	0e3d5H
	DW	0e696H
	DW	0e88aH
	DW	0ea0dH
	DW	0eb4aH
	DW	0ec56H
	DW	0ed3eH
	DW	0ee0aH
	DW	0eec1H
	DW	0ef67H
	DW	0effeH
	DW	0f089H
	DW	0f10aH
	DW	0f182H
	DW	0f1f2H
	DW	0f25bH
	DW	0f2beH
	DW	0f31cH
	DW	0f375H
	DW	0f3caH
	DW	0f41bH
	DW	0f468H
	DW	0f4b2H
	DW	0f4f9H
	DW	0f53dH
	DW	0f57fH
	DW	0f5beH
	DW	0f5fbH
	DW	0f636H
	DW	0f66fH
	DW	0f6a6H
	DW	0f6dbH
	DW	0f70fH
	DW	0f742H
	DW	0f772H
	DW	0f7a2H
	DW	0f7d0H
	DW	0f7feH
	DW	0f82aH
	DW	0f854H
	DW	0f87eH
	DW	0f8a7H
	DW	0f8cfH
	DW	0f8f6H
	DW	0f91cH
	DW	0f942H
	DW	0f966H
	DW	0f98aH
	DW	0f9adH
	DW	0f9d0H
	DW	0f9f1H
	DW	0fa12H
	DW	0fa33H
	DW	0fa53H
	DW	0fa72H
	DW	0fa91H
	DW	0faafH
	DW	0facdH
	DW	0faeaH
	DW	0fb07H
	DW	0fb23H
	DW	0fb3fH
	DW	0fb5aH
	DW	0fb75H
	DW	0fb8fH
	DW	0fbaaH
	DW	0fbc3H
	DW	0fbddH
	DW	0fbf6H
	DW	0fc0eH
	DW	0fc27H
	DW	0fc3fH
	DW	0fc56H
	DW	0fc6eH
	DW	0fc85H
	DW	0fc9bH
	DW	0fcb2H
	DW	0fcc8H
	DW	0fcdeH
	DW	0fcf3H
	DW	0fd09H
	DW	0fd1eH
	DW	0fd32H
	DW	0fd47H
	DW	0fd5bH
	DW	0fd6fH
	DW	0fd83H
	DW	0fd97H
	DW	0fdaaH
	DW	0fdbdH
	DW	0fdd0H
	DW	0fde3H
	DW	0fdf6H
	DW	0fe08H
	DW	0fe1aH
	DW	0fe2cH
	DW	0fe3eH
	DW	0fe50H
	DW	0fe61H
	DW	0fe73H
	DW	0fe84H
	DW	0fe95H
	DW	0fea5H
	DW	0feb6H
	DW	0fec7H
	DW	0fed7H
	DW	0fee7H
	DW	0fef7H
	DW	0ff07H
	DW	0ff17H
	DW	0ff26H
	DW	0ff36H
	DW	0ff45H
	DW	0ff54H
	DW	0ff63H
	DW	0ff72H
	DW	0ff81H
	DW	0ff8fH
	DW	0ff9eH
	DW	0ffacH
	DW	0ffbbH
	DW	0ffc9H
	DW	0ffd7H
	DW	0ffe5H
	DW	0fff3H
	DW	00H
?m_lDBToMIDI@CParamMerger@@0PAEA DB 07fH		; CParamMerger::m_lDBToMIDI
	DB	077H
	DB	071H
	DB	06aH
	DB	064H
	DB	05fH
	DB	059H
	DB	054H
	DB	050H
	DB	04bH
	DB	047H
	DB	043H
	DB	03fH
	DB	03cH
	DB	038H
	DB	035H
	DB	032H
	DB	02fH
	DB	02dH
	DB	02aH
	DB	028H
	DB	025H
	DB	023H
	DB	021H
	DB	01fH
	DB	01eH
	DB	01cH
	DB	01aH
	DB	019H
	DB	017H
	DB	016H
	DB	015H
	DB	014H
	DB	013H
	DB	011H
	DB	010H
	DB	0fH
	DB	0fH
	DB	0eH
	DB	0dH
	DB	0cH
	DB	0bH
	DB	0bH
	DB	0aH
	DB	0aH
	DB	09H
	DB	08H
	DB	08H
	DB	08H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	06H
	DB	05H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
_dwFallbackScales DD 0ab5ab5H
	DD	06ad6adH
	DD	05ab5abH
	DD	0ad5ad5H
	DD	06b56b5H
	DD	05ad5adH
	DD	056b56bH
	DD	0d5ad5aH
	DD	0b56b56H
	DD	0d6ad6aH
	DD	0b5ab5aH
	DD	0ad6ad6H
_DATA	ENDS
PUBLIC	?Clear@CChannelBlockList@@QAEXXZ		; CChannelBlockList::Clear
PUBLIC	?RemoveHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
;	COMDAT ?Clear@CChannelBlockList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12
$T75100 = -8
_pCB$ = -4
?Clear@CChannelBlockList@@QAEXXZ PROC NEAR		; CChannelBlockList::Clear, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L69427:

; 17   :     CChannelBlock* pCB;
; 18   :     while( pCB = RemoveHead() )

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pCB$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pCB$[ebp], 0
  00018	74 14		 je	 SHORT $L69424

; 19   :     {
; 20   :         delete pCB;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pCB$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR $T75100[ebp], eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR $T75100[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00029	83 c4 04	 add	 esp, 4

; 21   :     }

  0002c	eb db		 jmp	 SHORT $L69427
$L69424:

; 22   : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Clear@CChannelBlockList@@QAEXXZ ENDP			; CChannelBlockList::Clear
_TEXT	ENDS
PUBLIC	?Clear@CParamMerger@@QAEXJ@Z			; CParamMerger::Clear
PUBLIC	?Clear@CChannelMap@@QAEXXZ			; CChannelMap::Clear
PUBLIC	?Reset@CChannelMap@@QAEXH@Z			; CChannelMap::Reset
; Function compile flags: /Odt
;	COMDAT ?Clear@CChannelMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Clear@CChannelMap@@QAEXXZ PROC NEAR			; CChannelMap::Clear, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   :     Reset(TRUE);                // Clear all MIDI controllers

  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Reset@CChannelMap@@QAEXH@Z ; CChannelMap::Reset

; 28   :     m_TransposeMerger.Clear(0); // No transpose.

  00011	6a 00		 push	 0
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 18	 add	 ecx, 24			; 00000018H
  00019	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 29   :     nTranspose = 0;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	66 c7 40 7c 00
	00		 mov	 WORD PTR [eax+124], 0

; 30   :     wFlags = CMAP_FREE;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	66 c7 41 7e 01
	00		 mov	 WORD PTR [ecx+126], 1

; 31   : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?Clear@CChannelMap@@QAEXXZ ENDP				; CChannelMap::Clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Reset@CChannelMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_fVolumeAndPanToo$ = 8
?Reset@CChannelMap@@QAEXH@Z PROC NEAR			; CChannelMap::Reset, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 36   :     if (fVolumeAndPanToo)

  00007	83 7d 08 00	 cmp	 DWORD PTR _fVolumeAndPanToo$[ebp], 0
  0000b	74 1a		 je	 SHORT $L69438

; 37   :     {
; 38   :         m_PanMerger.Clear(0);       // Panned to center.

  0000d	6a 00		 push	 0
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 34	 add	 ecx, 52			; 00000034H
  00015	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 39   :         m_VolumeMerger.Clear(-415); // Equivalent to MIDI value 100.

  0001a	68 61 fe ff ff	 push	 -415			; fffffe61H
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear
$L69438:

; 40   :     }
; 41   :     m_PitchbendMerger.Clear(0); // No pitch bend.

  00027	6a 00		 push	 0
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 24	 add	 ecx, 36			; 00000024H
  0002f	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 42   :     m_ExpressionMerger.Clear(0);// Full volume for expression (MIDI 127.)

  00034	6a 00		 push	 0
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003c	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 43   :     m_FilterMerger.Clear(0);    // No filter change.

  00041	6a 00		 push	 0
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 40	 add	 ecx, 64			; 00000040H
  00049	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 44   :     m_ReverbMerger.Clear(-87); // Start at default level (MIDI 40).

  0004e	6a a9		 push	 -87			; ffffffa9H
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 58	 add	 ecx, 88			; 00000058H
  00056	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 45   :     m_ChorusMerger.Clear(-127);    // Start with no chorus.

  0005b	6a 81		 push	 -127			; ffffff81H
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 c1 64	 add	 ecx, 100		; 00000064H
  00063	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 46   :     m_ModWheelMerger.Clear(-127);  // Start with no mod wheel.

  00068	6a 81		 push	 -127			; ffffff81H
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00070	e8 00 00 00 00	 call	 ?Clear@CParamMerger@@QAEXJ@Z ; CParamMerger::Clear

; 47   : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?Reset@CChannelMap@@QAEXH@Z ENDP			; CChannelMap::Reset
_TEXT	ENDS
PUBLIC	?RemoveHead@CParamMerger@@AAEPAVCMergeParam@@XZ	; CParamMerger::RemoveHead
; Function compile flags: /Odt
;	COMDAT ?Clear@CParamMerger@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -12
$T75110 = -8
_pParam$ = -4
_lInitValue$ = 8
?Clear@CParamMerger@@QAEXJ@Z PROC NEAR			; CParamMerger::Clear, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L69445:

; 52   :     CMergeParam *pParam;
; 53   :     while (pParam = RemoveHead())

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CParamMerger@@AAEPAVCMergeParam@@XZ ; CParamMerger::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pParam$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pParam$[ebp], 0
  00018	74 14		 je	 SHORT $L69446

; 54   :     {
; 55   :         delete pParam;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pParam$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR $T75110[ebp], eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR $T75110[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00029	83 c4 04	 add	 esp, 4

; 56   :     }

  0002c	eb db		 jmp	 SHORT $L69445
$L69446:

; 57   :     m_lZeroIndexData = lInitValue;

  0002e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 45 08	 mov	 eax, DWORD PTR _lInitValue$[ebp]
  00034	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 58   :     m_lMergeTotal = 0;

  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 59   : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?Clear@CParamMerger@@QAEXJ@Z ENDP			; CParamMerger::Clear
_TEXT	ENDS
PUBLIC	??0CParamMerger@@QAE@XZ				; CParamMerger::CParamMerger
PUBLIC	??0AList@@QAE@XZ				; AList::AList
; Function compile flags: /Odt
;	COMDAT ??0CParamMerger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CParamMerger@@QAE@XZ PROC NEAR			; CParamMerger::CParamMerger, COMDAT
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList

; 98   :     m_lMergeTotal = 0;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 99   :     m_lZeroIndexData = 0;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 100  : }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0CParamMerger@@QAE@XZ ENDP				; CParamMerger::CParamMerger
_TEXT	ENDS
PUBLIC	?VolumeToMidi@CParamMerger@@SGEJ@Z		; CParamMerger::VolumeToMidi
; Function compile flags: /Odt
;	COMDAT ?VolumeToMidi@CParamMerger@@SGEJ@Z
_TEXT	SEGMENT
_lFraction$ = -8
_lResult$ = -4
_lVolume$ = 8
?VolumeToMidi@CParamMerger@@SGEJ@Z PROC NEAR		; CParamMerger::VolumeToMidi, COMDAT

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 105  :     if (lVolume < -9600) lVolume = -9600;

  00006	81 7d 08 80 da
	ff ff		 cmp	 DWORD PTR _lVolume$[ebp], -9600 ; ffffda80H
  0000d	7d 07		 jge	 SHORT $L69454
  0000f	c7 45 08 80 da
	ff ff		 mov	 DWORD PTR _lVolume$[ebp], -9600 ; ffffda80H
$L69454:

; 106  :     if (lVolume > 0) lVolume = 0;

  00016	83 7d 08 00	 cmp	 DWORD PTR _lVolume$[ebp], 0
  0001a	7e 07		 jle	 SHORT $L69455
  0001c	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lVolume$[ebp], 0
$L69455:

; 107  :     lVolume = -lVolume;

  00023	8b 45 08	 mov	 eax, DWORD PTR _lVolume$[ebp]
  00026	f7 d8		 neg	 eax
  00028	89 45 08	 mov	 DWORD PTR _lVolume$[ebp], eax

; 108  :     long lFraction = lVolume % 100;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lVolume$[ebp]
  0002e	99		 cdq
  0002f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00034	f7 f9		 idiv	 ecx
  00036	89 55 f8	 mov	 DWORD PTR _lFraction$[ebp], edx

; 109  :     lVolume = lVolume / 100;

  00039	8b 45 08	 mov	 eax, DWORD PTR _lVolume$[ebp]
  0003c	99		 cdq
  0003d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00042	f7 f9		 idiv	 ecx
  00044	89 45 08	 mov	 DWORD PTR _lVolume$[ebp], eax

; 110  :     long lResult = m_lDBToMIDI[lVolume];

  00047	8b 55 08	 mov	 edx, DWORD PTR _lVolume$[ebp]
  0004a	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR ?m_lDBToMIDI@CParamMerger@@0PAEA[edx]
  00051	89 45 fc	 mov	 DWORD PTR _lResult$[ebp], eax

; 111  :     lResult += ((m_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _lVolume$[ebp]
  00057	0f b6 81 01 00
	00 00		 movzx	 eax, BYTE PTR ?m_lDBToMIDI@CParamMerger@@0PAEA[ecx+1]
  0005e	2b 45 fc	 sub	 eax, DWORD PTR _lResult$[ebp]
  00061	0f af 45 f8	 imul	 eax, DWORD PTR _lFraction$[ebp]
  00065	99		 cdq
  00066	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0006b	f7 f9		 idiv	 ecx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _lResult$[ebp]
  00070	03 d0		 add	 edx, eax
  00072	89 55 fc	 mov	 DWORD PTR _lResult$[ebp], edx

; 112  :     return (BYTE) lResult;

  00075	8a 45 fc	 mov	 al, BYTE PTR _lResult$[ebp]

; 113  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?VolumeToMidi@CParamMerger@@SGEJ@Z ENDP			; CParamMerger::VolumeToMidi
_TEXT	ENDS
PUBLIC	?MergeMidiVolume@CParamMerger@@QAEEKE@Z		; CParamMerger::MergeMidiVolume
PUBLIC	?MergeData@CParamMerger@@AAEJKJ@Z		; CParamMerger::MergeData
; Function compile flags: /Odt
;	COMDAT ?MergeMidiVolume@CParamMerger@@QAEEKE@Z
_TEXT	SEGMENT
_this$ = -8
_lVolume$ = -4
_dwIndex$ = 8
_bMIDIVolume$ = 12
?MergeMidiVolume@CParamMerger@@QAEEKE@Z PROC NEAR	; CParamMerger::MergeMidiVolume, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 126  :     long lVolume = MergeData(dwIndex,(long)m_lMIDIToDB[bMIDIVolume]);

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _bMIDIVolume$[ebp]
  0000d	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_lMIDIToDB@CParamMerger@@0PAFA[eax*2]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?MergeData@CParamMerger@@AAEJKJ@Z ; CParamMerger::MergeData
  00022	89 45 fc	 mov	 DWORD PTR _lVolume$[ebp], eax

; 127  :     if (m_lMergeTotal || dwIndex) // Optimization for simplest and most frequent case - there are no additional indexes.

  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002c	75 06		 jne	 SHORT $L69467
  0002e	83 7d 08 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00032	74 0b		 je	 SHORT $L69466
$L69467:

; 128  :     {
; 129  :         return (BYTE) VolumeToMidi(lVolume);

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _lVolume$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ?VolumeToMidi@CParamMerger@@SGEJ@Z ; CParamMerger::VolumeToMidi
  0003d	eb 03		 jmp	 SHORT $L69463
$L69466:

; 130  :     }
; 131  :     return bMIDIVolume;

  0003f	8a 45 0c	 mov	 al, BYTE PTR _bMIDIVolume$[ebp]
$L69463:

; 132  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?MergeMidiVolume@CParamMerger@@QAEEKE@Z ENDP		; CParamMerger::MergeMidiVolume
_TEXT	ENDS
PUBLIC	?GetVolumeStart@CParamMerger@@QAEEK@Z		; CParamMerger::GetVolumeStart
PUBLIC	?GetIndexedValue@CParamMerger@@QAEJK@Z		; CParamMerger::GetIndexedValue
; Function compile flags: /Odt
;	COMDAT ?GetVolumeStart@CParamMerger@@QAEEK@Z
_TEXT	SEGMENT
_this$ = -4
_dwIndex$ = 8
?GetVolumeStart@CParamMerger@@QAEEK@Z PROC NEAR		; CParamMerger::GetVolumeStart, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  :     if (dwIndex == 0)

  00007	83 7d 08 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0000b	75 0e		 jne	 SHORT $L69473

; 138  :     {
; 139  :         return VolumeToMidi(m_lZeroIndexData);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?VolumeToMidi@CParamMerger@@SGEJ@Z ; CParamMerger::VolumeToMidi
  00019	eb 12		 jmp	 SHORT $L69472
$L69473:

; 140  :     }
; 141  :     return VolumeToMidi(GetIndexedValue(dwIndex));

  0001b	8b 55 08	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0001e	52		 push	 edx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?VolumeToMidi@CParamMerger@@SGEJ@Z ; CParamMerger::VolumeToMidi
$L69472:

; 142  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?GetVolumeStart@CParamMerger@@QAEEK@Z ENDP		; CParamMerger::GetVolumeStart
_TEXT	ENDS
PUBLIC	?MergeValue@CParamMerger@@QAEJKJJJ@Z		; CParamMerger::MergeValue
; Function compile flags: /Odt
;	COMDAT ?MergeValue@CParamMerger@@QAEJKJJJ@Z
_TEXT	SEGMENT
_this$ = -4
_dwIndex$ = 8
_lData$ = 12
_lCenter$ = 16
_lRange$ = 20
?MergeValue@CParamMerger@@QAEJKJJJ@Z PROC NEAR		; CParamMerger::MergeValue, COMDAT
; _this$ = ecx

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  :     lData = MergeData(dwIndex,lData - lCenter) + lCenter;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _lData$[ebp]
  0000a	2b 45 10	 sub	 eax, DWORD PTR _lCenter$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00011	51		 push	 ecx
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?MergeData@CParamMerger@@AAEJKJ@Z ; CParamMerger::MergeData
  0001a	03 45 10	 add	 eax, DWORD PTR _lCenter$[ebp]
  0001d	89 45 0c	 mov	 DWORD PTR _lData$[ebp], eax

; 155  :     if (lData < 0) lData = 0;

  00020	83 7d 0c 00	 cmp	 DWORD PTR _lData$[ebp], 0
  00024	7d 07		 jge	 SHORT $L69481
  00026	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _lData$[ebp], 0
$L69481:

; 156  :     if (lData > lRange) lData = lRange;

  0002d	8b 55 0c	 mov	 edx, DWORD PTR _lData$[ebp]
  00030	3b 55 14	 cmp	 edx, DWORD PTR _lRange$[ebp]
  00033	7e 06		 jle	 SHORT $L69482
  00035	8b 45 14	 mov	 eax, DWORD PTR _lRange$[ebp]
  00038	89 45 0c	 mov	 DWORD PTR _lData$[ebp], eax
$L69482:

; 157  :     return lData;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _lData$[ebp]

; 158  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 10 00	 ret	 16			; 00000010H
?MergeValue@CParamMerger@@QAEJKJJJ@Z ENDP		; CParamMerger::MergeValue
_TEXT	ENDS
PUBLIC	?MergeTranspose@CParamMerger@@QAEFKF@Z		; CParamMerger::MergeTranspose
; Function compile flags: /Odt
;	COMDAT ?MergeTranspose@CParamMerger@@QAEFKF@Z
_TEXT	SEGMENT
_this$ = -4
_dwIndex$ = 8
_nTranspose$ = 12
?MergeTranspose@CParamMerger@@QAEFKF@Z PROC NEAR	; CParamMerger::MergeTranspose, COMDAT
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 164  :     return (short) MergeData(dwIndex,nTranspose);

  00007	0f bf 45 0c	 movsx	 eax, WORD PTR _nTranspose$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0000f	51		 push	 ecx
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?MergeData@CParamMerger@@AAEJKJ@Z ; CParamMerger::MergeData

; 165  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?MergeTranspose@CParamMerger@@QAEFKF@Z ENDP		; CParamMerger::MergeTranspose
_TEXT	ENDS
PUBLIC	?GetNext@CMergeParam@@QAEPAV1@XZ		; CMergeParam::GetNext
PUBLIC	??0CMergeParam@@QAE@XZ				; CMergeParam::CMergeParam
PUBLIC	?AddHead@CParamMerger@@AAEXPAVCMergeParam@@@Z	; CParamMerger::AddHead
PUBLIC	?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ	; CParamMerger::GetHead
; Function compile flags: /Odt
;	COMDAT ?MergeData@CParamMerger@@AAEJKJ@Z
_TEXT	SEGMENT
tv84 = -20
_this$ = -16
$T75132 = -12
_fNoEntry$69495 = -8
_pParam$69496 = -4
_dwIndex$ = 8
_lData$ = 12
?MergeData@CParamMerger@@AAEJKJ@Z PROC NEAR		; CParamMerger::MergeData, COMDAT
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 170  :     if (dwIndex)

  00009	83 7d 08 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0000d	0f 84 d5 00 00
	00		 je	 $L69494

; 171  :     {
; 172  :         // If this has an index, scan the indexes. Look
; 173  :         // for the matching index. If it is found, update it
; 174  :         // with the new data. Meanwhile, add up all the data fields.
; 175  :         // If it is not found, add an entry for it.
; 176  :         m_lMergeTotal = 0;   // Recalculate

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 177  :         BOOL fNoEntry = TRUE;

  0001d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fNoEntry$69495[ebp], 1

; 178  :         CMergeParam *pParam = GetHead();

  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ ; CParamMerger::GetHead
  0002c	89 45 fc	 mov	 DWORD PTR _pParam$69496[ebp], eax

; 179  :         for (;pParam;pParam = pParam->GetNext())

  0002f	eb 0b		 jmp	 SHORT $L69497
$L69498:
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _pParam$69496[ebp]
  00034	e8 00 00 00 00	 call	 ?GetNext@CMergeParam@@QAEPAV1@XZ ; CMergeParam::GetNext
  00039	89 45 fc	 mov	 DWORD PTR _pParam$69496[ebp], eax
$L69497:
  0003c	83 7d fc 00	 cmp	 DWORD PTR _pParam$69496[ebp], 0
  00040	74 2f		 je	 SHORT $L69499

; 180  :         {
; 181  :             if (pParam->m_dwIndex == dwIndex)

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _pParam$69496[ebp]
  00045	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00048	3b 55 08	 cmp	 edx, DWORD PTR _dwIndex$[ebp]
  0004b	75 10		 jne	 SHORT $L69500

; 182  :             {
; 183  :                 // Found the index. Store the new value.
; 184  :                 pParam->m_lData = lData;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pParam$69496[ebp]
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _lData$[ebp]
  00053	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 185  :                 fNoEntry = FALSE;

  00056	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fNoEntry$69495[ebp], 0
$L69500:

; 186  :             }
; 187  :             // Sum all values to create the merged total.
; 188  :             m_lMergeTotal += pParam->m_lData;

  0005d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _pParam$69496[ebp]
  00066	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00069	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 189  :         }

  0006f	eb c0		 jmp	 SHORT $L69498
$L69499:

; 190  :         if (fNoEntry)

  00071	83 7d f8 00	 cmp	 DWORD PTR _fNoEntry$69495[ebp], 0
  00075	74 60		 je	 SHORT $L69501

; 191  :         {
; 192  :             // Didn't find the index. Create one and store the value.
; 193  :             pParam = new CMergeParam;

  00077	6a 0c		 push	 12			; 0000000cH
  00079	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 f4	 mov	 DWORD PTR $T75132[ebp], eax
  00084	83 7d f4 00	 cmp	 DWORD PTR $T75132[ebp], 0
  00088	74 0d		 je	 SHORT $L75133
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR $T75132[ebp]
  0008d	e8 00 00 00 00	 call	 ??0CMergeParam@@QAE@XZ
  00092	89 45 ec	 mov	 DWORD PTR tv84[ebp], eax
  00095	eb 07		 jmp	 SHORT $L75134
$L75133:
  00097	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$L75134:
  0009e	8b 45 ec	 mov	 eax, DWORD PTR tv84[ebp]
  000a1	89 45 fc	 mov	 DWORD PTR _pParam$69496[ebp], eax

; 194  :             if (pParam)

  000a4	83 7d fc 00	 cmp	 DWORD PTR _pParam$69496[ebp], 0
  000a8	74 2d		 je	 SHORT $L69501

; 195  :             {
; 196  :                 pParam->m_dwIndex = dwIndex;

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _pParam$69496[ebp]
  000ad	8b 55 08	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  000b0	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 197  :                 pParam->m_lData = lData;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _pParam$69496[ebp]
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _lData$[ebp]
  000b9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 198  :                 m_lMergeTotal += lData;

  000bc	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c2	03 45 0c	 add	 eax, DWORD PTR _lData$[ebp]
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 199  :                 AddHead(pParam);

  000cb	8b 55 fc	 mov	 edx, DWORD PTR _pParam$69496[ebp]
  000ce	52		 push	 edx
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?AddHead@CParamMerger@@AAEXPAVCMergeParam@@@Z ; CParamMerger::AddHead
$L69501:

; 200  :             }
; 201  :         }
; 202  :         // Add the initial value for merge index 0.
; 203  :         lData = m_lMergeTotal + m_lZeroIndexData;

  000d7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000dd	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e0	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000e3	89 4d 0c	 mov	 DWORD PTR _lData$[ebp], ecx

; 204  :     }
; 205  :     else

  000e6	eb 15		 jmp	 SHORT $L69505
$L69494:

; 206  :     {
; 207  :         m_lZeroIndexData = lData;

  000e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _lData$[ebp]
  000ee	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 208  :         lData += m_lMergeTotal;

  000f1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	8b 45 0c	 mov	 eax, DWORD PTR _lData$[ebp]
  000f7	03 42 04	 add	 eax, DWORD PTR [edx+4]
  000fa	89 45 0c	 mov	 DWORD PTR _lData$[ebp], eax
$L69505:

; 209  :     }
; 210  :     return lData;

  000fd	8b 45 0c	 mov	 eax, DWORD PTR _lData$[ebp]

; 211  : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 08 00	 ret	 8
?MergeData@CParamMerger@@AAEJKJ@Z ENDP			; CParamMerger::MergeData
_TEXT	ENDS
PUBLIC	??0AListItem@@QAE@XZ				; AListItem::AListItem
; Function compile flags: /Odt
;	COMDAT ??0CMergeParam@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CMergeParam@@QAE@XZ PROC NEAR			; CMergeParam::CMergeParam, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CMergeParam@@QAE@XZ ENDP				; CMergeParam::CMergeParam
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetIndexedValue@CParamMerger@@QAEJK@Z
_TEXT	SEGMENT
_this$ = -12
_fNoEntry$69513 = -8
_pParam$69514 = -4
_dwIndex$ = 8
?GetIndexedValue@CParamMerger@@QAEJK@Z PROC NEAR	; CParamMerger::GetIndexedValue, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 217  :     if (dwIndex)

  00009	83 7d 08 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0000d	74 3e		 je	 SHORT $L69512

; 218  :     {
; 219  :         // If this has an index, scan the indexes. Look
; 220  :         // for the matching index. If it is found, return its data.  
; 221  :         // If not, return the default 0.
; 222  :         BOOL fNoEntry = TRUE;

  0000f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fNoEntry$69513[ebp], 1

; 223  :         CMergeParam *pParam = GetHead();

  00016	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ ; CParamMerger::GetHead
  0001e	89 45 fc	 mov	 DWORD PTR _pParam$69514[ebp], eax

; 224  :         for (;pParam;pParam = pParam->GetNext())

  00021	eb 0b		 jmp	 SHORT $L69515
$L69516:
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _pParam$69514[ebp]
  00026	e8 00 00 00 00	 call	 ?GetNext@CMergeParam@@QAEPAV1@XZ ; CMergeParam::GetNext
  0002b	89 45 fc	 mov	 DWORD PTR _pParam$69514[ebp], eax
$L69515:
  0002e	83 7d fc 00	 cmp	 DWORD PTR _pParam$69514[ebp], 0
  00032	74 15		 je	 SHORT $L69517

; 225  :         {
; 226  :             if (pParam->m_dwIndex == dwIndex)

  00034	8b 45 fc	 mov	 eax, DWORD PTR _pParam$69514[ebp]
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	3b 4d 08	 cmp	 ecx, DWORD PTR _dwIndex$[ebp]
  0003d	75 08		 jne	 SHORT $L69518

; 227  :             {
; 228  :                 return pParam->m_lData;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _pParam$69514[ebp]
  00042	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00045	eb 0c		 jmp	 SHORT $L69511
$L69518:

; 229  :             }
; 230  :         }

  00047	eb da		 jmp	 SHORT $L69516
$L69517:

; 231  :         return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 06		 jmp	 SHORT $L69511
$L69512:

; 232  :     }
; 233  :     return m_lZeroIndexData;

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L69511:

; 234  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetIndexedValue@CParamMerger@@QAEJK@Z ENDP		; CParamMerger::GetIndexedValue
_TEXT	ENDS
PUBLIC	??0CPitchMerger@@QAE@XZ				; CPitchMerger::CPitchMerger
; Function compile flags: /Odt
;	COMDAT ??0CPitchMerger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPitchMerger@@QAE@XZ PROC NEAR			; CPitchMerger::CPitchMerger, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger

; 238  :     m_lBendRange = 200;     // Default value for pitch bend range is whole tone.

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 0c c8 00
	00 00		 mov	 DWORD PTR [eax+12], 200	; 000000c8H

; 239  : }

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0CPitchMerger@@QAE@XZ ENDP				; CPitchMerger::CPitchMerger
_TEXT	ENDS
PUBLIC	?Init@CChannelBlock@@QAEXKKKG@Z			; CChannelBlock::Init
; Function compile flags: /Odt
;	COMDAT ?Init@CChannelBlock@@QAEXKKKG@Z
_TEXT	SEGMENT
_this$ = -8
_dwIndex$ = -4
_dwPChannelStart$ = 8
_dwPortIndex$ = 12
_dwGroup$ = 16
_wFlags$ = 20
?Init@CChannelBlock@@QAEXKKKG@Z PROC NEAR		; CChannelBlock::Init, COMDAT
; _this$ = ecx

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 246  :     DWORD dwIndex;
; 247  :     m_dwPortIndex = dwPortIndex;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPortIndex$[ebp]
  0000f	89 88 0c 08 00
	00		 mov	 DWORD PTR [eax+2060], ecx

; 248  :     m_dwPChannelStart = ( dwPChannelStart / PCHANNEL_BLOCKSIZE ) * PCHANNEL_BLOCKSIZE;

  00015	8b 55 08	 mov	 edx, DWORD PTR _dwPChannelStart$[ebp]
  00018	c1 ea 04	 shr	 edx, 4
  0001b	c1 e2 04	 shl	 edx, 4
  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 249  :     for( dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++ )

  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $L69530
$L69531:
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d fc	 mov	 DWORD PTR _dwIndex$[ebp], ecx
$L69530:
  00036	83 7d fc 10	 cmp	 DWORD PTR _dwIndex$[ebp], 16 ; 00000010H
  0003a	73 6f		 jae	 SHORT $L69532

; 250  :     {
; 251  :         m_aChannelMap[dwIndex].Clear();

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0003f	c1 e2 07	 shl	 edx, 7
  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00049	e8 00 00 00 00	 call	 ?Clear@CChannelMap@@QAEXXZ ; CChannelMap::Clear

; 252  :         m_aChannelMap[dwIndex].dwPortIndex = dwPortIndex;

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00051	c1 e1 07	 shl	 ecx, 7
  00054	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 45 0c	 mov	 eax, DWORD PTR _dwPortIndex$[ebp]
  0005a	89 44 0a 78	 mov	 DWORD PTR [edx+ecx+120], eax

; 253  :         m_aChannelMap[dwIndex].dwGroup = dwGroup;

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00061	c1 e1 07	 shl	 ecx, 7
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 45 10	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  0006a	89 44 0a 7c	 mov	 DWORD PTR [edx+ecx+124], eax

; 254  :         m_aChannelMap[dwIndex].dwMChannel = dwIndex;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00071	c1 e1 07	 shl	 ecx, 7
  00074	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00077	8b 45 fc	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0007a	89 84 0a 80 00
	00 00		 mov	 DWORD PTR [edx+ecx+128], eax

; 255  :         m_aChannelMap[dwIndex].nTranspose = 0;

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00084	c1 e1 07	 shl	 ecx, 7
  00087	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	66 c7 84 0a 84
	00 00 00 00 00	 mov	 WORD PTR [edx+ecx+132], 0

; 256  :         m_aChannelMap[dwIndex].wFlags = wFlags;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00097	c1 e0 07	 shl	 eax, 7
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	66 8b 55 14	 mov	 dx, WORD PTR _wFlags$[ebp]
  000a1	66 89 94 01 86
	00 00 00	 mov	 WORD PTR [ecx+eax+134], dx

; 257  :     }

  000a9	eb 82		 jmp	 SHORT $L69531
$L69532:

; 258  :     if (wFlags == CMAP_FREE) m_dwFreeChannels = 16;

  000ab	0f b7 45 14	 movzx	 eax, WORD PTR _wFlags$[ebp]
  000af	83 f8 01	 cmp	 eax, 1
  000b2	75 0f		 jne	 SHORT $L69534
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	c7 81 08 08 00
	00 10 00 00 00	 mov	 DWORD PTR [ecx+2056], 16 ; 00000010H

; 259  :     else m_dwFreeChannels = 0;

  000c1	eb 0d		 jmp	 SHORT $L69528
$L69534:
  000c3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c6	c7 82 08 08 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2056], 0
$L69528:

; 260  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 10 00	 ret	 16			; 00000010H
?Init@CChannelBlock@@QAEXKKKG@Z ENDP			; CChannelBlock::Init
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0IDirectMusicPerformance@@QAE@XZ		; IDirectMusicPerformance::IDirectMusicPerformance
PUBLIC	??0IDirectMusicGraph@@QAE@XZ			; IDirectMusicGraph::IDirectMusicGraph
PUBLIC	??0CChannelBlockList@@QAE@XZ			; CChannelBlockList::CChannelBlockList
PUBLIC	??0IDirectMusicTool@@QAE@XZ			; IDirectMusicTool::IDirectMusicTool
PUBLIC	??0CPerformance@@QAE@XZ				; CPerformance::CPerformance
PUBLIC	?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
PUBLIC	?AddRef@CPerformance@@UAGKXZ			; CPerformance::AddRef
PUBLIC	?Release@CPerformance@@UAGKXZ			; CPerformance::Release
PUBLIC	?PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z ; CPerformance::PlaySegment
PUBLIC	?Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z ; CPerformance::Stop
PUBLIC	?GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z ; CPerformance::GetSegmentState
PUBLIC	?SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z	; CPerformance::SendPMsg
PUBLIC	?MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z	; CPerformance::MusicToReferenceTime
PUBLIC	?ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z	; CPerformance::ReferenceToMusicTime
PUBLIC	?IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z ; CPerformance::IsPlaying
PUBLIC	?GetTime@CPerformance@@UAGJPA_JPAJ@Z		; CPerformance::GetTime
PUBLIC	?AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z ; CPerformance::AllocPMsg
PUBLIC	?FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z	; CPerformance::FreePMsg
PUBLIC	?GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z ; CPerformance::GetNotificationPMsg
PUBLIC	?AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z ; CPerformance::AddNotificationType
PUBLIC	?RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z ; CPerformance::RemoveNotificationType
PUBLIC	?Invalidate@CPerformance@@UAGJJK@Z		; CPerformance::Invalidate
PUBLIC	?GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z ; CPerformance::GetParam
PUBLIC	?GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z ; CPerformance::GetGlobalParam
PUBLIC	?SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z ; CPerformance::SetGlobalParam
PUBLIC	?GetLatencyTime@CPerformance@@UAGJPA_J@Z	; CPerformance::GetLatencyTime
PUBLIC	?GetQueueTime@CPerformance@@UAGJPA_J@Z		; CPerformance::GetQueueTime
PUBLIC	?CloseDown@CPerformance@@UAGJXZ			; CPerformance::CloseDown
PUBLIC	?GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z	; CPerformance::GetResolvedTime
PUBLIC	?GetSynth@CPerformance@@UAGJPAPAUIDirectMusicSynthX@@@Z ; CPerformance::GetSynth
PUBLIC	?MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z ; CPerformance::MIDIToMusic
PUBLIC	?MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z ; CPerformance::MusicToMIDI
PUBLIC	??0CAudioPathList@@QAE@XZ			; CAudioPathList::CAudioPathList
PUBLIC	?PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z ; CPerformance::PlaySegmentEx
PUBLIC	?StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z	; CPerformance::StopEx
PUBLIC	?ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU2@@Z ; CPerformance::ClonePMsg
PUBLIC	?CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z ; CPerformance::CreateAudioPath
PUBLIC	?CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z ; CPerformance::CreateStandardAudioPath
PUBLIC	?SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z ; CPerformance::SetDefaultAudioPath
PUBLIC	?GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z ; CPerformance::GetDefaultAudioPath
PUBLIC	?GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z ; CPerformance::GetParamEx
PUBLIC	?InitAudioX@CPerformance@@UAGJKKKK@Z		; CPerformance::InitAudioX
PUBLIC	?Init@CPerformance@@UAGJPAUIDirectMusicGraph@@@Z ; CPerformance::Init
PUBLIC	?ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z ; CPerformance::ProcessPMsg
PUBLIC	?Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z ; CPerformance::Flush
PUBLIC	?GetMsgDeliveryType@CPerformance@@UAGJPAK@Z	; CPerformance::GetMsgDeliveryType
PUBLIC	?GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z	; CPerformance::GetMediaTypeArraySize
PUBLIC	?GetMediaTypes@CPerformance@@UAGJPAPAKK@Z	; CPerformance::GetMediaTypes
PUBLIC	?InsertTool@CPerformance@@UAGJPAUIDirectMusicTool@@PAKKJ@Z ; CPerformance::InsertTool
PUBLIC	?GetTool@CPerformance@@UAGJKPAPAUIDirectMusicTool@@@Z ; CPerformance::GetTool
PUBLIC	?RemoveTool@CPerformance@@UAGJPAUIDirectMusicTool@@@Z ; CPerformance::RemoveTool
PUBLIC	?StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z	; CPerformance::StampPMsg
PUBLIC	?GetPortAndFlags@CPerformance@@UAGJKPAPAUIDirectMusicPort@@PAK@Z ; CPerformance::GetPortAndFlags
PUBLIC	?Init@CPerformance@@AAEXXZ			; CPerformance::Init
PUBLIC	?SetID@CSegStateList@@QAEXK@Z			; CSegStateList::SetID
PUBLIC	??0CSegStateList@@QAE@XZ			; CSegStateList::CSegStateList
PUBLIC	?QueryInterface@CPerformance@@W3AGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
PUBLIC	?AddRef@CPerformance@@W3AGKXZ			; CPerformance::AddRef
PUBLIC	?Release@CPerformance@@W3AGKXZ			; CPerformance::Release
PUBLIC	?QueryInterface@CPerformance@@W7AGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
PUBLIC	?AddRef@CPerformance@@W7AGKXZ			; CPerformance::AddRef
PUBLIC	?Release@CPerformance@@W7AGKXZ			; CPerformance::Release
PUBLIC	?QueryInterface@CPerformance@@WM@AGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
PUBLIC	?AddRef@CPerformance@@WM@AGKXZ			; CPerformance::AddRef
PUBLIC	?Release@CPerformance@@WM@AGKXZ			; CPerformance::Release
PUBLIC	??_7CPerformance@@6BIDirectMusicPerformance@@@	; CPerformance::`vftable'
PUBLIC	??_7CPerformance@@6BIDirectMusicTool@@@		; CPerformance::`vftable'
PUBLIC	??_7CPerformance@@6BIDirectMusicGraph@@@	; CPerformance::`vftable'
PUBLIC	??_7CPerformance@@6BIDirectMusicPerformanceP@@@	; CPerformance::`vftable'
PUBLIC	??0CNotificationList@@QAE@XZ			; CNotificationList::CNotificationList
PUBLIC	??0IDirectMusicPerformanceP@@QAE@XZ		; IDirectMusicPerformanceP::IDirectMusicPerformanceP
PUBLIC	??0CPMsgZone@@QAE@KK@Z				; CPMsgZone::CPMsgZone
EXTRN	??0CPMsgQueue@@QAE@XZ:NEAR			; CPMsgQueue::CPMsgQueue
EXTRN	??0CBufferManager@@QAE@XZ:NEAR			; CBufferManager::CBufferManager
EXTRN	??0CMemTrack@@QAE@K@Z:NEAR			; CMemTrack::CMemTrack
EXTRN	_memset:NEAR
EXTRN	__imp__RtlInitializeCriticalSection@4:NEAR
;	COMDAT ??_7CPerformance@@6BIDirectMusicPerformance@@@
CONST	SEGMENT
??_7CPerformance@@6BIDirectMusicPerformance@@@ DD FLAT:?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z ; CPerformance::`vftable'
	DD	FLAT:?AddRef@CPerformance@@UAGKXZ
	DD	FLAT:?Release@CPerformance@@UAGKXZ
	DD	FLAT:?GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z
	DD	FLAT:?SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
	DD	FLAT:?MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z
	DD	FLAT:?ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z
	DD	FLAT:?IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z
	DD	FLAT:?GetTime@CPerformance@@UAGJPA_JPAJ@Z
	DD	FLAT:?AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z
	DD	FLAT:?FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
	DD	FLAT:?GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z
	DD	FLAT:?AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z
	DD	FLAT:?RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z
	DD	FLAT:?GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z
	DD	FLAT:?SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z
	DD	FLAT:?PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z
	DD	FLAT:?StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z
	DD	FLAT:?ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU2@@Z
	DD	FLAT:?CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z
	DD	FLAT:?CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z
	DD	FLAT:?SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z
	DD	FLAT:?GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z
	DD	FLAT:?GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z
	DD	FLAT:?InitAudioX@CPerformance@@UAGJKKKK@Z
	DD	FLAT:?CloseDown@CPerformance@@UAGJXZ
	DD	FLAT:?Invalidate@CPerformance@@UAGJJK@Z
	DD	FLAT:?GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z
	DD	FLAT:?PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z
	DD	FLAT:?Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z
	DD	FLAT:?MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z
	DD	FLAT:?MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z
	DD	FLAT:?GetLatencyTime@CPerformance@@UAGJPA_J@Z
	DD	FLAT:?GetQueueTime@CPerformance@@UAGJPA_J@Z
	DD	FLAT:?GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z
	DD	FLAT:?GetSynth@CPerformance@@UAGJPAPAUIDirectMusicSynthX@@@Z
CONST	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicTool@@@
CONST	SEGMENT
??_7CPerformance@@6BIDirectMusicTool@@@ DD FLAT:?QueryInterface@CPerformance@@W3AGJABU_GUID@@PAPAX@Z ; CPerformance::`vftable'
	DD	FLAT:?AddRef@CPerformance@@W3AGKXZ
	DD	FLAT:?Release@CPerformance@@W3AGKXZ
	DD	FLAT:?Init@CPerformance@@UAGJPAUIDirectMusicGraph@@@Z
	DD	FLAT:?GetMsgDeliveryType@CPerformance@@UAGJPAK@Z
	DD	FLAT:?GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z
	DD	FLAT:?GetMediaTypes@CPerformance@@UAGJPAPAKK@Z
	DD	FLAT:?ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z
	DD	FLAT:?Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z
CONST	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicGraph@@@
CONST	SEGMENT
??_7CPerformance@@6BIDirectMusicGraph@@@ DD FLAT:?QueryInterface@CPerformance@@W7AGJABU_GUID@@PAPAX@Z ; CPerformance::`vftable'
	DD	FLAT:?AddRef@CPerformance@@W7AGKXZ
	DD	FLAT:?Release@CPerformance@@W7AGKXZ
	DD	FLAT:?StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
	DD	FLAT:?InsertTool@CPerformance@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
	DD	FLAT:?GetTool@CPerformance@@UAGJKPAPAUIDirectMusicTool@@@Z
	DD	FLAT:?RemoveTool@CPerformance@@UAGJPAUIDirectMusicTool@@@Z
CONST	ENDS
;	COMDAT ??_7CPerformance@@6BIDirectMusicPerformanceP@@@
CONST	SEGMENT
??_7CPerformance@@6BIDirectMusicPerformanceP@@@ DD FLAT:?QueryInterface@CPerformance@@WM@AGJABU_GUID@@PAPAX@Z ; CPerformance::`vftable'
	DD	FLAT:?AddRef@CPerformance@@WM@AGKXZ
	DD	FLAT:?Release@CPerformance@@WM@AGKXZ
	DD	FLAT:?GetPortAndFlags@CPerformance@@UAGJKPAPAUIDirectMusicPort@@PAK@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CPerformance@@QAE@XZ
_TEXT	SEGMENT
tv193 = -16
_this$ = -12
$T75150 = -8
_dwCount$ = -4
??0CPerformance@@QAE@XZ PROC NEAR			; CPerformance::CPerformance, COMDAT
; _this$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	6a 06		 push	 6
  0000b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack
  00016	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0IDirectMusicPerformance@@QAE@XZ
  0001e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 04	 add	 ecx, 4
  00024	e8 00 00 00 00	 call	 ??0IDirectMusicTool@@QAE@XZ
  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 08	 add	 ecx, 8
  0002f	e8 00 00 00 00	 call	 ??0IDirectMusicGraph@@QAE@XZ
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003a	e8 00 00 00 00	 call	 ??0IDirectMusicPerformanceP@@QAE@XZ
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicPerformance@@@
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicTool@@@
  00052	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00055	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicGraph@@@
  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicPerformanceP@@@
  00066	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0006c	e8 00 00 00 00	 call	 ??0CChannelBlockList@@QAE@XZ
  00071	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 40	 add	 ecx, 64			; 00000040H
  00077	e8 00 00 00 00	 call	 ??0CChannelBlockList@@QAE@XZ
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??0CSegStateList@@QAE@XZ
  00081	6a 09		 push	 9
  00083	6a 08		 push	 8
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 44	 add	 ecx, 68			; 00000044H
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  00091	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0009a	e8 00 00 00 00	 call	 ??0CSegStateList@@QAE@XZ
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  000a8	e8 00 00 00 00	 call	 ??0CAudioPathList@@QAE@XZ
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  000b6	e8 00 00 00 00	 call	 ??0CBufferManager@@QAE@XZ ; CBufferManager::CBufferManager
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  000c4	e8 00 00 00 00	 call	 ??0CNotificationList@@QAE@XZ
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  000d2	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  000e0	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue
  000e5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  000ee	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue
  000f3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  000fc	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue
  00101	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  0010a	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00118	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  00126	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue

; 357  : #ifdef USE_PMSG_ZONE
; 358  :     m_pPMsgZone = new CPMsgZone();

  0012b	6a 10		 push	 16			; 00000010H
  0012d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00132	83 c4 04	 add	 esp, 4
  00135	89 45 f8	 mov	 DWORD PTR $T75150[ebp], eax
  00138	83 7d f8 00	 cmp	 DWORD PTR $T75150[ebp], 0
  0013c	74 17		 je	 SHORT $L75151
  0013e	68 38 3f 00 00	 push	 16184			; 00003f38H
  00143	68 38 3f 00 00	 push	 16184			; 00003f38H
  00148	8b 4d f8	 mov	 ecx, DWORD PTR $T75150[ebp]
  0014b	e8 00 00 00 00	 call	 ??0CPMsgZone@@QAE@KK@Z	; CPMsgZone::CPMsgZone
  00150	89 45 f0	 mov	 DWORD PTR tv193[ebp], eax
  00153	eb 07		 jmp	 SHORT $L75152
$L75151:
  00155	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv193[ebp], 0
$L75152:
  0015c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0015f	8b 45 f0	 mov	 eax, DWORD PTR tv193[ebp]
  00162	89 82 dc 03 00
	00		 mov	 DWORD PTR [edx+988], eax

; 359  : #endif
; 360  :     m_pGraph = NULL;

  00168	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 361  :     m_dwPrepareTime = 1000;

  00172	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00175	c7 82 dc 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [edx+732], 1000 ; 000003e8H

; 362  :     m_dwBumperLength = 50;

  0017f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00182	c7 80 e0 02 00
	00 32 00 00 00	 mov	 DWORD PTR [eax+736], 50	; 00000032H

; 363  :     m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;

  0018c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	8b 91 e0 02 00
	00		 mov	 edx, DWORD PTR [ecx+736]
  00195	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0019b	33 c0		 xor	 eax, eax
  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	89 91 c8 02 00
	00		 mov	 DWORD PTR [ecx+712], edx
  001a6	89 81 cc 02 00
	00		 mov	 DWORD PTR [ecx+716], eax

; 364  :     m_pGlobalData = NULL;

  001ac	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001af	c7 82 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+260], 0

; 365  :     m_fInTrackPlay = FALSE;

  001b9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	c7 80 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+272], 0

; 366  :     m_fPlaying = FALSE;

  001c6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	c7 81 c4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+964], 0

; 367  :     m_wRollOverCount = 0;

  001d3	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001d6	66 c7 82 f0 02
	00 00 00 00	 mov	 WORD PTR [edx+752], 0

; 368  :     m_mtTransported = 0;

  001df	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	c7 80 d0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+720], 0

; 369  :     m_mtTempoCursor = 0;

  001ec	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	c7 81 d8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+728], 0

; 370  :     m_hNotification = 0;

  001f9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001fc	c7 82 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+240], 0

; 371  :     m_rtNotificationDiscard = 20000000;

  00206	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00209	c7 80 f8 00 00
	00 00 2d 31 01	 mov	 DWORD PTR [eax+248], 20000000 ; 01312d00H
  00213	c7 80 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+252], 0

; 372  :     m_rtStart = 0;

  0021d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00220	c7 81 98 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+664], 0
  0022a	c7 81 9c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+668], 0

; 373  :     m_rtAdjust = 0;

  00234	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00237	c7 82 a0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+672], 0
  00241	c7 82 a4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+676], 0

; 374  :     m_mtPlayTo = 0;

  0024b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0024e	c7 80 d4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+724], 0

; 375  :     m_cRef = 0;

  00258	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0025b	c7 81 ec 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+748], 0

; 376  :     m_pUnkDispatch = NULL;

  00265	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00268	c7 82 d0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+976], 0

; 377  : #ifdef DXAPI
; 378  :     m_dwVersion = 6;
; 379  :     m_pParamHook = NULL;
; 380  :     m_fKillThread = 0; 
; 381  :     m_fKillRealtimeThread = 0;
; 382  :     m_dwTransportThreadID = 0;
; 383  :     m_dwInitCS = 0;
; 384  :     m_pPortTable = NULL;
; 385  :     m_dwNumPorts = 0;
; 386  :     m_pDirectMusic = NULL;
; 387  :     m_fReleasedInTransport = false;
; 388  :     m_fReleasedInRealtime = false;
; 389  : #else
; 390  :     m_dwNumChannelGroups = 0;

  00272	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00275	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 391  :     m_pSynth = NULL;

  0027c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 392  : #endif
; 393  :     m_fInTransportThread = 0;

  00286	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00289	c7 82 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+268], 0

; 394  :     m_dwAudioPathMode = 0;

  00293	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00296	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+264], 0

; 395  :     m_pDirectSound = NULL;

  002a0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 396  :     m_pClock = NULL;

  002aa	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002ad	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 397  :     IncrementDLLCount();
; 398  : 
; 399  :     TraceI(3,"CPerformance %lx\n", this);
; 400  : //#ifdef DXAPI
; 401  :     INITIALIZE_CRITICAL_SECTION(&m_SegmentCrSec);         m_dwInitCS |= PERF_ICS_SEGMENT;

  002b4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002b7	05 14 03 00 00	 add	 eax, 788		; 00000314H
  002bc	50		 push	 eax
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  002c3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002c6	8b 91 f4 02 00
	00		 mov	 edx, DWORD PTR [ecx+756]
  002cc	83 ca 01	 or	 edx, 1
  002cf	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002d2	89 90 f4 02 00
	00		 mov	 DWORD PTR [eax+756], edx

; 402  :     INITIALIZE_CRITICAL_SECTION(&m_PipelineCrSec);        m_dwInitCS |= PERF_ICS_PIPELINE;

  002d8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002db	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  002e1	51		 push	 ecx
  002e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  002e8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002eb	8b 82 f4 02 00
	00		 mov	 eax, DWORD PTR [edx+756]
  002f1	83 c8 02	 or	 eax, 2
  002f4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f7	89 81 f4 02 00
	00		 mov	 DWORD PTR [ecx+756], eax

; 403  :     INITIALIZE_CRITICAL_SECTION(&m_PChannelInfoCrSec);    m_dwInitCS |= PERF_ICS_PCHANNEL;

  002fd	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00300	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  00306	52		 push	 edx
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  0030d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00310	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  00316	83 c9 04	 or	 ecx, 4
  00319	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0031c	89 8a f4 02 00
	00		 mov	 DWORD PTR [edx+756], ecx

; 404  :     INITIALIZE_CRITICAL_SECTION(&m_GlobalDataCrSec);      m_dwInitCS |= PERF_ICS_GLOBAL;

  00322	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00325	05 68 03 00 00	 add	 eax, 872		; 00000368H
  0032a	50		 push	 eax
  0032b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  00331	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00334	8b 91 f4 02 00
	00		 mov	 edx, DWORD PTR [ecx+756]
  0033a	83 ca 10	 or	 edx, 16			; 00000010H
  0033d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00340	89 90 f4 02 00
	00		 mov	 DWORD PTR [eax+756], edx

; 405  :     INITIALIZE_CRITICAL_SECTION(&m_RealtimeCrSec);        m_dwInitCS |= PERF_ICS_REALTIME;

  00346	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00349	81 c1 84 03 00
	00		 add	 ecx, 900		; 00000384H
  0034f	51		 push	 ecx
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  00356	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00359	8b 82 f4 02 00
	00		 mov	 eax, DWORD PTR [edx+756]
  0035f	83 c8 20	 or	 eax, 32			; 00000020H
  00362	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00365	89 81 f4 02 00
	00		 mov	 DWORD PTR [ecx+756], eax

; 406  :     INITIALIZE_CRITICAL_SECTION(&m_PMsgCacheCrSec);       m_dwInitCS |= PERF_ICS_PMSGCACHE;

  0036b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0036e	81 c2 f8 02 00
	00		 add	 edx, 760		; 000002f8H
  00374	52		 push	 edx
  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  0037b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0037e	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  00384	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  0038a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0038d	89 8a f4 02 00
	00		 mov	 DWORD PTR [edx+756], ecx

; 407  :     INITIALIZE_CRITICAL_SECTION(&m_MainCrSec);            m_dwInitCS |= PERF_ICS_MAIN;

  00393	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00396	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0039b	50		 push	 eax
  0039c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4
  003a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003a5	8b 91 f4 02 00
	00		 mov	 edx, DWORD PTR [ecx+756]
  003ab	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  003b1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003b4	89 90 f4 02 00
	00		 mov	 DWORD PTR [eax+756], edx

; 408  : //#endif
; 409  :     memset( m_apPMsgCache, 0, sizeof(DMUS_PMSG*) * (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN) );

  003ba	68 20 01 00 00	 push	 288			; 00000120H
  003bf	6a 00		 push	 0
  003c1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003c4	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  003ca	51		 push	 ecx
  003cb	e8 00 00 00 00	 call	 _memset
  003d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  :     DWORD dwCount;
; 411  :     for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)

  003d3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  003da	eb 09		 jmp	 SHORT $L69595
$L69596:
  003dc	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  003df	83 c2 01	 add	 edx, 1
  003e2	89 55 fc	 mov	 DWORD PTR _dwCount$[ebp], edx
$L69595:
  003e5	83 7d fc 09	 cmp	 DWORD PTR _dwCount$[ebp], 9
  003e9	73 15		 jae	 SHORT $L69597

; 412  :     {
; 413  :         m_SegStateQueues[dwCount].SetID(dwCount);

  003eb	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  003ee	50		 push	 eax
  003ef	8b 4d fc	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  003f2	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  003f5	8d 4c ca 44	 lea	 ecx, DWORD PTR [edx+ecx*8+68]
  003f9	e8 00 00 00 00	 call	 ?SetID@CSegStateList@@QAEXK@Z ; CSegStateList::SetID

; 414  :     }

  003fe	eb dc		 jmp	 SHORT $L69596
$L69597:

; 415  :     Init();

  00400	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00403	e8 00 00 00 00	 call	 ?Init@CPerformance@@AAEXXZ ; CPerformance::Init

; 416  : }

  00408	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0040b	8b e5		 mov	 esp, ebp
  0040d	5d		 pop	 ebp
  0040e	c3		 ret	 0
??0CPerformance@@QAE@XZ ENDP				; CPerformance::CPerformance
_TEXT	ENDS
PUBLIC	?AllocZone@CPMsgZone@@AAEXK@Z			; CPMsgZone::AllocZone
; Function compile flags: /Odt
;	COMDAT ??0CPMsgZone@@QAE@KK@Z
_TEXT	SEGMENT
_this$ = -4
_dwInitalAlloc$ = 8
_dwDefaultGrowth$ = 12
??0CPMsgZone@@QAE@KK@Z PROC NEAR			; CPMsgZone::CPMsgZone, COMDAT
; _this$ = ecx

; 273  :     CPMsgZone(DWORD dwInitalAlloc = 16*1024-200, DWORD dwDefaultGrowth=16*1024-200){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 274  :         m_pBlock = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 275  :         m_dwOffset = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 276  :         m_dwSize = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 277  :         m_dwDefaultGrowth = dwDefaultGrowth;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _dwDefaultGrowth$[ebp]
  0002a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 278  :         AllocZone(dwInitalAlloc);

  0002d	8b 55 08	 mov	 edx, DWORD PTR _dwInitalAlloc$[ebp]
  00030	52		 push	 edx
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?AllocZone@CPMsgZone@@AAEXK@Z ; CPMsgZone::AllocZone

; 279  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
??0CPMsgZone@@QAE@KK@Z ENDP				; CPMsgZone::CPMsgZone
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AllocZone@CPMsgZone@@AAEXK@Z
_TEXT	SEGMENT
_this$ = -16
$T75159 = -12
_pNew$69579 = -8
_dwAllocSize$69577 = -4
_dwMinSize$ = 8
?AllocZone@CPMsgZone@@AAEXK@Z PROC NEAR			; CPMsgZone::AllocZone, COMDAT
; _this$ = ecx

; 308  :     void AllocZone(DWORD dwMinSize){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 309  :         if(m_dwSize - m_dwOffset < dwMinSize){

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00012	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00015	3b 55 08	 cmp	 edx, DWORD PTR _dwMinSize$[ebp]
  00018	73 5f		 jae	 SHORT $L69575

; 310  :             DWORD dwAllocSize = m_dwDefaultGrowth;

  0001a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00020	89 4d fc	 mov	 DWORD PTR _dwAllocSize$69577[ebp], ecx

; 311  :             if(dwAllocSize < dwMinSize + 4){

  00023	8b 55 08	 mov	 edx, DWORD PTR _dwMinSize$[ebp]
  00026	83 c2 04	 add	 edx, 4
  00029	39 55 fc	 cmp	 DWORD PTR _dwAllocSize$69577[ebp], edx
  0002c	73 09		 jae	 SHORT $L69578

; 312  :                 dwAllocSize = dwMinSize + 4;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _dwMinSize$[ebp]
  00031	83 c0 04	 add	 eax, 4
  00034	89 45 fc	 mov	 DWORD PTR _dwAllocSize$69577[ebp], eax
$L69578:

; 313  :             }
; 314  :             char* pNew = new char[dwAllocSize];

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _dwAllocSize$69577[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00040	83 c4 04	 add	 esp, 4
  00043	89 45 f4	 mov	 DWORD PTR $T75159[ebp], eax
  00046	8b 55 f4	 mov	 edx, DWORD PTR $T75159[ebp]
  00049	89 55 f8	 mov	 DWORD PTR _pNew$69579[ebp], edx

; 315  :             if(!pNew){

  0004c	83 7d f8 00	 cmp	 DWORD PTR _pNew$69579[ebp], 0
  00050	75 02		 jne	 SHORT $L69582

; 316  :                 return;

  00052	eb 25		 jmp	 SHORT $L69575
$L69582:

; 317  :             }
; 318  :             *((char**) pNew) = m_pBlock;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _pNew$69579[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	89 10		 mov	 DWORD PTR [eax], edx

; 319  :             m_pBlock = pNew;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _pNew$69579[ebp]
  00064	89 08		 mov	 DWORD PTR [eax], ecx

; 320  :             m_dwOffset = 4;

  00066	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00069	c7 42 04 04 00
	00 00		 mov	 DWORD PTR [edx+4], 4

; 321  :             m_dwSize = dwAllocSize;

  00070	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _dwAllocSize$69577[ebp]
  00076	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L69575:

; 322  :         }
; 323  :     }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
?AllocZone@CPMsgZone@@AAEXK@Z ENDP			; CPMsgZone::AllocZone
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt
;	COMDAT ??0IDirectMusicPerformance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicPerformance@@QAE@XZ PROC NEAR		; IDirectMusicPerformance::IDirectMusicPerformance, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicPerformance@@QAE@XZ ENDP			; IDirectMusicPerformance::IDirectMusicPerformance
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicTool@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicTool@@QAE@XZ PROC NEAR			; IDirectMusicTool::IDirectMusicTool, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicTool@@QAE@XZ ENDP			; IDirectMusicTool::IDirectMusicTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicGraph@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicGraph@@QAE@XZ PROC NEAR			; IDirectMusicGraph::IDirectMusicGraph, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicGraph@@QAE@XZ ENDP			; IDirectMusicGraph::IDirectMusicGraph
_TEXT	ENDS
PUBLIC	??_7IDirectMusicPerformanceP@@6B@		; IDirectMusicPerformanceP::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IDirectMusicPerformanceP@@6B@
CONST	SEGMENT
??_7IDirectMusicPerformanceP@@6B@ DD FLAT:__purecall	; IDirectMusicPerformanceP::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0IDirectMusicPerformanceP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicPerformanceP@@QAE@XZ PROC NEAR		; IDirectMusicPerformanceP::IDirectMusicPerformanceP, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IDirectMusicPerformanceP@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0IDirectMusicPerformanceP@@QAE@XZ ENDP		; IDirectMusicPerformanceP::IDirectMusicPerformanceP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CChannelBlockList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CChannelBlockList@@QAE@XZ PROC NEAR			; CChannelBlockList::CChannelBlockList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CChannelBlockList@@QAE@XZ ENDP			; CChannelBlockList::CChannelBlockList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CSegStateList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSegStateList@@QAE@XZ PROC NEAR			; CSegStateList::CSegStateList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CSegStateList@@QAE@XZ ENDP				; CSegStateList::CSegStateList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EPAX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L69618:
  00003	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  0000c	83 7d 10 00	 cmp	 DWORD PTR ___n$[ebp], 0
  00010	7c 11		 jl	 SHORT $L69616
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00015	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001b	03 4d 0c	 add	 ecx, DWORD PTR ___s$[ebp]
  0001e	89 4d 08	 mov	 DWORD PTR ___t$[ebp], ecx
  00021	eb e0		 jmp	 SHORT $L69618
$L69616:
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CAudioPathList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CAudioPathList@@QAE@XZ PROC NEAR			; CAudioPathList::CAudioPathList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CAudioPathList@@QAE@XZ ENDP				; CAudioPathList::CAudioPathList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CNotificationList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CNotificationList@@QAE@XZ PROC NEAR			; CNotificationList::CNotificationList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CNotificationList@@QAE@XZ ENDP			; CNotificationList::CNotificationList
_TEXT	ENDS
PUBLIC	??_C@_0BK@FKIBIHNF@DM?5PMSG?5queue?5early?5queue?$AA@ ; `string'
PUBLIC	??_C@_0BO@MEHJMEJ@DM?5PMSG?5queue?5near?5time?5queue?$AA@ ; `string'
PUBLIC	??_C@_0BM@ONDJHKEG@DM?5PMSG?5queue?5on?5time?5queue?$AA@ ; `string'
PUBLIC	??_C@_0BO@FGONGJL@DM?5PMSG?5queue?5tempo?5map?5queue?$AA@ ; `string'
PUBLIC	??_C@_0CC@OCBKJPHM@DM?5PMSG?5queue?5old?5tempo?5map?5queu@ ; `string'
PUBLIC	??_C@_0CB@OCJDPEPJ@DM?5PMSG?5queue?5notification?5queue@ ; `string'
PUBLIC	??_C@_0BN@HGHNOMKD@DM?5PMSG?5queue?5time?5sig?5queue?$AA@ ; `string'
PUBLIC	??_C@_0BJ@IDPHDPLE@DM?5Out?3?5Notes?5Per?5Second?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HNBEGFCO@DM?5Out?3?5Waves?5Per?5Second?$AA@ ; `string'
PUBLIC	??_C@_0CK@JAIOCEJE@DM?5Out?3?5Curve?5Generated?5Events?5P@ ; `string'
PUBLIC	??_C@_0BJ@ICACJKMA@DM?5Out?3?5SysEx?5Per?5Second?$AA@ ; `string'
PUBLIC	??_C@_0CD@POEOGGKN@DM?5Out?3?5Raw?5MIDI?5Events?5Per?5Seco@ ; `string'
EXTRN	?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z:NEAR	; CPMsgQueue::Enqueue
EXTRN	__fltused:NEAR
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
EXTRN	_DMusicRegisterPerformanceCounter@12:NEAR
EXTRN	_DMusicRegisterPerformanceCounters@0:NEAR
EXTRN	?dm_srand@@YAXI@Z:NEAR				; dm_srand
EXTRN	_time:NEAR
;	COMDAT ??_C@_0BK@FKIBIHNF@DM?5PMSG?5queue?5early?5queue?$AA@
CONST	SEGMENT
??_C@_0BK@FKIBIHNF@DM?5PMSG?5queue?5early?5queue?$AA@ DB 'DM PMSG queue e'
	DB	'arly queue', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MEHJMEJ@DM?5PMSG?5queue?5near?5time?5queue?$AA@
CONST	SEGMENT
??_C@_0BO@MEHJMEJ@DM?5PMSG?5queue?5near?5time?5queue?$AA@ DB 'DM PMSG que'
	DB	'ue near time queue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ONDJHKEG@DM?5PMSG?5queue?5on?5time?5queue?$AA@
CONST	SEGMENT
??_C@_0BM@ONDJHKEG@DM?5PMSG?5queue?5on?5time?5queue?$AA@ DB 'DM PMSG queu'
	DB	'e on time queue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FGONGJL@DM?5PMSG?5queue?5tempo?5map?5queue?$AA@
CONST	SEGMENT
??_C@_0BO@FGONGJL@DM?5PMSG?5queue?5tempo?5map?5queue?$AA@ DB 'DM PMSG que'
	DB	'ue tempo map queue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OCBKJPHM@DM?5PMSG?5queue?5old?5tempo?5map?5queu@
CONST	SEGMENT
??_C@_0CC@OCBKJPHM@DM?5PMSG?5queue?5old?5tempo?5map?5queu@ DB 'DM PMSG qu'
	DB	'eue old tempo map queue', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OCJDPEPJ@DM?5PMSG?5queue?5notification?5queue@
CONST	SEGMENT
??_C@_0CB@OCJDPEPJ@DM?5PMSG?5queue?5notification?5queue@ DB 'DM PMSG queu'
	DB	'e notification queue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HGHNOMKD@DM?5PMSG?5queue?5time?5sig?5queue?$AA@
CONST	SEGMENT
??_C@_0BN@HGHNOMKD@DM?5PMSG?5queue?5time?5sig?5queue?$AA@ DB 'DM PMSG que'
	DB	'ue time sig queue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IDPHDPLE@DM?5Out?3?5Notes?5Per?5Second?$AA@
CONST	SEGMENT
??_C@_0BJ@IDPHDPLE@DM?5Out?3?5Notes?5Per?5Second?$AA@ DB 'DM Out: Notes P'
	DB	'er Second', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNBEGFCO@DM?5Out?3?5Waves?5Per?5Second?$AA@
CONST	SEGMENT
??_C@_0BJ@HNBEGFCO@DM?5Out?3?5Waves?5Per?5Second?$AA@ DB 'DM Out: Waves P'
	DB	'er Second', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JAIOCEJE@DM?5Out?3?5Curve?5Generated?5Events?5P@
CONST	SEGMENT
??_C@_0CK@JAIOCEJE@DM?5Out?3?5Curve?5Generated?5Events?5P@ DB 'DM Out: Cu'
	DB	'rve Generated Events Per Second', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICACJKMA@DM?5Out?3?5SysEx?5Per?5Second?$AA@
CONST	SEGMENT
??_C@_0BJ@ICACJKMA@DM?5Out?3?5SysEx?5Per?5Second?$AA@ DB 'DM Out: SysEx P'
	DB	'er Second', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@POEOGGKN@DM?5Out?3?5Raw?5MIDI?5Events?5Per?5Seco@
CONST	SEGMENT
??_C@_0CD@POEOGGKN@DM?5Out?3?5Raw?5MIDI?5Events?5Per?5Seco@ DB 'DM Out: R'
	DB	'aw MIDI Events Per Second', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Init@CPerformance@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12
_fAuto$ = -8
_pTimeSig$ = -4
?Init@CPerformance@@AAEXXZ PROC NEAR			; CPerformance::Init, COMDAT
; _this$ = ecx

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 421  :     dm_srand((unsigned int)time(NULL));

  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _time
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?dm_srand@@YAXI@Z	; dm_srand
  00019	83 c4 04	 add	 esp, 4

; 422  :     m_rtEarliestStartTime = 0;

  0001c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 80 b0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+688], 0
  00029	c7 80 b4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+692], 0

; 423  :     m_rtLastSendTime = 0;

  00033	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  0003d	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 424  :     m_lMasterVolume = 0;

  00044	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00047	c7 82 e4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+740], 0

; 425  : #ifdef DXAPI
; 426  :     if (m_dwVersion >= 8)
; 427  : #endif
; 428  :     {
; 429  :         m_rtQueuePosition = 0;

  00051	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 80 b8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+696], 0
  0005e	c7 80 bc 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+700], 0

; 430  :         m_dwPrepareTime = 1000;

  00068	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	c7 81 dc 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [ecx+732], 1000 ; 000003e8H

; 431  :         m_dwBumperLength = 50;

  00075	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00078	c7 82 e0 02 00
	00 32 00 00 00	 mov	 DWORD PTR [edx+736], 50	; 00000032H

; 432  :         m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;

  00082	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 88 e0 02 00
	00		 mov	 ecx, DWORD PTR [eax+736]
  0008b	69 c9 10 27 00
	00		 imul	 ecx, 10000		; 00002710H
  00091	33 d2		 xor	 edx, edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00096	89 88 c8 02 00
	00		 mov	 DWORD PTR [eax+712], ecx
  0009c	89 90 cc 02 00
	00		 mov	 DWORD PTR [eax+716], edx

; 433  :         if (m_dwAudioPathMode)

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 b9 08 01 00
	00 00		 cmp	 DWORD PTR [ecx+264], 0
  000ac	74 0c		 je	 SHORT $L69629

; 434  :         {
; 435  :             CloseDown();

  000ae	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000b1	8b 02		 mov	 eax, DWORD PTR [edx]
  000b3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	51		 push	 ecx
  000b7	ff 50 64	 call	 DWORD PTR [eax+100]
$L69629:

; 436  :         }
; 437  :     }
; 438  :     m_pDefaultAudioPath = NULL;

  000ba	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000bd	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 439  :     m_fltRelTempo = 1;

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	c7 80 e8 02 00
	00 00 00 80 3f	 mov	 DWORD PTR [eax+744], 1065353216 ; 3f800000H

; 440  :     m_pGetParamSegmentState = NULL;

  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	c7 81 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+980], 0

; 441  :     m_dwGetParamFlags = 0;

  000de	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000e1	c7 82 d8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+984], 0

; 442  :     m_rtHighestPackedNoteOn = 0;

  000eb	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	c7 80 a8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+680], 0
  000f8	c7 80 ac 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+684], 0

; 443  :     m_dwAudioPathMode = 0;

  00102	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	c7 81 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+264], 0

; 444  :     m_fMusicStopped = TRUE;

  0010f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00112	c7 82 c8 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+968], 1

; 445  :     BOOL fAuto = FALSE;

  0011c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fAuto$[ebp], 0

; 446  : #ifdef DXAPI
; 447  :     m_hTransport = 0;
; 448  :     m_hTransportThread = 0;
; 449  :     m_dwRealtimeThreadID = 0;
; 450  :     m_hRealtime = 0;
; 451  :     m_hRealtimeThread = 0;
; 452  :     SetGlobalParam(GUID_PerfAutoDownload,&fAuto,sizeof(BOOL));
; 453  : #else
; 454  :     m_pTransportWorker = NULL;

  00123	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00126	c7 80 bc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+956], 0

; 455  :     m_pRealtimeWorker = NULL;

  00130	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	c7 81 c0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+960], 0

; 456  : #endif
; 457  :     DMUS_TIMESIG_PMSG* pTimeSig;
; 458  :     if (SUCCEEDED(AllocPMsg(sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG **) &pTimeSig)))

  0013d	8d 55 fc	 lea	 edx, DWORD PTR _pTimeSig$[ebp]
  00140	52		 push	 edx
  00141	6a 40		 push	 64			; 00000040H
  00143	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00146	8b 08		 mov	 ecx, DWORD PTR [eax]
  00148	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0014b	52		 push	 edx
  0014c	ff 51 24	 call	 DWORD PTR [ecx+36]
  0014f	85 c0		 test	 eax, eax
  00151	7c 60		 jl	 SHORT $L69635

; 459  :     {
; 460  :         pTimeSig->wGridsPerBeat = 4;

  00153	8b 45 fc	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  00156	66 c7 40 3a 04
	00		 mov	 WORD PTR [eax+58], 4

; 461  :         pTimeSig->bBeatsPerMeasure = 4;

  0015c	8b 4d fc	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  0015f	c6 41 38 04	 mov	 BYTE PTR [ecx+56], 4

; 462  :         pTimeSig->bBeat = 4;

  00163	8b 55 fc	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  00166	c6 42 39 04	 mov	 BYTE PTR [edx+57], 4

; 463  :         pTimeSig->dwFlags = DMUS_PMSGF_REFTIME;

  0016a	8b 45 fc	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  0016d	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1

; 464  :         pTimeSig->dwType = DMUS_PMSGT_TIMESIG;

  00174	8b 4d fc	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  00177	c7 41 28 06 00
	00 00		 mov	 DWORD PTR [ecx+40], 6

; 465  :         ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0017e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00181	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 466  :         m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pTimeSig) );

  0018e	8b 45 fc	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  00191	83 e8 18	 sub	 eax, 24			; 00000018H
  00194	50		 push	 eax
  00195	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  0019e	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 467  :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  001a3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  001ac	51		 push	 ecx
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L69635:

; 468  :     }
; 469  :     
; 470  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 471  :     DMusicRegisterPerformanceCounters();

  001b3	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounters@0

; 472  :     DMusicRegisterPerformanceCounter("DM PMSG queue early queue",
; 473  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 474  :                                       &m_EarlyQueue.m_lCount );

  001b8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001bb	81 c2 1c 01 00
	00		 add	 edx, 284		; 0000011cH
  001c1	52		 push	 edx
  001c2	68 00 00 02 00	 push	 131072			; 00020000H
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@FKIBIHNF@DM?5PMSG?5queue?5early?5queue?$AA@
  001cc	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 475  :     DMusicRegisterPerformanceCounter("DM PMSG queue near time queue",
; 476  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 477  :                                       &m_NearTimeQueue.m_lCount );

  001d1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001d4	05 28 01 00 00	 add	 eax, 296		; 00000128H
  001d9	50		 push	 eax
  001da	68 00 00 02 00	 push	 131072			; 00020000H
  001df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MEHJMEJ@DM?5PMSG?5queue?5near?5time?5queue?$AA@
  001e4	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 478  :     DMusicRegisterPerformanceCounter("DM PMSG queue on time queue",
; 479  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 480  :                                       &m_OnTimeQueue.m_lCount );

  001e9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ec	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  001f2	51		 push	 ecx
  001f3	68 00 00 02 00	 push	 131072			; 00020000H
  001f8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@ONDJHKEG@DM?5PMSG?5queue?5on?5time?5queue?$AA@
  001fd	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 481  :     DMusicRegisterPerformanceCounter("DM PMSG queue tempo map queue",
; 482  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 483  :                                       &m_TempoMap.m_lCount );

  00202	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00205	81 c2 40 01 00
	00		 add	 edx, 320		; 00000140H
  0020b	52		 push	 edx
  0020c	68 00 00 02 00	 push	 131072			; 00020000H
  00211	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@FGONGJL@DM?5PMSG?5queue?5tempo?5map?5queue?$AA@
  00216	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 484  :     DMusicRegisterPerformanceCounter("DM PMSG queue old tempo map queue",
; 485  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 486  :                                       &m_OldTempoMap.m_lCount );

  0021b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0021e	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00223	50		 push	 eax
  00224	68 00 00 02 00	 push	 131072			; 00020000H
  00229	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@OCBKJPHM@DM?5PMSG?5queue?5old?5tempo?5map?5queu@
  0022e	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 487  :     DMusicRegisterPerformanceCounter("DM PMSG queue notification queue",
; 488  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 489  :                                       &m_NotificationQueue.m_lCount );

  00233	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00236	81 c1 58 01 00
	00		 add	 ecx, 344		; 00000158H
  0023c	51		 push	 ecx
  0023d	68 00 00 02 00	 push	 131072			; 00020000H
  00242	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@OCJDPEPJ@DM?5PMSG?5queue?5notification?5queue@
  00247	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 490  :     DMusicRegisterPerformanceCounter("DM PMSG queue time sig queue",
; 491  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 492  :                                       &m_TimeSigQueue.m_lCount );

  0024c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0024f	81 c2 64 01 00
	00		 add	 edx, 356		; 00000164H
  00255	52		 push	 edx
  00256	68 00 00 02 00	 push	 131072			; 00020000H
  0025b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@HGHNOMKD@DM?5PMSG?5queue?5time?5sig?5queue?$AA@
  00260	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 493  :     DMusicRegisterPerformanceCounter("DM Out: Notes Per Second",
; 494  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 495  :                                       &m_dwNotesPerSecond );

  00265	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00268	05 e0 03 00 00	 add	 eax, 992		; 000003e0H
  0026d	50		 push	 eax
  0026e	68 00 00 02 00	 push	 131072			; 00020000H
  00273	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IDPHDPLE@DM?5Out?3?5Notes?5Per?5Second?$AA@
  00278	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 496  :     DMusicRegisterPerformanceCounter("DM Out: Waves Per Second",
; 497  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 498  :                                       &m_dwWavesPerSecond );

  0027d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00280	81 c1 e4 03 00
	00		 add	 ecx, 996		; 000003e4H
  00286	51		 push	 ecx
  00287	68 00 00 02 00	 push	 131072			; 00020000H
  0028c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@HNBEGFCO@DM?5Out?3?5Waves?5Per?5Second?$AA@
  00291	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 499  :     DMusicRegisterPerformanceCounter("DM Out: Curve Generated Events Per Second",
; 500  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 501  :                                       &m_dwCurvesPerSecond );

  00296	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00299	81 c2 e8 03 00
	00		 add	 edx, 1000		; 000003e8H
  0029f	52		 push	 edx
  002a0	68 00 00 02 00	 push	 131072			; 00020000H
  002a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@JAIOCEJE@DM?5Out?3?5Curve?5Generated?5Events?5P@
  002aa	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 502  :     DMusicRegisterPerformanceCounter("DM Out: SysEx Per Second",
; 503  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 504  :                                       &m_dwSysExPerSecond );

  002af	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002b2	05 ec 03 00 00	 add	 eax, 1004		; 000003ecH
  002b7	50		 push	 eax
  002b8	68 00 00 02 00	 push	 131072			; 00020000H
  002bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@ICACJKMA@DM?5Out?3?5SysEx?5Per?5Second?$AA@
  002c2	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 505  :     DMusicRegisterPerformanceCounter("DM Out: Raw MIDI Events Per Second",
; 506  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 507  :                                       &m_dwMIDIPerSecond );

  002c7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002ca	81 c1 f0 03 00
	00		 add	 ecx, 1008		; 000003f0H
  002d0	51		 push	 ecx
  002d1	68 00 00 02 00	 push	 131072			; 00020000H
  002d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@POEOGGKN@DM?5Out?3?5Raw?5MIDI?5Events?5Per?5Seco@
  002db	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 508  : #endif
; 509  : 
; 510  : }

  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c3		 ret	 0
?Init@CPerformance@@AAEXXZ ENDP				; CPerformance::Init
_TEXT	ENDS
PUBLIC	?UpdateDebugParams@CPerformance@@AAEXXZ		; CPerformance::UpdateDebugParams
; Function compile flags: /Odt
;	COMDAT ?UpdateDebugParams@CPerformance@@AAEXXZ
_TEXT	SEGMENT
tv95 = -20
_this$ = -12
_rtNow$ = -8
?UpdateDebugParams@CPerformance@@AAEXXZ PROC NEAR	; CPerformance::UpdateDebugParams, COMDAT
; _this$ = ecx

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 533  :     REFERENCE_TIME rtNow;
; 534  :     GetPentiumTime(&rtNow);

  00009	8d 45 f8	 lea	 eax, DWORD PTR _rtNow$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?GetPentiumTime@@YGXPA_J@Z ; GetPentiumTime

; 535  :     if (rtNow > (m_rtLastWrite + (1000 * 10000)))

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 91 10 04 00
	00		 mov	 edx, DWORD PTR [ecx+1040]
  0001b	81 c2 80 96 98
	00		 add	 edx, 10000000		; 00989680H
  00021	8b 81 14 04 00
	00		 mov	 eax, DWORD PTR [ecx+1044]
  00027	83 d0 00	 adc	 eax, 0
  0002a	89 55 ec	 mov	 DWORD PTR tv95[ebp], edx
  0002d	89 45 f0	 mov	 DWORD PTR tv95[ebp+4], eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _rtNow$[ebp+4]
  00033	3b 4d f0	 cmp	 ecx, DWORD PTR tv95[ebp+4]
  00036	0f 8c dd 00 00
	00		 jl	 $L69656
  0003c	7f 0c		 jg	 SHORT $L75194
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _rtNow$[ebp]
  00041	3b 55 ec	 cmp	 edx, DWORD PTR tv95[ebp]
  00044	0f 86 cf 00 00
	00		 jbe	 $L69656
$L75194:

; 536  :     {
; 537  :         m_rtLastWrite = rtNow;

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _rtNow$[ebp]
  00050	89 88 10 04 00
	00		 mov	 DWORD PTR [eax+1040], ecx
  00056	8b 55 fc	 mov	 edx, DWORD PTR _rtNow$[ebp+4]
  00059	89 90 14 04 00
	00		 mov	 DWORD PTR [eax+1044], edx

; 538  :         m_dwNotesPerSecond = m_dwTempNotesPerSecond;

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 91 f8 03 00
	00		 mov	 edx, DWORD PTR [ecx+1016]
  0006b	89 90 e0 03 00
	00		 mov	 DWORD PTR [eax+992], edx

; 539  :         m_dwWavesPerSecond = m_dwTempWavesPerSecond;

  00071	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 91 fc 03 00
	00		 mov	 edx, DWORD PTR [ecx+1020]
  0007d	89 90 e4 03 00
	00		 mov	 DWORD PTR [eax+996], edx

; 540  :         m_dwCurvesPerSecond = m_dwTempCurvesPerSecond;

  00083	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  0008f	89 90 e8 03 00
	00		 mov	 DWORD PTR [eax+1000], edx

; 541  :         m_dwSysExPerSecond = m_dwTempSysExPerSecond;

  00095	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 91 04 04 00
	00		 mov	 edx, DWORD PTR [ecx+1028]
  000a1	89 90 ec 03 00
	00		 mov	 DWORD PTR [eax+1004], edx

; 542  :         m_dwMIDIPerSecond = m_dwTempMIDIPerSecond;

  000a7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 91 08 04 00
	00		 mov	 edx, DWORD PTR [ecx+1032]
  000b3	89 90 f0 03 00
	00		 mov	 DWORD PTR [eax+1008], edx

; 543  :         m_dwPatchesPerSecond = m_dwTempPatchesPerSecond;

  000b9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	8b 91 0c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1036]
  000c5	89 90 f4 03 00
	00		 mov	 DWORD PTR [eax+1012], edx

; 544  :         m_dwTempNotesPerSecond = 0;

  000cb	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	c7 80 f8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1016], 0

; 545  :         m_dwTempWavesPerSecond = 0;

  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	c7 81 fc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1020], 0

; 546  :         m_dwTempCurvesPerSecond = 0;

  000e5	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	c7 82 00 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1024], 0

; 547  :         m_dwTempSysExPerSecond = 0;

  000f2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	c7 80 04 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1028], 0

; 548  :         m_dwTempMIDIPerSecond = 0;

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	c7 81 08 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1032], 0

; 549  :         m_dwTempPatchesPerSecond = 0;

  0010c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0010f	c7 82 0c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1036], 0
$L69656:

; 550  :     }
; 551  : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
?UpdateDebugParams@CPerformance@@AAEXXZ ENDP		; CPerformance::UpdateDebugParams
_TEXT	ENDS
EXTRN	__allmul:NEAR
EXTRN	__alldiv:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetPentiumTime@@YGXPA_J@Z
_TEXT	SEGMENT
_cycNow$ = -8
_prtTime$ = 8
?GetPentiumTime@@YGXPA_J@Z PROC NEAR			; GetPentiumTime, COMDAT

; 516  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 517  :     _int64 cycNow;
; 518  : 
; 519  :     _asm
; 520  :     {
; 521  :         RDTSC                       // Get the time in EDX:EAX

  00006	0f 31		 rdtsc

; 522  :         mov     dword ptr [cycNow], eax

  00008	89 45 f8	 mov	 DWORD PTR _cycNow$[ebp], eax

; 523  :         mov     dword ptr [cycNow+4], edx

  0000b	89 55 fc	 mov	 DWORD PTR _cycNow$[ebp+4], edx

; 524  :     }
; 525  : 
; 526  :     cycNow *= 10;          // Gives greater clock granularity.

  0000e	6a 00		 push	 0
  00010	6a 0a		 push	 10			; 0000000aH
  00012	8b 45 fc	 mov	 eax, DWORD PTR _cycNow$[ebp+4]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _cycNow$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 __allmul
  0001f	89 45 f8	 mov	 DWORD PTR _cycNow$[ebp], eax
  00022	89 55 fc	 mov	 DWORD PTR _cycNow$[ebp+4], edx

; 527  :     cycNow /= 733; // m_dwDivisor;

  00025	6a 00		 push	 0
  00027	68 dd 02 00 00	 push	 733			; 000002ddH
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _cycNow$[ebp+4]
  0002f	52		 push	 edx
  00030	8b 45 f8	 mov	 eax, DWORD PTR _cycNow$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	89 45 f8	 mov	 DWORD PTR _cycNow$[ebp], eax
  0003c	89 55 fc	 mov	 DWORD PTR _cycNow$[ebp+4], edx

; 528  :     *prtTime = cycNow;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _prtTime$[ebp]
  00042	8b 55 f8	 mov	 edx, DWORD PTR _cycNow$[ebp]
  00045	89 11		 mov	 DWORD PTR [ecx], edx
  00047	8b 45 fc	 mov	 eax, DWORD PTR _cycNow$[ebp+4]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 529  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?GetPentiumTime@@YGXPA_J@Z ENDP				; GetPentiumTime
_TEXT	ENDS
PUBLIC	??1CPerformance@@QAE@XZ				; CPerformance::~CPerformance
PUBLIC	?DeleteCriticalSection@@YGXPAX@Z		; DeleteCriticalSection
PUBLIC	??_GCPMsgZone@@QAEPAXI@Z			; CPMsgZone::`scalar deleting destructor'
EXTRN	??1CPMsgQueue@@QAE@XZ:NEAR			; CPMsgQueue::~CPMsgQueue
EXTRN	??1CBufferManager@@QAE@XZ:NEAR			; CBufferManager::~CBufferManager
EXTRN	??1CMemTrack@@QAE@XZ:NEAR			; CMemTrack::~CMemTrack
; Function compile flags: /Odt
;	COMDAT ??1CPerformance@@QAE@XZ
_TEXT	SEGMENT
tv69 = -20
tv141 = -16
_this$ = -12
$T75206 = -8
$T75205 = -4
??1CPerformance@@QAE@XZ PROC NEAR			; CPerformance::~CPerformance, COMDAT
; _this$ = ecx

; 555  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicPerformance@@@
  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicTool@@@
  0001c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicGraph@@@
  00026	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:??_7CPerformance@@6BIDirectMusicPerformanceP@@@

; 556  :     TraceI(3,"~CPerformance %lx\n", this);
; 557  :     CloseDown(); // this should have already been called, but just in case...

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?CloseDown@CPerformance@@UAGJXZ ; CPerformance::CloseDown

; 558  : #ifdef USE_PMSG_ZONE
; 559  :     delete m_pPMsgZone;

  00039	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 82 dc 03 00
	00		 mov	 eax, DWORD PTR [edx+988]
  00042	89 45 f8	 mov	 DWORD PTR $T75206[ebp], eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR $T75206[ebp]
  00048	89 4d fc	 mov	 DWORD PTR $T75205[ebp], ecx
  0004b	83 7d fc 00	 cmp	 DWORD PTR $T75205[ebp], 0
  0004f	74 0f		 je	 SHORT $L75207
  00051	6a 01		 push	 1
  00053	8b 4d fc	 mov	 ecx, DWORD PTR $T75205[ebp]
  00056	e8 00 00 00 00	 call	 ??_GCPMsgZone@@QAEPAXI@Z
  0005b	89 45 f0	 mov	 DWORD PTR tv141[ebp], eax
  0005e	eb 07		 jmp	 SHORT $L75208
$L75207:
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
$L75208:

; 560  :     m_pPMsgZone = NULL;

  00067	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	c7 82 dc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+988], 0

; 561  : #endif
; 562  : 
; 563  :     if (m_pUnkDispatch)

  00074	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00077	83 b8 d0 03 00
	00 00		 cmp	 DWORD PTR [eax+976], 0
  0007e	74 18		 je	 SHORT $L69665

; 564  :         m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

  00080	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 91 d0 03 00
	00		 mov	 edx, DWORD PTR [ecx+976]
  00089	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 88 d0 03 00
	00		 mov	 ecx, DWORD PTR [eax+976]
  00092	8b 12		 mov	 edx, DWORD PTR [edx]
  00094	51		 push	 ecx
  00095	ff 52 08	 call	 DWORD PTR [edx+8]
$L69665:

; 565  : 
; 566  : #ifdef DXAPI
; 567  :     if (m_pParamHook)
; 568  :     {
; 569  :         m_pParamHook->Release();
; 570  :     }
; 571  : #endif
; 572  :     if (m_dwInitCS & PERF_ICS_SEGMENT)  DELETE_CRITICAL_SECTION(&m_SegmentCrSec);

  00098	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  000a1	83 e1 01	 and	 ecx, 1
  000a4	85 c9		 test	 ecx, ecx
  000a6	74 0f		 je	 SHORT $L69666
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69666:

; 573  :     if (m_dwInitCS & PERF_ICS_PIPELINE) DELETE_CRITICAL_SECTION(&m_PipelineCrSec);

  000b7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  000c0	83 e1 02	 and	 ecx, 2
  000c3	85 c9		 test	 ecx, ecx
  000c5	74 0f		 je	 SHORT $L69667
  000c7	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69667:

; 574  :     if (m_dwInitCS & PERF_ICS_PCHANNEL) DELETE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  000d6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  000df	83 e1 04	 and	 ecx, 4
  000e2	85 c9		 test	 ecx, ecx
  000e4	74 0f		 je	 SHORT $L69668
  000e6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69668:

; 575  :     if (m_dwInitCS & PERF_ICS_GLOBAL)   DELETE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  000fe	83 e1 10	 and	 ecx, 16			; 00000010H
  00101	85 c9		 test	 ecx, ecx
  00103	74 0f		 je	 SHORT $L69669
  00105	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00108	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69669:

; 576  :     if (m_dwInitCS & PERF_ICS_REALTIME) DELETE_CRITICAL_SECTION(&m_RealtimeCrSec);

  00114	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00117	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  0011d	83 e1 20	 and	 ecx, 32			; 00000020H
  00120	85 c9		 test	 ecx, ecx
  00122	74 0f		 je	 SHORT $L69670
  00124	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00127	81 c2 84 03 00
	00		 add	 edx, 900		; 00000384H
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69670:

; 577  :     if (m_dwInitCS & PERF_ICS_PMSGCACHE)DELETE_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00133	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00136	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  0013c	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00142	85 c9		 test	 ecx, ecx
  00144	74 0f		 je	 SHORT $L69671
  00146	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00149	81 c2 f8 02 00
	00		 add	 edx, 760		; 000002f8H
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69671:

; 578  :     if (m_dwInitCS & PERF_ICS_MAIN)     DELETE_CRITICAL_SECTION(&m_MainCrSec);

  00155	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00158	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  0015e	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00164	85 c9		 test	 ecx, ecx
  00166	74 0f		 je	 SHORT $L69661
  00168	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0016b	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69661:

; 579  : 
; 580  :     DecrementDLLCount();
; 581  : }

  00177	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  00180	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  00185	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0018e	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  00193	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  0019c	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  001a1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  001aa	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  001af	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  001b8	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  001bd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  001c6	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  001cb	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ce	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  001d4	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  001d9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  001e2	e8 00 00 00 00	 call	 ??1CBufferManager@@QAE@XZ ; CBufferManager::~CBufferManager
  001e7	83 7d f4 00	 cmp	 DWORD PTR _this$[ebp], 0
  001eb	74 0b		 je	 SHORT $L75203
  001ed	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001f0	83 c0 10	 add	 eax, 16			; 00000010H
  001f3	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  001f6	eb 07		 jmp	 SHORT $L75204
$L75203:
  001f8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L75204:
  001ff	8b 4d ec	 mov	 ecx, DWORD PTR tv69[ebp]
  00202	e8 00 00 00 00	 call	 ??1CMemTrack@@QAE@XZ	; CMemTrack::~CMemTrack
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
??1CPerformance@@QAE@XZ ENDP				; CPerformance::~CPerformance
_TEXT	ENDS
PUBLIC	??1CPMsgZone@@QAE@XZ				; CPMsgZone::~CPMsgZone
; Function compile flags: /Odt
;	COMDAT ??_GCPMsgZone@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCPMsgZone@@QAEPAXI@Z PROC NEAR			; CPMsgZone::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPMsgZone@@QAE@XZ	; CPMsgZone::~CPMsgZone
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69676
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69676:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCPMsgZone@@QAEPAXI@Z ENDP				; CPMsgZone::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?FreeAll@CPMsgZone@@QAEXXZ			; CPMsgZone::FreeAll
; Function compile flags: /Odt
;	COMDAT ??1CPMsgZone@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CPMsgZone@@QAE@XZ PROC NEAR				; CPMsgZone::~CPMsgZone, COMDAT
; _this$ = ecx

; 281  :     ~CPMsgZone(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 282  :         FreeAll();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?FreeAll@CPMsgZone@@QAEXXZ ; CPMsgZone::FreeAll

; 283  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CPMsgZone@@QAE@XZ ENDP				; CPMsgZone::~CPMsgZone
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreeAll@CPMsgZone@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12
$T75218 = -8
_pNext$69567 = -4
?FreeAll@CPMsgZone@@QAEXXZ PROC NEAR			; CPMsgZone::FreeAll, COMDAT
; _this$ = ecx

; 285  :     void FreeAll(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L69565:

; 286  :         while(m_pBlock){

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 28		 je	 SHORT $L69566

; 287  :             char* pNext = *((char**) m_pBlock);

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	89 45 fc	 mov	 DWORD PTR _pNext$69567[ebp], eax

; 288  :             delete [] m_pBlock;

  0001b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	89 55 f8	 mov	 DWORD PTR $T75218[ebp], edx
  00023	8b 45 f8	 mov	 eax, DWORD PTR $T75218[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002c	83 c4 04	 add	 esp, 4

; 289  :             m_pBlock = pNext;

  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _pNext$69567[ebp]
  00035	89 11		 mov	 DWORD PTR [ecx], edx

; 290  :         }

  00037	eb d0		 jmp	 SHORT $L69565
$L69566:

; 291  :         m_dwOffset = 0;

  00039	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 292  :         m_dwSize = 0;

  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 293  :     }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?FreeAll@CPMsgZone@@QAEXXZ ENDP				; CPMsgZone::FreeAll
_TEXT	ENDS
PUBLIC	??_GGlobalData@@QAEPAXI@Z			; GlobalData::`scalar deleting destructor'
PUBLIC	?SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z ; CPerformance::SetGraph
PUBLIC	?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z	; CPerformance::FreePMsg
PUBLIC	?DequeueAllSegments@CPerformance@@AAEXXZ	; CPerformance::DequeueAllSegments
PUBLIC	?Release@IDirectSound@@QAGKXZ			; IDirectSound::Release
PUBLIC	?GetNext@CNotificationItem@@QAEPAV1@XZ		; CNotificationItem::GetNext
PUBLIC	?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
PUBLIC	?Remove@AList@@QAEXPAVAListItem@@@Z		; AList::Remove
EXTRN	?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ:NEAR	; CPMsgQueue::Dequeue
EXTRN	?Clear@CBufferManager@@QAEXXZ:NEAR		; CBufferManager::Clear
EXTRN	?Clear@CAudioPathList@@QAEXXZ:NEAR		; CAudioPathList::Clear
EXTRN	_DMusicUnregisterPerformanceCounter@4:NEAR
EXTRN	_DMusicUnregisterPerformanceCounters@0:NEAR
EXTRN	?PinkSlip@CWorker@@QAEXXZ:NEAR			; CWorker::PinkSlip
; Function compile flags: /Odt
;	COMDAT ?CloseDown@CPerformance@@UAGJXZ
_TEXT	SEGMENT
tv213 = -48
$T75227 = -44
$T75224 = -40
$T75223 = -36
$T75222 = -32
_pPriv$69731 = -28
_cbSize$69732 = -24
_i$69724 = -20
_pNext$69691 = -16
_pGD$ = -12
_pItem$ = -8
_pPMsg$ = -4
_this$ = 8
?CloseDown@CPerformance@@UAGJXZ PROC NEAR		; CPerformance::CloseDown, COMDAT

; 584  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 585  :     V_INAME(CPerformance::CloseDown);
; 586  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 587  :     DMusicUnregisterPerformanceCounters();

  00006	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounters@0

; 588  :     DMusicUnregisterPerformanceCounter("DM PMSG queue early queue");

  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@FKIBIHNF@DM?5PMSG?5queue?5early?5queue?$AA@
  00010	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 589  :     DMusicUnregisterPerformanceCounter("DM PMSG queue near time queue");

  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MEHJMEJ@DM?5PMSG?5queue?5near?5time?5queue?$AA@
  0001a	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 590  :     DMusicUnregisterPerformanceCounter("DM PMSG queue on time queue");

  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@ONDJHKEG@DM?5PMSG?5queue?5on?5time?5queue?$AA@
  00024	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 591  :     DMusicUnregisterPerformanceCounter("DM PMSG queue tempo map queue");

  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@FGONGJL@DM?5PMSG?5queue?5tempo?5map?5queue?$AA@
  0002e	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 592  :     DMusicUnregisterPerformanceCounter("DM PMSG queue old tempo map queue");

  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@OCBKJPHM@DM?5PMSG?5queue?5old?5tempo?5map?5queu@
  00038	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 593  :     DMusicUnregisterPerformanceCounter("DM PMSG queue notification queue");

  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@OCJDPEPJ@DM?5PMSG?5queue?5notification?5queue@
  00042	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 594  :     DMusicUnregisterPerformanceCounter("DM PMSG queue time sig queue");

  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@HGHNOMKD@DM?5PMSG?5queue?5time?5sig?5queue?$AA@
  0004c	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 595  :     DMusicUnregisterPerformanceCounter("DM Out: Notes Per Second");

  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IDPHDPLE@DM?5Out?3?5Notes?5Per?5Second?$AA@
  00056	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 596  :     DMusicUnregisterPerformanceCounter("DM Out: Waves Per Second");

  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@HNBEGFCO@DM?5Out?3?5Waves?5Per?5Second?$AA@
  00060	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 597  :     DMusicUnregisterPerformanceCounter("DM Out: Curve Generated Events Per Second");

  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@JAIOCEJE@DM?5Out?3?5Curve?5Generated?5Events?5P@
  0006a	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 598  :     DMusicUnregisterPerformanceCounter("DM Out: SysEx Per Second");

  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@ICACJKMA@DM?5Out?3?5SysEx?5Per?5Second?$AA@
  00074	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 599  :     DMusicUnregisterPerformanceCounter("DM Out: Raw MIDI Events Per Second");

  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@POEOGGKN@DM?5Out?3?5Raw?5MIDI?5Events?5Per?5Seco@
  0007e	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 600  : #endif
; 601  : #ifdef DXAPI
; 602  :     DWORD dwThreadID = GetCurrentThreadId();
; 603  :     if( m_dwAudioPathMode )
; 604  :     {
; 605  :         // kill the transport thread
; 606  :         m_fKillThread = 1;
; 607  :         m_fKillRealtimeThread = 1;
; 608  :         if (dwThreadID != m_dwTransportThreadID)
; 609  :         {
; 610  :             // signal the transport thread so we don't have to wait for it to wake up on its own
; 611  :             if( m_hTransport ) SetEvent( m_hTransport );
; 612  :             // wait until the transport thread quits
; 613  :             WaitForSingleObject(m_hTransportThread, INFINITE);
; 614  :         }
; 615  :         if (dwThreadID != m_dwRealtimeThreadID)
; 616  :         {
; 617  :             // signal the realtime thread so we don't have to wait for it to wake up on its own
; 618  :             if( m_hRealtime ) SetEvent( m_hRealtime );
; 619  :             // wait until the realtime thread quits
; 620  :             WaitForSingleObject(m_hRealtimeThread, INFINITE);
; 621  :         }
; 622  :     }
; 623  : #else
; 624  :     if (m_pTransportWorker)

  00083	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00086	83 b8 bc 03 00
	00 00		 cmp	 DWORD PTR [eax+956], 0
  0008d	74 1b		 je	 SHORT $L69683

; 625  :     {
; 626  :         m_pTransportWorker->PinkSlip();

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 89 bc 03 00
	00		 mov	 ecx, DWORD PTR [ecx+956]
  00098	e8 00 00 00 00	 call	 ?PinkSlip@CWorker@@QAEXXZ ; CWorker::PinkSlip

; 627  :         m_pTransportWorker = NULL;

  0009d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	c7 82 bc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+956], 0
$L69683:

; 628  :     }
; 629  :     if (m_pRealtimeWorker)

  000aa	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	83 b8 c0 03 00
	00 00		 cmp	 DWORD PTR [eax+960], 0
  000b4	74 1b		 je	 SHORT $L69684

; 630  :     {
; 631  :         m_pRealtimeWorker->PinkSlip();

  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [ecx+960]
  000bf	e8 00 00 00 00	 call	 ?PinkSlip@CWorker@@QAEXXZ ; CWorker::PinkSlip

; 632  :         m_pRealtimeWorker = NULL;

  000c4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	c7 82 c0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+960], 0
$L69684:

; 633  :     }
; 634  : #endif
; 635  : 
; 636  : //    if (m_pDummy) m_pDummy->Release();
; 637  : //    m_pDummy = NULL;
; 638  : 
; 639  :     if (m_pGraph) SetGraph(NULL); // shut down the graph and release it (needs to happen before clearing audio path)

  000d1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  000d8	74 0b		 je	 SHORT $L69685
  000da	6a 00		 push	 0
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z ; CPerformance::SetGraph
$L69685:

; 640  : 
; 641  :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  000e5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  000ee	52		 push	 edx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 642  :     ENTER_CRITICAL_SECTION(&m_RealtimeCrSec);

  000f5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	05 84 03 00 00	 add	 eax, 900		; 00000384H
  000fd	50		 push	 eax
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 643  : 
; 644  :     m_fPlaying = FALSE; // prevents transport thread from doing anything more

  00104	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	c7 81 c4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+964], 0

; 645  : #ifdef DXAPI
; 646  :     IDirectMusicPerformance* pPerf = NULL;
; 647  :     if (SUCCEEDED(QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)))
; 648  :     {
; 649  :         CWavTrack::UnloadAllWaves(pPerf);
; 650  :         pPerf->Release();
; 651  :     }
; 652  : #endif
; 653  :     DequeueAllSegments();

  00111	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?DequeueAllSegments@CPerformance@@AAEXXZ ; CPerformance::DequeueAllSegments

; 654  :     if (m_pDefaultAudioPath)

  00119	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0011c	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00120	74 1c		 je	 SHORT $L69686

; 655  :     {
; 656  :         m_pDefaultAudioPath->Release();

  00122	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00125	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00128	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0012e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00130	50		 push	 eax
  00131	ff 51 08	 call	 DWORD PTR [ecx+8]

; 657  :         m_pDefaultAudioPath = NULL;

  00134	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00137	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
$L69686:

; 658  :     }
; 659  :     m_AudioPathList.Clear();

  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00147	e8 00 00 00 00	 call	 ?Clear@CAudioPathList@@QAEXXZ ; CAudioPathList::Clear

; 660  :     m_dwAudioPathMode = 0;  // Set this after clearing, so if any audiopaths are still

  0014c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+264], 0

; 661  :                             // around, they won't assert in PChannelInfo() when 
; 662  :                             // disconnecting the synth.
; 663  :     CNotificationItem* pItem = m_NotificationList.GetHead();

  00159	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00162	e8 00 00 00 00	 call	 ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
  00167	89 45 f8	 mov	 DWORD PTR _pItem$[ebp], eax
$L69689:

; 664  :     while( pItem )

  0016a	83 7d f8 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0016e	74 37		 je	 SHORT $L69690

; 665  :     {
; 666  :         CNotificationItem* pNext = pItem->GetNext();

  00170	8b 4d f8	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00173	e8 00 00 00 00	 call	 ?GetNext@CNotificationItem@@QAEPAV1@XZ ; CNotificationItem::GetNext
  00178	89 45 f0	 mov	 DWORD PTR _pNext$69691[ebp], eax

; 667  :         m_NotificationList.Remove( pItem );

  0017b	8b 4d f8	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0017e	51		 push	 ecx
  0017f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00188	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove

; 668  :         delete pItem;

  0018d	8b 55 f8	 mov	 edx, DWORD PTR _pItem$[ebp]
  00190	89 55 e0	 mov	 DWORD PTR $T75222[ebp], edx
  00193	8b 45 e0	 mov	 eax, DWORD PTR $T75222[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0019c	83 c4 04	 add	 esp, 4

; 669  :         pItem = pNext;

  0019f	8b 4d f0	 mov	 ecx, DWORD PTR _pNext$69691[ebp]
  001a2	89 4d f8	 mov	 DWORD PTR _pItem$[ebp], ecx

; 670  :     }

  001a5	eb c3		 jmp	 SHORT $L69689
$L69690:

; 671  :     LEAVE_CRITICAL_SECTION(&m_RealtimeCrSec);

  001a7	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001aa	81 c2 84 03 00
	00		 add	 edx, 900		; 00000384H
  001b0	52		 push	 edx
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 672  :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  001b7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001ba	05 14 03 00 00	 add	 eax, 788		; 00000314H
  001bf	50		 push	 eax
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 673  : 
; 674  :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  001c6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  001cf	51		 push	 ecx
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4
$L69695:

; 675  :     PRIV_PMSG* pPMsg;
; 676  :     while( pPMsg = m_EarlyQueue.Dequeue() )

  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  001df	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  001e4	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  001e7	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  001eb	74 0e		 je	 SHORT $L69698

; 677  :     {
; 678  :         FreePMsg(pPMsg);

  001ed	8b 55 fc	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  001f0	52		 push	 edx
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 679  :     }

  001f9	eb db		 jmp	 SHORT $L69695
$L69698:

; 680  :     while( pPMsg = m_NearTimeQueue.Dequeue() )

  001fb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00204	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00209	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  0020c	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  00210	74 0e		 je	 SHORT $L69701

; 681  :     {
; 682  :         FreePMsg(pPMsg);

  00212	8b 45 fc	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00215	50		 push	 eax
  00216	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 683  :     }

  0021e	eb db		 jmp	 SHORT $L69698
$L69701:

; 684  :     while( pPMsg = m_OnTimeQueue.Dequeue() )

  00220	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00229	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  0022e	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  00231	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  00235	74 0e		 je	 SHORT $L69704

; 685  :     {
; 686  :         FreePMsg(pPMsg);

  00237	8b 4d fc	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0023a	51		 push	 ecx
  0023b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0023e	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 687  :     }

  00243	eb db		 jmp	 SHORT $L69701
$L69704:

; 688  :     while( pPMsg = m_TempoMap.Dequeue() )

  00245	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00248	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  0024e	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00253	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  00256	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  0025a	74 0e		 je	 SHORT $L69707

; 689  :     {
; 690  :         FreePMsg(pPMsg);

  0025c	8b 55 fc	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0025f	52		 push	 edx
  00260	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 691  :     }

  00268	eb db		 jmp	 SHORT $L69704
$L69707:

; 692  :     while( pPMsg = m_OldTempoMap.Dequeue() )

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00273	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00278	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  0027b	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  0027f	74 0e		 je	 SHORT $L69710

; 693  :     {
; 694  :         FreePMsg(pPMsg);

  00281	8b 45 fc	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00284	50		 push	 eax
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00288	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 695  :     }

  0028d	eb db		 jmp	 SHORT $L69707
$L69710:

; 696  :     while( pPMsg = m_NotificationQueue.Dequeue() )

  0028f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00292	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00298	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  0029d	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  002a0	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  002a4	74 0e		 je	 SHORT $L69713

; 697  :     {
; 698  :         FreePMsg(pPMsg);

  002a6	8b 4d fc	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  002a9	51		 push	 ecx
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002ad	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 699  :     }

  002b2	eb db		 jmp	 SHORT $L69710
$L69713:

; 700  :     while( pPMsg = m_TimeSigQueue.Dequeue() )

  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002b7	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  002bd	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  002c2	89 45 fc	 mov	 DWORD PTR _pPMsg$[ebp], eax
  002c5	83 7d fc 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  002c9	74 0e		 je	 SHORT $L69714

; 701  :     {
; 702  :         FreePMsg(pPMsg);

  002cb	8b 55 fc	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  002ce	52		 push	 edx
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002d2	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 703  :     }

  002d7	eb db		 jmp	 SHORT $L69713
$L69714:

; 704  : 
; 705  :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  002d9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002dc	05 30 03 00 00	 add	 eax, 816		; 00000330H
  002e1	50		 push	 eax
  002e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 706  : 
; 707  :     ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);

  002e8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002eb	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  002f1	51		 push	 ecx
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 708  :     GlobalData* pGD = m_pGlobalData;

  002f8	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002fb	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  00301	89 45 f4	 mov	 DWORD PTR _pGD$[ebp], eax
$L69717:

; 709  :     while( pGD )

  00304	83 7d f4 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  00308	74 44		 je	 SHORT $L69718

; 710  :     {
; 711  :         m_pGlobalData = pGD->pNext;

  0030a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0030d	8b 55 f4	 mov	 edx, DWORD PTR _pGD$[ebp]
  00310	8b 02		 mov	 eax, DWORD PTR [edx]
  00312	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 712  :         delete pGD;

  00318	8b 4d f4	 mov	 ecx, DWORD PTR _pGD$[ebp]
  0031b	89 4d d8	 mov	 DWORD PTR $T75224[ebp], ecx
  0031e	8b 55 d8	 mov	 edx, DWORD PTR $T75224[ebp]
  00321	89 55 dc	 mov	 DWORD PTR $T75223[ebp], edx
  00324	83 7d dc 00	 cmp	 DWORD PTR $T75223[ebp], 0
  00328	74 0f		 je	 SHORT $L75225
  0032a	6a 01		 push	 1
  0032c	8b 4d dc	 mov	 ecx, DWORD PTR $T75223[ebp]
  0032f	e8 00 00 00 00	 call	 ??_GGlobalData@@QAEPAXI@Z
  00334	89 45 d0	 mov	 DWORD PTR tv213[ebp], eax
  00337	eb 07		 jmp	 SHORT $L75226
$L75225:
  00339	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv213[ebp], 0
$L75226:

; 713  :         pGD = m_pGlobalData;

  00340	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00343	8b 88 04 01 00
	00		 mov	 ecx, DWORD PTR [eax+260]
  00349	89 4d f4	 mov	 DWORD PTR _pGD$[ebp], ecx

; 714  :     }

  0034c	eb b6		 jmp	 SHORT $L69717
$L69718:

; 715  :     LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  0034e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00351	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  00357	52		 push	 edx
  00358	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 716  : 
; 717  :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0035e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00361	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00366	50		 push	 eax
  00367	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 718  :     // clear out ports, buffers, and pchannel maps
; 719  : #ifdef DXAPI
; 720  :     if( m_pPortTable )
; 721  :     {
; 722  :         DWORD dwIndex;
; 723  :         for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 724  :         {
; 725  :             if( m_pPortTable[dwIndex].pPort )
; 726  :             {
; 727  :                 m_pPortTable[dwIndex].pPort->Release();
; 728  :             }
; 729  :             if( m_pPortTable[dwIndex].pBuffer )
; 730  :             {
; 731  :                 m_pPortTable[dwIndex].pBuffer->Release();
; 732  :             }
; 733  :             if( m_pPortTable[dwIndex].pLatencyClock )
; 734  :             {
; 735  :                 m_pPortTable[dwIndex].pLatencyClock->Release();
; 736  :             }
; 737  :         }
; 738  :         delete [] m_pPortTable;
; 739  :         m_pPortTable = NULL;
; 740  :         m_dwNumPorts = 0;
; 741  :     }
; 742  : #endif
; 743  :     m_ChannelBlockList.Clear();

  0036d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00370	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00373	e8 00 00 00 00	 call	 ?Clear@CChannelBlockList@@QAEXXZ ; CChannelBlockList::Clear

; 744  :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00378	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0037b	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  00381	51		 push	 ecx
  00382	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 745  :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00388	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0038b	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  00391	52		 push	 edx
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 746  :     if( m_pClock )

  00398	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0039b	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0039f	74 1c		 je	 SHORT $L69721

; 747  :     {
; 748  :         m_pClock->Release();

  003a1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003a4	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  003a7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003aa	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  003ad	8b 12		 mov	 edx, DWORD PTR [edx]
  003af	51		 push	 ecx
  003b0	ff 52 08	 call	 DWORD PTR [edx+8]

; 749  :         m_pClock = NULL;

  003b3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003b6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$L69721:

; 750  :     }
; 751  :     m_BufferManager.Clear();

  003bd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003c0	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  003c6	e8 00 00 00 00	 call	 ?Clear@CBufferManager@@QAEXXZ ; CBufferManager::Clear

; 752  :     if (m_pDirectSound)

  003cb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003ce	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  003d2	74 16		 je	 SHORT $L69722

; 753  :     {
; 754  :         m_pDirectSound->Release();

  003d4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  003d7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 ?Release@IDirectSound@@QAGKXZ ; IDirectSound::Release

; 755  :         m_pDirectSound = NULL;

  003e0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003e3	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
$L69722:

; 756  :     }
; 757  : #ifdef DXAPI
; 758  :     if( m_pDirectMusic )
; 759  :     {
; 760  :         m_pDirectMusic->Release();
; 761  :         m_pDirectMusic = NULL;
; 762  :     }
; 763  : #else
; 764  :     if (m_pSynth)

  003ea	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  003ed	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  003f1	74 1c		 je	 SHORT $L69723

; 765  :     {
; 766  :         m_pSynth->Release();

  003f3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003f6	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003f9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  003fc	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  003ff	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00401	50		 push	 eax
  00402	ff 51 08	 call	 DWORD PTR [ecx+8]

; 767  :         m_pSynth = NULL;

  00405	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00408	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
$L69723:

; 768  :     }
; 769  : #endif
; 770  :     m_hNotification = NULL;

  0040f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00412	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0

; 771  :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0041c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0041f	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00425	51		 push	 ecx
  00426	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 772  : 
; 773  :     ENTER_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  0042c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0042f	81 c2 f8 02 00
	00		 add	 edx, 760		; 000002f8H
  00435	52		 push	 edx
  00436	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 774  :     for( int i = 0; i < (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN); i++ )

  0043c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$69724[ebp], 0
  00443	eb 09		 jmp	 SHORT $L69725
$L69726:
  00445	8b 45 ec	 mov	 eax, DWORD PTR _i$69724[ebp]
  00448	83 c0 01	 add	 eax, 1
  0044b	89 45 ec	 mov	 DWORD PTR _i$69724[ebp], eax
$L69725:
  0044e	83 7d ec 48	 cmp	 DWORD PTR _i$69724[ebp], 72 ; 00000048H
  00452	7d 5f		 jge	 SHORT $L69727
$L69729:

; 775  :     {
; 776  :         while( m_apPMsgCache[i] )

  00454	8b 4d ec	 mov	 ecx, DWORD PTR _i$69724[ebp]
  00457	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0045a	83 bc 8a 74 01
	00 00 00	 cmp	 DWORD PTR [edx+ecx*4+372], 0
  00462	74 4d		 je	 SHORT $L69730

; 777  :         {
; 778  :             PRIV_PMSG* pPriv = m_apPMsgCache[i];

  00464	8b 45 ec	 mov	 eax, DWORD PTR _i$69724[ebp]
  00467	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0046a	8b 94 81 74 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+372]
  00471	89 55 e4	 mov	 DWORD PTR _pPriv$69731[ebp], edx

; 779  :             m_apPMsgCache[i] = pPriv->pNext;

  00474	8b 45 ec	 mov	 eax, DWORD PTR _i$69724[ebp]
  00477	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0047a	8b 55 e4	 mov	 edx, DWORD PTR _pPriv$69731[ebp]
  0047d	8b 12		 mov	 edx, DWORD PTR [edx]
  0047f	89 94 81 74 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+372], edx

; 780  : #ifdef USE_PMSG_ZONE
; 781  :             // This test has to match the one in CPerformance::FreePMsg and CPerformance::AllocPMsg
; 782  :             ULONG cbSize = pPriv->dwPrivPubSize; 

  00486	8b 45 e4	 mov	 eax, DWORD PTR _pPriv$69731[ebp]
  00489	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0048c	89 4d e8	 mov	 DWORD PTR _cbSize$69732[ebp], ecx

; 783  :             if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) ){

  0048f	83 7d e8 30	 cmp	 DWORD PTR _cbSize$69732[ebp], 48 ; 00000030H
  00493	72 08		 jb	 SHORT $L69733
  00495	83 7d e8 78	 cmp	 DWORD PTR _cbSize$69732[ebp], 120 ; 00000078H
  00499	73 02		 jae	 SHORT $L69733

; 784  :                 // allocated out of the zone, do nothing
; 785  :             }
; 786  :             else {

  0049b	eb 12		 jmp	 SHORT $L69734
$L69733:

; 787  :                 delete [] pPriv;

  0049d	8b 55 e4	 mov	 edx, DWORD PTR _pPriv$69731[ebp]
  004a0	89 55 d4	 mov	 DWORD PTR $T75227[ebp], edx
  004a3	8b 45 d4	 mov	 eax, DWORD PTR $T75227[ebp]
  004a6	50		 push	 eax
  004a7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  004ac	83 c4 04	 add	 esp, 4
$L69734:

; 788  :             }
; 789  : #else
; 790  :             delete [] pPriv;
; 791  : #endif
; 792  :         }

  004af	eb a3		 jmp	 SHORT $L69729
$L69730:

; 793  :     }

  004b1	eb 92		 jmp	 SHORT $L69726
$L69727:

; 794  :     LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  004b3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  004b6	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  004bc	51		 push	 ecx
  004bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 795  : #ifdef DXAPI
; 796  :     if (m_hTransportThread)
; 797  :     {
; 798  :         CloseHandle( m_hTransportThread );
; 799  :         m_hTransportThread = 0;
; 800  :     }
; 801  :     if( m_hTransport )
; 802  :     {
; 803  :         CloseHandle( m_hTransport );
; 804  :         m_hTransport = 0;
; 805  :     }
; 806  :     if (m_hRealtimeThread)
; 807  :     {
; 808  :         CloseHandle( m_hRealtimeThread );
; 809  :         m_hRealtimeThread = 0;
; 810  :     }
; 811  :     if( m_hRealtime )
; 812  :     {
; 813  :         CloseHandle( m_hRealtime );
; 814  :         m_hRealtime = 0;
; 815  :     }
; 816  : #else
; 817  :     
; 818  : #endif
; 819  :     m_mtPlayTo = 0;

  004c3	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  004c6	c7 82 d4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+724], 0

; 820  : #ifdef USE_PMSG_ZONE
; 821  :     m_pPMsgZone->FreeAll();

  004d0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  004d3	8b 88 dc 03 00
	00		 mov	 ecx, DWORD PTR [eax+988]
  004d9	e8 00 00 00 00	 call	 ?FreeAll@CPMsgZone@@QAEXXZ ; CPMsgZone::FreeAll

; 822  : #endif
; 823  :     return S_OK;

  004de	33 c0		 xor	 eax, eax

; 824  : }

  004e0	8b e5		 mov	 esp, ebp
  004e2	5d		 pop	 ebp
  004e3	c2 04 00	 ret	 4
?CloseDown@CPerformance@@UAGJXZ ENDP			; CPerformance::CloseDown
_TEXT	ENDS
PUBLIC	??1GlobalData@@QAE@XZ				; GlobalData::~GlobalData
; Function compile flags: /Odt
;	COMDAT ??_GGlobalData@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GGlobalData@@QAEPAXI@Z PROC NEAR			; GlobalData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1GlobalData@@QAE@XZ	; GlobalData::~GlobalData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69740
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69740:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GGlobalData@@QAEPAXI@Z ENDP				; GlobalData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ ; `string'
PUBLIC	??_C@_0ED@EHENEGMG@Warning?3?5Request?5to?5query?5unknow@ ; `string'
PUBLIC	_==@8
EXTRN	_CLSID_AutDirectMusicPerformance:BYTE
EXTRN	_IID_IDispatch:BYTE
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
EXTRN	_IID_CPerformance:BYTE
EXTRN	_DebugBreak@0:NEAR
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IDirectMusicPerformance:BYTE
EXTRN	_IID_IDirectMusicGraph:BYTE
EXTRN	_IID_IDirectMusicTool:BYTE
EXTRN	_DirectMusicCreateInstance@16:NEAR
EXTRN	_IsBadReadPtr@8:NEAR
EXTRN	_IsBadWritePtr@8:NEAR
EXTRN	_IID_IDirectMusicPerformanceP:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'Performance::QueryInterface', 00H		; `CPerformance::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ DB '%s: Invalid '
	DB	'pointer ppv', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT
??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ DB '%'
	DB	's: Invalid pointer (void*)&iid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@EHENEGMG@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT
??_C@_0ED@EHENEGMG@Warning?3?5Request?5to?5query?5unknow@ DB 'Warning: Re'
	DB	'quest to query unknown interface on Performance object', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv146 = -12
tv139 = -8
tv128 = -4
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CPerformance::QueryInterface, COMDAT

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 838  :     V_INAME(CPerformance::QueryInterface);
; 839  :     V_PTRPTR_WRITE(ppv);

  00006	6a 04		 push	 4
  00008	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69749
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69749:

; 840  :     V_REFGUID(iid);

  0002e	6a 10		 push	 16			; 00000010H
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L69753
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L69753:

; 841  : 
; 842  :     *ppv = NULL;

  00056	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00059	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 843  :     if (iid == IID_IUnknown || iid == IID_IDirectMusicPerformance)

  0005f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00064	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _==@8
  0006d	85 c0		 test	 eax, eax
  0006f	75 12		 jne	 SHORT $L69756
  00071	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicPerformance
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _==@8
  0007f	85 c0		 test	 eax, eax
  00081	74 0a		 je	 SHORT $L69755
$L69756:

; 844  :     {
; 845  :         *ppv = static_cast<IDirectMusicPerformance*>(this);

  00083	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00086	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00089	89 02		 mov	 DWORD PTR [edx], eax

; 846  :     } else

  0008b	eb 6a		 jmp	 SHORT $L69758
$L69755:

; 847  :     if (iid == IID_IDirectMusicPerformance8)

  0008d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicPerformance
  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _==@8
  0009b	85 c0		 test	 eax, eax
  0009d	74 0a		 je	 SHORT $L69759

; 848  :     {
; 849  : #ifdef DXAPI
; 850  :         m_dwVersion = 8;
; 851  : #endif
; 852  :         *ppv = static_cast<IDirectMusicPerformance8*>(this);

  0009f	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  000a2	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	89 02		 mov	 DWORD PTR [edx], eax

; 853  :     } else

  000a7	eb 4e		 jmp	 SHORT $L69758
$L69759:

; 854  : #ifdef DXAPI
; 855  :     if (iid == IID_IDirectMusicPerformance2)
; 856  :     {
; 857  :         m_dwVersion = 7;
; 858  :         *ppv = static_cast<IDirectMusicPerformance*>(this);
; 859  :     } else 
; 860  :     if( iid == IID_IDirectMusicPerformanceStats )
; 861  :     {
; 862  :         *ppv = static_cast<IDirectMusicPerformanceStats*>(this);
; 863  :     } else 
; 864  :     if( iid == IID_IDirectMusicSetParamHook )
; 865  :     {
; 866  :         *ppv = static_cast<IDirectMusicSetParamHook*>(this);
; 867  :     } else
; 868  : #endif
; 869  :     if (iid == IID_IDirectMusicTool)

  000a9	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTool
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 _==@8
  000b7	85 c0		 test	 eax, eax
  000b9	74 22		 je	 SHORT $L69762

; 870  :     {
; 871  :         *ppv = static_cast<IDirectMusicTool*>(this);

  000bb	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  000bf	74 0b		 je	 SHORT $L75234
  000c1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	83 c2 04	 add	 edx, 4
  000c7	89 55 fc	 mov	 DWORD PTR tv128[ebp], edx
  000ca	eb 07		 jmp	 SHORT $L75235
$L75234:
  000cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
$L75235:
  000d3	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR tv128[ebp]
  000d9	89 08		 mov	 DWORD PTR [eax], ecx

; 872  :     } else

  000db	eb 1a		 jmp	 SHORT $L69758
$L69762:

; 873  :     if (iid == IID_CPerformance)

  000dd	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CPerformance
  000e2	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 _==@8
  000eb	85 c0		 test	 eax, eax
  000ed	74 08		 je	 SHORT $L69758

; 874  :     {
; 875  :         *ppv = static_cast<CPerformance*>(this);

  000ef	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	89 08		 mov	 DWORD PTR [eax], ecx
$L69758:

; 876  :     }
; 877  :     if (iid == IID_IDirectMusicGraph)

  000f7	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGraph
  000fc	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 _==@8
  00105	85 c0		 test	 eax, eax
  00107	74 20		 je	 SHORT $L69767

; 878  :     {
; 879  :         *ppv = static_cast<IDirectMusicGraph*>(this);

  00109	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  0010d	74 0b		 je	 SHORT $L75236
  0010f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00112	83 c0 08	 add	 eax, 8
  00115	89 45 f8	 mov	 DWORD PTR tv139[ebp], eax
  00118	eb 07		 jmp	 SHORT $L75237
$L75236:
  0011a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
$L75237:
  00121	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  00124	8b 55 f8	 mov	 edx, DWORD PTR tv139[ebp]
  00127	89 11		 mov	 DWORD PTR [ecx], edx
$L69767:

; 880  :     }
; 881  :     if (iid == IID_IDirectMusicPerformanceP)

  00129	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicPerformanceP
  0012e	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 _==@8
  00137	85 c0		 test	 eax, eax
  00139	74 22		 je	 SHORT $L69769

; 882  :     {
; 883  :         *ppv = static_cast<IDirectMusicPerformanceP*>(this);

  0013b	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  0013f	74 0b		 je	 SHORT $L75238
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00147	89 4d f4	 mov	 DWORD PTR tv146[ebp], ecx
  0014a	eb 07		 jmp	 SHORT $L75239
$L75238:
  0014c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
$L75239:
  00153	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00156	8b 45 f4	 mov	 eax, DWORD PTR tv146[ebp]
  00159	89 02		 mov	 DWORD PTR [edx], eax

; 884  :     } else

  0015b	eb 68		 jmp	 SHORT $L69771
$L69769:

; 885  :     if (iid == IID_IDispatch)

  0015d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  00162	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _==@8
  0016b	85 c0		 test	 eax, eax
  0016d	74 56		 je	 SHORT $L69771

; 886  :     {
; 887  :         // A helper scripting object implements IDispatch, which we expose from the
; 888  :         // Performance object via COM aggregation.
; 889  :         if (!m_pUnkDispatch)

  0016f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00172	83 ba d0 03 00
	00 00		 cmp	 DWORD PTR [edx+976], 0
  00179	75 1c		 jne	 SHORT $L69773

; 890  :         {
; 891  :             // Create the helper object
; 892  :             DirectMusicCreateInstance(
; 893  :                 CLSID_AutDirectMusicPerformance,
; 894  :                 static_cast<IDirectMusicPerformance*>(this),
; 895  :                 IID_IUnknown,
; 896  :                 reinterpret_cast<void**>(&m_pUnkDispatch));

  0017b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0017e	05 d0 03 00 00	 add	 eax, 976		; 000003d0H
  00183	50		 push	 eax
  00184	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00189	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	51		 push	 ecx
  0018d	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AutDirectMusicPerformance
  00192	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
$L69773:

; 897  :         }
; 898  :         if (m_pUnkDispatch)

  00197	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0019a	83 ba d0 03 00
	00 00		 cmp	 DWORD PTR [edx+976], 0
  001a1	74 22		 je	 SHORT $L69771

; 899  :         {
; 900  :             return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);

  001a3	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  001a6	50		 push	 eax
  001a7	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  001ac	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	8b 91 d0 03 00
	00		 mov	 edx, DWORD PTR [ecx+976]
  001b5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	8b 88 d0 03 00
	00		 mov	 ecx, DWORD PTR [eax+976]
  001be	8b 12		 mov	 edx, DWORD PTR [edx]
  001c0	51		 push	 ecx
  001c1	ff 12		 call	 DWORD PTR [edx]
  001c3	eb 2c		 jmp	 SHORT $L69745
$L69771:

; 901  :         }
; 902  :     }
; 903  :     if (*ppv == NULL)

  001c5	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  001c8	83 38 00	 cmp	 DWORD PTR [eax], 0
  001cb	75 16		 jne	 SHORT $L69777

; 904  :     {
; 905  :         Trace(4,"Warning: Request to query unknown interface on Performance object\n");

  001cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0ED@EHENEGMG@Warning?3?5Request?5to?5query?5unknow@
  001d2	6a 04		 push	 4
  001d4	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001d9	83 c4 08	 add	 esp, 8

; 906  :         return E_NOINTERFACE;

  001dc	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  001e1	eb 0e		 jmp	 SHORT $L69745
$L69777:

; 907  :     }
; 908  :     reinterpret_cast<IUnknown*>(this)->AddRef();

  001e3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001eb	50		 push	 eax
  001ec	ff 52 04	 call	 DWORD PTR [edx+4]

; 909  :     return S_OK;

  001ef	33 c0		 xor	 eax, eax
$L69745:

; 910  : }

  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z ENDP ; CPerformance::QueryInterface
_TEXT	ENDS
PUBLIC	_IsEqualGUID@8
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==@8	PROC NEAR					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     return IsEqualGUID(guidOne,guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IsEqualGUID@8

; 190  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
_==@8	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
_TEXT	ENDS
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
;	COMDAT ?AddRef@CPerformance@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CPerformance@@UAGKXZ PROC NEAR			; CPerformance::AddRef, COMDAT

; 918  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 919  :     return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	05 ec 02 00 00	 add	 eax, 748		; 000002ecH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 920  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?AddRef@CPerformance@@UAGKXZ ENDP			; CPerformance::AddRef
_TEXT	ENDS
PUBLIC	??_GCPerformance@@QAEPAXI@Z			; CPerformance::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CPerformance@@UAGKXZ
_TEXT	SEGMENT
tv73 = -12
$T75253 = -8
$T75252 = -4
_this$ = 8
?Release@CPerformance@@UAGKXZ PROC NEAR			; CPerformance::Release, COMDAT

; 928  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 929  :     if (!InterlockedDecrement(&m_cRef))

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	05 ec 02 00 00	 add	 eax, 748		; 000002ecH
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00014	85 c0		 test	 eax, eax
  00016	75 39		 jne	 SHORT $L69788

; 930  :     {
; 931  : #ifndef XBOX
; 932  :         DWORD dwThreadID = GetCurrentThreadId();
; 933  :         m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
; 934  :         if (dwThreadID == m_dwTransportThreadID)
; 935  :         {
; 936  :             m_fReleasedInTransport = true;
; 937  :             m_fKillThread = TRUE;
; 938  :         }
; 939  :         else if (dwThreadID == m_dwRealtimeThreadID)
; 940  :         {
; 941  :             m_fReleasedInRealtime = true;
; 942  :             m_fKillRealtimeThread = TRUE;
; 943  :         }
; 944  :         else
; 945  :         {
; 946  :             delete this;
; 947  :         }
; 948  :         return 0;
; 949  : #else
; 950  :         m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 81 ec 02 00
	00 64 00 00 00	 mov	 DWORD PTR [ecx+748], 100 ; 00000064H

; 951  :         delete this;

  00025	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00028	89 55 f8	 mov	 DWORD PTR $T75253[ebp], edx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T75253[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR $T75252[ebp], eax
  00031	83 7d fc 00	 cmp	 DWORD PTR $T75252[ebp], 0
  00035	74 0f		 je	 SHORT $L75254
  00037	6a 01		 push	 1
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T75252[ebp]
  0003c	e8 00 00 00 00	 call	 ??_GCPerformance@@QAEPAXI@Z
  00041	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00044	eb 07		 jmp	 SHORT $L75255
$L75254:
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L75255:

; 952  :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 09		 jmp	 SHORT $L69787
$L69788:

; 953  : #endif
; 954  :     }
; 955  : 
; 956  :     return m_cRef;

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 81 ec 02 00
	00		 mov	 eax, DWORD PTR [ecx+748]
$L69787:

; 957  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?Release@CPerformance@@UAGKXZ ENDP			; CPerformance::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCPerformance@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCPerformance@@QAEPAXI@Z PROC NEAR			; CPerformance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPerformance@@QAE@XZ	; CPerformance::~CPerformance
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69794
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69794:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCPerformance@@QAEPAXI@Z ENDP			; CPerformance::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ	; CSegStateList::RemoveHead
EXTRN	?ShutDown@CSegState@@QAEJXZ:NEAR		; CSegState::ShutDown
; Function compile flags: /Odt
;	COMDAT ?DequeueAllSegments@CPerformance@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12
_pNode$ = -8
_dwCount$ = -4
?DequeueAllSegments@CPerformance@@AAEXXZ PROC NEAR	; CPerformance::DequeueAllSegments, COMDAT
; _this$ = ecx

; 963  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 964  :     CSegState *pNode;
; 965  :     DWORD dwCount;
; 966  : 
; 967  :     for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  00010	eb 09		 jmp	 SHORT $L69800
$L69801:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _dwCount$[ebp], eax
$L69800:
  0001b	83 7d fc 09	 cmp	 DWORD PTR _dwCount$[ebp], 9
  0001f	73 24		 jae	 SHORT $L69807
$L69804:

; 968  :     {
; 969  :         while( pNode = m_SegStateQueues[dwCount].RemoveHead())

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  00024	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8d 4c ca 44	 lea	 ecx, DWORD PTR [edx+ecx*8+68]
  0002b	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  00030	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
  00033	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00037	74 0a		 je	 SHORT $L69805

; 970  :         {
; 971  :             pNode->ShutDown();

  00039	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0003c	e8 00 00 00 00	 call	 ?ShutDown@CSegState@@QAEJXZ ; CSegState::ShutDown

; 972  :         }

  00041	eb de		 jmp	 SHORT $L69804
$L69805:

; 973  :     }

  00043	eb cd		 jmp	 SHORT $L69801
$L69807:

; 974  :     while( pNode = m_ShutDownQueue.RemoveHead())

  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0004e	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  00053	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
  00056	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  0005a	74 0a		 je	 SHORT $L69797

; 975  :     {
; 976  :         pNode->ShutDown();

  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0005f	e8 00 00 00 00	 call	 ?ShutDown@CSegState@@QAEJXZ ; CSegState::ShutDown

; 977  :     }

  00064	eb df		 jmp	 SHORT $L69807
$L69797:

; 978  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?DequeueAllSegments@CPerformance@@AAEXXZ ENDP		; CPerformance::DequeueAllSegments
_TEXT	ENDS
PUBLIC	??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@ ; `string'
PUBLIC	??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BG@MHOFNGKM@pEvent?9?$DOpNext?5?$DN?$DN?5NULL?$AA@ ; `string'
PUBLIC	?Realtime@CPerformance@@AAEXPA_J@Z		; CPerformance::Realtime
PUBLIC	?GetNextPMsg@CPerformance@@AAEPAUPRIV_PMSG@@XZ	; CPerformance::GetNextPMsg
PUBLIC	?GetLatency@CPerformance@@AAE_JXZ		; CPerformance::GetLatency
EXTRN	__imp__RtlAssert@16:NEAR
EXTRN	_GetTickCount@0:NEAR
;	COMDAT ??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
CONST	SEGMENT
??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@ DB 'Error: Perfo'
	DB	'rmance not initialized.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\dmperf.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MHOFNGKM@pEvent?9?$DOpNext?5?$DN?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BG@MHOFNGKM@pEvent?9?$DOpNext?5?$DN?$DN?5NULL?$AA@ DB 'pEvent->pNe'
	DB	'xt == NULL', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Realtime@CPerformance@@AAEXPA_J@Z
_TEXT	SEGMENT
tv129 = -52
tv179 = -48
_this$ = -44
_rtFirst$ = -40
_hr$ = -28
_dwTestTime$ = -24
_pEvent$ = -20
_dwBeginTime$ = -16
_dwLimitLoop$ = -12
_rtEnter$ = -8
_prtWakeUp$ = 8
?Realtime@CPerformance@@AAEXPA_J@Z PROC NEAR		; CPerformance::Realtime, COMDAT
; _this$ = ecx

; 1124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 1125 :     if (m_dwAudioPathMode == 0)

  00009	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00013	75 14		 jne	 SHORT $L69818

; 1126 :     {
; 1127 :         Trace(1,"Error: Performance not initialized.\n");

  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  0001a	6a 01		 push	 1
  0001c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00021	83 c4 08	 add	 esp, 8

; 1128 :         return ;

  00024	e9 c6 01 00 00	 jmp	 $L69817
$L69818:

; 1129 :     }
; 1130 :     ENTER_CRITICAL_SECTION(&m_RealtimeCrSec);

  00029	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 84 03 00
	00		 add	 ecx, 900		; 00000384H
  00032	51		 push	 ecx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1131 :     PRIV_PMSG *pEvent;
; 1132 :     HRESULT hr;
; 1133 :     REFERENCE_TIME  rtFirst = 0;

  00039	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _rtFirst$[ebp], 0
  00040	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _rtFirst$[ebp+4], 0

; 1134 :     REFERENCE_TIME  rtEnter = GetLatencyWithPrePlay();

  00047	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  0004f	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	03 81 c8 02 00
	00		 add	 eax, DWORD PTR [ecx+712]
  00058	13 91 cc 02 00
	00		 adc	 edx, DWORD PTR [ecx+716]
  0005e	89 45 f8	 mov	 DWORD PTR _rtEnter$[ebp], eax
  00061	89 55 fc	 mov	 DWORD PTR _rtEnter$[ebp+4], edx

; 1135 :     DWORD   dwTestTime;
; 1136 :     DWORD   dwBeginTime = timeGetTime();

  00064	e8 00 00 00 00	 call	 _GetTickCount@0
  00069	89 45 f0	 mov	 DWORD PTR _dwBeginTime$[ebp], eax

; 1137 :     DWORD   dwLimitLoop = 0;

  0006c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwLimitLoop$[ebp], 0

; 1138 : 
; 1139 :     if( rtEnter > m_rtQueuePosition )

  00073	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00076	89 55 d0	 mov	 DWORD PTR tv179[ebp], edx
  00079	8b 45 d0	 mov	 eax, DWORD PTR tv179[ebp]
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _rtEnter$[ebp+4]
  0007f	3b 88 bc 02 00
	00		 cmp	 ecx, DWORD PTR [eax+700]
  00085	7c 25		 jl	 SHORT $L69829
  00087	7f 0e		 jg	 SHORT $L75267
  00089	8b 55 d0	 mov	 edx, DWORD PTR tv179[ebp]
  0008c	8b 45 f8	 mov	 eax, DWORD PTR _rtEnter$[ebp]
  0008f	3b 82 b8 02 00
	00		 cmp	 eax, DWORD PTR [edx+696]
  00095	76 15		 jbe	 SHORT $L69829
$L75267:

; 1140 :     {
; 1141 :         m_rtQueuePosition = rtEnter;

  00097	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 55 f8	 mov	 edx, DWORD PTR _rtEnter$[ebp]
  0009d	89 91 b8 02 00
	00		 mov	 DWORD PTR [ecx+696], edx
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _rtEnter$[ebp+4]
  000a6	89 81 bc 02 00
	00		 mov	 DWORD PTR [ecx+700], eax
$L69829:

; 1142 :     }
; 1143 : 
; 1144 :     while (1)

  000ac	b9 01 00 00 00	 mov	 ecx, 1
  000b1	85 c9		 test	 ecx, ecx
  000b3	0f 84 0f 01 00
	00		 je	 $L69830

; 1145 :     {
; 1146 :         // rtFirst equals the time that the first event was packed into a buffer.
; 1147 :         // Once this time is greater than the latency clock (minus a delay) we need
; 1148 :         // to queue the buffers so the events get down in time to be rendered.
; 1149 :         // If rtFirst is 0 it means it hasn't been initialized yet.
; 1150 :         dwTestTime = timeGetTime();

  000b9	e8 00 00 00 00	 call	 _GetTickCount@0
  000be	89 45 e8	 mov	 DWORD PTR _dwTestTime$[ebp], eax

; 1151 :         if( dwTestTime - dwBeginTime > REALTIME_RES )

  000c1	8b 55 e8	 mov	 edx, DWORD PTR _dwTestTime$[ebp]
  000c4	2b 55 f0	 sub	 edx, DWORD PTR _dwBeginTime$[ebp]
  000c7	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000ca	76 1a		 jbe	 SHORT $L69831

; 1152 :         {
; 1153 :             if( ++dwLimitLoop > 10 )

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _dwLimitLoop$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 f4	 mov	 DWORD PTR _dwLimitLoop$[ebp], eax
  000d5	83 7d f4 0a	 cmp	 DWORD PTR _dwLimitLoop$[ebp], 10 ; 0000000aH
  000d9	76 05		 jbe	 SHORT $L69832

; 1154 :             {
; 1155 :                 TraceI(1,"Error! We've been in the realtime thread too long!!! Breaking out without completing.\n");
; 1156 :                 break;

  000db	e9 e8 00 00 00	 jmp	 $L69830
$L69832:

; 1157 :             }
; 1158 :             SendBuffers();
; 1159 :             dwBeginTime = dwTestTime;

  000e0	8b 4d e8	 mov	 ecx, DWORD PTR _dwTestTime$[ebp]
  000e3	89 4d f0	 mov	 DWORD PTR _dwBeginTime$[ebp], ecx
$L69831:

; 1160 :         }
; 1161 :         pEvent = GetNextPMsg();

  000e6	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	e8 00 00 00 00	 call	 ?GetNextPMsg@CPerformance@@AAEPAUPRIV_PMSG@@XZ ; CPerformance::GetNextPMsg
  000ee	89 45 ec	 mov	 DWORD PTR _pEvent$[ebp], eax

; 1162 :         if( NULL == pEvent )

  000f1	83 7d ec 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  000f5	75 05		 jne	 SHORT $L69834

; 1163 :         {
; 1164 :             break;

  000f7	e9 cc 00 00 00	 jmp	 $L69830
$L69834:

; 1165 :         }
; 1166 :         ASSERT( pEvent->pNext == NULL );

  000fc	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000ff	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00102	74 17		 je	 SHORT $L69835
  00104	6a 00		 push	 0
  00106	68 8e 04 00 00	 push	 1166			; 0000048eH
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@MHOFNGKM@pEvent?9?$DOpNext?5?$DN?$DN?5NULL?$AA@
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69835:

; 1167 :         if( !pEvent->pTool )

  0011b	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0011e	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00122	75 2d		 jne	 SHORT $L69838

; 1168 :         {
; 1169 :             // this event doesn't have a Tool pointer, so stamp it with the
; 1170 :             // final output Tool.
; 1171 :             pEvent->pTool = (IDirectMusicTool*)this;

  00124	83 7d d4 00	 cmp	 DWORD PTR _this$[ebp], 0
  00128	74 0b		 je	 SHORT $L75265
  0012a	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	83 c1 04	 add	 ecx, 4
  00130	89 4d cc	 mov	 DWORD PTR tv129[ebp], ecx
  00133	eb 07		 jmp	 SHORT $L75266
$L75265:
  00135	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$L75266:
  0013c	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0013f	8b 45 cc	 mov	 eax, DWORD PTR tv129[ebp]
  00142	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1172 :             AddRef();

  00145	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	50		 push	 eax
  0014e	ff 52 04	 call	 DWORD PTR [edx+4]
$L69838:

; 1173 :         }
; 1174 : 
; 1175 :         // before processing the event, set rtLast to the event's current time
; 1176 :         pEvent->rtLast = pEvent->rtTime;

  00151	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00154	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00157	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0015a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0015d	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  00160	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1177 : 
; 1178 :         hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );

  00163	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00166	83 c0 18	 add	 eax, 24			; 00000018H
  00169	50		 push	 eax
  0016a	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	51		 push	 ecx
  0016e	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00171	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00174	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00177	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0017a	8b 00		 mov	 eax, DWORD PTR [eax]
  0017c	52		 push	 edx
  0017d	ff 50 1c	 call	 DWORD PTR [eax+28]
  00180	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax

; 1179 :         if( hr != S_OK ) // S_OK means do nothing

  00183	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00187	74 3a		 je	 SHORT $L69843

; 1180 :         {
; 1181 :             if( hr == DMUS_S_REQUEUE )

  00189	81 7d e4 00 12
	78 08		 cmp	 DWORD PTR _hr$[ebp], 142086656 ; 08781200H
  00190	75 25		 jne	 SHORT $L69848

; 1182 :             {
; 1183 :                 if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))

  00192	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00195	83 c1 18	 add	 ecx, 24			; 00000018H
  00198	51		 push	 ecx
  00199	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0019c	8b 02		 mov	 eax, DWORD PTR [edx]
  0019e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	51		 push	 ecx
  001a2	ff 50 10	 call	 DWORD PTR [eax+16]
  001a5	85 c0		 test	 eax, eax
  001a7	7d 0c		 jge	 SHORT $L69852

; 1184 :                 {
; 1185 :                     FreePMsg(pEvent);

  001a9	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$[ebp]
  001ac	52		 push	 edx
  001ad	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L69852:

; 1186 :                 }
; 1187 :             }
; 1188 :             else // e.g. DMUS_S_FREE or error code

  001b5	eb 0c		 jmp	 SHORT $L69843
$L69848:

; 1189 :             {
; 1190 :                 FreePMsg( pEvent );

  001b7	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$[ebp]
  001ba	50		 push	 eax
  001bb	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L69843:

; 1191 :             }
; 1192 :         }
; 1193 :     }

  001c3	e9 e4 fe ff ff	 jmp	 $L69829
$L69830:

; 1194 :     SendBuffers();
; 1195 :     LEAVE_CRITICAL_SECTION(&m_RealtimeCrSec);

  001c8	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	81 c1 84 03 00
	00		 add	 ecx, 900		; 00000384H
  001d1	51		 push	 ecx
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1196 :     *prtWakeUp = rtEnter + REALTIME_RES * 10000;    

  001d8	8b 55 f8	 mov	 edx, DWORD PTR _rtEnter$[ebp]
  001db	81 c2 a0 86 01
	00		 add	 edx, 100000		; 000186a0H
  001e1	8b 45 fc	 mov	 eax, DWORD PTR _rtEnter$[ebp+4]
  001e4	83 d0 00	 adc	 eax, 0
  001e7	8b 4d 08	 mov	 ecx, DWORD PTR _prtWakeUp$[ebp]
  001ea	89 11		 mov	 DWORD PTR [ecx], edx
  001ec	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L69817:

; 1197 : }

  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c2 04 00	 ret	 4
?Realtime@CPerformance@@AAEXPA_J@Z ENDP			; CPerformance::Realtime
_TEXT	ENDS
PUBLIC	?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z ; CPerformance::FindNotification
PUBLIC	?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ; CPerformance::GenerateNotification
EXTRN	_GUID_NOTIFICATION_PERFORMANCE:BYTE
; Function compile flags: /Odt
;	COMDAT ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z
_TEXT	SEGMENT
_this$ = -24
_pEvent$69862 = -20
_guid$ = -16
_dwNotification$ = 8
_mtTime$ = 12
_pSegSt$ = 16
?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z PROC NEAR ; CPerformance::GenerateNotification, COMDAT
; _this$ = ecx

; 1225 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1226 :     GUID guid;
; 1227 :     guid = GUID_NOTIFICATION_PERFORMANCE;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE
  0000e	89 45 f0	 mov	 DWORD PTR _guid$[ebp], eax
  00011	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE+4
  00017	89 4d f4	 mov	 DWORD PTR _guid$[ebp+4], ecx
  0001a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE+8
  00020	89 55 f8	 mov	 DWORD PTR _guid$[ebp+8], edx
  00023	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE+12
  00028	89 45 fc	 mov	 DWORD PTR _guid$[ebp+12], eax

; 1228 :     if( FindNotification( guid ))

  0002b	8d 4d f0	 lea	 ecx, DWORD PTR _guid$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z ; CPerformance::FindNotification
  00037	85 c0		 test	 eax, eax
  00039	0f 84 eb 00 00
	00		 je	 $L69859

; 1229 :     {
; 1230 :         DMUS_NOTIFICATION_PMSG* pEvent = NULL;

  0003f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pEvent$69862[ebp], 0

; 1231 :         if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
; 1232 :             (DMUS_PMSG**)&pEvent )))

  00046	8d 55 ec	 lea	 edx, DWORD PTR _pEvent$69862[ebp]
  00049	52		 push	 edx
  0004a	6a 58		 push	 88			; 00000058H
  0004c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00054	52		 push	 edx
  00055	ff 51 24	 call	 DWORD PTR [ecx+36]
  00058	85 c0		 test	 eax, eax
  0005a	0f 8c ca 00 00
	00		 jl	 $L69859

; 1233 :         {
; 1234 :             pEvent->dwField1 = 0;

  00060	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$69862[ebp]
  00063	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 1235 :             pEvent->dwField2 = 0;

  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$69862[ebp]
  0006d	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 1236 :             pEvent->guidNotificationType = GUID_NOTIFICATION_PERFORMANCE;

  00074	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$69862[ebp]
  00077	83 c2 38	 add	 edx, 56			; 00000038H
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE
  0007f	89 02		 mov	 DWORD PTR [edx], eax
  00081	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE+4
  00087	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0008a	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE+8
  0008f	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00092	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_NOTIFICATION_PERFORMANCE+12
  00098	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1237 :             pEvent->dwType = DMUS_PMSGT_NOTIFICATION;

  0009b	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$69862[ebp]
  0009e	c7 42 28 03 00
	00 00		 mov	 DWORD PTR [edx+40], 3

; 1238 :             pEvent->mtTime = mtTime;

  000a5	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$69862[ebp]
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000ab	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1239 :             pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;

  000ae	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$69862[ebp]
  000b1	c7 42 14 12 00
	00 00		 mov	 DWORD PTR [edx+20], 18	; 00000012H

; 1240 :             pEvent->dwGroupID = 0xffffffff;

  000b8	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$69862[ebp]
  000bb	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1

; 1241 :             pEvent->dwPChannel = 0;

  000c2	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$69862[ebp]
  000c5	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 1242 :             pEvent->dwNotificationOption = dwNotification;

  000cc	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$69862[ebp]
  000cf	8b 45 08	 mov	 eax, DWORD PTR _dwNotification$[ebp]
  000d2	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 1243 :             if( pSegSt )

  000d5	83 7d 10 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  000d9	74 17		 je	 SHORT $L69867

; 1244 :             {
; 1245 :                 pSegSt->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

  000db	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$69862[ebp]
  000de	83 c1 34	 add	 ecx, 52			; 00000034H
  000e1	51		 push	 ecx
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  000e7	8b 55 10	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  000ea	8b 02		 mov	 eax, DWORD PTR [edx]
  000ec	8b 4d 10	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  000ef	51		 push	 ecx
  000f0	ff 10		 call	 DWORD PTR [eax]
$L69867:

; 1246 :             }
; 1247 :             StampPMsg((DMUS_PMSG*)pEvent);

  000f2	8b 55 ec	 mov	 edx, DWORD PTR _pEvent$69862[ebp]
  000f5	52		 push	 edx
  000f6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	83 c0 08	 add	 eax, 8
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00102	50		 push	 eax
  00103	ff 52 0c	 call	 DWORD PTR [edx+12]

; 1248 :             if(FAILED(SendPMsg( (DMUS_PMSG*)pEvent )))

  00106	8b 45 ec	 mov	 eax, DWORD PTR _pEvent$69862[ebp]
  00109	50		 push	 eax
  0010a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00112	50		 push	 eax
  00113	ff 52 10	 call	 DWORD PTR [edx+16]
  00116	85 c0		 test	 eax, eax
  00118	7d 10		 jge	 SHORT $L69859

; 1249 :             {
; 1250 :                 FreePMsg((DMUS_PMSG*)pEvent);

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR _pEvent$69862[ebp]
  0011d	51		 push	 ecx
  0011e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00121	8b 02		 mov	 eax, DWORD PTR [edx]
  00123	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	51		 push	 ecx
  00127	ff 50 28	 call	 DWORD PTR [eax+40]
$L69859:

; 1251 :             }
; 1252 :         }
; 1253 :     }
; 1254 : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 0c 00	 ret	 12			; 0000000cH
?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ENDP ; CPerformance::GenerateNotification
_TEXT	ENDS
PUBLIC	?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z ; CPerformance::PrepSegToPlay
PUBLIC	?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap
EXTRN	?GetEndTime@CSegState@@QAEJJ@Z:NEAR		; CSegState::GetEndTime
; Function compile flags: /Odt
;	COMDAT ?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z
_TEXT	SEGMENT
_this$ = -4
_pSegState$ = 8
_fQueue$ = 12
?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z PROC NEAR ; CPerformance::PrepSegToPlay, COMDAT
; _this$ = ecx

; 1263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1264 :     if (!pSegState->m_fPrepped)

  00007	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  0000a	83 b8 14 01 00
	00 00		 cmp	 DWORD PTR [eax+276], 0
  00011	75 67		 jne	 SHORT $L69878

; 1265 :     {
; 1266 :         pSegState->m_fPrepped = TRUE;

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00016	c7 81 14 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+276], 1

; 1267 :         pSegState->m_mtLastPlayed = pSegState->m_mtResolvedStart;

  00020	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00023	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00026	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00029	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 1268 :         // if this is queued to play after the current segment ends, no need to recalc the tempo map;
; 1269 :         // it will be updated as necessary by the transport thread.
; 1270 :         if (!fQueue)

  0002c	0f b6 55 0c	 movzx	 edx, BYTE PTR _fQueue$[ebp]
  00030	85 d2		 test	 edx, edx
  00032	75 15		 jne	 SHORT $L69880

; 1271 :         {
; 1272 :             RecalcTempoMap(pSegState, pSegState->m_mtResolvedStart);

  00034	6a 01		 push	 1
  00036	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00039	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0003c	51		 push	 ecx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00040	52		 push	 edx
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap
$L69880:

; 1273 :         }
; 1274 :         MusicToReferenceTime(pSegState->m_mtLastPlayed,&pSegState->m_rtLastPlayed);

  00049	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  0004c	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00055	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00058	52		 push	 edx
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	52		 push	 edx
  00062	ff 51 14	 call	 DWORD PTR [ecx+20]

; 1275 :         // Calculate the total duration of the segment and store in m_mtEndTime.
; 1276 :         pSegState->m_mtEndTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart);

  00065	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00068	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0006b	51		 push	 ecx
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  0006f	e8 00 00 00 00	 call	 ?GetEndTime@CSegState@@QAEJJ@Z ; CSegState::GetEndTime
  00074	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00077	89 42 68	 mov	 DWORD PTR [edx+104], eax
$L69878:

; 1277 :     }
; 1278 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z ENDP ; CPerformance::PrepSegToPlay
_TEXT	ENDS
PUBLIC	??_C@_0DF@EMJFMCPP@?$CB?$CIpSegStNode?9?$DOm_dwPlaySegFlags?5?$CG@ ; `string'
PUBLIC	?ProcessEarlyPMsgs@CPerformance@@AAEXXZ		; CPerformance::ProcessEarlyPMsgs
PUBLIC	?ManageControllingTracks@CPerformance@@AAEXXZ	; CPerformance::ManageControllingTracks
PUBLIC	?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode
PUBLIC	?GetHead@CSegStateList@@QAEPAVCSegState@@XZ	; CSegStateList::GetHead
PUBLIC	?Remove@CSegStateList@@QAEXPAVCSegState@@@Z	; CSegStateList::Remove
PUBLIC	?WakeUp@CWorker@@QAEXXZ				; CWorker::WakeUp
PUBLIC	?IsEmpty@AList@@QBEHXZ				; AList::IsEmpty
EXTRN	?AbortPlay@CSegState@@QAEJJH@Z:NEAR		; CSegState::AbortPlay
EXTRN	?Play@CSegState@@QAEJJ@Z:NEAR			; CSegState::Play
EXTRN	?Insert@CSegStateList@@QAEXPAVCSegState@@@Z:NEAR ; CSegStateList::Insert
;	COMDAT ??_C@_0DF@EMJFMCPP@?$CB?$CIpSegStNode?9?$DOm_dwPlaySegFlags?5?$CG@
CONST	SEGMENT
??_C@_0DF@EMJFMCPP@?$CB?$CIpSegStNode?9?$DOm_dwPlaySegFlags?5?$CG@ DB '!('
	DB	'pSegStNode->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z
_TEXT	SEGMENT
_this$ = -32
_mtNow$69927 = -28
_mtEnd$69921 = -24
_mtRange$69911 = -20
_mtMargin$ = -16
_hr$ = -12
_pList$ = -8
_pNext$ = -4
_dwList$ = 8
_pSegStNode$ = 12
?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z PROC NEAR ; CPerformance::PerformSegStNode, COMDAT
; _this$ = ecx

; 1292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1293 :     MUSIC_TIME mtMargin; // tracks how much of a segment to play
; 1294 :     HRESULT hr;
; 1295 :     CSegStateList *pList = &m_SegStateQueues[dwList];

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwList$[ebp]
  0000c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8d 54 c1 44	 lea	 edx, DWORD PTR [ecx+eax*8+68]
  00013	89 55 f8	 mov	 DWORD PTR _pList$[ebp], edx

; 1296 :     CSegState *pNext;
; 1297 : 
; 1298 :     if( !m_fPlaying || m_fInTrackPlay )

  00016	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 b8 c4 03 00
	00 00		 cmp	 DWORD PTR [eax+964], 0
  00020	74 0c		 je	 SHORT $L69891
  00022	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 b9 10 01 00
	00 00		 cmp	 DWORD PTR [ecx+272], 0
  0002c	74 05		 je	 SHORT $L69890
$L69891:

; 1299 :     {
; 1300 :         return;

  0002e	e9 d0 03 00 00	 jmp	 $L69885
$L69890:

; 1301 :     }
; 1302 :     if( pSegStNode )

  00033	83 7d 0c 00	 cmp	 DWORD PTR _pSegStNode$[ebp], 0
  00037	0f 84 c6 03 00
	00		 je	 $L69885

; 1303 :     {
; 1304 :         m_fInTransportThread = TRUE;    // Disable realtime processing of early queue messages.

  0003d	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	c7 82 0c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+268], 1

; 1305 :         hr = S_OK;

  0004a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1306 : //Trace(0,"%ld: Performing %lx, Active: %ld, Start Time: %ld, End Time: %ld\n",m_mtPlayTo,
; 1307 : //      pSegStNode->m_pSegment,pSegStNode->m_fStartedPlay,pSegStNode->m_mtResolvedStart,pSegStNode->m_mtEndTime);
; 1308 :         if( !pSegStNode->m_fStartedPlay )

  00051	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00054	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [eax+260], 0
  0005b	0f 85 1f 01 00
	00		 jne	 $L69894

; 1309 :         {
; 1310 :             // check to see if this SegState should start playing.
; 1311 :             ASSERT( !(pSegStNode->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ));

  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00064	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00067	83 e2 40	 and	 edx, 64			; 00000040H
  0006a	85 d2		 test	 edx, edx
  0006c	74 17		 je	 SHORT $L69895
  0006e	6a 00		 push	 0
  00070	68 1f 05 00 00	 push	 1311			; 0000051fH
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@EMJFMCPP@?$CB?$CIpSegStNode?9?$DOm_dwPlaySegFlags?5?$CG@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69895:

; 1312 :             if( pSegStNode->m_mtResolvedStart < m_mtPlayTo )

  00085	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00088	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0008e	3b 91 d4 02 00
	00		 cmp	 edx, DWORD PTR [ecx+724]
  00094	0f 8d c9 00 00
	00		 jge	 $L69897

; 1313 :             {
; 1314 :                 pSegStNode->m_fStartedPlay = TRUE;

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  0009d	c7 80 04 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+260], 1

; 1315 :                 PrepSegToPlay(pSegStNode);

  000a7	6a 00		 push	 0
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z ; CPerformance::PrepSegToPlay

; 1316 :                 // send a MUSICSTARTED notification if needed
; 1317 :                 if(m_fMusicStopped)

  000b5	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	83 ba c8 03 00
	00 00		 cmp	 DWORD PTR [edx+968], 0
  000bf	74 20		 je	 SHORT $L69898

; 1318 :                 {
; 1319 :                     m_fMusicStopped = FALSE;

  000c1	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	c7 80 c8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+968], 0

; 1320 :                     GenerateNotification( DMUS_NOTIFICATION_MUSICSTARTED, pSegStNode->m_mtResolvedStart, NULL );

  000ce	6a 00		 push	 0
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  000d3	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000d6	52		 push	 edx
  000d7	6a 00		 push	 0
  000d9	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	e8 00 00 00 00	 call	 ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ; CPerformance::GenerateNotification
$L69898:

; 1321 :                 }
; 1322 :                 // We don't want the music to start with a big BLURP in track
; 1323 :                 // order, so we send a little dribble out on each track.
; 1324 :                 mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;

  000e1	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  000e7	8b 90 d4 02 00
	00		 mov	 edx, DWORD PTR [eax+724]
  000ed	2b 51 70	 sub	 edx, DWORD PTR [ecx+112]
  000f0	89 55 f0	 mov	 DWORD PTR _mtMargin$[ebp], edx

; 1325 :                 if( mtMargin >= 50 )

  000f3	83 7d f0 32	 cmp	 DWORD PTR _mtMargin$[ebp], 50 ; 00000032H
  000f7	7c 68		 jl	 SHORT $L69899

; 1326 :                 {
; 1327 :                     hr = pSegStNode->Play( 50 );

  000f9	6a 32		 push	 50			; 00000032H
  000fb	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  000fe	e8 00 00 00 00	 call	 ?Play@CSegState@@QAEJJ@Z ; CSegState::Play
  00103	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1328 :                     ProcessEarlyPMsgs();

  00106	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?ProcessEarlyPMsgs@CPerformance@@AAEXXZ ; CPerformance::ProcessEarlyPMsgs

; 1329 :                     // Once done processing all the early messages, make sure that the realtime
; 1330 :                     // thread wakes up and does whatever it needs to do. This ensures that the starting
; 1331 :                     // notes in a sequence get to the output port immediately. 
; 1332 : #ifdef DXAPI
; 1333 :                     if( m_hRealtime ) SetEvent( m_hRealtime );
; 1334 : #else
; 1335 :                     if (m_pRealtimeWorker) m_pRealtimeWorker->WakeUp();

  0010e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00111	83 b8 c0 03 00
	00 00		 cmp	 DWORD PTR [eax+960], 0
  00118	74 0e		 je	 SHORT $L69900
  0011a	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [ecx+960]
  00123	e8 00 00 00 00	 call	 ?WakeUp@CWorker@@QAEXXZ	; CWorker::WakeUp
$L69900:

; 1336 : #endif
; 1337 :                     mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;

  00128	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  0012e	8b 8a d4 02 00
	00		 mov	 ecx, DWORD PTR [edx+724]
  00134	2b 48 70	 sub	 ecx, DWORD PTR [eax+112]
  00137	89 4d f0	 mov	 DWORD PTR _mtMargin$[ebp], ecx

; 1338 :                     // Then, we send a larger chunk out on each track to catch up a little more...
; 1339 :                     if ((hr == S_OK) && ( mtMargin >= 200 ))

  0013a	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013e	75 21		 jne	 SHORT $L69899
  00140	81 7d f0 c8 00
	00 00		 cmp	 DWORD PTR _mtMargin$[ebp], 200 ; 000000c8H
  00147	7c 18		 jl	 SHORT $L69899

; 1340 :                     {
; 1341 :                         hr = pSegStNode->Play( 200 );

  00149	68 c8 00 00 00	 push	 200			; 000000c8H
  0014e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00151	e8 00 00 00 00	 call	 ?Play@CSegState@@QAEJJ@Z ; CSegState::Play
  00156	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1342 :                         ProcessEarlyPMsgs();

  00159	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?ProcessEarlyPMsgs@CPerformance@@AAEXXZ ; CPerformance::ProcessEarlyPMsgs
$L69899:

; 1343 :                     }
; 1344 :                 }
; 1345 :             }
; 1346 :             else

  00161	eb 1d		 jmp	 SHORT $L69894
$L69897:

; 1347 :             {
; 1348 :                 MusicToReferenceTime(pSegStNode->m_mtLastPlayed,&pSegStNode->m_rtLastPlayed);

  00163	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00166	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  0016c	52		 push	 edx
  0016d	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00170	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00173	51		 push	 ecx
  00174	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00177	8b 02		 mov	 eax, DWORD PTR [edx]
  00179	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	51		 push	 ecx
  0017d	ff 50 14	 call	 DWORD PTR [eax+20]
$L69894:

; 1349 :             }
; 1350 :         }
; 1351 :         if( pSegStNode->m_fStartedPlay )

  00180	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00183	83 ba 04 01 00
	00 00		 cmp	 DWORD PTR [edx+260], 0
  0018a	0f 84 8a 00 00
	00		 je	 $L69904

; 1352 :         {
; 1353 :             if( pSegStNode->m_mtStopTime && ( pSegStNode->m_mtStopTime < m_mtPlayTo ) )

  00190	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00193	83 78 74 00	 cmp	 DWORD PTR [eax+116], 0
  00197	74 22		 je	 SHORT $L69905
  00199	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  0019c	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0019f	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  001a2	3b 82 d4 02 00
	00		 cmp	 eax, DWORD PTR [edx+724]
  001a8	7d 11		 jge	 SHORT $L69905

; 1354 :             {
; 1355 :                 mtMargin = pSegStNode->m_mtStopTime - pSegStNode->m_mtLastPlayed;

  001aa	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  001ad	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  001b0	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  001b3	2b 42 70	 sub	 eax, DWORD PTR [edx+112]
  001b6	89 45 f0	 mov	 DWORD PTR _mtMargin$[ebp], eax

; 1356 :             }
; 1357 :             else

  001b9	eb 12		 jmp	 SHORT $L69908
$L69905:

; 1358 :             {
; 1359 :                 mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;

  001bb	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  001c1	8b 81 d4 02 00
	00		 mov	 eax, DWORD PTR [ecx+724]
  001c7	2b 42 70	 sub	 eax, DWORD PTR [edx+112]
  001ca	89 45 f0	 mov	 DWORD PTR _mtMargin$[ebp], eax
$L69908:

; 1360 :             }
; 1361 :             while ((hr == S_OK) && (mtMargin > 0))

  001cd	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001d1	75 47		 jne	 SHORT $L69904
  001d3	83 7d f0 00	 cmp	 DWORD PTR _mtMargin$[ebp], 0
  001d7	7e 41		 jle	 SHORT $L69904

; 1362 :             {
; 1363 :                 // Do not allow more than a quarter note's worth to be done at once.
; 1364 :                 MUSIC_TIME mtRange = mtMargin;

  001d9	8b 4d f0	 mov	 ecx, DWORD PTR _mtMargin$[ebp]
  001dc	89 4d ec	 mov	 DWORD PTR _mtRange$69911[ebp], ecx

; 1365 :                 if (mtRange > DMUS_PPQ) 

  001df	81 7d ec 00 03
	00 00		 cmp	 DWORD PTR _mtRange$69911[ebp], 768 ; 00000300H
  001e6	7e 12		 jle	 SHORT $L69912

; 1366 :                 {
; 1367 :                     mtRange = DMUS_PPQ;

  001e8	c7 45 ec 00 03
	00 00		 mov	 DWORD PTR _mtRange$69911[ebp], 768 ; 00000300H

; 1368 :                     mtMargin -= mtRange;

  001ef	8b 55 f0	 mov	 edx, DWORD PTR _mtMargin$[ebp]
  001f2	2b 55 ec	 sub	 edx, DWORD PTR _mtRange$69911[ebp]
  001f5	89 55 f0	 mov	 DWORD PTR _mtMargin$[ebp], edx

; 1369 :                 }
; 1370 :                 else

  001f8	eb 07		 jmp	 SHORT $L69913
$L69912:

; 1371 :                 {
; 1372 :                     mtMargin = 0;

  001fa	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mtMargin$[ebp], 0
$L69913:

; 1373 :                 }
; 1374 :                 hr = pSegStNode->Play( mtRange );

  00201	8b 45 ec	 mov	 eax, DWORD PTR _mtRange$69911[ebp]
  00204	50		 push	 eax
  00205	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00208	e8 00 00 00 00	 call	 ?Play@CSegState@@QAEJJ@Z ; CSegState::Play
  0020d	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1375 :                 ProcessEarlyPMsgs();

  00210	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	e8 00 00 00 00	 call	 ?ProcessEarlyPMsgs@CPerformance@@AAEXXZ ; CPerformance::ProcessEarlyPMsgs

; 1376 :             }

  00218	eb b3		 jmp	 SHORT $L69908
$L69904:

; 1377 :         }
; 1378 :         if( (hr == DMUS_S_END) || ( pSegStNode->m_mtStopTime && 
; 1379 :                                   ( pSegStNode->m_mtStopTime <= pSegStNode->m_mtLastPlayed ) ) )

  0021a	81 7d f4 02 12
	78 08		 cmp	 DWORD PTR _hr$[ebp], 142086658 ; 08781202H
  00221	74 1f		 je	 SHORT $L69919
  00223	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00226	83 79 74 00	 cmp	 DWORD PTR [ecx+116], 0
  0022a	0f 84 c6 01 00
	00		 je	 $L69918
  00230	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00233	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00236	8b 4a 74	 mov	 ecx, DWORD PTR [edx+116]
  00239	3b 48 70	 cmp	 ecx, DWORD PTR [eax+112]
  0023c	0f 8f b4 01 00
	00		 jg	 $L69918
$L69919:

; 1380 :         {
; 1381 : 
; 1382 :             if( pSegStNode->m_mtStopTime && (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed) )

  00242	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00245	83 7a 74 00	 cmp	 DWORD PTR [edx+116], 0
  00249	74 22		 je	 SHORT $L69920
  0024b	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  0024e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00251	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  00254	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  00257	75 14		 jne	 SHORT $L69920

; 1383 :             {
; 1384 :                 pSegStNode->AbortPlay(pSegStNode->m_mtStopTime - 1, FALSE);

  00259	6a 00		 push	 0
  0025b	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  0025e	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00261	83 e9 01	 sub	 ecx, 1
  00264	51		 push	 ecx
  00265	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00268	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay
$L69920:

; 1385 :             }
; 1386 :             MUSIC_TIME mtEnd = pSegStNode->m_mtLastPlayed;

  0026d	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00270	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00273	89 45 e8	 mov	 DWORD PTR _mtEnd$69921[ebp], eax

; 1387 :             if( pList == &m_SegStateQueues[SQ_PRI_PLAY] )

  00276	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0027c	39 4d f8	 cmp	 DWORD PTR _pList$[ebp], ecx
  0027f	0f 85 92 00 00
	00		 jne	 $L69922

; 1388 :             {
; 1389 :                 // move primary segments to PriPastList
; 1390 :                 pList->Remove(pSegStNode);

  00285	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00288	52		 push	 edx
  00289	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  0028c	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 1391 :                 m_SegStateQueues[SQ_PRI_DONE].Insert(pSegStNode);

  00291	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00294	50		 push	 eax
  00295	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00298	83 c1 74	 add	 ecx, 116		; 00000074H
  0029b	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 1392 :                 pNext = pList->GetHead();

  002a0	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  002a3	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002a8	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 1393 :                 if( pNext )

  002ab	83 7d fc 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  002af	74 38		 je	 SHORT $L69923

; 1394 :                 {
; 1395 :                     if (!( pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE ))

  002b1	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  002b4	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  002b7	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  002bd	85 d2		 test	 edx, edx
  002bf	75 26		 jne	 SHORT $L69924

; 1396 :                     {
; 1397 :                         if (IsConQueue(dwList))

  002c1	8b 45 08	 mov	 eax, DWORD PTR _dwList$[ebp]
  002c4	33 d2		 xor	 edx, edx
  002c6	b9 03 00 00 00	 mov	 ecx, 3
  002cb	f7 f1		 div	 ecx
  002cd	83 fa 01	 cmp	 edx, 1
  002d0	75 15		 jne	 SHORT $L69924

; 1398 :                         {
; 1399 :                             Invalidate( pNext->m_mtResolvedStart, 0 );

  002d2	6a 00		 push	 0
  002d4	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  002d7	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  002da	50		 push	 eax
  002db	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002de	8b 11		 mov	 edx, DWORD PTR [ecx]
  002e0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  002e3	50		 push	 eax
  002e4	ff 52 68	 call	 DWORD PTR [edx+104]
$L69924:

; 1400 :                         }
; 1401 :                     }
; 1402 :                 }
; 1403 :                 else    // No more primary segments, send DMUS_NOTIFICATION_MUSICALMOSTEND

  002e7	eb 24		 jmp	 SHORT $L69926
$L69923:

; 1404 :                 {
; 1405 : #ifdef DXAPI
; 1406 :                     if (m_dwVersion >= 8)
; 1407 : #endif
; 1408 :                     {
; 1409 :                         MUSIC_TIME mtNow;
; 1410 :                         GetTime( NULL, &mtNow );

  002e9	8d 4d e4	 lea	 ecx, DWORD PTR _mtNow$69927[ebp]
  002ec	51		 push	 ecx
  002ed	6a 00		 push	 0
  002ef	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  002f2	8b 02		 mov	 eax, DWORD PTR [edx]
  002f4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002f7	51		 push	 ecx
  002f8	ff 50 20	 call	 DWORD PTR [eax+32]

; 1411 :                         GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegStNode );

  002fb	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  002fe	52		 push	 edx
  002ff	8b 45 e4	 mov	 eax, DWORD PTR _mtNow$69927[ebp]
  00302	50		 push	 eax
  00303	6a 02		 push	 2
  00305	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00308	e8 00 00 00 00	 call	 ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ; CPerformance::GenerateNotification
$L69926:

; 1412 :                     }
; 1413 :                 }
; 1414 :                 ManageControllingTracks();

  0030d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00310	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks

; 1415 :             }
; 1416 :             else if ( pList == &m_SegStateQueues[SQ_CON_PLAY] )

  00315	eb 68		 jmp	 SHORT $L69928
$L69922:
  00317	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0031a	83 c1 64	 add	 ecx, 100		; 00000064H
  0031d	39 4d f8	 cmp	 DWORD PTR _pList$[ebp], ecx
  00320	75 3f		 jne	 SHORT $L69929

; 1417 :             {
; 1418 :                 pList->Remove(pSegStNode );

  00322	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00325	52		 push	 edx
  00326	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  00329	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 1419 :                 if (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed)

  0032e	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00331	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00334	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  00337	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  0033a	75 14		 jne	 SHORT $L69930

; 1420 :                 {
; 1421 :                     m_ShutDownQueue.Insert(pSegStNode); 

  0033c	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  0033f	50		 push	 eax
  00340	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00343	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00349	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 1422 :                 }
; 1423 :                 else

  0034e	eb 0f		 jmp	 SHORT $L69931
$L69930:

; 1424 :                 {
; 1425 :                     m_SegStateQueues[SQ_CON_DONE].Insert(pSegStNode);

  00350	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegStNode$[ebp]
  00353	51		 push	 ecx
  00354	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00357	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0035a	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L69931:

; 1426 :                 }
; 1427 :             }
; 1428 :             else

  0035f	eb 1e		 jmp	 SHORT $L69928
$L69929:

; 1429 :             {
; 1430 :                 // move 2ndary segments to SecPastList
; 1431 :                 pList->Remove(pSegStNode);

  00361	8b 55 0c	 mov	 edx, DWORD PTR _pSegStNode$[ebp]
  00364	52		 push	 edx
  00365	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  00368	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 1432 :                 m_SegStateQueues[SQ_SEC_DONE].Insert(pSegStNode);

  0036d	8b 45 0c	 mov	 eax, DWORD PTR _pSegStNode$[ebp]
  00370	50		 push	 eax
  00371	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00374	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0037a	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L69928:

; 1433 :             }
; 1434 :             // if there aren't any more segments to play, send a Music Stopped
; 1435 :             // notification
; 1436 :             if( (m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
; 1437 :                 m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
; 1438 :                 m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty()))

  0037f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00382	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00385	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  0038a	85 c0		 test	 eax, eax
  0038c	74 68		 je	 SHORT $L69918
  0038e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00391	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00394	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  00399	85 c0		 test	 eax, eax
  0039b	74 59		 je	 SHORT $L69918
  0039d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  003a0	83 c1 44	 add	 ecx, 68			; 00000044H
  003a3	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003a8	85 c0		 test	 eax, eax
  003aa	74 4a		 je	 SHORT $L69918
  003ac	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  003af	83 c1 54	 add	 ecx, 84			; 00000054H
  003b2	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003b7	85 c0		 test	 eax, eax
  003b9	74 3b		 je	 SHORT $L69918
  003bb	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  003be	83 c1 64	 add	 ecx, 100		; 00000064H
  003c1	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003c6	85 c0		 test	 eax, eax
  003c8	74 2c		 je	 SHORT $L69918
  003ca	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  003cd	83 c1 4c	 add	 ecx, 76			; 0000004cH
  003d0	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003d5	85 c0		 test	 eax, eax
  003d7	74 1d		 je	 SHORT $L69918

; 1439 :             {
; 1440 :                 m_fMusicStopped = TRUE;

  003d9	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  003dc	c7 81 c8 03 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+968], 1

; 1441 :                 GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtEnd, NULL );

  003e6	6a 00		 push	 0
  003e8	8b 55 e8	 mov	 edx, DWORD PTR _mtEnd$69921[ebp]
  003eb	52		 push	 edx
  003ec	6a 01		 push	 1
  003ee	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  003f1	e8 00 00 00 00	 call	 ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ; CPerformance::GenerateNotification
$L69918:

; 1442 :             }
; 1443 :         }
; 1444 :         m_fInTransportThread = FALSE;

  003f6	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  003f9	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0
$L69885:

; 1445 :     }
; 1446 : }

  00403	8b e5		 mov	 esp, ebp
  00405	5d		 pop	 ebp
  00406	c2 08 00	 ret	 8
?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ENDP ; CPerformance::PerformSegStNode
_TEXT	ENDS
PUBLIC	?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ	; CPMsgQueue::GetHead
PUBLIC	?Transport@CPerformance@@AAEXPA_J@Z		; CPerformance::Transport
PUBLIC	?GetTime@CPerformance@@AAE_JXZ			; CPerformance::GetTime
PUBLIC	?GetNext@CSegState@@QAEPAV1@XZ			; CSegState::GetNext
PUBLIC	?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::QueuePrimarySegment
PUBLIC	?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::QueueSecondarySegment
PUBLIC	?IncrementTempoMap@CPerformance@@AAEXXZ		; CPerformance::IncrementTempoMap
EXTRN	?CheckPlay@CSegState@@QAEJJPAJ@Z:NEAR		; CSegState::CheckPlay
; Function compile flags: /Odt
;	COMDAT ?Transport@CPerformance@@AAEXPA_J@Z
_TEXT	SEGMENT
tv581 = -120
tv580 = -112
tv556 = -108
tv555 = -100
tv533 = -96
tv532 = -88
tv506 = -84
tv505 = -76
tv195 = -72
_this$ = -68
_fDirty$69958 = -64
_mtAmount$ = -60
_rtLatency$ = -56
_mtPlayTo$ = -44
_pNode$ = -40
_pTempQueue$ = -36
_rtPlayTo$ = -32
_rtNow$ = -24
_dwCount$ = -12
_pNext$ = -8
_mtResult$ = -4
_prtWakeUp$ = 8
?Transport@CPerformance@@AAEXPA_J@Z PROC NEAR		; CPerformance::Transport, COMDAT
; _this$ = ecx

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	56		 push	 esi
  00007	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 1494 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  0000a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1495 :     if (m_dwAudioPathMode == 0)

  00019	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 b9 08 01 00
	00 00		 cmp	 DWORD PTR [ecx+264], 0
  00023	75 24		 jne	 SHORT $L69943

; 1496 :     {
; 1497 :         Trace(1,"Error: Performance not initialized.\n");

  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  0002a	6a 01		 push	 1
  0002c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00031	83 c4 08	 add	 esp, 8

; 1498 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00034	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1499 :         return ;

  00044	e9 8c 06 00 00	 jmp	 $L69942
$L69943:

; 1500 :     }
; 1501 :     DWORD dwCount;
; 1502 :     CSegState*  pNode;
; 1503 :     CSegState*  pNext;
; 1504 :     CSegState*  pTempQueue = NULL;

  00049	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pTempQueue$[ebp], 0

; 1505 :     REFERENCE_TIME rtNow = GetTime();

  00050	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  00058	89 45 e8	 mov	 DWORD PTR _rtNow$[ebp], eax
  0005b	89 55 ec	 mov	 DWORD PTR _rtNow$[ebp+4], edx

; 1506 : 
; 1507 :     // Compute the time we should play all the segments to.
; 1508 :     REFERENCE_TIME rtPlayTo = rtNow + PREPARE_TIME;

  0005e	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 88 dc 02 00
	00		 mov	 ecx, DWORD PTR [eax+732]
  00067	69 c9 10 27 00
	00		 imul	 ecx, 10000		; 00002710H
  0006d	33 d2		 xor	 edx, edx
  0006f	8b 45 e8	 mov	 eax, DWORD PTR _rtNow$[ebp]
  00072	03 c1		 add	 eax, ecx
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _rtNow$[ebp+4]
  00077	13 ca		 adc	 ecx, edx
  00079	89 45 e0	 mov	 DWORD PTR _rtPlayTo$[ebp], eax
  0007c	89 4d e4	 mov	 DWORD PTR _rtPlayTo$[ebp+4], ecx

; 1509 :     MUSIC_TIME mtAmount, mtResult, mtPlayTo;
; 1510 :     mtPlayTo = 0;

  0007f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _mtPlayTo$[ebp], 0

; 1511 :     ReferenceToMusicTime( rtPlayTo, &mtPlayTo );

  00086	8d 55 d4	 lea	 edx, DWORD PTR _mtPlayTo$[ebp]
  00089	52		 push	 edx
  0008a	8b 45 e4	 mov	 eax, DWORD PTR _rtPlayTo$[ebp+4]
  0008d	50		 push	 eax
  0008e	8b 4d e0	 mov	 ecx, DWORD PTR _rtPlayTo$[ebp]
  00091	51		 push	 ecx
  00092	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00095	8b 02		 mov	 eax, DWORD PTR [edx]
  00097	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	51		 push	 ecx
  0009b	ff 50 18	 call	 DWORD PTR [eax+24]

; 1512 :     if (m_fTempoChanged)

  0009e	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	83 ba cc 03 00
	00 00		 cmp	 DWORD PTR [edx+972], 0
  000a8	74 2a		 je	 SHORT $L69953

; 1513 :     {
; 1514 :         // If there has been a tempo change to slower, any clock time tracks could
; 1515 :         // be delayed to long as the transport holds off sending out events. That's
; 1516 :         // okay for music time tracks, but bad news for clock time tracks. This
; 1517 :         // makes sure that the clock time tracks get a chance to spew.
; 1518 :         if (m_mtPlayTo >= mtPlayTo)

  000aa	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 88 d4 02 00
	00		 mov	 ecx, DWORD PTR [eax+724]
  000b3	3b 4d d4	 cmp	 ecx, DWORD PTR _mtPlayTo$[ebp]
  000b6	7c 0f		 jl	 SHORT $L69954

; 1519 :         {
; 1520 :             mtPlayTo = m_mtPlayTo + 10;

  000b8	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	8b 82 d4 02 00
	00		 mov	 eax, DWORD PTR [edx+724]
  000c1	83 c0 0a	 add	 eax, 10			; 0000000aH
  000c4	89 45 d4	 mov	 DWORD PTR _mtPlayTo$[ebp], eax
$L69954:

; 1521 :         }
; 1522 :         m_fTempoChanged = FALSE;

  000c7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	c7 81 cc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+972], 0
$L69953:

; 1523 :     }
; 1524 :     IncrementTempoMap();

  000d4	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?IncrementTempoMap@CPerformance@@AAEXXZ ; CPerformance::IncrementTempoMap
$L69956:

; 1525 :     while (m_mtPlayTo < mtPlayTo)

  000dc	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000df	8b 82 d4 02 00
	00		 mov	 eax, DWORD PTR [edx+724]
  000e5	3b 45 d4	 cmp	 eax, DWORD PTR _mtPlayTo$[ebp]
  000e8	0f 8d 2a 03 00
	00		 jge	 $L69957

; 1526 :     {
; 1527 :         BOOL fDirty = FALSE; // see below

  000ee	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _fDirty$69958[ebp], 0

; 1528 :         m_mtPlayTo = mtPlayTo; // Start out optimistic

  000f5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	8b 55 d4	 mov	 edx, DWORD PTR _mtPlayTo$[ebp]
  000fb	89 91 d4 02 00
	00		 mov	 DWORD PTR [ecx+724], edx

; 1529 :         // We need to set play boundaries at the end of control segments.
; 1530 :         // The beginnings of control segments are handled inside the segment state code.
; 1531 :         pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead();

  00101	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00107	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0010c	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax

; 1532 :         if( pNode && pNode->m_fStartedPlay )

  0010f	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00113	74 50		 je	 SHORT $L69959
  00115	8b 45 d8	 mov	 eax, DWORD PTR _pNode$[ebp]
  00118	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [eax+260], 0
  0011f	74 44		 je	 SHORT $L69959

; 1533 :         {
; 1534 :             mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;

  00121	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  00127	8b 81 d4 02 00
	00		 mov	 eax, DWORD PTR [ecx+724]
  0012d	2b 42 70	 sub	 eax, DWORD PTR [edx+112]
  00130	89 45 c4	 mov	 DWORD PTR _mtAmount$[ebp], eax

; 1535 :             pNode->CheckPlay( mtAmount, &mtResult );

  00133	8d 4d fc	 lea	 ecx, DWORD PTR _mtResult$[ebp]
  00136	51		 push	 ecx
  00137	8b 55 c4	 mov	 edx, DWORD PTR _mtAmount$[ebp]
  0013a	52		 push	 edx
  0013b	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0013e	e8 00 00 00 00	 call	 ?CheckPlay@CSegState@@QAEJJPAJ@Z ; CSegState::CheckPlay

; 1536 :             if( mtResult < mtAmount )

  00143	8b 45 fc	 mov	 eax, DWORD PTR _mtResult$[ebp]
  00146	3b 45 c4	 cmp	 eax, DWORD PTR _mtAmount$[ebp]
  00149	7d 1a		 jge	 SHORT $L69959

; 1537 :             {
; 1538 :                 m_mtPlayTo -= ( mtAmount - mtResult );

  0014b	8b 4d c4	 mov	 ecx, DWORD PTR _mtAmount$[ebp]
  0014e	2b 4d fc	 sub	 ecx, DWORD PTR _mtResult$[ebp]
  00151	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00154	8b 82 d4 02 00
	00		 mov	 eax, DWORD PTR [edx+724]
  0015a	2b c1		 sub	 eax, ecx
  0015c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	89 81 d4 02 00
	00		 mov	 DWORD PTR [ecx+724], eax
$L69959:

; 1539 :                 // don't need dirty flag when primary segment loops or ends normally (bug 30829)
; 1540 :                 // fDirty = TRUE; // see below 
; 1541 :             }
; 1542 :         }
; 1543 :         // if a control segment ended prematurely, mtPlayTo will have a value besides 0
; 1544 :         // check for upcoming endings to control segments
; 1545 :         for( pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pNode; pNode = pNode->GetNext() )

  00165	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	83 c1 64	 add	 ecx, 100		; 00000064H
  0016b	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00170	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
  00173	eb 0b		 jmp	 SHORT $L69961
$L69962:
  00175	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00178	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0017d	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
$L69961:
  00180	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00184	0f 84 8e 00 00
	00		 je	 $L69963

; 1546 :         {
; 1547 :             if( pNode->m_fStartedPlay )

  0018a	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  0018d	83 ba 04 01 00
	00 00		 cmp	 DWORD PTR [edx+260], 0
  00194	74 7d		 je	 SHORT $L69964

; 1548 :             {
; 1549 :                 if( pNode->m_mtStopTime && (m_mtPlayTo > pNode->m_mtStopTime) )

  00196	8b 45 d8	 mov	 eax, DWORD PTR _pNode$[ebp]
  00199	83 78 74 00	 cmp	 DWORD PTR [eax+116], 0
  0019d	74 29		 je	 SHORT $L69965
  0019f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  001a5	8b 81 d4 02 00
	00		 mov	 eax, DWORD PTR [ecx+724]
  001ab	3b 42 74	 cmp	 eax, DWORD PTR [edx+116]
  001ae	7e 18		 jle	 SHORT $L69965

; 1550 :                 {
; 1551 :                     m_mtPlayTo = pNode->m_mtStopTime;

  001b0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  001b6	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  001b9	89 81 d4 02 00
	00		 mov	 DWORD PTR [ecx+724], eax

; 1552 :                     fDirty = TRUE; // see below

  001bf	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _fDirty$69958[ebp], 1

; 1553 :                 }
; 1554 :                 else

  001c6	eb 4b		 jmp	 SHORT $L69964
$L69965:

; 1555 :                 {
; 1556 :                     mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;

  001c8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  001ce	8b 81 d4 02 00
	00		 mov	 eax, DWORD PTR [ecx+724]
  001d4	2b 42 70	 sub	 eax, DWORD PTR [edx+112]
  001d7	89 45 c4	 mov	 DWORD PTR _mtAmount$[ebp], eax

; 1557 :                     pNode->CheckPlay( mtAmount, &mtResult );

  001da	8d 4d fc	 lea	 ecx, DWORD PTR _mtResult$[ebp]
  001dd	51		 push	 ecx
  001de	8b 55 c4	 mov	 edx, DWORD PTR _mtAmount$[ebp]
  001e1	52		 push	 edx
  001e2	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  001e5	e8 00 00 00 00	 call	 ?CheckPlay@CSegState@@QAEJJPAJ@Z ; CSegState::CheckPlay

; 1558 :                     if( mtResult < mtAmount )

  001ea	8b 45 fc	 mov	 eax, DWORD PTR _mtResult$[ebp]
  001ed	3b 45 c4	 cmp	 eax, DWORD PTR _mtAmount$[ebp]
  001f0	7d 21		 jge	 SHORT $L69964

; 1559 :                     {
; 1560 :                         m_mtPlayTo -= ( mtAmount - mtResult );

  001f2	8b 4d c4	 mov	 ecx, DWORD PTR _mtAmount$[ebp]
  001f5	2b 4d fc	 sub	 ecx, DWORD PTR _mtResult$[ebp]
  001f8	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  001fb	8b 82 d4 02 00
	00		 mov	 eax, DWORD PTR [edx+724]
  00201	2b c1		 sub	 eax, ecx
  00203	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00206	89 81 d4 02 00
	00		 mov	 DWORD PTR [ecx+724], eax

; 1561 :                         fDirty = TRUE; // see below

  0020c	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _fDirty$69958[ebp], 1
$L69964:

; 1562 :                     }
; 1563 :                 }
; 1564 :             }
; 1565 :         }

  00213	e9 5d ff ff ff	 jmp	 $L69962
$L69963:

; 1566 :         // play the primary segment
; 1567 :         PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );

  00218	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0021e	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00223	50		 push	 eax
  00224	6a 03		 push	 3
  00226	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode
$L69969:

; 1568 :         // check to see if the next primary segment in the queue is ready to play
; 1569 :         while( (pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead()) && 
; 1570 :             (pNext = pNode->GetNext()) &&
; 1571 :             ( pNext->m_mtResolvedStart <= pNode->m_mtLastPlayed ) )

  0022e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00234	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00239	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
  0023c	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00240	0f 84 d5 00 00
	00		 je	 $L69970
  00246	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00249	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0024e	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax
  00251	83 7d f8 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00255	0f 84 c0 00 00
	00		 je	 $L69970
  0025b	8b 55 f8	 mov	 edx, DWORD PTR _pNext$[ebp]
  0025e	8b 45 d8	 mov	 eax, DWORD PTR _pNode$[ebp]
  00261	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  00264	3b 48 70	 cmp	 ecx, DWORD PTR [eax+112]
  00267	0f 8f ae 00 00
	00		 jg	 $L69970

; 1572 :         {
; 1573 :             // the next primary segment is indeed ready to begin playing.
; 1574 :             // save the old one in the primary past list so Tools can reference
; 1575 :             // it if they're looking for chord progressions and such.
; 1576 :             pNode->AbortPlay(pNext->m_mtResolvedStart-1,TRUE && (pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));

  0026d	ba 01 00 00 00	 mov	 edx, 1
  00272	85 d2		 test	 edx, edx
  00274	74 19		 je	 SHORT $L75280
  00276	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00279	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0027c	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00282	85 c9		 test	 ecx, ecx
  00284	74 09		 je	 SHORT $L75280
  00286	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv195[ebp], 1
  0028d	eb 07		 jmp	 SHORT $L75281
$L75280:
  0028f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv195[ebp], 0
$L75281:
  00296	8b 55 b8	 mov	 edx, DWORD PTR tv195[ebp]
  00299	52		 push	 edx
  0029a	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  0029d	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  002a0	83 e9 01	 sub	 ecx, 1
  002a3	51		 push	 ecx
  002a4	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  002a7	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 1577 :             m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());

  002ac	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002af	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002b2	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  002b7	50		 push	 eax
  002b8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bb	83 c1 74	 add	 ecx, 116		; 00000074H
  002be	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 1578 :             ManageControllingTracks();

  002c3	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c6	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks

; 1579 :             // we need to flush primary events after the new start time
; 1580 :             if(!( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_dwPlaySegFlags & 
; 1581 :                 (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))

  002cb	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ce	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002d1	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002d6	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  002d9	81 e2 00 80 00
	10		 and	 edx, 268468224		; 10008000H
  002df	85 d2		 test	 edx, edx
  002e1	75 1d		 jne	 SHORT $L69971

; 1582 :             {
; 1583 :                 Invalidate( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart, 0 );

  002e3	6a 00		 push	 0
  002e5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002eb	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002f0	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  002f3	50		 push	 eax
  002f4	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f7	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f9	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  002fc	50		 push	 eax
  002fd	ff 52 68	 call	 DWORD PTR [edx+104]
$L69971:

; 1584 :             }
; 1585 :             // and play the new segment
; 1586 :             PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead());

  00300	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00303	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00306	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0030b	50		 push	 eax
  0030c	6a 03		 push	 3
  0030e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00311	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode

; 1587 :         }

  00316	e9 13 ff ff ff	 jmp	 $L69969
$L69970:

; 1588 :         // play the controlling segments
; 1589 :         pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();

  0031b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031e	83 c1 64	 add	 ecx, 100		; 00000064H
  00321	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00326	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax

; 1590 :         pNext = NULL;

  00329	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0

; 1591 :         for(; pNode != NULL; pNode = pNext)

  00330	eb 06		 jmp	 SHORT $L69972
$L69973:
  00332	8b 4d f8	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00335	89 4d d8	 mov	 DWORD PTR _pNode$[ebp], ecx
$L69972:
  00338	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  0033c	74 1b		 je	 SHORT $L69974

; 1592 :         {
; 1593 :             pNext = pNode->GetNext();

  0033e	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00341	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00346	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax

; 1594 :             PerformSegStNode(SQ_CON_PLAY,pNode );

  00349	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  0034c	52		 push	 edx
  0034d	6a 04		 push	 4
  0034f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00352	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode

; 1595 :         }

  00357	eb d9		 jmp	 SHORT $L69973
$L69974:

; 1596 :         // play the secondary segments
; 1597 :         pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();

  00359	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0035f	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00364	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax

; 1598 :         pNext = NULL;

  00367	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0

; 1599 :         for(; pNode != NULL; pNode = pNext)

  0036e	eb 06		 jmp	 SHORT $L69975
$L69976:
  00370	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00373	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
$L69975:
  00376	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  0037a	74 1b		 je	 SHORT $L69977

; 1600 :         {
; 1601 :             pNext = pNode->GetNext();

  0037c	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0037f	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00384	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax

; 1602 :             PerformSegStNode( SQ_SEC_PLAY,pNode );

  00387	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0038a	51		 push	 ecx
  0038b	6a 05		 push	 5
  0038d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00390	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode

; 1603 :         }

  00395	eb d9		 jmp	 SHORT $L69976
$L69977:

; 1604 : 
; 1605 :         // if we set fDirty above, it means that we truncated the playback of a control
; 1606 :         // segment because of a loop or end condition. Therefore, we want all segments
; 1607 :         // to set the DMUS_TRACKF_DIRTY flag on the next play cycle.
; 1608 :         if( fDirty )

  00397	83 7d c0 00	 cmp	 DWORD PTR _fDirty$69958[ebp], 0
  0039b	74 64		 je	 SHORT $L69978

; 1609 :         {
; 1610 :             for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)

  0039d	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 3
  003a4	eb 09		 jmp	 SHORT $L69979
$L69980:
  003a6	8b 55 f4	 mov	 edx, DWORD PTR _dwCount$[ebp]
  003a9	83 c2 01	 add	 edx, 1
  003ac	89 55 f4	 mov	 DWORD PTR _dwCount$[ebp], edx
$L69979:
  003af	83 7d f4 05	 cmp	 DWORD PTR _dwCount$[ebp], 5
  003b3	77 44		 ja	 SHORT $L69981

; 1611 :             {
; 1612 :                 for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  003b5	8b 45 f4	 mov	 eax, DWORD PTR _dwCount$[ebp]
  003b8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003bb	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  003bf	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  003c4	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
  003c7	eb 0b		 jmp	 SHORT $L69982
$L69983:
  003c9	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  003cc	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  003d1	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
$L69982:
  003d4	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  003d8	74 1d		 je	 SHORT $L69984

; 1613 :                 {
; 1614 :                     if( pNode->m_fStartedPlay )

  003da	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  003dd	83 ba 04 01 00
	00 00		 cmp	 DWORD PTR [edx+260], 0
  003e4	74 0f		 je	 SHORT $L69985

; 1615 :                     {
; 1616 :                         pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;

  003e6	8b 45 d8	 mov	 eax, DWORD PTR _pNode$[ebp]
  003e9	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  003ec	83 c9 10	 or	 ecx, 16			; 00000010H
  003ef	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  003f2	89 4a 58	 mov	 DWORD PTR [edx+88], ecx
$L69985:

; 1617 :                     }
; 1618 :                 }

  003f5	eb d2		 jmp	 SHORT $L69983
$L69984:

; 1619 :             }

  003f7	eb ad		 jmp	 SHORT $L69980
$L69981:

; 1620 :             ManageControllingTracks();

  003f9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fc	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks
$L69978:

; 1621 :         }
; 1622 :         m_mtTransported = m_mtPlayTo;

  00401	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00404	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00407	8b 91 d4 02 00
	00		 mov	 edx, DWORD PTR [ecx+724]
  0040d	89 90 d0 02 00
	00		 mov	 DWORD PTR [eax+720], edx

; 1623 : 
; 1624 :     }

  00413	e9 c4 fc ff ff	 jmp	 $L69956
$L69957:

; 1625 : 
; 1626 :     // check segments queued in ref-time to see if it's time for them to
; 1627 :     // play. Add some extra time just in case. We'll bet that a tempo pmsg won't come
; 1628 :     // in in the intervening 200 ms.
; 1629 :     REFERENCE_TIME rtLatency = GetLatencyWithPrePlay();

  00418	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0041b	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00420	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00423	03 81 c8 02 00
	00		 add	 eax, DWORD PTR [ecx+712]
  00429	13 91 cc 02 00
	00		 adc	 edx, DWORD PTR [ecx+716]
  0042f	89 45 c8	 mov	 DWORD PTR _rtLatency$[ebp], eax
  00432	89 55 cc	 mov	 DWORD PTR _rtLatency$[ebp+4], edx

; 1630 :     for (dwCount = SQ_PRI_WAIT;dwCount <= SQ_SEC_WAIT; dwCount++)

  00435	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  0043c	eb 09		 jmp	 SHORT $L69987
$L69988:
  0043e	8b 55 f4	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00441	83 c2 01	 add	 edx, 1
  00444	89 55 f4	 mov	 DWORD PTR _dwCount$[ebp], edx
$L69987:
  00447	83 7d f4 02	 cmp	 DWORD PTR _dwCount$[ebp], 2
  0044b	0f 87 aa 00 00
	00		 ja	 $L69989
$L69991:

; 1631 :     {
; 1632 :         while( pNode = m_SegStateQueues[dwCount].GetHead() )

  00451	8b 45 f4	 mov	 eax, DWORD PTR _dwCount$[ebp]
  00454	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00457	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  0045b	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00460	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
  00463	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00467	0f 84 89 00 00
	00		 je	 $L69992

; 1633 :         {
; 1634 :             if( pNode->m_rtGivenStart > (rtLatency + PREPARE_TIME + (200 * REF_PER_MIL) ))

  0046d	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00470	8b 82 dc 02 00
	00		 mov	 eax, DWORD PTR [edx+732]
  00476	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  0047c	33 c9		 xor	 ecx, ecx
  0047e	8b 55 c8	 mov	 edx, DWORD PTR _rtLatency$[ebp]
  00481	03 d0		 add	 edx, eax
  00483	8b 45 cc	 mov	 eax, DWORD PTR _rtLatency$[ebp+4]
  00486	13 c1		 adc	 eax, ecx
  00488	81 c2 80 84 1e
	00		 add	 edx, 2000000		; 001e8480H
  0048e	83 d0 00	 adc	 eax, 0
  00491	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00494	89 4d b4	 mov	 DWORD PTR tv505[ebp], ecx
  00497	89 55 ac	 mov	 DWORD PTR tv506[ebp], edx
  0049a	89 45 b0	 mov	 DWORD PTR tv506[ebp+4], eax
  0049d	8b 55 b4	 mov	 edx, DWORD PTR tv505[ebp]
  004a0	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  004a6	3b 45 b0	 cmp	 eax, DWORD PTR tv506[ebp+4]
  004a9	7c 12		 jl	 SHORT $L69993
  004ab	7f 0e		 jg	 SHORT $L75282
  004ad	8b 4d b4	 mov	 ecx, DWORD PTR tv505[ebp]
  004b0	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  004b6	3b 55 ac	 cmp	 edx, DWORD PTR tv506[ebp]
  004b9	76 02		 jbe	 SHORT $L69993
$L75282:

; 1635 :             {
; 1636 :                 // it's not yet time to handle this one
; 1637 :                 break;

  004bb	eb 39		 jmp	 SHORT $L69992
$L69993:

; 1638 :             }
; 1639 :             if (dwCount == SQ_PRI_WAIT)

  004bd	83 7d f4 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  004c1	75 16		 jne	 SHORT $L69994

; 1640 :             {
; 1641 :                 QueuePrimarySegment( m_SegStateQueues[SQ_PRI_WAIT].RemoveHead());

  004c3	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c6	83 c1 44	 add	 ecx, 68			; 00000044H
  004c9	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  004ce	50		 push	 eax
  004cf	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  004d2	e8 00 00 00 00	 call	 ?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::QueuePrimarySegment

; 1642 :             }
; 1643 :             else

  004d7	eb 18		 jmp	 SHORT $L69995
$L69994:

; 1644 :             {
; 1645 :                 QueueSecondarySegment( m_SegStateQueues[dwCount].RemoveHead());

  004d9	8b 45 f4	 mov	 eax, DWORD PTR _dwCount$[ebp]
  004dc	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  004df	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  004e3	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  004e8	50		 push	 eax
  004e9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ec	e8 00 00 00 00	 call	 ?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::QueueSecondarySegment
$L69995:

; 1646 :             }
; 1647 :         }

  004f1	e9 5b ff ff ff	 jmp	 $L69991
$L69992:

; 1648 :     }

  004f6	e9 43 ff ff ff	 jmp	 $L69988
$L69989:

; 1649 : 
; 1650 :     // Check to see if Segments in the done queues
; 1651 :     // can be released. They can be released if their
; 1652 :     // final play times are older than the current time.
; 1653 :     for (dwCount = SQ_PRI_DONE;dwCount <= SQ_SEC_DONE; dwCount++)

  004fb	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 6
  00502	eb 09		 jmp	 SHORT $L69996
$L69997:
  00504	8b 55 f4	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00507	83 c2 01	 add	 edx, 1
  0050a	89 55 f4	 mov	 DWORD PTR _dwCount$[ebp], edx
$L69996:
  0050d	83 7d f4 08	 cmp	 DWORD PTR _dwCount$[ebp], 8
  00511	0f 87 85 00 00
	00		 ja	 $L69998

; 1654 :     {
; 1655 :         for (pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode = pNext)

  00517	8b 45 f4	 mov	 eax, DWORD PTR _dwCount$[ebp]
  0051a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0051d	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  00521	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00526	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
  00529	eb 06		 jmp	 SHORT $L69999
$L70000:
  0052b	8b 55 f8	 mov	 edx, DWORD PTR _pNext$[ebp]
  0052e	89 55 d8	 mov	 DWORD PTR _pNode$[ebp], edx
$L69999:
  00531	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00535	74 60		 je	 SHORT $L70001

; 1656 :         {
; 1657 :             pNext = pNode->GetNext();

  00537	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0053a	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0053f	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax

; 1658 :             if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second

  00542	8b 45 e8	 mov	 eax, DWORD PTR _rtNow$[ebp]
  00545	2d 80 96 98 00	 sub	 eax, 10000000		; 00989680H
  0054a	8b 4d ec	 mov	 ecx, DWORD PTR _rtNow$[ebp+4]
  0054d	83 d9 00	 sbb	 ecx, 0
  00550	8b 55 d8	 mov	 edx, DWORD PTR _pNode$[ebp]
  00553	89 55 a8	 mov	 DWORD PTR tv532[ebp], edx
  00556	89 45 a0	 mov	 DWORD PTR tv533[ebp], eax
  00559	89 4d a4	 mov	 DWORD PTR tv533[ebp+4], ecx
  0055c	8b 45 a8	 mov	 eax, DWORD PTR tv532[ebp]
  0055f	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00565	3b 4d a4	 cmp	 ecx, DWORD PTR tv533[ebp+4]
  00568	7f 2b		 jg	 SHORT $L70002
  0056a	7c 0e		 jl	 SHORT $L75283
  0056c	8b 55 a8	 mov	 edx, DWORD PTR tv532[ebp]
  0056f	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00575	3b 45 a0	 cmp	 eax, DWORD PTR tv533[ebp]
  00578	73 1b		 jae	 SHORT $L70002
$L75283:

; 1659 :             {
; 1660 :                 m_SegStateQueues[dwCount].Remove(pNode);

  0057a	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0057d	51		 push	 ecx
  0057e	8b 55 f4	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00581	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00584	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  00588	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 1661 :                 pNode->ShutDown();

  0058d	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00590	e8 00 00 00 00	 call	 ?ShutDown@CSegState@@QAEJXZ ; CSegState::ShutDown
$L70002:

; 1662 :             }
; 1663 :         }

  00595	eb 94		 jmp	 SHORT $L70000
$L70001:

; 1664 :     }

  00597	e9 68 ff ff ff	 jmp	 $L69997
$L69998:

; 1665 :     for (pNode = m_ShutDownQueue.GetHead();pNode;pNode = pNext)

  0059c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0059f	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  005a5	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  005aa	89 45 d8	 mov	 DWORD PTR _pNode$[ebp], eax
  005ad	eb 06		 jmp	 SHORT $L70003
$L70004:
  005af	8b 4d f8	 mov	 ecx, DWORD PTR _pNext$[ebp]
  005b2	89 4d d8	 mov	 DWORD PTR _pNode$[ebp], ecx
$L70003:
  005b5	83 7d d8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  005b9	74 60		 je	 SHORT $L70005

; 1666 :     {
; 1667 :         pNext = pNode->GetNext();

  005bb	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  005be	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  005c3	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax

; 1668 :         if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second

  005c6	8b 55 e8	 mov	 edx, DWORD PTR _rtNow$[ebp]
  005c9	81 ea 80 96 98
	00		 sub	 edx, 10000000		; 00989680H
  005cf	8b 45 ec	 mov	 eax, DWORD PTR _rtNow$[ebp+4]
  005d2	83 d8 00	 sbb	 eax, 0
  005d5	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  005d8	89 4d 9c	 mov	 DWORD PTR tv555[ebp], ecx
  005db	89 55 94	 mov	 DWORD PTR tv556[ebp], edx
  005de	89 45 98	 mov	 DWORD PTR tv556[ebp+4], eax
  005e1	8b 55 9c	 mov	 edx, DWORD PTR tv555[ebp]
  005e4	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  005ea	3b 45 98	 cmp	 eax, DWORD PTR tv556[ebp+4]
  005ed	7f 2a		 jg	 SHORT $L70006
  005ef	7c 0e		 jl	 SHORT $L75284
  005f1	8b 4d 9c	 mov	 ecx, DWORD PTR tv555[ebp]
  005f4	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  005fa	3b 55 94	 cmp	 edx, DWORD PTR tv556[ebp]
  005fd	73 1a		 jae	 SHORT $L70006
$L75284:

; 1669 :         {
; 1670 :             m_ShutDownQueue.Remove(pNode);

  005ff	8b 45 d8	 mov	 eax, DWORD PTR _pNode$[ebp]
  00602	50		 push	 eax
  00603	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00606	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0060c	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 1671 :             pNode->ShutDown();

  00611	8b 4d d8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00614	e8 00 00 00 00	 call	 ?ShutDown@CSegState@@QAEJXZ ; CSegState::ShutDown
$L70006:

; 1672 :         }
; 1673 :     }

  00619	eb 94		 jmp	 SHORT $L70004
$L70005:

; 1674 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0061b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0061e	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00624	51		 push	 ecx
  00625	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1675 : 
; 1676 :     // check to see if there are old notifications that haven't been
; 1677 :     // retrieved by the application and need to be removed.
; 1678 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0062b	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  0062e	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  00634	52		 push	 edx
  00635	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4
$L70008:

; 1679 :     while( m_NotificationQueue.GetHead() )

  0063b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0063e	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00644	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00649	85 c0		 test	 eax, eax
  0064b	74 61		 je	 SHORT $L70009

; 1680 :     {
; 1681 :         if( m_NotificationQueue.GetHead()->rtTime < 
; 1682 :             (rtNow - m_rtNotificationDiscard) )

  0064d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00650	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00656	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  0065b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0065e	8b 55 e8	 mov	 edx, DWORD PTR _rtNow$[ebp]
  00661	2b 91 f8 00 00
	00		 sub	 edx, DWORD PTR [ecx+248]
  00667	8b 75 ec	 mov	 esi, DWORD PTR _rtNow$[ebp+4]
  0066a	1b b1 fc 00 00
	00		 sbb	 esi, DWORD PTR [ecx+252]
  00670	89 45 90	 mov	 DWORD PTR tv580[ebp], eax
  00673	89 55 88	 mov	 DWORD PTR tv581[ebp], edx
  00676	89 75 8c	 mov	 DWORD PTR tv581[ebp+4], esi
  00679	8b 45 90	 mov	 eax, DWORD PTR tv580[ebp]
  0067c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0067f	3b 4d 8c	 cmp	 ecx, DWORD PTR tv581[ebp+4]
  00682	7f 26		 jg	 SHORT $L70010
  00684	7c 0b		 jl	 SHORT $L75285
  00686	8b 55 90	 mov	 edx, DWORD PTR tv580[ebp]
  00689	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0068c	3b 45 88	 cmp	 eax, DWORD PTR tv581[ebp]
  0068f	73 19		 jae	 SHORT $L70010
$L75285:

; 1683 :         {
; 1684 :             FreePMsg(m_NotificationQueue.Dequeue());

  00691	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00694	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0069a	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  0069f	50		 push	 eax
  006a0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a3	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 1685 :         }
; 1686 :         else

  006a8	eb 02		 jmp	 SHORT $L70011
$L70010:

; 1687 :         {
; 1688 :             break;

  006aa	eb 02		 jmp	 SHORT $L70009
$L70011:

; 1689 :         }
; 1690 :     }

  006ac	eb 8d		 jmp	 SHORT $L70008
$L70009:

; 1691 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  006ae	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006b1	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  006b7	51		 push	 ecx
  006b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1692 :     *prtWakeUp = rtPlayTo + TRANSPORT_RES * 10000;

  006be	8b 55 e0	 mov	 edx, DWORD PTR _rtPlayTo$[ebp]
  006c1	81 c2 40 42 0f
	00		 add	 edx, 1000000		; 000f4240H
  006c7	8b 45 e4	 mov	 eax, DWORD PTR _rtPlayTo$[ebp+4]
  006ca	83 d0 00	 adc	 eax, 0
  006cd	8b 4d 08	 mov	 ecx, DWORD PTR _prtWakeUp$[ebp]
  006d0	89 11		 mov	 DWORD PTR [ecx], edx
  006d2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L69942:

; 1693 : }

  006d5	5e		 pop	 esi
  006d6	8b e5		 mov	 esp, ebp
  006d8	5d		 pop	 ebp
  006d9	c2 04 00	 ret	 4
?Transport@CPerformance@@AAEXPA_J@Z ENDP		; CPerformance::Transport
_TEXT	ENDS
PUBLIC	??_C@_0DG@PHPGNDLB@m_OnTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFlags@ ; `string'
PUBLIC	??_C@_0DI@KAECAIIH@m_NearTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFla@ ; `string'
EXTRN	__allshr:NEAR
;	COMDAT ??_C@_0DG@PHPGNDLB@m_OnTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFlags@
CONST	SEGMENT
??_C@_0DG@PHPGNDLB@m_OnTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFlags@ DB 'm_OnT'
	DB	'imeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KAECAIIH@m_NearTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFla@
CONST	SEGMENT
??_C@_0DI@KAECAIIH@m_NearTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFla@ DB 'm_Nea'
	DB	'rTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetNextPMsg@CPerformance@@AAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT
tv214 = -28
tv213 = -20
tv181 = -16
_this$ = -8
_pEvent$ = -4
?GetNextPMsg@CPerformance@@AAEPAUPRIV_PMSG@@XZ PROC NEAR ; CPerformance::GetNextPMsg, COMDAT
; _this$ = ecx

; 1708 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1709 : #ifdef DBG_PROFILE
; 1710 :     DWORD dwDebugTime;
; 1711 :     dwDebugTime = timeGetTime();
; 1712 : #endif
; 1713 :     PRIV_PMSG* pEvent = NULL;

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pEvent$[ebp], 0

; 1714 : 
; 1715 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	05 30 03 00 00	 add	 eax, 816		; 00000330H
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1716 :     if (m_OnTimeQueue.GetHead())

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  0002a	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  0002f	85 c0		 test	 eax, eax
  00031	74 76		 je	 SHORT $L70016

; 1717 :     {
; 1718 :         ASSERT( m_OnTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  0003c	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00041	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00044	83 e1 01	 and	 ecx, 1
  00047	85 c9		 test	 ecx, ecx
  00049	75 17		 jne	 SHORT $L70017
  0004b	6a 00		 push	 0
  0004d	68 b6 06 00 00	 push	 1718			; 000006b6H
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@PHPGNDLB@m_OnTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFlags@
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70017:

; 1719 :         if ( m_OnTimeQueue.GetHead()->rtTime - GetTime() <= 0 )

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  0006b	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00070	8b f0		 mov	 esi, eax
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  0007a	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0007d	2b c8		 sub	 ecx, eax
  0007f	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00082	1b c2		 sbb	 eax, edx
  00084	89 4d f0	 mov	 DWORD PTR tv181[ebp], ecx
  00087	89 45 f4	 mov	 DWORD PTR tv181[ebp+4], eax
  0008a	83 7d f4 00	 cmp	 DWORD PTR tv181[ebp+4], 0
  0008e	7f 19		 jg	 SHORT $L70016
  00090	7c 06		 jl	 SHORT $L75289
  00092	83 7d f0 00	 cmp	 DWORD PTR tv181[ebp], 0
  00096	77 11		 ja	 SHORT $L70016
$L75289:

; 1720 :         {
; 1721 :             pEvent = m_OnTimeQueue.Dequeue();

  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  000a1	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  000a6	89 45 fc	 mov	 DWORD PTR _pEvent$[ebp], eax
$L70016:

; 1722 :         }
; 1723 :     }
; 1724 :     if( !pEvent )

  000a9	83 7d fc 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  000ad	0f 85 e5 00 00
	00		 jne	 $L70020

; 1725 :     {
; 1726 :         if (m_NearTimeQueue.GetHead())

  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  000bc	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 9a 00 00
	00		 je	 $L70021

; 1727 :         {
; 1728 :             ASSERT( m_NearTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );

  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  000d2	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  000d7	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000da	83 e1 01	 and	 ecx, 1
  000dd	85 c9		 test	 ecx, ecx
  000df	75 17		 jne	 SHORT $L70022
  000e1	6a 00		 push	 0
  000e3	68 c0 06 00 00	 push	 1728			; 000006c0H
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  000ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@KAECAIIH@m_NearTimeQueue?4GetHead?$CI?$CJ?9?$DOdwFla@
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70022:

; 1729 :             if ( m_NearTimeQueue.GetHead()->rtTime < (m_rtQueuePosition + (m_rtBumperLength >> 1)))

  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00101	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00106	8b f0		 mov	 esi, eax
  00108	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010b	8b 82 c8 02 00
	00		 mov	 eax, DWORD PTR [edx+712]
  00111	8b 92 cc 02 00
	00		 mov	 edx, DWORD PTR [edx+716]
  00117	b1 01		 mov	 cl, 1
  00119	e8 00 00 00 00	 call	 __allshr
  0011e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8b b9 b8 02 00
	00		 mov	 edi, DWORD PTR [ecx+696]
  00127	03 f8		 add	 edi, eax
  00129	8b 81 bc 02 00
	00		 mov	 eax, DWORD PTR [ecx+700]
  0012f	13 c2		 adc	 eax, edx
  00131	89 75 ec	 mov	 DWORD PTR tv213[ebp], esi
  00134	89 7d e4	 mov	 DWORD PTR tv214[ebp], edi
  00137	89 45 e8	 mov	 DWORD PTR tv214[ebp+4], eax
  0013a	8b 4d ec	 mov	 ecx, DWORD PTR tv213[ebp]
  0013d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00140	3b 55 e8	 cmp	 edx, DWORD PTR tv214[ebp+4]
  00143	7f 1e		 jg	 SHORT $L70021
  00145	7c 0b		 jl	 SHORT $L75291
  00147	8b 45 ec	 mov	 eax, DWORD PTR tv213[ebp]
  0014a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0014d	3b 4d e4	 cmp	 ecx, DWORD PTR tv214[ebp]
  00150	73 11		 jae	 SHORT $L70021
$L75291:

; 1730 :             {
; 1731 :                 pEvent = m_NearTimeQueue.Dequeue();

  00152	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  0015b	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00160	89 45 fc	 mov	 DWORD PTR _pEvent$[ebp], eax
$L70021:

; 1732 :             }
; 1733 :         }
; 1734 :         if( !pEvent && !m_fInTransportThread)

  00163	83 7d fc 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  00167	75 2f		 jne	 SHORT $L70020
  00169	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0016c	83 ba 0c 01 00
	00 00		 cmp	 DWORD PTR [edx+268], 0
  00173	75 23		 jne	 SHORT $L70020

; 1735 :         {
; 1736 :             if (m_EarlyQueue.GetHead())

  00175	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0017e	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00183	85 c0		 test	 eax, eax
  00185	74 11		 je	 SHORT $L70020

; 1737 :             {
; 1738 :                 pEvent = m_EarlyQueue.Dequeue();

  00187	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00190	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00195	89 45 fc	 mov	 DWORD PTR _pEvent$[ebp], eax
$L70020:

; 1739 :             }
; 1740 :         }
; 1741 :     }
; 1742 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00198	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	05 30 03 00 00	 add	 eax, 816		; 00000330H
  001a0	50		 push	 eax
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1743 : #ifdef DBG_PROFILE
; 1744 :     dwDebugTime = timeGetTime() - dwDebugTime;
; 1745 :     if( dwDebugTime > 1 )
; 1746 :     {
; 1747 :         TraceI(5, "Hall, debugtime GetNextPMsg %u\n", dwDebugTime);
; 1748 :     }
; 1749 : #endif
; 1750 : 
; 1751 :     return pEvent;

  001a7	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]

; 1752 : }

  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
?GetNextPMsg@CPerformance@@AAEPAUPRIV_PMSG@@XZ ENDP	; CPerformance::GetNextPMsg
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ProcessEarlyPMsgs@CPerformance@@AAEXXZ
_TEXT	SEGMENT
tv83 = -16
_this$ = -12
_hr$70041 = -8
_pEvent$ = -4
?ProcessEarlyPMsgs@CPerformance@@AAEXXZ PROC NEAR	; CPerformance::ProcessEarlyPMsgs, COMDAT
; _this$ = ecx

; 1772 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L70032:

; 1773 :     PRIV_PMSG* pEvent;
; 1774 : 
; 1775 : #ifdef XBOX
; 1776 :     while (1)

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	0f 84 3b 01 00
	00		 je	 $L70029

; 1777 : #else
; 1778 :     //  Exit if the thread is exiting.  If we don't test here
; 1779 :     //  we can actually loop forever because tools and queue more
; 1780 :     //  early PMSGs (the Echo tool does this)
; 1781 :     while (!m_fKillThread)
; 1782 : #endif
; 1783 :     {
; 1784 :         ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00016	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1785 :         pEvent = m_EarlyQueue.Dequeue();

  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0002f	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00034	89 45 fc	 mov	 DWORD PTR _pEvent$[ebp], eax

; 1786 :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00037	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  00040	52		 push	 edx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1787 :         if (!pEvent) break; // Done?

  00047	83 7d fc 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0004b	75 05		 jne	 SHORT $L70034
  0004d	e9 ff 00 00 00	 jmp	 $L70029
$L70034:

; 1788 :         ASSERT( pEvent->pNext == NULL );

  00052	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00055	83 38 00	 cmp	 DWORD PTR [eax], 0
  00058	74 17		 je	 SHORT $L70035
  0005a	6a 00		 push	 0
  0005c	68 fc 06 00 00	 push	 1788			; 000006fcH
  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@MHOFNGKM@pEvent?9?$DOpNext?5?$DN?$DN?5NULL?$AA@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70035:

; 1789 :         if( !pEvent->pTool )

  00071	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00074	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00078	75 60		 jne	 SHORT $L70036

; 1790 :         {
; 1791 :             // this event doesn't have a Tool pointer, so stamp it with the
; 1792 :             // final output Tool.
; 1793 :             pEvent->pTool = (IDirectMusicTool*)this;

  0007a	83 7d f4 00	 cmp	 DWORD PTR _this$[ebp], 0
  0007e	74 0b		 je	 SHORT $L75295
  00080	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00083	83 c2 04	 add	 edx, 4
  00086	89 55 f0	 mov	 DWORD PTR tv83[ebp], edx
  00089	eb 07		 jmp	 SHORT $L75296
$L75295:
  0008b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$L75296:
  00092	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00095	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00098	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 1794 :             AddRef();

  0009b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	51		 push	 ecx
  000a4	ff 50 04	 call	 DWORD PTR [eax+4]

; 1795 :             // Don't process it. Instead, send to neartime queue so
; 1796 :             // realtime thread will deal with it.
; 1797 :             pEvent->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);

  000a7	8b 55 fc	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000aa	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000ad	83 e0 e3	 and	 eax, -29		; ffffffe3H
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  000b3	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 1798 :             pEvent->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000b9	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000bc	83 c8 08	 or	 eax, 8
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  000c2	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 1799 :             SendPMsg( PRIV_TO_DMUS(pEvent) );

  000c5	8b 55 fc	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000c8	83 c2 18	 add	 edx, 24			; 00000018H
  000cb	52		 push	 edx
  000cc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	52		 push	 edx
  000d5	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1800 :         }
; 1801 :         else

  000d8	eb 72		 jmp	 SHORT $L70040
$L70036:

; 1802 :         {
; 1803 :             // before processing the event, set rtLast to the event's current time
; 1804 :             pEvent->rtLast = pEvent->rtTime;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  000e0	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000e3	89 50 10	 mov	 DWORD PTR [eax+16], edx
  000e6	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  000e9	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1805 : 
; 1806 :             HRESULT hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );

  000ec	8b 55 fc	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000ef	83 c2 18	 add	 edx, 24			; 00000018H
  000f2	52		 push	 edx
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	50		 push	 eax
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  000fa	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000fd	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00100	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00103	8b 12		 mov	 edx, DWORD PTR [edx]
  00105	51		 push	 ecx
  00106	ff 52 1c	 call	 DWORD PTR [edx+28]
  00109	89 45 f8	 mov	 DWORD PTR _hr$70041[ebp], eax

; 1807 :             if( hr != S_OK ) // S_OK means do nothing

  0010c	83 7d f8 00	 cmp	 DWORD PTR _hr$70041[ebp], 0
  00110	74 3a		 je	 SHORT $L70040

; 1808 :             {
; 1809 :                 if( hr == DMUS_S_REQUEUE )

  00112	81 7d f8 00 12
	78 08		 cmp	 DWORD PTR _hr$70041[ebp], 142086656 ; 08781200H
  00119	75 25		 jne	 SHORT $L70050

; 1810 :                 {
; 1811 :                     if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0011e	83 c0 18	 add	 eax, 24			; 00000018H
  00121	50		 push	 eax
  00122	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	8b 11		 mov	 edx, DWORD PTR [ecx]
  00127	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0012a	50		 push	 eax
  0012b	ff 52 10	 call	 DWORD PTR [edx+16]
  0012e	85 c0		 test	 eax, eax
  00130	7d 0c		 jge	 SHORT $L70054

; 1812 :                     {
; 1813 :                         FreePMsg(pEvent);

  00132	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00135	51		 push	 ecx
  00136	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L70054:

; 1814 :                     }
; 1815 :                 }
; 1816 :                 else // e.g. DMUS_S_FREE or error code

  0013e	eb 0c		 jmp	 SHORT $L70040
$L70050:

; 1817 :                 {
; 1818 :                     FreePMsg( pEvent );

  00140	8b 55 fc	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00143	52		 push	 edx
  00144	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L70040:

; 1819 :                 }
; 1820 :             }
; 1821 :         }
; 1822 :     }

  0014c	e9 b8 fe ff ff	 jmp	 $L70032
$L70029:

; 1823 : }

  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
?ProcessEarlyPMsgs@CPerformance@@AAEXXZ ENDP		; CPerformance::ProcessEarlyPMsgs
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetTime@CPerformance@@AAE_JXZ
_TEXT	SEGMENT
_this$ = -24
_dwTime$ = -20
_rtCurrent$ = -16
_w$ = -4
?GetTime@CPerformance@@AAE_JXZ PROC NEAR		; CPerformance::GetTime, COMDAT
; _this$ = ecx

; 1826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1827 :     DWORD dwTime;
; 1828 :     REFERENCE_TIME rtCurrent;
; 1829 :     WORD    w;
; 1830 : 
; 1831 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1832 :     if( !m_pClock || ( m_pClock && FAILED( m_pClock->GetTime( &rtCurrent ) ) ) )

  00018	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0001f	74 27		 je	 SHORT $L70064
  00021	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00024	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00028	0f 84 90 00 00
	00		 je	 $L70063
  0002e	8d 45 f0	 lea	 eax, DWORD PTR _rtCurrent$[ebp]
  00031	50		 push	 eax
  00032	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00038	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0003e	8b 12		 mov	 edx, DWORD PTR [edx]
  00040	51		 push	 ecx
  00041	ff 52 0c	 call	 DWORD PTR [edx+12]
  00044	85 c0		 test	 eax, eax
  00046	7d 76		 jge	 SHORT $L70063
$L70064:

; 1833 :     {
; 1834 :         // this only gets called with machines that don't support m_pClock
; 1835 :         dwTime = timeGetTime();

  00048	e8 00 00 00 00	 call	 _GetTickCount@0
  0004d	89 45 ec	 mov	 DWORD PTR _dwTime$[ebp], eax

; 1836 :         rtCurrent = dwTime * 10; // 100 ns increments

  00050	8b 45 ec	 mov	 eax, DWORD PTR _dwTime$[ebp]
  00053	6b c0 0a	 imul	 eax, 10			; 0000000aH
  00056	33 c9		 xor	 ecx, ecx
  00058	89 45 f0	 mov	 DWORD PTR _rtCurrent$[ebp], eax
  0005b	89 4d f4	 mov	 DWORD PTR _rtCurrent$[ebp+4], ecx

; 1837 :         // take care of timeGetTime rolling over every 49 days
; 1838 :         if( rtCurrent < 0 )

  0005e	83 7d f4 00	 cmp	 DWORD PTR _rtCurrent$[ebp+4], 0
  00062	7f 20		 jg	 SHORT $L70065
  00064	7c 06		 jl	 SHORT $L75300
  00066	83 7d f0 00	 cmp	 DWORD PTR _rtCurrent$[ebp], 0
  0006a	73 18		 jae	 SHORT $L70065
$L75300:

; 1839 :         {
; 1840 :             m_wRollOverCount++;

  0006c	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	66 8b 82 f0 02
	00 00		 mov	 ax, WORD PTR [edx+752]
  00076	66 05 01 00	 add	 ax, 1
  0007a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	66 89 81 f0 02
	00 00		 mov	 WORD PTR [ecx+752], ax
$L70065:

; 1841 :         }
; 1842 :         for( w = 0; w < m_wRollOverCount; w++ )

  00084	66 c7 45 fc 00
	00		 mov	 WORD PTR _w$[ebp], 0
  0008a	eb 0c		 jmp	 SHORT $L70066
$L70067:
  0008c	66 8b 55 fc	 mov	 dx, WORD PTR _w$[ebp]
  00090	66 83 c2 01	 add	 dx, 1
  00094	66 89 55 fc	 mov	 WORD PTR _w$[ebp], dx
$L70066:
  00098	0f b7 45 fc	 movzx	 eax, WORD PTR _w$[ebp]
  0009c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	0f b7 91 f0 02
	00 00		 movzx	 edx, WORD PTR [ecx+752]
  000a6	3b c2		 cmp	 eax, edx
  000a8	7d 14		 jge	 SHORT $L70063

; 1843 :         {
; 1844 :             rtCurrent += 4294967296;

  000aa	8b 45 f0	 mov	 eax, DWORD PTR _rtCurrent$[ebp]
  000ad	83 c0 00	 add	 eax, 0
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR _rtCurrent$[ebp+4]
  000b3	83 d1 01	 adc	 ecx, 1
  000b6	89 45 f0	 mov	 DWORD PTR _rtCurrent$[ebp], eax
  000b9	89 4d f4	 mov	 DWORD PTR _rtCurrent$[ebp+4], ecx

; 1845 :         }

  000bc	eb ce		 jmp	 SHORT $L70067
$L70063:

; 1846 :         // if rtCurrent is negative, it means we've rolled over rtCurrent. Ignore
; 1847 :         // this case for now, as it will be quite uncommon.
; 1848 :     }
; 1849 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000be	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  000c7	52		 push	 edx
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1850 : 
; 1851 :     return rtCurrent;

  000ce	8b 45 f0	 mov	 eax, DWORD PTR _rtCurrent$[ebp]
  000d1	8b 55 f4	 mov	 edx, DWORD PTR _rtCurrent$[ebp+4]

; 1852 : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?GetTime@CPerformance@@AAE_JXZ ENDP			; CPerformance::GetTime
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetLatency@CPerformance@@AAE_JXZ
_TEXT	SEGMENT
tv77 = -16
_this$ = -12
_rtLatency$ = -8
?GetLatency@CPerformance@@AAE_JXZ PROC NEAR		; CPerformance::GetLatency, COMDAT
; _this$ = ecx

; 1855 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1856 :     REFERENCE_TIME rtLatency = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _rtLatency$[ebp], 0
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rtLatency$[ebp+4], 0

; 1857 : #ifdef DXAPI
; 1858 :     DWORD dwIndex;
; 1859 :     REFERENCE_TIME rtTemp;
; 1860 : 
; 1861 : #ifdef DBG_PROFILE
; 1862 :     DWORD dwDebugTime;
; 1863 :     dwDebugTime = timeGetTime();
; 1864 : #endif
; 1865 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 1866 :     if( m_pPortTable )
; 1867 :     {
; 1868 :         for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 1869 :         {
; 1870 :             if( m_pPortTable[dwIndex].pLatencyClock )
; 1871 :             {
; 1872 :                 if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
; 1873 :                 {
; 1874 :                     if( rtTemp > rtLatency )
; 1875 :                         rtLatency = rtTemp;
; 1876 :                 }
; 1877 :             }
; 1878 :             else if( m_pPortTable[dwIndex].pPort )
; 1879 :             {
; 1880 :                 if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
; 1881 :                 {
; 1882 :                     if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
; 1883 :                     {
; 1884 :                         if( rtTemp > rtLatency )
; 1885 :                             rtLatency = rtTemp;
; 1886 :                     }
; 1887 :                 }
; 1888 :             }
; 1889 :         }
; 1890 :     }
; 1891 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 1892 : #endif
; 1893 :     if( 0 == rtLatency )

  00017	83 7d f8 00	 cmp	 DWORD PTR _rtLatency$[ebp], 0
  0001b	75 14		 jne	 SHORT $L70074
  0001d	83 7d fc 00	 cmp	 DWORD PTR _rtLatency$[ebp+4], 0
  00021	75 0e		 jne	 SHORT $L70074

; 1894 :     {
; 1895 :         rtLatency = GetTime();

  00023	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  0002b	89 45 f8	 mov	 DWORD PTR _rtLatency$[ebp], eax
  0002e	89 55 fc	 mov	 DWORD PTR _rtLatency$[ebp+4], edx
$L70074:

; 1896 :     }
; 1897 : #ifdef DBG_PROFILE
; 1898 :     dwDebugTime = timeGetTime() - dwDebugTime;
; 1899 :     if( dwDebugTime > 1 )
; 1900 :     {
; 1901 :         TraceI(5, "Hall, debugtime GetLatency %u\n", dwDebugTime);
; 1902 :     }
; 1903 : #endif
; 1904 :     if (m_rtEarliestStartTime > rtLatency)

  00031	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00034	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  00037	8b 4d f0	 mov	 ecx, DWORD PTR tv77[ebp]
  0003a	8b 91 b4 02 00
	00		 mov	 edx, DWORD PTR [ecx+692]
  00040	3b 55 fc	 cmp	 edx, DWORD PTR _rtLatency$[ebp+4]
  00043	7c 25		 jl	 SHORT $L70075
  00045	7f 0e		 jg	 SHORT $L75304
  00047	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0004a	8b 88 b0 02 00
	00		 mov	 ecx, DWORD PTR [eax+688]
  00050	3b 4d f8	 cmp	 ecx, DWORD PTR _rtLatency$[ebp]
  00053	76 15		 jbe	 SHORT $L70075
$L75304:

; 1905 :     {
; 1906 :         rtLatency = m_rtEarliestStartTime;

  00055	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 82 b0 02 00
	00		 mov	 eax, DWORD PTR [edx+688]
  0005e	89 45 f8	 mov	 DWORD PTR _rtLatency$[ebp], eax
  00061	8b 8a b4 02 00
	00		 mov	 ecx, DWORD PTR [edx+692]
  00067	89 4d fc	 mov	 DWORD PTR _rtLatency$[ebp+4], ecx
$L70075:

; 1907 :     }
; 1908 :     return rtLatency;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _rtLatency$[ebp]
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _rtLatency$[ebp+4]

; 1909 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?GetLatency@CPerformance@@AAE_JXZ ENDP			; CPerformance::GetLatency
_TEXT	ENDS
PUBLIC	?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z ; CPerformance::GetBestSegLatency
; Function compile flags: /Odt
;	COMDAT ?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z
_TEXT	SEGMENT
_this$ = -4
_pSeg$ = 8
?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z PROC NEAR ; CPerformance::GetBestSegLatency, COMDAT
; _this$ = ecx

; 1914 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1915 : #ifdef XBOX
; 1916 :     return GetLatency();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency

; 1917 : #else
; 1918 :     // If we're using audiopaths, the code below doesn't work because it doesn't
; 1919 :     // take converting pchannels into account. So, just use the worse case
; 1920 :     // latency. 99% of the time, there is only one port, so this results
; 1921 :     // in just a performance enhancement.
; 1922 :     if (m_dwAudioPathMode == 2)
; 1923 :     {
; 1924 :         return GetLatency();
; 1925 :     }
; 1926 :     DWORD dwIndex;
; 1927 :     REFERENCE_TIME rtLatency = 0;
; 1928 :     REFERENCE_TIME rtTemp;
; 1929 :     BOOL* pafIndexUsed = NULL;
; 1930 :     DWORD dwCount;
; 1931 : 
; 1932 :     if( m_dwNumPorts == 1 )
; 1933 :     {
; 1934 :         return GetLatency();
; 1935 :     }
; 1936 :     pafIndexUsed = new BOOL[m_dwNumPorts];
; 1937 :     if( NULL == pafIndexUsed )
; 1938 :     {
; 1939 :         return GetLatency();
; 1940 :     }
; 1941 :     for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
; 1942 :     {
; 1943 :         pafIndexUsed[dwCount] = FALSE;
; 1944 :     }
; 1945 :     DWORD dwNumPChannels, dwGroup, dwMChannel;
; 1946 :     DWORD* paPChannels;
; 1947 :     pSeg->m_pSegment->GetPChannels( &dwNumPChannels, &paPChannels );
; 1948 :     for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
; 1949 :     {
; 1950 :         if( SUCCEEDED( PChannelIndex( paPChannels[dwCount],
; 1951 :             &dwIndex, &dwGroup, &dwMChannel )))
; 1952 :         {
; 1953 :             pafIndexUsed[dwIndex] = TRUE;
; 1954 :         }
; 1955 :     }
; 1956 :     for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
; 1957 :     {
; 1958 :         if( pafIndexUsed[dwCount] )
; 1959 :             break;
; 1960 :     }
; 1961 :     if( dwCount >= m_dwNumPorts )
; 1962 :     {
; 1963 :         delete [] pafIndexUsed;
; 1964 :         return GetLatency();
; 1965 :     }
; 1966 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 1967 :     for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 1968 :     {
; 1969 :         if( pafIndexUsed[dwIndex] )
; 1970 :         {
; 1971 :             if( m_pPortTable[dwIndex].pLatencyClock )
; 1972 :             {
; 1973 :                 if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
; 1974 :                 {
; 1975 :                     if( rtTemp > rtLatency )
; 1976 :                         rtLatency = rtTemp;
; 1977 :                 }
; 1978 :             }
; 1979 :             else if( m_pPortTable[dwIndex].pPort )
; 1980 :             {
; 1981 :                 if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
; 1982 :                 {
; 1983 :                     if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
; 1984 :                     {
; 1985 :                         if( rtTemp > rtLatency )
; 1986 :                             rtLatency = rtTemp;
; 1987 :                     }
; 1988 :                 }
; 1989 :             }
; 1990 :         }
; 1991 :     }
; 1992 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 1993 :     if( 0 == rtLatency )
; 1994 :     {
; 1995 :         rtLatency = GetLatency();
; 1996 :     }
; 1997 :     delete [] pafIndexUsed;
; 1998 :     return rtLatency;
; 1999 : #endif // !XBOX
; 2000 : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z ENDP ; CPerformance::GetBestSegLatency
_TEXT	ENDS
PUBLIC	?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::CalculateSegmentStartTime
PUBLIC	?ResolveTime@CPerformance@@AAEJJKPAJ@Z		; CPerformance::ResolveTime
EXTRN	_GUID_Valid_Start_Time:BYTE
; Function compile flags: /Odt
;	COMDAT ?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT
_this$ = -28
_mtOverrideTime$70098 = -24
_ValidStart$70086 = -20
_mtIntervalSize$70087 = -16
_mtTimeNow$70088 = -12
_mtStartTime$70090 = -8
_fNoValidStart$ = -4
_pSeg$ = 8
?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z PROC NEAR ; CPerformance::CalculateSegmentStartTime, COMDAT
; _this$ = ecx

; 2010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2011 :     BOOL fNoValidStart = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fNoValidStart$[ebp], 1

; 2012 :     if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_ALIGN)

  00010	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00013	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00016	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  0001c	85 c9		 test	 ecx, ecx
  0001e	0f 84 b2 01 00
	00		 je	 $L70085

; 2013 :     {
; 2014 :         // If the ALIGN flag is set, see if we can align with the requested resolution,
; 2015 :         // but switch to the new segment at an earlier point, as defined by
; 2016 :         // a "valid start" point in the new segment.
; 2017 :         DMUS_VALID_START_PARAM ValidStart;    // Used to read start parameter from segment.
; 2018 :         MUSIC_TIME mtIntervalSize = 0;      // Quantization value.

  00024	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mtIntervalSize$70087[ebp], 0

; 2019 :         MUSIC_TIME mtTimeNow = (MUSIC_TIME)pSeg->m_rtGivenStart; // The earliest time this can start.

  0002b	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0002e	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00034	89 45 f4	 mov	 DWORD PTR _mtTimeNow$70088[ebp], eax

; 2020 :         // Call resolve time to get the last quantized interval that precedes mtTimeNow.
; 2021 :         MUSIC_TIME mtStartTime = ResolveTime( mtTimeNow, pSeg->m_dwPlaySegFlags, &mtIntervalSize );

  00037	8d 4d f0	 lea	 ecx, DWORD PTR _mtIntervalSize$70087[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0003e	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00041	50		 push	 eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  00045	51		 push	 ecx
  00046	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  0004e	89 45 f8	 mov	 DWORD PTR _mtStartTime$70090[ebp], eax

; 2022 :         // StartTime actually shows the next time after now, so subtract the interval time to get the previous position.
; 2023 :         mtStartTime -= mtIntervalSize;

  00051	8b 55 f8	 mov	 edx, DWORD PTR _mtStartTime$70090[ebp]
  00054	2b 55 f0	 sub	 edx, DWORD PTR _mtIntervalSize$70087[ebp]
  00057	89 55 f8	 mov	 DWORD PTR _mtStartTime$70090[ebp], edx

; 2024 :         // If the segment was supposed to start after the very beginning, quantize it.
; 2025 :         if (mtIntervalSize && pSeg->m_mtStartPoint)

  0005a	83 7d f0 00	 cmp	 DWORD PTR _mtIntervalSize$70087[ebp], 0
  0005e	74 24		 je	 SHORT $L70091
  00060	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00063	83 78 7c 00	 cmp	 DWORD PTR [eax+124], 0
  00067	74 1b		 je	 SHORT $L70091

; 2026 :         {
; 2027 :             pSeg->m_mtStartPoint = ((pSeg->m_mtStartPoint + (mtIntervalSize >> 1)) 
; 2028 :                 / mtIntervalSize) * mtIntervalSize;

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _mtIntervalSize$70087[ebp]
  0006c	d1 f9		 sar	 ecx, 1
  0006e	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00071	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00074	03 c1		 add	 eax, ecx
  00076	99		 cdq
  00077	f7 7d f0	 idiv	 DWORD PTR _mtIntervalSize$70087[ebp]
  0007a	0f af 45 f0	 imul	 eax, DWORD PTR _mtIntervalSize$70087[ebp]
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00081	89 41 7c	 mov	 DWORD PTR [ecx+124], eax
$L70091:

; 2029 :             // If this ends up being longer than the segment, do we need to drop back?
; 2030 :         }
; 2031 :         // Now, get the next start point after the point in the segment that 
; 2032 :         // corresponds with mtTimeNow, adjusted for the startpoint.
; 2033 :         if (SUCCEEDED(pSeg->m_pSegment->GetParam( GUID_Valid_Start_Time,-1,0,
; 2034 :             pSeg->m_mtStartPoint + mtTimeNow - mtStartTime,NULL,(void *) &ValidStart)))

  00084	8d 55 ec	 lea	 edx, DWORD PTR _ValidStart$70086[ebp]
  00087	52		 push	 edx
  00088	6a 00		 push	 0
  0008a	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0008d	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  00090	03 4d f4	 add	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  00093	2b 4d f8	 sub	 ecx, DWORD PTR _mtStartTime$70090[ebp]
  00096	51		 push	 ecx
  00097	6a 00		 push	 0
  00099	6a ff		 push	 -1
  0009b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Valid_Start_Time
  000a0	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000a3	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  000a9	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000ac	8b 00		 mov	 eax, DWORD PTR [eax]
  000ae	52		 push	 edx
  000af	ff 50 6c	 call	 DWORD PTR [eax+108]
  000b2	85 c0		 test	 eax, eax
  000b4	7c 3e		 jl	 SHORT $L70094

; 2035 :         {
; 2036 :             // If the valid start point is within the range, we can cut in at the start point.
; 2037 :             if ((mtTimeNow - mtStartTime + ValidStart.mtTime) < (mtIntervalSize + pSeg->m_mtStartPoint))

  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  000b9	2b 4d f8	 sub	 ecx, DWORD PTR _mtStartTime$70090[ebp]
  000bc	03 4d ec	 add	 ecx, DWORD PTR _ValidStart$70086[ebp]
  000bf	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000c2	8b 45 f0	 mov	 eax, DWORD PTR _mtIntervalSize$70087[ebp]
  000c5	03 42 7c	 add	 eax, DWORD PTR [edx+124]
  000c8	3b c8		 cmp	 ecx, eax
  000ca	7d 28		 jge	 SHORT $L70094

; 2038 :             {
; 2039 :                 pSeg->m_mtResolvedStart = mtTimeNow + ValidStart.mtTime;

  000cc	8b 4d f4	 mov	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  000cf	03 4d ec	 add	 ecx, DWORD PTR _ValidStart$70086[ebp]
  000d2	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000d5	89 4a 64	 mov	 DWORD PTR [edx+100], ecx

; 2040 :                 pSeg->m_mtStartPoint += mtTimeNow - mtStartTime + ValidStart.mtTime;

  000d8	8b 45 f4	 mov	 eax, DWORD PTR _mtTimeNow$70088[ebp]
  000db	2b 45 f8	 sub	 eax, DWORD PTR _mtStartTime$70090[ebp]
  000de	03 45 ec	 add	 eax, DWORD PTR _ValidStart$70086[ebp]
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  000e4	03 41 7c	 add	 eax, DWORD PTR [ecx+124]
  000e7	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000ea	89 42 7c	 mov	 DWORD PTR [edx+124], eax

; 2041 :                 fNoValidStart = FALSE;

  000ed	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fNoValidStart$[ebp], 0
$L70094:

; 2042 :             }
; 2043 :         }
; 2044 :         if (fNoValidStart)

  000f4	83 7d fc 00	 cmp	 DWORD PTR _fNoValidStart$[ebp], 0
  000f8	0f 84 d8 00 00
	00		 je	 $L70085

; 2045 :         {
; 2046 :             // Couldn't find a valid start point. Was DMUS_SEGF_VALID_START_XXX set so we can override?
; 2047 :             if (pSeg->m_dwPlaySegFlags & 
; 2048 :                 (DMUS_SEGF_VALID_START_MEASURE | DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_TICK))

  000fe	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00101	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00104	81 e1 00 00 0e
	08		 and	 ecx, 135135232		; 080e0000H
  0010a	85 c9		 test	 ecx, ecx
  0010c	0f 84 c4 00 00
	00		 je	 $L70085

; 2049 :             {
; 2050 :                 MUSIC_TIME mtOverrideTime;
; 2051 :                 // Depending on the flag, we need to get the appropriate interval resolution.
; 2052 :                 if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_MEASURE)

  00112	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00115	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00118	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0011d	85 c0		 test	 eax, eax
  0011f	74 18		 je	 SHORT $L70099

; 2053 :                 {
; 2054 :                     mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_MEASURE, 0 );

  00121	6a 00		 push	 0
  00123	68 00 20 00 00	 push	 8192			; 00002000H
  00128	8b 4d f4	 mov	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  0012b	51		 push	 ecx
  0012c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  00134	89 45 e8	 mov	 DWORD PTR _mtOverrideTime$70098[ebp], eax

; 2055 :                 } 
; 2056 :                 else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_BEAT)

  00137	eb 54		 jmp	 SHORT $L70100
$L70099:
  00139	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0013c	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0013f	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00144	85 c0		 test	 eax, eax
  00146	74 18		 je	 SHORT $L70101

; 2057 :                 {
; 2058 :                     mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_BEAT, 0 );

  00148	6a 00		 push	 0
  0014a	68 00 10 00 00	 push	 4096			; 00001000H
  0014f	8b 4d f4	 mov	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  00152	51		 push	 ecx
  00153	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  0015b	89 45 e8	 mov	 DWORD PTR _mtOverrideTime$70098[ebp], eax

; 2059 :                 } 
; 2060 :                 else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_GRID)

  0015e	eb 2d		 jmp	 SHORT $L70100
$L70101:
  00160	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00163	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00166	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0016b	85 c0		 test	 eax, eax
  0016d	74 18		 je	 SHORT $L70103

; 2061 :                 {
; 2062 :                     mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_GRID, 0 );

  0016f	6a 00		 push	 0
  00171	68 00 08 00 00	 push	 2048			; 00000800H
  00176	8b 4d f4	 mov	 ecx, DWORD PTR _mtTimeNow$70088[ebp]
  00179	51		 push	 ecx
  0017a	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  00182	89 45 e8	 mov	 DWORD PTR _mtOverrideTime$70098[ebp], eax

; 2063 :                 } 
; 2064 :                 else

  00185	eb 06		 jmp	 SHORT $L70100
$L70103:

; 2065 :                 {
; 2066 :                     mtOverrideTime = mtTimeNow;

  00187	8b 55 f4	 mov	 edx, DWORD PTR _mtTimeNow$70088[ebp]
  0018a	89 55 e8	 mov	 DWORD PTR _mtOverrideTime$70098[ebp], edx
$L70100:

; 2067 :                 }
; 2068 :                 // If the valid start point is within the range, we can cut in at the start point.
; 2069 :                 if ((mtOverrideTime - mtTimeNow) < (mtIntervalSize + pSeg->m_mtStartPoint))

  0018d	8b 45 e8	 mov	 eax, DWORD PTR _mtOverrideTime$70098[ebp]
  00190	2b 45 f4	 sub	 eax, DWORD PTR _mtTimeNow$70088[ebp]
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00196	8b 55 f0	 mov	 edx, DWORD PTR _mtIntervalSize$70087[ebp]
  00199	03 51 7c	 add	 edx, DWORD PTR [ecx+124]
  0019c	3b c2		 cmp	 eax, edx
  0019e	7d 36		 jge	 SHORT $L70085

; 2070 :                 {
; 2071 :                     pSeg->m_mtResolvedStart = mtOverrideTime;

  001a0	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001a3	8b 4d e8	 mov	 ecx, DWORD PTR _mtOverrideTime$70098[ebp]
  001a6	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 2072 :                     if ((mtOverrideTime - mtStartTime) >= mtIntervalSize)

  001a9	8b 55 e8	 mov	 edx, DWORD PTR _mtOverrideTime$70098[ebp]
  001ac	2b 55 f8	 sub	 edx, DWORD PTR _mtStartTime$70090[ebp]
  001af	3b 55 f0	 cmp	 edx, DWORD PTR _mtIntervalSize$70087[ebp]
  001b2	7c 09		 jl	 SHORT $L70106

; 2073 :                     {
; 2074 :                         mtOverrideTime -= mtIntervalSize;

  001b4	8b 45 e8	 mov	 eax, DWORD PTR _mtOverrideTime$70098[ebp]
  001b7	2b 45 f0	 sub	 eax, DWORD PTR _mtIntervalSize$70087[ebp]
  001ba	89 45 e8	 mov	 DWORD PTR _mtOverrideTime$70098[ebp], eax
$L70106:

; 2075 :                     }
; 2076 : /*Trace(0,"Startpoint %ld plus OverrideTime %ld - StartTime %ld = %ld\n",
; 2077 :       pSeg->m_mtStartPoint, mtOverrideTime - mtSegmentTime, mtStartTime - mtSegmentTime,
; 2078 :         pSeg->m_mtStartPoint + mtOverrideTime - mtStartTime);*/
; 2079 :                     pSeg->m_mtStartPoint += mtOverrideTime - mtStartTime;

  001bd	8b 4d e8	 mov	 ecx, DWORD PTR _mtOverrideTime$70098[ebp]
  001c0	2b 4d f8	 sub	 ecx, DWORD PTR _mtStartTime$70090[ebp]
  001c3	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  001c6	03 4a 7c	 add	 ecx, DWORD PTR [edx+124]
  001c9	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001cc	89 48 7c	 mov	 DWORD PTR [eax+124], ecx

; 2080 :                     fNoValidStart = FALSE;

  001cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fNoValidStart$[ebp], 0
$L70085:

; 2081 :                 }
; 2082 :             }
; 2083 :         }
; 2084 :     }
; 2085 :     if (fNoValidStart)

  001d6	83 7d fc 00	 cmp	 DWORD PTR _fNoValidStart$[ebp], 0
  001da	74 23		 je	 SHORT $L70111

; 2086 :     {
; 2087 :         pSeg->m_mtResolvedStart = ResolveTime( (MUSIC_TIME)pSeg->m_rtGivenStart,
; 2088 :             pSeg->m_dwPlaySegFlags, NULL );

  001dc	6a 00		 push	 0
  001de	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  001e1	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  001e4	52		 push	 edx
  001e5	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001e8	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  001ee	51		 push	 ecx
  001ef	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f2	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  001f7	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  001fa	89 42 64	 mov	 DWORD PTR [edx+100], eax

; 2089 :     }
; 2090 :     else

  001fd	eb 6b		 jmp	 SHORT $L70109
$L70111:

; 2091 :     {
; 2092 :         // If we succeeded in finding a place to switch over, make sure it isn't deep inside
; 2093 :         // a loop. This is specifically a problem when syncing to segment and switching inside
; 2094 :         // or after a loop.
; 2095 :         while (pSeg->m_dwRepeats && (pSeg->m_mtStartPoint >= pSeg->m_mtLoopEnd))

  001ff	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00202	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00206	74 39		 je	 SHORT $L70112
  00208	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0020b	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0020e	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  00211	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  00214	7c 2b		 jl	 SHORT $L70112

; 2096 :         {
; 2097 :             pSeg->m_dwRepeats--;

  00216	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00219	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0021c	83 ea 01	 sub	 edx, 1
  0021f	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00222	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 2098 :             pSeg->m_mtStartPoint -= (pSeg->m_mtLoopEnd - pSeg->m_mtLoopStart);

  00225	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00228	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0022b	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0022e	2b 42 48	 sub	 eax, DWORD PTR [edx+72]
  00231	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00234	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  00237	2b d0		 sub	 edx, eax
  00239	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0023c	89 50 7c	 mov	 DWORD PTR [eax+124], edx

; 2099 :         }

  0023f	eb be		 jmp	 SHORT $L70111
$L70112:

; 2100 :         // Since we were decrementing the repeats, we need to also decrement the repeats left.
; 2101 :         pSeg->m_dwRepeatsLeft = pSeg->m_dwRepeats;

  00241	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00244	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00247	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0024a	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax

; 2102 :         // Finally, if the startpoint is after the end of the segment, cut it back to the end of the
; 2103 :         // segment. This will cause it to play for time 0 and, if this is a transition segment, whatever
; 2104 :         // should play after will play immediately.
; 2105 :         if (pSeg->m_mtStartPoint > pSeg->m_mtLength)

  00250	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00253	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00256	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  00259	3b 42 54	 cmp	 eax, DWORD PTR [edx+84]
  0025c	7e 0c		 jle	 SHORT $L70109

; 2106 :         {
; 2107 :             pSeg->m_mtStartPoint = pSeg->m_mtLength;

  0025e	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00261	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00264	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00267	89 41 7c	 mov	 DWORD PTR [ecx+124], eax
$L70109:

; 2108 :         }
; 2109 :     }
; 2110 :     pSeg->m_mtOffset = pSeg->m_mtResolvedStart;

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0026d	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00270	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00273	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 2111 :     pSeg->m_mtLastPlayed = pSeg->m_mtResolvedStart;

  00276	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00279	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0027c	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0027f	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 2112 : }

  00282	8b e5		 mov	 esp, ebp
  00284	5d		 pop	 ebp
  00285	c2 04 00	 ret	 4
?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z ENDP ; CPerformance::CalculateSegmentStartTime
_TEXT	ENDS
PUBLIC	??_C@_0CP@JDNMBECK@?$CB?$CIpSeg?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_@ ; `string'
PUBLIC	??_C@_0DA@DKFLICIG@m_SegStateQueues?$FLSQ_PRI_PLAY?$FN?4Ge@ ; `string'
PUBLIC	?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z	; CPerformance::SyncTimeSig
PUBLIC	?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z	; CSegStateList::AddHead
PUBLIC	?GetTail@CSegStateList@@QAEPAVCSegState@@XZ	; CSegStateList::GetTail
PUBLIC	?SetNext@AListItem@@QAEXPAV1@@Z			; AListItem::SetNext
EXTRN	?Flush@CSegState@@QAGJJ@Z:NEAR			; CSegState::Flush
;	COMDAT ??_C@_0CP@JDNMBECK@?$CB?$CIpSeg?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_@
CONST	SEGMENT
??_C@_0CP@JDNMBECK@?$CB?$CIpSeg?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_@ DB '!'
	DB	'(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DKFLICIG@m_SegStateQueues?$FLSQ_PRI_PLAY?$FN?4Ge@
CONST	SEGMENT
??_C@_0DA@DKFLICIG@m_SegStateQueues?$FLSQ_PRI_PLAY?$FN?4Ge@ DB 'm_SegStat'
	DB	'eQueues[SQ_PRI_PLAY].GetHead() == pSeg', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT
tv424 = -136
tv390 = -132
tv387 = -128
tv381 = -124
tv316 = -120
tv313 = -116
tv304 = -112
tv298 = -108
tv295 = -104
tv696 = -100
tv634 = -96
tv589 = -92
tv588 = -84
tv561 = -80
_this$ = -76
_pSegTemp$70185 = -72
_pCurrentSeg$70181 = -68
_mtTime$70176 = -64
_mtTime$70148 = -60
_rtNow$70147 = -56
_rtStart$70141 = -48
_mtStart$70140 = -36
_rtQueue$70135 = -32
_rtTrans$70129 = -24
_mtStart$70122 = -16
_fNotDone$ = -12
_fInCrSec$ = -8
_pTemp$ = -4
_pSeg$ = 8
?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z PROC NEAR ; CPerformance::QueuePrimarySegment, COMDAT
; _this$ = ecx

; 2117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	56		 push	 esi
  0000a	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 2118 :     CSegState* pTemp;
; 2119 :     BOOL fInCrSec = TRUE;

  0000d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 1

; 2120 :     BOOL fNotDone = TRUE;

  00014	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fNotDone$[ebp], 1

; 2121 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0001b	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2122 :     pSeg->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0002d	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00030	83 ca 10	 or	 edx, 16			; 00000010H
  00033	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00036	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 2123 :     if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_QUEUE )

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0003c	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0003f	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00045	85 d2		 test	 edx, edx
  00047	0f 84 e6 01 00
	00		 je	 $L70121

; 2124 :     {
; 2125 :         MUSIC_TIME mtStart = 0;

  0004d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mtStart$70122[ebp], 0

; 2126 : 
; 2127 :         pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetTail();

  00054	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0005a	e8 00 00 00 00	 call	 ?GetTail@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetTail
  0005f	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax

; 2128 :         if( pTemp )

  00062	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  00066	74 14		 je	 SHORT $L70123

; 2129 :         {
; 2130 :             mtStart = pTemp->GetEndTime( pTemp->m_mtResolvedStart );

  00068	8b 45 fc	 mov	 eax, DWORD PTR _pTemp$[ebp]
  0006b	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0006e	51		 push	 ecx
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00072	e8 00 00 00 00	 call	 ?GetEndTime@CSegState@@QAEJJ@Z ; CSegState::GetEndTime
  00077	89 45 f0	 mov	 DWORD PTR _mtStart$70122[ebp], eax

; 2131 :         }
; 2132 :         else

  0007a	eb 1d		 jmp	 SHORT $L70124
$L70123:

; 2133 :         {
; 2134 :             pTemp = m_SegStateQueues[SQ_PRI_DONE].GetTail();

  0007c	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 74	 add	 ecx, 116		; 00000074H
  00082	e8 00 00 00 00	 call	 ?GetTail@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetTail
  00087	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax

; 2135 :             if( pTemp )

  0008a	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  0008e	74 09		 je	 SHORT $L70124

; 2136 :             {
; 2137 :                 mtStart = pTemp->m_mtLastPlayed;

  00090	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  00093	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00096	89 45 f0	 mov	 DWORD PTR _mtStart$70122[ebp], eax
$L70124:

; 2138 :             }
; 2139 :         }
; 2140 :         pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE;

  00099	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0009c	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0009f	81 e2 ff fe ff
	ff		 and	 edx, -257		; fffffeffH
  000a5	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  000a8	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 2141 :         if( NULL == pTemp )

  000ab	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  000af	0f 85 f4 00 00
	00		 jne	 $L70126

; 2142 :         {
; 2143 :             // if there's nothing in the queue, this means play it now
; 2144 :             if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )

  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  000b8	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  000bb	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  000c1	85 d2		 test	 edx, edx
  000c3	0f 84 c4 00 00
	00		 je	 $L70127

; 2145 :             {
; 2146 :                 // we want to queue this at the last transported time,
; 2147 :                 // so we don't need to do an invalidate
; 2148 :                 if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )

  000c9	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  000cc	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  000cf	83 e1 40	 and	 ecx, 64			; 00000040H
  000d2	85 c9		 test	 ecx, ecx
  000d4	74 68		 je	 SHORT $L70128

; 2149 :                 {
; 2150 :                     REFERENCE_TIME rtTrans;
; 2151 :                     MusicToReferenceTime( m_mtTransported, &rtTrans );

  000d6	8d 55 e8	 lea	 edx, DWORD PTR _rtTrans$70129[ebp]
  000d9	52		 push	 edx
  000da	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  000e3	51		 push	 ecx
  000e4	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	8b 02		 mov	 eax, DWORD PTR [edx]
  000e9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	ff 50 14	 call	 DWORD PTR [eax+20]

; 2152 :                     if( pSeg->m_rtGivenStart < rtTrans )

  000f0	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000f3	89 55 b0	 mov	 DWORD PTR tv561[ebp], edx
  000f6	8b 45 b0	 mov	 eax, DWORD PTR tv561[ebp]
  000f9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000ff	3b 4d ec	 cmp	 ecx, DWORD PTR _rtTrans$70129[ebp+4]
  00102	7f 38		 jg	 SHORT $L70130
  00104	7c 0e		 jl	 SHORT $L75326
  00106	8b 55 b0	 mov	 edx, DWORD PTR tv561[ebp]
  00109	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  0010f	3b 45 e8	 cmp	 eax, DWORD PTR _rtTrans$70129[ebp]
  00112	73 28		 jae	 SHORT $L70130
$L75326:

; 2153 :                     {
; 2154 :                         pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;

  00114	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00117	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0011a	83 e2 bf	 and	 edx, -65		; ffffffbfH
  0011d	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00120	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 2155 :                         pSeg->m_rtGivenStart = m_mtTransported;

  00123	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	8b 81 d0 02 00
	00		 mov	 eax, DWORD PTR [ecx+720]
  0012c	99		 cdq
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00130	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  00136	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx
$L70130:

; 2156 :                     }
; 2157 :                 }
; 2158 :                 else

  0013c	eb 4d		 jmp	 SHORT $L70131
$L70128:

; 2159 :                 {
; 2160 :                     if( pSeg->m_rtGivenStart < m_mtTransported )

  0013e	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  00141	8b 82 d0 02 00
	00		 mov	 eax, DWORD PTR [edx+720]
  00147	99		 cdq
  00148	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0014b	89 4d ac	 mov	 DWORD PTR tv588[ebp], ecx
  0014e	89 45 a4	 mov	 DWORD PTR tv589[ebp], eax
  00151	89 55 a8	 mov	 DWORD PTR tv589[ebp+4], edx
  00154	8b 55 ac	 mov	 edx, DWORD PTR tv588[ebp]
  00157	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0015d	3b 45 a8	 cmp	 eax, DWORD PTR tv589[ebp+4]
  00160	7f 29		 jg	 SHORT $L70131
  00162	7c 0e		 jl	 SHORT $L75327
  00164	8b 4d ac	 mov	 ecx, DWORD PTR tv588[ebp]
  00167	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  0016d	3b 55 a4	 cmp	 edx, DWORD PTR tv589[ebp]
  00170	73 19		 jae	 SHORT $L70131
$L75327:

; 2161 :                     {
; 2162 :                         pSeg->m_rtGivenStart = m_mtTransported;

  00172	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00175	8b 80 d0 02 00
	00		 mov	 eax, DWORD PTR [eax+720]
  0017b	99		 cdq
  0017c	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0017f	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  00185	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx
$L70131:

; 2163 :                     }
; 2164 :                 }
; 2165 :             }
; 2166 :             else

  0018b	eb 17		 jmp	 SHORT $L70133
$L70127:

; 2167 :             {
; 2168 :                 // This will be changed to Queue time below
; 2169 :                 pSeg->m_rtGivenStart = 0;

  0018d	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00190	c7 82 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+160], 0
  0019a	c7 82 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+164], 0
$L70133:

; 2170 :             }
; 2171 :         }
; 2172 :         else

  001a4	e9 8a 00 00 00	 jmp	 $L70121
$L70126:

; 2173 :         {
; 2174 :             REFERENCE_TIME rtQueue;
; 2175 :             
; 2176 :             // otherwise, time stamp it with the time corresponding to
; 2177 :             // the end time of all segments currently in the queue.
; 2178 :             pSeg->m_mtResolvedStart = mtStart;

  001a9	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001ac	8b 4d f0	 mov	 ecx, DWORD PTR _mtStart$70122[ebp]
  001af	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 2179 :             // make sure the resolved start time isn't before the latency
; 2180 :             GetQueueTime(&rtQueue);

  001b2	8d 55 e0	 lea	 edx, DWORD PTR _rtQueue$70135[ebp]
  001b5	52		 push	 edx
  001b6	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bb	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  001be	52		 push	 edx
  001bf	ff 91 84 00 00
	00		 call	 DWORD PTR [ecx+132]

; 2181 :             ReferenceToMusicTime( rtQueue, &mtStart );

  001c5	8d 45 f0	 lea	 eax, DWORD PTR _mtStart$70122[ebp]
  001c8	50		 push	 eax
  001c9	8b 4d e4	 mov	 ecx, DWORD PTR _rtQueue$70135[ebp+4]
  001cc	51		 push	 ecx
  001cd	8b 55 e0	 mov	 edx, DWORD PTR _rtQueue$70135[ebp]
  001d0	52		 push	 edx
  001d1	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  001d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d6	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  001d9	52		 push	 edx
  001da	ff 51 18	 call	 DWORD PTR [ecx+24]

; 2182 :             if( pSeg->m_mtResolvedStart < mtStart )

  001dd	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001e0	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  001e3	3b 4d f0	 cmp	 ecx, DWORD PTR _mtStart$70122[ebp]
  001e6	7d 0c		 jge	 SHORT $L70136

; 2183 :             {
; 2184 :                 pSeg->m_mtResolvedStart = 0; // below code will take care of this case

  001e8	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  001eb	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0

; 2185 :             }
; 2186 :             else

  001f2	eb 3f		 jmp	 SHORT $L70121
$L70136:

; 2187 :             {
; 2188 :                 pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;

  001f4	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001f7	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  001fa	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  001fd	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00200	89 4a 5c	 mov	 DWORD PTR [edx+92], ecx

; 2189 :                 pSeg->m_mtOffset = pSeg->m_mtResolvedStart;

  00203	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00206	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00209	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0020c	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 2190 :                 m_SegStateQueues[SQ_PRI_PLAY].Insert(pSeg);

  0020f	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00212	50		 push	 eax
  00213	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00216	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00219	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2191 :                 TraceI(2, "dmperf: queueing primary seg/DMUS_SEGF_QUEUE. Prev time=%ld, this=%ld\n",
; 2192 :                     pTemp->m_mtResolvedStart, pSeg->m_mtResolvedStart);
; 2193 :                 fNotDone = FALSE;

  0021e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fNotDone$[ebp], 0

; 2194 :                 PrepSegToPlay(pSeg, true);

  00225	6a 01		 push	 1
  00227	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0022a	51		 push	 ecx
  0022b	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	e8 00 00 00 00	 call	 ?PrepSegToPlay@CPerformance@@AAEXPAVCSegState@@_N@Z ; CPerformance::PrepSegToPlay
$L70121:

; 2195 :             }
; 2196 :         }
; 2197 :     }
; 2198 :     if( fNotDone && (pSeg->m_rtGivenStart == 0) )

  00233	83 7d f4 00	 cmp	 DWORD PTR _fNotDone$[ebp], 0
  00237	0f 84 c8 00 00
	00		 je	 $L70139
  0023d	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00240	89 55 a0	 mov	 DWORD PTR tv634[ebp], edx
  00243	8b 45 a0	 mov	 eax, DWORD PTR tv634[ebp]
  00246	8b 4d a0	 mov	 ecx, DWORD PTR tv634[ebp]
  00249	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  0024f	0b 91 a4 00 00
	00		 or	 edx, DWORD PTR [ecx+164]
  00255	85 d2		 test	 edx, edx
  00257	0f 85 a8 00 00
	00		 jne	 $L70139

; 2199 :     {
; 2200 :         // if the given start time is 0, it means play now.
; 2201 :         MUSIC_TIME mtStart;
; 2202 :         REFERENCE_TIME rtStart;
; 2203 : 
; 2204 :         GetQueueTime( &rtStart );

  0025d	8d 45 d0	 lea	 eax, DWORD PTR _rtStart$70141[ebp]
  00260	50		 push	 eax
  00261	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00264	8b 11		 mov	 edx, DWORD PTR [ecx]
  00266	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00269	50		 push	 eax
  0026a	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 2205 :         ReferenceToMusicTime( rtStart, &mtStart );

  00270	8d 4d dc	 lea	 ecx, DWORD PTR _mtStart$70140[ebp]
  00273	51		 push	 ecx
  00274	8b 55 d4	 mov	 edx, DWORD PTR _rtStart$70141[ebp+4]
  00277	52		 push	 edx
  00278	8b 45 d0	 mov	 eax, DWORD PTR _rtStart$70141[ebp]
  0027b	50		 push	 eax
  0027c	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00281	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00284	50		 push	 eax
  00285	ff 52 18	 call	 DWORD PTR [edx+24]

; 2206 :         pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;

  00288	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0028b	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0028e	83 e2 bf	 and	 edx, -65		; ffffffbfH
  00291	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00294	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 2207 :         pSeg->m_rtGivenStart = mtStart;

  00297	8b 45 dc	 mov	 eax, DWORD PTR _mtStart$70140[ebp]
  0029a	99		 cdq
  0029b	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0029e	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  002a4	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx

; 2208 :         // we definitely want to get rid of all segments following
; 2209 :         // the currently playing segment
; 2210 :         if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )

  002aa	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  002ad	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002b0	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002b5	85 c0		 test	 eax, eax
  002b7	74 4c		 je	 SHORT $L70139
$L70144:

; 2211 :         {
; 2212 :             while( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead()->GetNext() )

  002b9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002bf	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002c4	8b c8		 mov	 ecx, eax
  002c6	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  002cb	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  002ce	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  002d2	74 31		 je	 SHORT $L70139

; 2213 :             {
; 2214 :                 m_SegStateQueues[SQ_PRI_PLAY].Remove(pTemp);

  002d4	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  002d7	52		 push	 edx
  002d8	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  002db	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002de	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 2215 :                 pTemp->AbortPlay(mtStart,FALSE);

  002e3	6a 00		 push	 0
  002e5	8b 45 dc	 mov	 eax, DWORD PTR _mtStart$70140[ebp]
  002e8	50		 push	 eax
  002e9	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  002ec	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 2216 :                 m_ShutDownQueue.Insert(pTemp); 

  002f1	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  002f4	51		 push	 ecx
  002f5	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f8	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  002fe	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2217 :             }

  00303	eb b4		 jmp	 SHORT $L70144
$L70139:

; 2218 :         }
; 2219 :     }
; 2220 :     if( fNotDone && pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )

  00305	83 7d f4 00	 cmp	 DWORD PTR _fNotDone$[ebp], 0
  00309	0f 84 d9 00 00
	00		 je	 $L70146
  0030f	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00312	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00315	83 e0 40	 and	 eax, 64			; 00000040H
  00318	85 c0		 test	 eax, eax
  0031a	0f 84 c8 00 00
	00		 je	 $L70146

; 2221 :     {
; 2222 :         // rtStartTime is in RefTime units. 
; 2223 :         // We can convert this to Music Time immediately if either there
; 2224 :         // is no currently playing Primary Segment, or the conversion
; 2225 :         // falls within the time that has already played. If the time
; 2226 :         // falls within PREPARE_TIME, we need to get this Segment
; 2227 :         // playing right away.
; 2228 :         REFERENCE_TIME rtNow = GetLatencyWithPrePlay() + PREPARE_TIME + (200 * REF_PER_MIL); //m_rtQueuePosition;

  00320	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00323	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00328	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0032b	03 81 c8 02 00
	00		 add	 eax, DWORD PTR [ecx+712]
  00331	13 91 cc 02 00
	00		 adc	 edx, DWORD PTR [ecx+716]
  00337	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0033a	8b 89 dc 02 00
	00		 mov	 ecx, DWORD PTR [ecx+732]
  00340	69 c9 10 27 00
	00		 imul	 ecx, 10000		; 00002710H
  00346	33 f6		 xor	 esi, esi
  00348	03 c1		 add	 eax, ecx
  0034a	13 d6		 adc	 edx, esi
  0034c	05 80 84 1e 00	 add	 eax, 2000000		; 001e8480H
  00351	83 d2 00	 adc	 edx, 0
  00354	89 45 c8	 mov	 DWORD PTR _rtNow$70147[ebp], eax
  00357	89 55 cc	 mov	 DWORD PTR _rtNow$70147[ebp+4], edx

; 2229 :         MUSIC_TIME mtTime;
; 2230 :         if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() || ( pSeg->m_rtGivenStart <= rtNow ) )

  0035a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0035d	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00360	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  00365	85 c0		 test	 eax, eax
  00367	75 24		 jne	 SHORT $L70150
  00369	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0036c	89 55 9c	 mov	 DWORD PTR tv696[ebp], edx
  0036f	8b 45 9c	 mov	 eax, DWORD PTR tv696[ebp]
  00372	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00378	3b 4d cc	 cmp	 ecx, DWORD PTR _rtNow$70147[ebp+4]
  0037b	7f 55		 jg	 SHORT $L70149
  0037d	7c 0e		 jl	 SHORT $L70150
  0037f	8b 55 9c	 mov	 edx, DWORD PTR tv696[ebp]
  00382	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00388	3b 45 c8	 cmp	 eax, DWORD PTR _rtNow$70147[ebp]
  0038b	77 45		 ja	 SHORT $L70149
$L70150:

; 2231 :         {
; 2232 :             ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );

  0038d	8d 4d c4	 lea	 ecx, DWORD PTR _mtTime$70148[ebp]
  00390	51		 push	 ecx
  00391	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00394	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0039a	50		 push	 eax
  0039b	8b 8a a0 00 00
	00		 mov	 ecx, DWORD PTR [edx+160]
  003a1	51		 push	 ecx
  003a2	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  003a5	8b 02		 mov	 eax, DWORD PTR [edx]
  003a7	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  003aa	51		 push	 ecx
  003ab	ff 50 18	 call	 DWORD PTR [eax+24]

; 2233 :             pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );

  003ae	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  003b1	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  003b4	83 e0 bf	 and	 eax, -65		; ffffffbfH
  003b7	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  003ba	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 2234 :             pSeg->m_rtGivenStart = mtTime;

  003bd	8b 45 c4	 mov	 eax, DWORD PTR _mtTime$70148[ebp]
  003c0	99		 cdq
  003c1	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  003c4	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  003ca	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx

; 2235 :             // let the block of code below that handles music time
; 2236 :             // deal with it from here on
; 2237 :         }
; 2238 :         else

  003d0	eb 16		 jmp	 SHORT $L70146
$L70149:

; 2239 :         {
; 2240 :             // Otherwise, we must wait until rtStartTime
; 2241 :             // has been performed in order to convert to music time, because
; 2242 :             // we require the tempo map at that time to do the conversion.
; 2243 :             // This will be handled by the Transport code.
; 2244 :             m_SegStateQueues[SQ_PRI_WAIT].Insert(pSeg);

  003d2	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  003d5	52		 push	 edx
  003d6	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  003d9	83 c1 44	 add	 ecx, 68			; 00000044H
  003dc	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2245 :             fNotDone = FALSE; // prevents the next block of code from operating on

  003e1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fNotDone$[ebp], 0
$L70146:

; 2246 :                         // this Segment.
; 2247 :         }
; 2248 :     }
; 2249 :     if( fNotDone ) // music time

  003e8	83 7d f4 00	 cmp	 DWORD PTR _fNotDone$[ebp], 0
  003ec	0f 84 7c 05 00
	00		 je	 $L70152

; 2250 :     {
; 2251 :         // if we're in music time units, we can queue this segment in the
; 2252 :         // main queue, in time order. If this segment's music time is less
; 2253 :         // than the start time of other segments in the queue, all of those
; 2254 :         // segments are removed and discarded. Also, segments that are in
; 2255 :         // the wait queue as RefTime are discarded.
; 2256 :         
; 2257 :         ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_rtGivenStart must be in music time

  003f2	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  003f5	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  003f8	83 e1 40	 and	 ecx, 64			; 00000040H
  003fb	85 c9		 test	 ecx, ecx
  003fd	74 17		 je	 SHORT $L70153
  003ff	6a 00		 push	 0
  00401	68 d1 08 00 00	 push	 2257			; 000008d1H
  00406	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  0040b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@JDNMBECK@?$CB?$CIpSeg?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_@
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70153:

; 2258 :         CalculateSegmentStartTime( pSeg );

  00416	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00419	52		 push	 edx
  0041a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0041d	e8 00 00 00 00	 call	 ?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::CalculateSegmentStartTime
$L70156:

; 2259 :         while( (pTemp = m_SegStateQueues[SQ_PRI_WAIT].RemoveHead()) )

  00422	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00425	83 c1 44	 add	 ecx, 68			; 00000044H
  00428	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  0042d	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  00430	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  00434	74 25		 je	 SHORT $L70157

; 2260 :         {
; 2261 :             pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);

  00436	6a 00		 push	 0
  00438	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0043b	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0043e	51		 push	 ecx
  0043f	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00442	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 2262 :             m_ShutDownQueue.Insert(pTemp);

  00447	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  0044a	52		 push	 edx
  0044b	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0044e	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00454	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2263 :         }

  00459	eb c7		 jmp	 SHORT $L70156
$L70157:

; 2264 :         if( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead() )

  0045b	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0045e	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00461	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00466	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  00469	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  0046d	0f 84 ad 04 00
	00		 je	 $L70158

; 2265 :         {
; 2266 :             if( pSeg->m_mtResolvedStart > pTemp->m_mtResolvedStart )

  00473	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00476	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00479	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0047c	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  0047f	0f 8e f4 00 00
	00		 jle	 $L70159
$L70161:

; 2267 :             {
; 2268 :                 while( pTemp->GetNext() )

  00485	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00488	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0048d	85 c0		 test	 eax, eax
  0048f	74 22		 je	 SHORT $L70162

; 2269 :                 {
; 2270 :                     if( pTemp->GetNext()->m_mtResolvedStart >= pSeg->m_mtResolvedStart )

  00491	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00494	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00499	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0049c	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0049f	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  004a2	7c 02		 jl	 SHORT $L70163

; 2271 :                     {
; 2272 :                         break;

  004a4	eb 0d		 jmp	 SHORT $L70162
$L70163:

; 2273 :                     }
; 2274 :                     pTemp = pTemp->GetNext();

  004a6	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  004a9	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  004ae	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax

; 2275 :                 }

  004b1	eb d2		 jmp	 SHORT $L70161
$L70162:

; 2276 :                 pSeg->SetNext(pTemp->GetNext());

  004b3	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  004b6	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  004bb	89 45 98	 mov	 DWORD PTR tv295[ebp], eax
  004be	83 7d 98 00	 cmp	 DWORD PTR tv295[ebp], 0
  004c2	74 0b		 je	 SHORT $L75314
  004c4	8b 45 98	 mov	 eax, DWORD PTR tv295[ebp]
  004c7	83 c0 08	 add	 eax, 8
  004ca	89 45 94	 mov	 DWORD PTR tv298[ebp], eax
  004cd	eb 07		 jmp	 SHORT $L75315
$L75314:
  004cf	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv298[ebp], 0
$L75315:
  004d6	8b 4d 94	 mov	 ecx, DWORD PTR tv298[ebp]
  004d9	51		 push	 ecx
  004da	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  004dd	83 c1 08	 add	 ecx, 8
  004e0	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 2277 :                 pTemp->SetNext(pSeg);

  004e5	83 7d 08 00	 cmp	 DWORD PTR _pSeg$[ebp], 0
  004e9	74 0b		 je	 SHORT $L75316
  004eb	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  004ee	83 c2 08	 add	 edx, 8
  004f1	89 55 90	 mov	 DWORD PTR tv304[ebp], edx
  004f4	eb 07		 jmp	 SHORT $L75317
$L75316:
  004f6	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv304[ebp], 0
$L75317:
  004fd	8b 45 90	 mov	 eax, DWORD PTR tv304[ebp]
  00500	50		 push	 eax
  00501	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00504	83 c1 08	 add	 ecx, 8
  00507	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L70165:

; 2278 :                 while( pTemp = pSeg->GetNext() )

  0050c	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0050f	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00514	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  00517	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  0051b	74 57		 je	 SHORT $L70166

; 2279 :                 {
; 2280 :                     // delete the remaining pSegs after this one
; 2281 :                     pSeg->SetNext(pTemp->GetNext());

  0051d	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00520	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00525	89 45 8c	 mov	 DWORD PTR tv313[ebp], eax
  00528	83 7d 8c 00	 cmp	 DWORD PTR tv313[ebp], 0
  0052c	74 0b		 je	 SHORT $L75318
  0052e	8b 4d 8c	 mov	 ecx, DWORD PTR tv313[ebp]
  00531	83 c1 08	 add	 ecx, 8
  00534	89 4d 88	 mov	 DWORD PTR tv316[ebp], ecx
  00537	eb 07		 jmp	 SHORT $L75319
$L75318:
  00539	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv316[ebp], 0
$L75319:
  00540	8b 55 88	 mov	 edx, DWORD PTR tv316[ebp]
  00543	52		 push	 edx
  00544	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00547	83 c1 08	 add	 ecx, 8
  0054a	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 2282 :                     pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);

  0054f	6a 00		 push	 0
  00551	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00554	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00557	51		 push	 ecx
  00558	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  0055b	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 2283 :                     m_ShutDownQueue.Insert(pTemp); 

  00560	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  00563	52		 push	 edx
  00564	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00567	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0056d	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2284 :                 }

  00572	eb 98		 jmp	 SHORT $L70165
$L70166:

; 2285 :             }
; 2286 :             else

  00574	e9 73 01 00 00	 jmp	 $L70167
$L70159:

; 2287 :             {
; 2288 :                 if( !pTemp->m_fStartedPlay )

  00579	8b 45 fc	 mov	 eax, DWORD PTR _pTemp$[ebp]
  0057c	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [eax+260], 0
  00583	0f 85 95 00 00
	00		 jne	 $L70168
$L70170:

; 2289 :                 {
; 2290 :                     // blow away the entire queue
; 2291 :                     while( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )

  00589	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0058c	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0058f	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00594	85 c0		 test	 eax, eax
  00596	74 33		 je	 SHORT $L70171

; 2292 :                     {
; 2293 :                         pTemp = m_SegStateQueues[SQ_PRI_PLAY].RemoveHead();

  00598	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0059b	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0059e	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  005a3	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax

; 2294 :                         pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);

  005a6	6a 00		 push	 0
  005a8	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  005ab	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  005ae	52		 push	 edx
  005af	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  005b2	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 2295 :                         m_ShutDownQueue.Insert(pTemp); 

  005b7	8b 45 fc	 mov	 eax, DWORD PTR _pTemp$[ebp]
  005ba	50		 push	 eax
  005bb	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  005be	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  005c4	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2296 :                     }

  005c9	eb be		 jmp	 SHORT $L70170
$L70171:

; 2297 :                     m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);

  005cb	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  005ce	51		 push	 ecx
  005cf	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  005d2	83 c1 5c	 add	 ecx, 92			; 0000005cH
  005d5	e8 00 00 00 00	 call	 ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::AddHead

; 2298 :                     // give this a chance to start performing if it's near
; 2299 :                     // enough to time
; 2300 :                     if( fInCrSec )

  005da	83 7d f8 00	 cmp	 DWORD PTR _fInCrSec$[ebp], 0
  005de	74 17		 je	 SHORT $L70172

; 2301 :                     {
; 2302 :                         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  005e0	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  005e3	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  005e9	52		 push	 edx
  005ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2303 :                         fInCrSec = FALSE;

  005f0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 0
$L70172:

; 2304 :                     }
; 2305 :                     SyncTimeSig( pSeg );

  005f7	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  005fa	50		 push	 eax
  005fb	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  005fe	e8 00 00 00 00	 call	 ?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::SyncTimeSig

; 2306 :                     ManageControllingTracks();

  00603	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00606	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks

; 2307 :                     PerformSegStNode( SQ_PRI_PLAY,pSeg);

  0060b	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0060e	51		 push	 ecx
  0060f	6a 03		 push	 3
  00611	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00614	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode

; 2308 :                 }
; 2309 :                 else

  00619	e9 ce 00 00 00	 jmp	 $L70167
$L70168:

; 2310 :                 {
; 2311 :                     // else, place this segment after the current one
; 2312 :                     // and count on the routine below to take care of dequeing
; 2313 :                     // the current one, because in this case m_mtLastPlayed
; 2314 :                     // must be greater than m_mtResolvedStart.
; 2315 :                     if ( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtLastPlayed <= 
; 2316 :                         m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart )

  0061e	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00621	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00624	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00629	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0062c	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0062f	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead

; 2317 :                     {
; 2318 :                         TraceI(0,"Current Primary segment has not started playing.\n");
; 2319 :                     }
; 2320 :                     m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);

  00634	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00637	50		 push	 eax
  00638	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0063b	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0063e	e8 00 00 00 00	 call	 ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::AddHead

; 2321 :                     MUSIC_TIME mtTime = pSeg->m_mtResolvedStart;

  00643	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00646	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00649	89 55 c0	 mov	 DWORD PTR _mtTime$70176[ebp], edx
$L70178:

; 2322 :                     while( pTemp = pSeg->GetNext() )

  0064c	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0064f	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00654	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  00657	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  0065b	0f 84 8b 00 00
	00		 je	 $L70167

; 2323 :                     {
; 2324 :                         pTemp->AbortPlay( mtTime, TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) );

  00661	b8 01 00 00 00	 mov	 eax, 1
  00666	85 c0		 test	 eax, eax
  00668	74 19		 je	 SHORT $L75320
  0066a	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0066d	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00670	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  00676	85 d2		 test	 edx, edx
  00678	74 09		 je	 SHORT $L75320
  0067a	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv381[ebp], 1
  00681	eb 07		 jmp	 SHORT $L75321
$L75320:
  00683	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv381[ebp], 0
$L75321:
  0068a	8b 45 84	 mov	 eax, DWORD PTR tv381[ebp]
  0068d	50		 push	 eax
  0068e	8b 4d c0	 mov	 ecx, DWORD PTR _mtTime$70176[ebp]
  00691	51		 push	 ecx
  00692	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00695	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 2325 :                         // delete the remaining pSegs after this one
; 2326 :                         pSeg->SetNext(pTemp->GetNext());

  0069a	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  0069d	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  006a2	89 45 80	 mov	 DWORD PTR tv387[ebp], eax
  006a5	83 7d 80 00	 cmp	 DWORD PTR tv387[ebp], 0
  006a9	74 0e		 je	 SHORT $L75322
  006ab	8b 55 80	 mov	 edx, DWORD PTR tv387[ebp]
  006ae	83 c2 08	 add	 edx, 8
  006b1	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv390[ebp], edx
  006b7	eb 0a		 jmp	 SHORT $L75323
$L75322:
  006b9	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv390[ebp], 0
$L75323:
  006c3	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv390[ebp]
  006c9	50		 push	 eax
  006ca	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  006cd	83 c1 08	 add	 ecx, 8
  006d0	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 2327 :                         m_ShutDownQueue.Insert(pTemp); 

  006d5	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  006d8	51		 push	 ecx
  006d9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  006dc	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  006e2	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2328 :                     }

  006e7	e9 60 ff ff ff	 jmp	 $L70178
$L70167:

; 2329 :                 }
; 2330 :             }
; 2331 :             // m_pPriSegQueue could have become NULL from the PerformSegStNode call above.
; 2332 :             if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() && (pSeg != m_SegStateQueues[SQ_PRI_PLAY].GetHead()) )

  006ec	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  006ef	83 c1 5c	 add	 ecx, 92			; 0000005cH
  006f2	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  006f7	85 c0		 test	 eax, eax
  006f9	0f 84 1f 02 00
	00		 je	 $L70180
  006ff	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00702	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00705	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0070a	39 45 08	 cmp	 DWORD PTR _pSeg$[ebp], eax
  0070d	0f 84 0b 02 00
	00		 je	 $L70180

; 2333 :             {
; 2334 :                 CSegState *pCurrentSeg = m_SegStateQueues[SQ_PRI_PLAY].GetHead();

  00713	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00716	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00719	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0071e	89 45 bc	 mov	 DWORD PTR _pCurrentSeg$70181[ebp], eax

; 2335 :                 if( pCurrentSeg->m_fStartedPlay &&
; 2336 :                     ( pSeg->m_mtResolvedStart <= pCurrentSeg->m_mtLastPlayed ))

  00721	8b 55 bc	 mov	 edx, DWORD PTR _pCurrentSeg$70181[ebp]
  00724	83 ba 04 01 00
	00 00		 cmp	 DWORD PTR [edx+260], 0
  0072b	0f 84 93 01 00
	00		 je	 $L70182
  00731	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00734	8b 4d bc	 mov	 ecx, DWORD PTR _pCurrentSeg$70181[ebp]
  00737	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0073a	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  0073d	0f 8f 81 01 00
	00		 jg	 $L70182

; 2337 :                 {
; 2338 :                     // If Playsegment is recursively called by the end of a previous segment in a song, don't abort.
; 2339 :                     if (!pCurrentSeg->m_fInPlay || !pCurrentSeg->m_fSongMode)

  00743	8b 45 bc	 mov	 eax, DWORD PTR _pCurrentSeg$70181[ebp]
  00746	83 b8 20 01 00
	00 00		 cmp	 DWORD PTR [eax+288], 0
  0074d	74 10		 je	 SHORT $L70184
  0074f	8b 4d bc	 mov	 ecx, DWORD PTR _pCurrentSeg$70181[ebp]
  00752	83 b9 18 01 00
	00 00		 cmp	 DWORD PTR [ecx+280], 0
  00759	0f 85 63 01 00
	00		 jne	 $L70183
$L70184:

; 2340 :                     {
; 2341 :                         // the new segment wants to play on top of stuff that's
; 2342 :                         // already been transported by the current primary segment.
; 2343 :                         pCurrentSeg->AbortPlay(pSeg->m_mtResolvedStart-1,TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));

  0075f	ba 01 00 00 00	 mov	 edx, 1
  00764	85 d2		 test	 edx, edx
  00766	74 1c		 je	 SHORT $L75324
  00768	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0076b	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0076e	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00774	85 c9		 test	 ecx, ecx
  00776	74 0c		 je	 SHORT $L75324
  00778	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv424[ebp], 1
  00782	eb 0a		 jmp	 SHORT $L75325
$L75324:
  00784	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv424[ebp], 0
$L75325:
  0078e	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv424[ebp]
  00794	52		 push	 edx
  00795	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00798	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0079b	83 e9 01	 sub	 ecx, 1
  0079e	51		 push	 ecx
  0079f	8b 4d bc	 mov	 ecx, DWORD PTR _pCurrentSeg$70181[ebp]
  007a2	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 2344 :                         m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());

  007a7	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  007aa	83 c1 5c	 add	 ecx, 92			; 0000005cH
  007ad	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead
  007b2	50		 push	 eax
  007b3	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  007b6	83 c1 74	 add	 ecx, 116		; 00000074H
  007b9	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2345 :                         // make sure none of the last played times in the past list
; 2346 :                         // are past the resolved start
; 2347 :                         for( CSegState* pSegTemp = m_SegStateQueues[SQ_PRI_DONE].GetHead(); 

  007be	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  007c1	83 c1 74	 add	 ecx, 116		; 00000074H
  007c4	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  007c9	89 45 b8	 mov	 DWORD PTR _pSegTemp$70185[ebp], eax

; 2348 :                             pSegTemp; pSegTemp = pSegTemp->GetNext() )

  007cc	eb 0b		 jmp	 SHORT $L70186
$L70187:
  007ce	8b 4d b8	 mov	 ecx, DWORD PTR _pSegTemp$70185[ebp]
  007d1	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  007d6	89 45 b8	 mov	 DWORD PTR _pSegTemp$70185[ebp], eax
$L70186:
  007d9	83 7d b8 00	 cmp	 DWORD PTR _pSegTemp$70185[ebp], 0
  007dd	74 1c		 je	 SHORT $L70188

; 2349 :                         {
; 2350 :                             if( pSegTemp->m_mtLastPlayed > pSeg->m_mtResolvedStart )

  007df	8b 55 b8	 mov	 edx, DWORD PTR _pSegTemp$70185[ebp]
  007e2	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  007e5	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  007e8	3b 48 64	 cmp	 ecx, DWORD PTR [eax+100]
  007eb	7e 0c		 jle	 SHORT $L70189

; 2351 :                             {
; 2352 :                                 pSegTemp->m_mtLastPlayed = pSeg->m_mtResolvedStart;

  007ed	8b 55 b8	 mov	 edx, DWORD PTR _pSegTemp$70185[ebp]
  007f0	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  007f3	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  007f6	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
$L70189:

; 2353 :                             }
; 2354 :                         }

  007f9	eb d3		 jmp	 SHORT $L70187
$L70188:

; 2355 :                         if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ) )

  007fb	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  007fe	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00801	25 00 80 00 10	 and	 eax, 268468224		; 10008000H
  00806	85 c0		 test	 eax, eax
  00808	75 1c		 jne	 SHORT $L70190

; 2356 :                         {
; 2357 :                             // if we set the PREPARE flag it means we specifically
; 2358 :                             // don't want to invalidate
; 2359 :                             Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );

  0080a	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0080d	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00810	52		 push	 edx
  00811	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00814	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00817	51		 push	 ecx
  00818	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  0081b	8b 02		 mov	 eax, DWORD PTR [edx]
  0081d	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00820	51		 push	 ecx
  00821	ff 50 68	 call	 DWORD PTR [eax+104]

; 2360 :                         }
; 2361 :                         else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&

  00824	eb 2f		 jmp	 SHORT $L70191
$L70190:

; 2362 :                                    !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )

  00826	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00829	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0082c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00831	85 c0		 test	 eax, eax
  00833	74 20		 je	 SHORT $L70191
  00835	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00838	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0083b	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  00841	85 d2		 test	 edx, edx
  00843	75 10		 jne	 SHORT $L70191

; 2363 :                         {
; 2364 :                             pCurrentSeg->Flush(pSeg->m_mtResolvedStart);

  00845	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00848	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0084b	51		 push	 ecx
  0084c	8b 55 bc	 mov	 edx, DWORD PTR _pCurrentSeg$70181[ebp]
  0084f	52		 push	 edx
  00850	e8 00 00 00 00	 call	 ?Flush@CSegState@@QAGJJ@Z ; CSegState::Flush
$L70191:

; 2365 :                         }
; 2366 :                         ASSERT( m_SegStateQueues[SQ_PRI_PLAY].GetHead() == pSeg ); // this should be the case

  00855	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00858	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0085b	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00860	3b 45 08	 cmp	 eax, DWORD PTR _pSeg$[ebp]
  00863	74 17		 je	 SHORT $L70193
  00865	6a 00		 push	 0
  00867	68 3e 09 00 00	 push	 2366			; 0000093eH
  0086c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  00871	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DA@DKFLICIG@m_SegStateQueues?$FLSQ_PRI_PLAY?$FN?4Ge@
  00876	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70193:

; 2367 :                         if( fInCrSec )

  0087c	83 7d f8 00	 cmp	 DWORD PTR _fInCrSec$[ebp], 0
  00880	74 16		 je	 SHORT $L70195

; 2368 :                         {
; 2369 :                             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00882	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00885	05 30 03 00 00	 add	 eax, 816		; 00000330H
  0088a	50		 push	 eax
  0088b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2370 :                             fInCrSec = FALSE;

  00891	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 0
$L70195:

; 2371 :                         }
; 2372 :                         SyncTimeSig( pSeg );

  00898	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0089b	51		 push	 ecx
  0089c	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0089f	e8 00 00 00 00	 call	 ?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::SyncTimeSig

; 2373 :                         ManageControllingTracks();

  008a4	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  008a7	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks

; 2374 :                         PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );

  008ac	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  008af	83 c1 5c	 add	 ecx, 92			; 0000005cH
  008b2	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  008b7	50		 push	 eax
  008b8	6a 03		 push	 3
  008ba	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  008bd	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode
$L70183:

; 2375 :                     }
; 2376 :                 }
; 2377 :                 else

  008c2	eb 5a		 jmp	 SHORT $L70180
$L70182:

; 2378 :                 {
; 2379 :                     if( !( pSeg->m_dwPlaySegFlags & 
; 2380 :                         (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))

  008c4	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  008c7	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  008ca	25 00 80 00 10	 and	 eax, 268468224		; 10008000H
  008cf	85 c0		 test	 eax, eax
  008d1	75 1c		 jne	 SHORT $L70197

; 2381 :                     {
; 2382 :                         Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );

  008d3	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  008d6	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  008d9	52		 push	 edx
  008da	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  008dd	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  008e0	51		 push	 ecx
  008e1	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  008e4	8b 02		 mov	 eax, DWORD PTR [edx]
  008e6	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  008e9	51		 push	 ecx
  008ea	ff 50 68	 call	 DWORD PTR [eax+104]

; 2383 :                     }
; 2384 :                     else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&

  008ed	eb 2f		 jmp	 SHORT $L70180
$L70197:

; 2385 :                              !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )

  008ef	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  008f2	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  008f5	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  008fa	85 c0		 test	 eax, eax
  008fc	74 20		 je	 SHORT $L70180
  008fe	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00901	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00904	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  0090a	85 d2		 test	 edx, edx
  0090c	75 10		 jne	 SHORT $L70180

; 2386 :                     {
; 2387 :                         pCurrentSeg->Flush(pSeg->m_mtResolvedStart);

  0090e	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00911	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00914	51		 push	 ecx
  00915	8b 55 bc	 mov	 edx, DWORD PTR _pCurrentSeg$70181[ebp]
  00918	52		 push	 edx
  00919	e8 00 00 00 00	 call	 ?Flush@CSegState@@QAGJJ@Z ; CSegState::Flush
$L70180:

; 2388 :                     }
; 2389 :                 }
; 2390 :             }
; 2391 :         }
; 2392 :         else

  0091e	eb 4e		 jmp	 SHORT $L70152
$L70158:

; 2393 :         {
; 2394 :             m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);

  00920	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00923	50		 push	 eax
  00924	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00927	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0092a	e8 00 00 00 00	 call	 ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::AddHead

; 2395 :             // give this a chance to start performing if it's near
; 2396 :             // enough to time
; 2397 :             if( fInCrSec )

  0092f	83 7d f8 00	 cmp	 DWORD PTR _fInCrSec$[ebp], 0
  00933	74 17		 je	 SHORT $L70201

; 2398 :             {
; 2399 :                 LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00935	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00938	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  0093e	51		 push	 ecx
  0093f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2400 :                 fInCrSec = FALSE;

  00945	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 0
$L70201:

; 2401 :             }
; 2402 : 			//DWORD dwDebugTime = timeGetTime();
; 2403 :             SyncTimeSig( pSeg );

  0094c	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0094f	52		 push	 edx
  00950	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00953	e8 00 00 00 00	 call	 ?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::SyncTimeSig

; 2404 : 			//DWORD dwDebugTime2 = timeGetTime();
; 2405 : 			//Trace(0, "perf, debugtime SyncTimeSig %u\n", dwDebugTime2 - dwDebugTime);
; 2406 : 
; 2407 :             ManageControllingTracks();

  00958	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0095b	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks

; 2408 : 			//dwDebugTime = timeGetTime();
; 2409 : 			//Trace(0, "perf, debugtime ManageControllingTracks %u\n", dwDebugTime - dwDebugTime2);
; 2410 : 
; 2411 :             PerformSegStNode( SQ_PRI_PLAY,pSeg );

  00960	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00963	50		 push	 eax
  00964	6a 03		 push	 3
  00966	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00969	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode
$L70152:

; 2412 : 			//dwDebugTime2 = timeGetTime();
; 2413 : 			//Trace(0, "perf, debugtime PerformSegStNode %u\n", dwDebugTime2 - dwDebugTime);
; 2414 :         }
; 2415 :     }
; 2416 :     if( fInCrSec )

  0096e	83 7d f8 00	 cmp	 DWORD PTR _fInCrSec$[ebp], 0
  00972	74 10		 je	 SHORT $L70117

; 2417 :     {
; 2418 :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00974	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00977	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  0097d	51		 push	 ecx
  0097e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L70117:

; 2419 :     }
; 2420 : }

  00984	5e		 pop	 esi
  00985	8b e5		 mov	 esp, ebp
  00987	5d		 pop	 ebp
  00988	c2 04 00	 ret	 4
?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z ENDP ; CPerformance::QueuePrimarySegment
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT
tv302 = -56
tv248 = -52
_this$ = -48
_pNode$70231 = -44
_pNext$70232 = -40
_mtTime$70219 = -36
_rtNow$70216 = -32
_rtStart$70213 = -24
_mtStart$70211 = -12
_fNotDone$ = -8
_fInCrSec$ = -4
_pSeg$ = 8
?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z PROC NEAR ; CPerformance::QueueSecondarySegment, COMDAT
; _this$ = ecx

; 2425 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 2426 :     BOOL fInCrSec = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 0

; 2427 :     BOOL fNotDone = TRUE;

  00010	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fNotDone$[ebp], 1

; 2428 : 
; 2429 :     if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )

  00017	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  0001a	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0001d	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00023	85 c9		 test	 ecx, ecx
  00025	74 17		 je	 SHORT $L70209

; 2430 :     {
; 2431 :         ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00027	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  00030	52		 push	 edx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2432 :         fInCrSec = TRUE;

  00037	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 1
$L70209:

; 2433 :     }
; 2434 :     pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE; // not legal for 2ndary segs.

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00041	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00044	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  0004a	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0004d	89 4a 5c	 mov	 DWORD PTR [edx+92], ecx

; 2435 :     if( pSeg->m_rtGivenStart == 0 )

  00050	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00053	89 45 cc	 mov	 DWORD PTR tv248[ebp], eax
  00056	8b 4d cc	 mov	 ecx, DWORD PTR tv248[ebp]
  00059	8b 55 cc	 mov	 edx, DWORD PTR tv248[ebp]
  0005c	8b 81 a0 00 00
	00		 mov	 eax, DWORD PTR [ecx+160]
  00062	0b 82 a4 00 00
	00		 or	 eax, DWORD PTR [edx+164]
  00068	85 c0		 test	 eax, eax
  0006a	75 7d		 jne	 SHORT $L70210

; 2436 :     {
; 2437 :         MUSIC_TIME mtStart;
; 2438 :         
; 2439 :         if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  0006f	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00072	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00078	85 d2		 test	 edx, edx
  0007a	74 2d		 je	 SHORT $L70212

; 2440 :         {
; 2441 :             REFERENCE_TIME rtStart;
; 2442 :             GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations

  0007c	8d 45 e8	 lea	 eax, DWORD PTR _rtStart$70213[ebp]
  0007f	50		 push	 eax
  00080	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00088	50		 push	 eax
  00089	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 2443 :             ReferenceToMusicTime( rtStart, &mtStart );

  0008f	8d 4d f4	 lea	 ecx, DWORD PTR _mtStart$70211[ebp]
  00092	51		 push	 ecx
  00093	8b 55 ec	 mov	 edx, DWORD PTR _rtStart$70213[ebp+4]
  00096	52		 push	 edx
  00097	8b 45 e8	 mov	 eax, DWORD PTR _rtStart$70213[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	50		 push	 eax
  000a4	ff 52 18	 call	 DWORD PTR [edx+24]

; 2444 :         }
; 2445 :         else

  000a7	eb 1e		 jmp	 SHORT $L70214
$L70212:

; 2446 :         {
; 2447 :             ReferenceToMusicTime( GetBestSegLatency(pSeg), &mtStart );

  000a9	8d 4d f4	 lea	 ecx, DWORD PTR _mtStart$70211[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000b0	52		 push	 edx
  000b1	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z ; CPerformance::GetBestSegLatency
  000b9	52		 push	 edx
  000ba	50		 push	 eax
  000bb	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  000c3	52		 push	 edx
  000c4	ff 51 18	 call	 DWORD PTR [ecx+24]
$L70214:

; 2448 :         }
; 2449 :         pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  000ca	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  000cd	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  000d0	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000d3	89 4a 5c	 mov	 DWORD PTR [edx+92], ecx

; 2450 :         pSeg->m_rtGivenStart = mtStart;

  000d6	8b 45 f4	 mov	 eax, DWORD PTR _mtStart$70211[ebp]
  000d9	99		 cdq
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  000dd	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  000e3	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx
$L70210:

; 2451 :     }
; 2452 : 
; 2453 :     if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )

  000e9	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  000ec	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000ef	83 e0 40	 and	 eax, 64			; 00000040H
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 01 01 00
	00		 je	 $L70215

; 2454 :     {
; 2455 :         // rtStartTime is in RefTime units. 
; 2456 :         // We can convert this to Music Time immediately if either there
; 2457 :         // is no currently playing Primary Segment, or the conversion
; 2458 :         // falls within the time that has already played. If the time
; 2459 :         // falls within PREPARE_TIME, we need to get this Segment
; 2460 :         // playing right away.
; 2461 :         REFERENCE_TIME rtNow;
; 2462 :         if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  000fd	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00100	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00106	85 d2		 test	 edx, edx
  00108	74 15		 je	 SHORT $L70217

; 2463 :         {
; 2464 :             GetQueueTime( &rtNow ); // need queue time because control segments cause invalidations

  0010a	8d 45 e0	 lea	 eax, DWORD PTR _rtNow$70216[ebp]
  0010d	50		 push	 eax
  0010e	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	8b 11		 mov	 edx, DWORD PTR [ecx]
  00113	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00116	50		 push	 eax
  00117	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 2465 :         }
; 2466 :         else

  0011d	eb 12		 jmp	 SHORT $L70218
$L70217:

; 2467 :         {
; 2468 :             rtNow = GetBestSegLatency(pSeg);

  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00122	51		 push	 ecx
  00123	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	e8 00 00 00 00	 call	 ?GetBestSegLatency@CPerformance@@AAE_JPAVCSegState@@@Z ; CPerformance::GetBestSegLatency
  0012b	89 45 e0	 mov	 DWORD PTR _rtNow$70216[ebp], eax
  0012e	89 55 e4	 mov	 DWORD PTR _rtNow$70216[ebp+4], edx
$L70218:

; 2469 :         }
; 2470 :         MUSIC_TIME mtTime;
; 2471 :         if( pSeg->m_rtGivenStart <= rtNow )

  00131	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00134	89 55 c8	 mov	 DWORD PTR tv302[ebp], edx
  00137	8b 45 c8	 mov	 eax, DWORD PTR tv302[ebp]
  0013a	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00140	3b 4d e4	 cmp	 ecx, DWORD PTR _rtNow$70216[ebp+4]
  00143	7f 4c		 jg	 SHORT $L70220
  00145	7c 0e		 jl	 SHORT $L75332
  00147	8b 55 c8	 mov	 edx, DWORD PTR tv302[ebp]
  0014a	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00150	3b 45 e0	 cmp	 eax, DWORD PTR _rtNow$70216[ebp]
  00153	77 3c		 ja	 SHORT $L70220
$L75332:

; 2472 :         {
; 2473 :             ReferenceToMusicTime( rtNow, &mtTime );

  00155	8d 4d dc	 lea	 ecx, DWORD PTR _mtTime$70219[ebp]
  00158	51		 push	 ecx
  00159	8b 55 e4	 mov	 edx, DWORD PTR _rtNow$70216[ebp+4]
  0015c	52		 push	 edx
  0015d	8b 45 e0	 mov	 eax, DWORD PTR _rtNow$70216[ebp]
  00160	50		 push	 eax
  00161	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	8b 11		 mov	 edx, DWORD PTR [ecx]
  00166	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00169	50		 push	 eax
  0016a	ff 52 18	 call	 DWORD PTR [edx+24]

; 2474 :             pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );

  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00170	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00173	83 e2 bf	 and	 edx, -65		; ffffffbfH
  00176	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00179	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 2475 :             pSeg->m_rtGivenStart = mtTime;

  0017c	8b 45 dc	 mov	 eax, DWORD PTR _mtTime$70219[ebp]
  0017f	99		 cdq
  00180	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00183	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  00189	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx

; 2476 :             // let the block of code below that handles music time
; 2477 :             // deal with it from here on
; 2478 :         }
; 2479 :         else if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() )

  0018f	eb 6a		 jmp	 SHORT $L70215
$L70220:
  00191	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00197	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  0019c	85 c0		 test	 eax, eax
  0019e	74 45		 je	 SHORT $L70222

; 2480 :         {
; 2481 :             ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );

  001a0	8d 55 dc	 lea	 edx, DWORD PTR _mtTime$70219[ebp]
  001a3	52		 push	 edx
  001a4	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001a7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001ad	51		 push	 ecx
  001ae	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  001b4	52		 push	 edx
  001b5	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  001bd	52		 push	 edx
  001be	ff 51 18	 call	 DWORD PTR [ecx+24]

; 2482 :             pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );

  001c1	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  001c4	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  001c7	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  001ca	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  001cd	89 4a 5c	 mov	 DWORD PTR [edx+92], ecx

; 2483 :             pSeg->m_rtGivenStart = mtTime;

  001d0	8b 45 dc	 mov	 eax, DWORD PTR _mtTime$70219[ebp]
  001d3	99		 cdq
  001d4	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  001d7	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  001dd	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx

; 2484 :         }
; 2485 :         else

  001e3	eb 16		 jmp	 SHORT $L70215
$L70222:

; 2486 :         {
; 2487 :             // Otherwise, we must wait until rtStartTime
; 2488 :             // has been performed in order to convert to music time, because
; 2489 :             // we require the tempo map at that time to do the conversion.
; 2490 :             // This will be handled by the Transport code.
; 2491 :             m_SegStateQueues[SQ_SEC_WAIT].Insert(pSeg);

  001e5	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  001e8	52		 push	 edx
  001e9	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ec	83 c1 54	 add	 ecx, 84			; 00000054H
  001ef	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2492 :             fNotDone = FALSE; // prevents the next block of code from operating on

  001f4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fNotDone$[ebp], 0
$L70215:

; 2493 :                         // this Segment.
; 2494 :         }
; 2495 :     }
; 2496 : 
; 2497 :     if( fNotDone ) // music time

  001fb	83 7d f8 00	 cmp	 DWORD PTR _fNotDone$[ebp], 0
  001ff	0f 84 18 01 00
	00		 je	 $L70224

; 2498 :     {
; 2499 :         // if we're in music time units, we can queue this segment in the
; 2500 :         // main queue, in time order. If this segment's music time is less
; 2501 :         // than the start time of other segments in the queue, all of those
; 2502 :         // segments are removed and discarded.
; 2503 :         ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_m_rtGivenStart must be in music time

  00205	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00208	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0020b	83 e1 40	 and	 ecx, 64			; 00000040H
  0020e	85 c9		 test	 ecx, ecx
  00210	74 17		 je	 SHORT $L70225
  00212	6a 00		 push	 0
  00214	68 c7 09 00 00	 push	 2503			; 000009c7H
  00219	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  0021e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@JDNMBECK@?$CB?$CIpSeg?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_@
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70225:

; 2504 :         CalculateSegmentStartTime( pSeg );

  00229	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  0022c	52		 push	 edx
  0022d	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	e8 00 00 00 00	 call	 ?CalculateSegmentStartTime@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::CalculateSegmentStartTime

; 2505 :         TraceI(2,"Queuing 2ndary seg time %ld\n",pSeg->m_mtResolvedStart);
; 2506 :         if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL)

  00235	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00238	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0023b	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00241	85 c9		 test	 ecx, ecx
  00243	74 3e		 je	 SHORT $L70227

; 2507 :         {
; 2508 :             m_SegStateQueues[SQ_CON_PLAY].Insert( pSeg );

  00245	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00248	52		 push	 edx
  00249	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	83 c1 64	 add	 ecx, 100		; 00000064H
  0024f	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 2509 :             // If this is a control segment, we need to do an invalidate.
; 2510 :             if(!(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )

  00254	8b 45 08	 mov	 eax, DWORD PTR _pSeg$[ebp]
  00257	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0025a	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00260	85 c9		 test	 ecx, ecx
  00262	75 1d		 jne	 SHORT $L70228

; 2511 :             {
; 2512 :                 ManageControllingTracks();

  00264	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00267	e8 00 00 00 00	 call	 ?ManageControllingTracks@CPerformance@@AAEXXZ ; CPerformance::ManageControllingTracks

; 2513 :                 Invalidate( pSeg->m_mtResolvedStart, 0 );

  0026c	6a 00		 push	 0
  0026e	8b 55 08	 mov	 edx, DWORD PTR _pSeg$[ebp]
  00271	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00274	50		 push	 eax
  00275	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00278	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027a	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0027d	50		 push	 eax
  0027e	ff 52 68	 call	 DWORD PTR [edx+104]
$L70228:

; 2514 :             }
; 2515 :         }
; 2516 :         else

  00281	eb 0f		 jmp	 SHORT $L70229
$L70227:

; 2517 :         {
; 2518 :             m_SegStateQueues[SQ_SEC_PLAY].Insert( pSeg );

  00283	8b 4d 08	 mov	 ecx, DWORD PTR _pSeg$[ebp]
  00286	51		 push	 ecx
  00287	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0028d	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L70229:

; 2519 :         }
; 2520 :         // give this a chance to start performing if it's near
; 2521 :         // enough to time
; 2522 :         if( fInCrSec )

  00292	83 7d fc 00	 cmp	 DWORD PTR _fInCrSec$[ebp], 0
  00296	74 17		 je	 SHORT $L70230

; 2523 :         {
; 2524 :             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00298	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0029b	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  002a1	52		 push	 edx
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2525 :             fInCrSec = FALSE;

  002a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fInCrSec$[ebp], 0
$L70230:

; 2526 :         }
; 2527 :         // play the secondary segments
; 2528 :         CSegState *pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();

  002af	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  002b2	83 c1 6c	 add	 ecx, 108		; 0000006cH
  002b5	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002ba	89 45 d4	 mov	 DWORD PTR _pNode$70231[ebp], eax

; 2529 :         CSegState *pNext;
; 2530 :         for(; pNode != NULL; pNode = pNext)

  002bd	eb 06		 jmp	 SHORT $L70233
$L70234:
  002bf	8b 45 d8	 mov	 eax, DWORD PTR _pNext$70232[ebp]
  002c2	89 45 d4	 mov	 DWORD PTR _pNode$70231[ebp], eax
$L70233:
  002c5	83 7d d4 00	 cmp	 DWORD PTR _pNode$70231[ebp], 0
  002c9	74 1b		 je	 SHORT $L70235

; 2531 :         {
; 2532 :             pNext = pNode->GetNext();

  002cb	8b 4d d4	 mov	 ecx, DWORD PTR _pNode$70231[ebp]
  002ce	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  002d3	89 45 d8	 mov	 DWORD PTR _pNext$70232[ebp], eax

; 2533 :             PerformSegStNode( SQ_SEC_PLAY,pNode );

  002d6	8b 4d d4	 mov	 ecx, DWORD PTR _pNode$70231[ebp]
  002d9	51		 push	 ecx
  002da	6a 05		 push	 5
  002dc	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  002df	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode

; 2534 :         }

  002e4	eb d9		 jmp	 SHORT $L70234
$L70235:

; 2535 :         // play the controlling segments
; 2536 :         pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();

  002e6	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  002e9	83 c1 64	 add	 ecx, 100		; 00000064H
  002ec	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002f1	89 45 d4	 mov	 DWORD PTR _pNode$70231[ebp], eax

; 2537 :         for(; pNode != NULL; pNode = pNext)

  002f4	eb 06		 jmp	 SHORT $L70236
$L70237:
  002f6	8b 55 d8	 mov	 edx, DWORD PTR _pNext$70232[ebp]
  002f9	89 55 d4	 mov	 DWORD PTR _pNode$70231[ebp], edx
$L70236:
  002fc	83 7d d4 00	 cmp	 DWORD PTR _pNode$70231[ebp], 0
  00300	74 1b		 je	 SHORT $L70224

; 2538 :         {
; 2539 :             pNext = pNode->GetNext();

  00302	8b 4d d4	 mov	 ecx, DWORD PTR _pNode$70231[ebp]
  00305	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0030a	89 45 d8	 mov	 DWORD PTR _pNext$70232[ebp], eax

; 2540 :             PerformSegStNode( SQ_CON_PLAY,pNode );

  0030d	8b 45 d4	 mov	 eax, DWORD PTR _pNode$70231[ebp]
  00310	50		 push	 eax
  00311	6a 04		 push	 4
  00313	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00316	e8 00 00 00 00	 call	 ?PerformSegStNode@CPerformance@@AAEXKPAVCSegState@@@Z ; CPerformance::PerformSegStNode

; 2541 :         }

  0031b	eb d9		 jmp	 SHORT $L70237
$L70224:

; 2542 :     }
; 2543 :     if( fInCrSec )

  0031d	83 7d fc 00	 cmp	 DWORD PTR _fInCrSec$[ebp], 0
  00321	74 10		 je	 SHORT $L70206

; 2544 :     {
; 2545 :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00323	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  0032c	51		 push	 ecx
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L70206:

; 2546 :     }
; 2547 : }

  00333	8b e5		 mov	 esp, ebp
  00335	5d		 pop	 ebp
  00336	c2 04 00	 ret	 4
?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z ENDP ; CPerformance::QueueSecondarySegment
_TEXT	ENDS
PUBLIC	?GetNext@CTrack@@QAEPAV1@XZ			; CTrack::GetNext
PUBLIC	?GetHead@CTrackList@@QAEPAVCTrack@@XZ		; CTrackList::GetHead
; Function compile flags: /Odt
;	COMDAT ?ManageControllingTracks@CPerformance@@AAEXXZ
_TEXT	SEGMENT
_this$ = -28
_pTrack$70282 = -24
_pPrimaryTrack$70272 = -20
_pTrack$70264 = -16
_pTrack$70247 = -12
_pSegNode$ = -8
_pControlNode$ = -4
?ManageControllingTracks@CPerformance@@AAEXXZ PROC NEAR	; CPerformance::ManageControllingTracks, COMDAT
; _this$ = ecx

; 2567 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2568 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2569 :     CSegState* pSegNode;
; 2570 :     // First, prepare all tracks in the primary segment, putting them back to normal. 
; 2571 :     // so they are ready to be reset by the controlling tracks.
; 2572 :     // To do this, check for WAS_ENABLED or WAS_DISABLED and set the appropriate flags in m_dwFlags.
; 2573 :     // Else, if these weren't set, then it's time to set them, since this is the first pass through this segment.
; 2574 :     for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )

  00018	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0001e	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00023	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
  00026	eb 0b		 jmp	 SHORT $L70244
$L70245:
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0002b	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00030	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L70244:
  00033	83 7d f8 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00037	0f 84 0d 01 00
	00		 je	 $L70246

; 2575 :     {
; 2576 :         ENTER_CRITICAL_SECTION(&pSegNode->m_CriticalSection);

  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00040	83 c1 14	 add	 ecx, 20			; 00000014H
  00043	51		 push	 ecx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2577 :         CTrack *pTrack = pSegNode->m_TrackList.GetHead();

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0004d	83 c1 44	 add	 ecx, 68			; 00000044H
  00050	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00055	89 45 f4	 mov	 DWORD PTR _pTrack$70247[ebp], eax

; 2578 :         for (;pTrack;pTrack = pTrack->GetNext())

  00058	eb 0b		 jmp	 SHORT $L70248
$L70249:
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$70247[ebp]
  0005d	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00062	89 45 f4	 mov	 DWORD PTR _pTrack$70247[ebp], eax
$L70248:
  00065	83 7d f4 00	 cmp	 DWORD PTR _pTrack$70247[ebp], 0
  00069	0f 84 c9 00 00
	00		 je	 $L70250

; 2579 :         {
; 2580 :             if (pTrack->m_dwInternalFlags) // This has been touched before.

  0006f	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  00072	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00076	74 68		 je	 SHORT $L70251

; 2581 :             {
; 2582 :                 // First transfer and reset the is disabled flags.
; 2583 :                 if (pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED)

  00078	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  0007b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0007e	83 e1 01	 and	 ecx, 1
  00081	85 c9		 test	 ecx, ecx
  00083	74 0f		 je	 SHORT $L70252

; 2584 :                 {
; 2585 :                     pTrack->m_dwInternalFlags |= CONTROL_PLAY_WAS_DISABLED;

  00085	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  00088	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0008b	83 c8 02	 or	 eax, 2
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$70247[ebp]
  00091	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$L70252:

; 2586 :                 }
; 2587 :                 pTrack->m_dwInternalFlags &= ~(CONTROL_PLAY_IS_DISABLED | CONTROL_NTFY_IS_DISABLED);

  00094	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  00097	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0009a	83 e0 de	 and	 eax, -34		; ffffffdeH
  0009d	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$70247[ebp]
  000a0	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 2588 :                 // Then, set the play flags based on the original state.
; 2589 :                 if (pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED)

  000a3	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  000a6	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000a9	83 e0 10	 and	 eax, 16			; 00000010H
  000ac	85 c0		 test	 eax, eax
  000ae	74 0f		 je	 SHORT $L70253

; 2590 :                 {
; 2591 :                     pTrack->m_dwFlags |= DMUS_TRACKCONFIG_PLAY_ENABLED;

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$70247[ebp]
  000b3	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000b6	83 ca 10	 or	 edx, 16			; 00000010H
  000b9	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  000bc	89 50 34	 mov	 DWORD PTR [eax+52], edx
$L70253:

; 2592 :                 }
; 2593 :                 if (pTrack->m_dwInternalFlags & CONTROL_NTFY_DEFAULT_ENABLED)

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$70247[ebp]
  000c2	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000c5	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  000cb	85 d2		 test	 edx, edx
  000cd	74 0f		 je	 SHORT $L70254

; 2594 :                 {
; 2595 :                     pTrack->m_dwFlags |= DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;

  000cf	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  000d2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d5	83 c9 20	 or	 ecx, 32			; 00000020H
  000d8	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  000db	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
$L70254:

; 2596 :                 }
; 2597 :             }
; 2598 :             else

  000de	eb 53		 jmp	 SHORT $L70255
$L70251:

; 2599 :             {
; 2600 :                 // Since this has never been touched before, set the flags so we can know what to return to.
; 2601 :                 if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED)

  000e0	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  000e3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000e6	83 e1 10	 and	 ecx, 16			; 00000010H
  000e9	85 c9		 test	 ecx, ecx
  000eb	74 0c		 je	 SHORT $L70256

; 2602 :                 {
; 2603 :                     pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_ENABLED;

  000ed	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  000f0	c7 42 38 10 00
	00 00		 mov	 DWORD PTR [edx+56], 16	; 00000010H

; 2604 :                 }
; 2605 :                 else

  000f7	eb 0a		 jmp	 SHORT $L70257
$L70256:

; 2606 :                 {
; 2607 :                     pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_DISABLED;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  000fc	c7 40 38 08 00
	00 00		 mov	 DWORD PTR [eax+56], 8
$L70257:

; 2608 :                 }
; 2609 :                 if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)

  00103	8b 4d f4	 mov	 ecx, DWORD PTR _pTrack$70247[ebp]
  00106	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00109	83 e2 20	 and	 edx, 32			; 00000020H
  0010c	85 d2		 test	 edx, edx
  0010e	74 14		 je	 SHORT $L70258

; 2610 :                 {
; 2611 :                     pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_ENABLED;

  00110	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  00113	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00116	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0011c	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  0011f	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 2612 :                 }
; 2613 :                 else

  00122	eb 0f		 jmp	 SHORT $L70255
$L70258:

; 2614 :                 {
; 2615 :                     pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_DISABLED;

  00124	8b 45 f4	 mov	 eax, DWORD PTR _pTrack$70247[ebp]
  00127	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0012a	83 c9 40	 or	 ecx, 64			; 00000040H
  0012d	8b 55 f4	 mov	 edx, DWORD PTR _pTrack$70247[ebp]
  00130	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$L70255:

; 2616 :                 }
; 2617 :             }
; 2618 :         }

  00133	e9 22 ff ff ff	 jmp	 $L70249
$L70250:

; 2619 :         LEAVE_CRITICAL_SECTION(&pSegNode->m_CriticalSection);

  00138	8b 45 f8	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  0013b	83 c0 14	 add	 eax, 20			; 00000014H
  0013e	50		 push	 eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2620 :     }

  00145	e9 de fe ff ff	 jmp	 $L70245
$L70246:

; 2621 :     CSegState* pControlNode;
; 2622 :     // Now, go through all the controlling segments and, for each controlling track that matches
; 2623 :     // a primary segment track, clear the enable flags on the segment track.
; 2624 :     for( pControlNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pControlNode; pControlNode = pControlNode->GetNext() )

  0014a	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	83 c1 64	 add	 ecx, 100		; 00000064H
  00150	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00155	89 45 fc	 mov	 DWORD PTR _pControlNode$[ebp], eax
  00158	eb 0b		 jmp	 SHORT $L70261
$L70262:
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _pControlNode$[ebp]
  0015d	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00162	89 45 fc	 mov	 DWORD PTR _pControlNode$[ebp], eax
$L70261:
  00165	83 7d fc 00	 cmp	 DWORD PTR _pControlNode$[ebp], 0
  00169	0f 84 6a 01 00
	00		 je	 $L70263

; 2625 :     {
; 2626 :         ENTER_CRITICAL_SECTION(&pControlNode->m_CriticalSection);

  0016f	8b 4d fc	 mov	 ecx, DWORD PTR _pControlNode$[ebp]
  00172	83 c1 14	 add	 ecx, 20			; 00000014H
  00175	51		 push	 ecx
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2627 :         CTrack *pTrack = pControlNode->m_TrackList.GetHead();

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _pControlNode$[ebp]
  0017f	83 c1 44	 add	 ecx, 68			; 00000044H
  00182	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00187	89 45 f0	 mov	 DWORD PTR _pTrack$70264[ebp], eax

; 2628 :         for (;pTrack;pTrack = pTrack->GetNext())

  0018a	eb 0b		 jmp	 SHORT $L70265
$L70266:
  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _pTrack$70264[ebp]
  0018f	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00194	89 45 f0	 mov	 DWORD PTR _pTrack$70264[ebp], eax
$L70265:
  00197	83 7d f0 00	 cmp	 DWORD PTR _pTrack$70264[ebp], 0
  0019b	0f 84 26 01 00
	00		 je	 $L70267

; 2629 :         {
; 2630 :             // If the track has never been overridden, the internal flags for IS_DISABLED should be clear.
; 2631 :             // If the track is currently overridden, the internal flags should be CONTROL_PLAY_IS_DISABLED and/or 
; 2632 :             // CONTROL_NTFY_IS_DISABLED
; 2633 :             if (pTrack->m_dwFlags & (DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION)) // This overrides playback and/or notification.

  001a1	8b 55 f0	 mov	 edx, DWORD PTR _pTrack$70264[ebp]
  001a4	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  001a7	25 00 00 03 00	 and	 eax, 196608		; 00030000H
  001ac	85 c0		 test	 eax, eax
  001ae	0f 84 0e 01 00
	00		 je	 $L70268

; 2634 :             {
; 2635 :                 for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )

  001b4	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	83 c1 5c	 add	 ecx, 92			; 0000005cH
  001ba	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001bf	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
  001c2	eb 0b		 jmp	 SHORT $L70269
$L70270:
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  001c7	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  001cc	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L70269:
  001cf	83 7d f8 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  001d3	0f 84 e9 00 00
	00		 je	 $L70268

; 2636 :                 {
; 2637 :                     ENTER_CRITICAL_SECTION(&pSegNode->m_CriticalSection);

  001d9	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  001dc	83 c1 14	 add	 ecx, 20			; 00000014H
  001df	51		 push	 ecx
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2638 :                     CTrack *pPrimaryTrack = pSegNode->m_TrackList.GetHead();

  001e6	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  001e9	83 c1 44	 add	 ecx, 68			; 00000044H
  001ec	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  001f1	89 45 ec	 mov	 DWORD PTR _pPrimaryTrack$70272[ebp], eax

; 2639 :                     for (;pPrimaryTrack;pPrimaryTrack = pPrimaryTrack->GetNext())

  001f4	eb 0b		 jmp	 SHORT $L70273
$L70274:
  001f6	8b 4d ec	 mov	 ecx, DWORD PTR _pPrimaryTrack$70272[ebp]
  001f9	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  001fe	89 45 ec	 mov	 DWORD PTR _pPrimaryTrack$70272[ebp], eax
$L70273:
  00201	83 7d ec 00	 cmp	 DWORD PTR _pPrimaryTrack$70272[ebp], 0
  00205	0f 84 a5 00 00
	00		 je	 $L70275

; 2640 :                     {
; 2641 :                         // A track matches if it has the same class id and overlapping group bits.
; 2642 :                         if ((pPrimaryTrack->m_guidClassID == pTrack->m_guidClassID) &&
; 2643 :                             (pPrimaryTrack->m_dwGroupBits & pTrack->m_dwGroupBits))

  0020b	8b 55 f0	 mov	 edx, DWORD PTR _pTrack$70264[ebp]
  0020e	83 c2 04	 add	 edx, 4
  00211	52		 push	 edx
  00212	8b 45 ec	 mov	 eax, DWORD PTR _pPrimaryTrack$70272[ebp]
  00215	83 c0 04	 add	 eax, 4
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _==@8
  0021e	85 c0		 test	 eax, eax
  00220	0f 84 85 00 00
	00		 je	 $L70276
  00226	8b 4d ec	 mov	 ecx, DWORD PTR _pPrimaryTrack$70272[ebp]
  00229	8b 55 f0	 mov	 edx, DWORD PTR _pTrack$70264[ebp]
  0022c	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0022f	23 42 28	 and	 eax, DWORD PTR [edx+40]
  00232	85 c0		 test	 eax, eax
  00234	74 75		 je	 SHORT $L70276

; 2644 :                         {
; 2645 :                             if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_PLAY) &&
; 2646 :                                 (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))

  00236	8b 4d f0	 mov	 ecx, DWORD PTR _pTrack$70264[ebp]
  00239	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0023c	81 e2 00 00 01
	00		 and	 edx, 65536		; 00010000H
  00242	85 d2		 test	 edx, edx
  00244	74 2b		 je	 SHORT $L70277
  00246	8b 45 ec	 mov	 eax, DWORD PTR _pPrimaryTrack$70272[ebp]
  00249	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0024c	83 e1 10	 and	 ecx, 16			; 00000010H
  0024f	85 c9		 test	 ecx, ecx
  00251	74 1e		 je	 SHORT $L70277

; 2647 :                             {
; 2648 :                                 pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;

  00253	8b 55 ec	 mov	 edx, DWORD PTR _pPrimaryTrack$70272[ebp]
  00256	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00259	83 e0 ef	 and	 eax, -17		; ffffffefH
  0025c	8b 4d ec	 mov	 ecx, DWORD PTR _pPrimaryTrack$70272[ebp]
  0025f	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 2649 :                                 pPrimaryTrack->m_dwInternalFlags |= CONTROL_PLAY_IS_DISABLED; // Mark so we can turn on later.

  00262	8b 55 ec	 mov	 edx, DWORD PTR _pPrimaryTrack$70272[ebp]
  00265	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00268	83 c8 01	 or	 eax, 1
  0026b	8b 4d ec	 mov	 ecx, DWORD PTR _pPrimaryTrack$70272[ebp]
  0026e	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$L70277:

; 2650 :                             }
; 2651 :                             if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION) &&
; 2652 :                                 (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))

  00271	8b 55 f0	 mov	 edx, DWORD PTR _pTrack$70264[ebp]
  00274	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00277	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  0027c	85 c0		 test	 eax, eax
  0027e	74 2b		 je	 SHORT $L70276
  00280	8b 4d ec	 mov	 ecx, DWORD PTR _pPrimaryTrack$70272[ebp]
  00283	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00286	83 e2 20	 and	 edx, 32			; 00000020H
  00289	85 d2		 test	 edx, edx
  0028b	74 1e		 je	 SHORT $L70276

; 2653 :                             {
; 2654 :                                 pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;

  0028d	8b 45 ec	 mov	 eax, DWORD PTR _pPrimaryTrack$70272[ebp]
  00290	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00293	83 e1 df	 and	 ecx, -33		; ffffffdfH
  00296	8b 55 ec	 mov	 edx, DWORD PTR _pPrimaryTrack$70272[ebp]
  00299	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 2655 :                                 pPrimaryTrack->m_dwInternalFlags |= CONTROL_NTFY_IS_DISABLED; // Mark so we can turn on later.

  0029c	8b 45 ec	 mov	 eax, DWORD PTR _pPrimaryTrack$70272[ebp]
  0029f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  002a2	83 c9 20	 or	 ecx, 32			; 00000020H
  002a5	8b 55 ec	 mov	 edx, DWORD PTR _pPrimaryTrack$70272[ebp]
  002a8	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$L70276:

; 2656 :                             }
; 2657 :                         }
; 2658 :                     }

  002ab	e9 46 ff ff ff	 jmp	 $L70274
$L70275:

; 2659 :                     LEAVE_CRITICAL_SECTION(&pSegNode->m_CriticalSection);

  002b0	8b 45 f8	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  002b3	83 c0 14	 add	 eax, 20			; 00000014H
  002b6	50		 push	 eax
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2660 :                 }

  002bd	e9 02 ff ff ff	 jmp	 $L70270
$L70268:

; 2661 :             }
; 2662 :         }

  002c2	e9 c5 fe ff ff	 jmp	 $L70266
$L70267:

; 2663 :         LEAVE_CRITICAL_SECTION(&pControlNode->m_CriticalSection);

  002c7	8b 4d fc	 mov	 ecx, DWORD PTR _pControlNode$[ebp]
  002ca	83 c1 14	 add	 ecx, 20			; 00000014H
  002cd	51		 push	 ecx
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2664 :     }

  002d4	e9 81 fe ff ff	 jmp	 $L70262
$L70263:

; 2665 :     // Now, go back to the primary segment and find all tracks that have been reenabled
; 2666 :     // and tag them so they will generate refresh data on the next play (by seeking, as if they 
; 2667 :     // were starting or looping playback.) We only do this for play, not notify, because no
; 2668 :     // notifications have state.
; 2669 :     for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )

  002d9	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002df	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002e4	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
  002e7	eb 0b		 jmp	 SHORT $L70279
$L70280:
  002e9	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  002ec	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  002f1	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L70279:
  002f4	83 7d f8 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  002f8	74 78		 je	 SHORT $L70281

; 2670 :     {
; 2671 :         ENTER_CRITICAL_SECTION(&pSegNode->m_CriticalSection);

  002fa	8b 55 f8	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  002fd	83 c2 14	 add	 edx, 20			; 00000014H
  00300	52		 push	 edx
  00301	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2672 :         CTrack *pTrack = pSegNode->m_TrackList.GetHead();

  00307	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0030a	83 c1 44	 add	 ecx, 68			; 00000044H
  0030d	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00312	89 45 e8	 mov	 DWORD PTR _pTrack$70282[ebp], eax

; 2673 :         for (;pTrack;pTrack = pTrack->GetNext())

  00315	eb 0b		 jmp	 SHORT $L70283
$L70284:
  00317	8b 4d e8	 mov	 ecx, DWORD PTR _pTrack$70282[ebp]
  0031a	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  0031f	89 45 e8	 mov	 DWORD PTR _pTrack$70282[ebp], eax
$L70283:
  00322	83 7d e8 00	 cmp	 DWORD PTR _pTrack$70282[ebp], 0
  00326	74 38		 je	 SHORT $L70285

; 2674 :         {
; 2675 :             if ((pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED) &&
; 2676 :                 (pTrack->m_dwInternalFlags & CONTROL_PLAY_WAS_DISABLED) &&
; 2677 :                 !(pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED))

  00328	8b 45 e8	 mov	 eax, DWORD PTR _pTrack$70282[ebp]
  0032b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0032e	83 e1 10	 and	 ecx, 16			; 00000010H
  00331	85 c9		 test	 ecx, ecx
  00333	74 29		 je	 SHORT $L70286
  00335	8b 55 e8	 mov	 edx, DWORD PTR _pTrack$70282[ebp]
  00338	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0033b	83 e0 02	 and	 eax, 2
  0033e	85 c0		 test	 eax, eax
  00340	74 1c		 je	 SHORT $L70286
  00342	8b 4d e8	 mov	 ecx, DWORD PTR _pTrack$70282[ebp]
  00345	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00348	83 e2 01	 and	 edx, 1
  0034b	85 d2		 test	 edx, edx
  0034d	75 0f		 jne	 SHORT $L70286

; 2678 :             {
; 2679 :                 pTrack->m_dwInternalFlags |= CONTROL_PLAY_REFRESH; // Mark so we can turn on later.

  0034f	8b 45 e8	 mov	 eax, DWORD PTR _pTrack$70282[ebp]
  00352	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00355	83 c9 04	 or	 ecx, 4
  00358	8b 55 e8	 mov	 edx, DWORD PTR _pTrack$70282[ebp]
  0035b	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$L70286:

; 2680 :             }
; 2681 :         }

  0035e	eb b7		 jmp	 SHORT $L70284
$L70285:

; 2682 :         LEAVE_CRITICAL_SECTION(&pSegNode->m_CriticalSection);

  00360	8b 45 f8	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  00363	83 c0 14	 add	 eax, 20			; 00000014H
  00366	50		 push	 eax
  00367	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2683 :     }

  0036d	e9 77 ff ff ff	 jmp	 $L70280
$L70281:

; 2684 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00372	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00375	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  0037b	51		 push	 ecx
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2685 : }

  00382	8b e5		 mov	 esp, ebp
  00384	5d		 pop	 ebp
  00385	c3		 ret	 0
?ManageControllingTracks@CPerformance@@AAEXXZ ENDP	; CPerformance::ManageControllingTracks
_TEXT	ENDS
PUBLIC	?GetTimeSig@CPerformance@@AAEXJPAU_DMUS_TIMESIG_PMSG@@@Z ; CPerformance::GetTimeSig
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetTimeSig@CPerformance@@AAEXJPAU_DMUS_TIMESIG_PMSG@@@Z
_TEXT	SEGMENT
_this$ = -12
_pNewTimeSig$70298 = -8
_pEvent$ = -4
_mtTime$ = 8
_pTimeSig$ = 12
?GetTimeSig@CPerformance@@AAEXJPAU_DMUS_TIMESIG_PMSG@@@Z PROC NEAR ; CPerformance::GetTimeSig, COMDAT
; _this$ = ecx

; 2688 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2689 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2690 :     PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();

  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  00021	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00026	89 45 fc	 mov	 DWORD PTR _pEvent$[ebp], eax

; 2691 :     for (;pEvent;pEvent = pEvent->pNext)

  00029	eb 08		 jmp	 SHORT $L70293
$L70294:
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	89 55 fc	 mov	 DWORD PTR _pEvent$[ebp], edx
$L70293:
  00033	83 7d fc 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  00037	74 44		 je	 SHORT $L70295

; 2692 :     {
; 2693 :         // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
; 2694 :         if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0003c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003f	74 0d		 je	 SHORT $L70297
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00049	3b 45 08	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  0004c	7e 2d		 jle	 SHORT $L70296
$L70297:

; 2695 :         {
; 2696 :             DMUS_TIMESIG_PMSG* pNewTimeSig = (DMUS_TIMESIG_PMSG*)PRIV_TO_DMUS(pEvent);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00051	83 c1 18	 add	 ecx, 24			; 00000018H
  00054	89 4d f8	 mov	 DWORD PTR _pNewTimeSig$70298[ebp], ecx

; 2697 :             memcpy( pTimeSig, pNewTimeSig, sizeof(DMUS_TIMESIG_PMSG) );

  00057	6a 40		 push	 64			; 00000040H
  00059	8b 55 f8	 mov	 edx, DWORD PTR _pNewTimeSig$70298[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 0c	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _memcpy
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2698 :             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00069	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  00072	51		 push	 ecx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2699 :             return;

  00079	eb 38		 jmp	 SHORT $L70291
$L70296:

; 2700 :         }
; 2701 :     }

  0007b	eb ae		 jmp	 SHORT $L70294
$L70295:

; 2702 :     // This should only happen if there is no timesig at all. Should only happen before any segments play.
; 2703 :     memset( pTimeSig, 0, sizeof(DMUS_TIMESIG_PMSG ) );

  0007d	6a 40		 push	 64			; 00000040H
  0007f	6a 00		 push	 0
  00081	8b 55 0c	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _memset
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2704 :     pTimeSig->wGridsPerBeat = 4;

  0008d	8b 45 0c	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  00090	66 c7 40 3a 04
	00		 mov	 WORD PTR [eax+58], 4

; 2705 :     pTimeSig->bBeatsPerMeasure = 4;

  00096	8b 4d 0c	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  00099	c6 41 38 04	 mov	 BYTE PTR [ecx+56], 4

; 2706 :     pTimeSig->bBeat = 4;

  0009d	8b 55 0c	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  000a0	c6 42 39 04	 mov	 BYTE PTR [edx+57], 4

; 2707 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000a4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	05 30 03 00 00	 add	 eax, 816		; 00000330H
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L70291:

; 2708 : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 08 00	 ret	 8
?GetTimeSig@CPerformance@@AAEXJPAU_DMUS_TIMESIG_PMSG@@@Z ENDP ; CPerformance::GetTimeSig
_TEXT	ENDS
EXTRN	?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z:NEAR ; CSegState::GetParam
EXTRN	_GUID_TimeSignature:BYTE
; Function compile flags: /Odt
;	COMDAT ?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z
_TEXT	SEGMENT
_this$ = -20
_pEvent$70313 = -16
_mtTime$70312 = -12
_TimeSig$ = -8
_pSegState$ = 8
?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z PROC NEAR ; CPerformance::SyncTimeSig, COMDAT
; _this$ = ecx

; 2717 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2718 :     // First, test to see if the segment has a time signature.
; 2719 :     // If it doesn't then we need to do this.
; 2720 :     DMUS_TIMESIGNATURE TimeSig;
; 2721 :     if (FAILED(pSegState->GetParam(this,GUID_TimeSignature,-1,0,0,NULL,(void *)&TimeSig)))

  00009	8d 45 f8	 lea	 eax, DWORD PTR _TimeSig$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	6a ff		 push	 -1
  00015	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TimeSignature
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00021	e8 00 00 00 00	 call	 ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
  00026	85 c0		 test	 eax, eax
  00028	0f 8d 82 00 00
	00		 jge	 $L70307

; 2722 :     {
; 2723 :         MUSIC_TIME mtTime = pSegState->m_mtResolvedStart;

  0002e	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00031	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00034	89 45 f4	 mov	 DWORD PTR _mtTime$70312[ebp], eax

; 2724 :         ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  00040	51		 push	 ecx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2725 :         PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();

  00047	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  00050	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00055	89 45 f0	 mov	 DWORD PTR _pEvent$70313[ebp], eax

; 2726 :         // Scan through the time signatures until the most recent one is found.
; 2727 :         for (;pEvent;pEvent = pEvent->pNext)

  00058	eb 08		 jmp	 SHORT $L70314
$L70315:
  0005a	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$70313[ebp]
  0005d	8b 02		 mov	 eax, DWORD PTR [edx]
  0005f	89 45 f0	 mov	 DWORD PTR _pEvent$70313[ebp], eax
$L70314:
  00062	83 7d f0 00	 cmp	 DWORD PTR _pEvent$70313[ebp], 0
  00066	74 39		 je	 SHORT $L70316

; 2728 :         {
; 2729 :             // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
; 2730 :             if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))

  00068	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$70313[ebp]
  0006b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0006e	74 0d		 je	 SHORT $L70318
  00070	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$70313[ebp]
  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00078	3b 4d f4	 cmp	 ecx, DWORD PTR _mtTime$70312[ebp]
  0007b	7e 22		 jle	 SHORT $L70317
$L70318:

; 2731 :             {
; 2732 :                 pEvent->mtTime = mtTime;

  0007d	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$70313[ebp]
  00080	8b 45 f4	 mov	 eax, DWORD PTR _mtTime$70312[ebp]
  00083	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 2733 :                 MusicToReferenceTime(mtTime,&pEvent->rtTime);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$70313[ebp]
  00089	83 c1 20	 add	 ecx, 32			; 00000020H
  0008c	51		 push	 ecx
  0008d	8b 55 f4	 mov	 edx, DWORD PTR _mtTime$70312[ebp]
  00090	52		 push	 edx
  00091	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00099	52		 push	 edx
  0009a	ff 51 14	 call	 DWORD PTR [ecx+20]

; 2734 :                 break;

  0009d	eb 02		 jmp	 SHORT $L70316
$L70317:

; 2735 :             }
; 2736 :         }

  0009f	eb b9		 jmp	 SHORT $L70315
$L70316:

; 2737 :         // Should never fall through to here without finding a time signature because Init() creates a timesig.
; 2738 :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	05 30 03 00 00	 add	 eax, 816		; 00000330H
  000a9	50		 push	 eax
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L70307:

; 2739 :     }
; 2740 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?SyncTimeSig@CPerformance@@AAEXPAVCSegState@@@Z ENDP	; CPerformance::SyncTimeSig
_TEXT	ENDS
PUBLIC	?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
EXTRN	_GUID_Play_Marker:BYTE
; Function compile flags: /Odt
;	COMDAT ?ResolveTime@CPerformance@@AAEJJKPAJ@Z
_TEXT	SEGMENT
_this$ = -60
_llEnd$70351 = -56
_pSegNode$70348 = -48
_mtInitialTime$70333 = -44
_mtFirst$70334 = -40
_mtSecond$70335 = -36
_fIsMarker$70332 = -32
_Marker$70327 = -28
_mtNext$70328 = -24
_mtNewTime$ = -20
_timeSig$ = -16
_mtStartOfTimeSig$ = -8
_lQuantize$ = -4
_mtTime$ = 8
_dwResolution$ = 12
_pmtIntervalSize$ = 16
?ResolveTime@CPerformance@@AAEJJKPAJ@Z PROC NEAR	; CPerformance::ResolveTime, COMDAT
; _this$ = ecx

; 2746 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 2747 :     if (pmtIntervalSize)

  0000a	83 7d 10 00	 cmp	 DWORD PTR _pmtIntervalSize$[ebp], 0
  0000e	74 09		 je	 SHORT $L70325

; 2748 :     {
; 2749 :         *pmtIntervalSize = 0;

  00010	8b 45 10	 mov	 eax, DWORD PTR _pmtIntervalSize$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L70325:

; 2750 :     }
; 2751 :     if (dwResolution & DMUS_SEGF_MARKER)

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _dwResolution$[ebp]
  0001c	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 c7 00 00
	00		 je	 $L70326

; 2752 :     {
; 2753 :         DMUS_PLAY_MARKER_PARAM Marker;
; 2754 :         MUSIC_TIME mtNext;
; 2755 :         // First, get the time of the marker preceding this one.
; 2756 :         if (SUCCEEDED (GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))

  0002a	8d 55 e4	 lea	 edx, DWORD PTR _Marker$70327[ebp]
  0002d	52		 push	 edx
  0002e	8d 45 e8	 lea	 eax, DWORD PTR _mtNext$70328[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00035	51		 push	 ecx
  00036	6a 00		 push	 0
  00038	6a ff		 push	 -1
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Play_Marker
  0003f	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	51		 push	 ecx
  00048	ff 50 6c	 call	 DWORD PTR [eax+108]
  0004b	85 c0		 test	 eax, eax
  0004d	0f 8c 9e 00 00
	00		 jl	 $L70326

; 2757 :         {
; 2758 :             BOOL fIsMarker = FALSE;

  00053	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fIsMarker$70332[ebp], 0

; 2759 :             MUSIC_TIME mtInitialTime = mtTime;

  0005a	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0005d	89 55 d4	 mov	 DWORD PTR _mtInitialTime$70333[ebp], edx

; 2760 :             MUSIC_TIME mtFirst = mtTime + Marker.mtTime; // This is the time of the preceding marker.

  00060	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00063	03 45 e4	 add	 eax, DWORD PTR _Marker$70327[ebp]
  00066	89 45 d8	 mov	 DWORD PTR _mtFirst$70334[ebp], eax

; 2761 :             MUSIC_TIME mtSecond = mtTime + mtNext;  // This might be the time of the next marker.

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0006c	03 4d e8	 add	 ecx, DWORD PTR _mtNext$70328[ebp]
  0006f	89 4d dc	 mov	 DWORD PTR _mtSecond$70335[ebp], ecx
$L70337:

; 2762 :             // Then, scan forward until a marker is found after or equal to this time.
; 2763 :             // If a loop point or end of segment is encountered, the value in Marker.mtTime will
; 2764 :             // continue to be negative. Once we hit the actual marker, it will become 0, since
; 2765 :             // we are asking for the marker at that specific time.
; 2766 :             while (mtNext)

  00072	83 7d e8 00	 cmp	 DWORD PTR _mtNext$70328[ebp], 0
  00076	74 4e		 je	 SHORT $L70338

; 2767 :             {
; 2768 :                 mtTime += mtNext;

  00078	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0007b	03 55 e8	 add	 edx, DWORD PTR _mtNext$70328[ebp]
  0007e	89 55 08	 mov	 DWORD PTR _mtTime$[ebp], edx

; 2769 :                 if (SUCCEEDED(GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))

  00081	8d 45 e4	 lea	 eax, DWORD PTR _Marker$70327[ebp]
  00084	50		 push	 eax
  00085	8d 4d e8	 lea	 ecx, DWORD PTR _mtNext$70328[ebp]
  00088	51		 push	 ecx
  00089	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	6a ff		 push	 -1
  00091	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Play_Marker
  00096	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	52		 push	 edx
  0009f	ff 51 6c	 call	 DWORD PTR [ecx+108]
  000a2	85 c0		 test	 eax, eax
  000a4	7c 1c		 jl	 SHORT $L70341

; 2770 :                 {
; 2771 :                     // If the marker time is 0, this means we are sitting right on the marker, 
; 2772 :                     // so we are done. 
; 2773 :                     if (fIsMarker = (Marker.mtTime == 0))

  000a6	33 c0		 xor	 eax, eax
  000a8	83 7d e4 00	 cmp	 DWORD PTR _Marker$70327[ebp], 0
  000ac	0f 94 c0	 sete	 al
  000af	89 45 e0	 mov	 DWORD PTR _fIsMarker$70332[ebp], eax
  000b2	83 7d e0 00	 cmp	 DWORD PTR _fIsMarker$70332[ebp], 0
  000b6	74 08		 je	 SHORT $L70342

; 2774 :                     {
; 2775 :                         mtSecond = mtTime;

  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000bb	89 4d dc	 mov	 DWORD PTR _mtSecond$70335[ebp], ecx

; 2776 :                         break;

  000be	eb 06		 jmp	 SHORT $L70338
$L70342:

; 2777 :                     }
; 2778 :                     // Otherwise, this was a loop boundary or segment end, so we should continue scanning forward.
; 2779 :                 }
; 2780 :                 else

  000c0	eb 02		 jmp	 SHORT $L70343
$L70341:

; 2781 :                 {
; 2782 :                     // GetParam failed, must be nothing more to search. 
; 2783 :                     break;

  000c2	eb 02		 jmp	 SHORT $L70338
$L70343:

; 2784 :                 }
; 2785 :             }            

  000c4	eb ac		 jmp	 SHORT $L70337
$L70338:

; 2786 :             // If the caller wants the interval size, then we know they are interested in 
; 2787 :             // aligning to a previous marker as well as a future one. In that case, 
; 2788 :             // if we didn't find a marker in the future, it's okay because it will 
; 2789 :             // use the previous marker (mtFirst) anyway.
; 2790 :             // For all other cases, we only return if the upcoming marker is legal.
; 2791 :             // Otherwise, we drop through and try other resolutions.
; 2792 :             if (pmtIntervalSize || fIsMarker)

  000c6	83 7d 10 00	 cmp	 DWORD PTR _pmtIntervalSize$[ebp], 0
  000ca	75 06		 jne	 SHORT $L70345
  000cc	83 7d e0 00	 cmp	 DWORD PTR _fIsMarker$70332[ebp], 0
  000d0	74 19		 je	 SHORT $L70344
$L70345:

; 2793 :             {
; 2794 :                 if (pmtIntervalSize)

  000d2	83 7d 10 00	 cmp	 DWORD PTR _pmtIntervalSize$[ebp], 0
  000d6	74 0b		 je	 SHORT $L70346

; 2795 :                 {
; 2796 :                     *pmtIntervalSize = mtSecond - mtFirst;

  000d8	8b 55 dc	 mov	 edx, DWORD PTR _mtSecond$70335[ebp]
  000db	2b 55 d8	 sub	 edx, DWORD PTR _mtFirst$70334[ebp]
  000de	8b 45 10	 mov	 eax, DWORD PTR _pmtIntervalSize$[ebp]
  000e1	89 10		 mov	 DWORD PTR [eax], edx
$L70346:

; 2797 :                 }
; 2798 :                 return mtSecond;

  000e3	8b 45 dc	 mov	 eax, DWORD PTR _mtSecond$70335[ebp]
  000e6	e9 a5 01 00 00	 jmp	 $L70324
$L70344:

; 2799 :             }
; 2800 :             mtTime = mtInitialTime;

  000eb	8b 4d d4	 mov	 ecx, DWORD PTR _mtInitialTime$70333[ebp]
  000ee	89 4d 08	 mov	 DWORD PTR _mtTime$[ebp], ecx
$L70326:

; 2801 :         }
; 2802 :         // If marker fails, we can drop down to the other types...
; 2803 :     }
; 2804 :     if( dwResolution & DMUS_SEGF_SEGMENTEND )

  000f1	8b 55 0c	 mov	 edx, DWORD PTR _dwResolution$[ebp]
  000f4	81 e2 00 00 80
	00		 and	 edx, 8388608		; 00800000H
  000fa	85 d2		 test	 edx, edx
  000fc	0f 84 83 00 00
	00		 je	 $L70347

; 2805 :     {
; 2806 :         // In this mode, we don't actually get the time signature. Instead, we
; 2807 :         // find out the time of the next segment start after the requested time. 
; 2808 :         CSegState *pSegNode = GetPrimarySegmentAtTime( mtTime );

  00102	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00105	50		 push	 eax
  00106	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  0010e	89 45 d0	 mov	 DWORD PTR _pSegNode$70348[ebp], eax

; 2809 :         if( pSegNode )

  00111	83 7d d0 00	 cmp	 DWORD PTR _pSegNode$70348[ebp], 0
  00115	74 6e		 je	 SHORT $L70347

; 2810 :         {
; 2811 :             // First, calculate the end time of the segment.
; 2812 :             // Include any starting offset so we see the full span of the segment.
; 2813 :             mtTime = pSegNode->GetEndTime( pSegNode->m_mtStartPoint );

  00117	8b 4d d0	 mov	 ecx, DWORD PTR _pSegNode$70348[ebp]
  0011a	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  0011d	52		 push	 edx
  0011e	8b 4d d0	 mov	 ecx, DWORD PTR _pSegNode$70348[ebp]
  00121	e8 00 00 00 00	 call	 ?GetEndTime@CSegState@@QAEJJ@Z ; CSegState::GetEndTime
  00126	89 45 08	 mov	 DWORD PTR _mtTime$[ebp], eax

; 2814 :             if (pmtIntervalSize)

  00129	83 7d 10 00	 cmp	 DWORD PTR _pmtIntervalSize$[ebp], 0
  0012d	74 08		 je	 SHORT $L70350

; 2815 :             {
; 2816 :                 // Interval would be the length of the primary segment!
; 2817 :                 *pmtIntervalSize = mtTime;

  0012f	8b 45 10	 mov	 eax, DWORD PTR _pmtIntervalSize$[ebp]
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00135	89 08		 mov	 DWORD PTR [eax], ecx
$L70350:

; 2818 :             }
; 2819 :             // Return the end of the segment.
; 2820 :             LONGLONG llEnd = mtTime + (LONGLONG)(pSegNode->m_mtResolvedStart - pSegNode->m_mtStartPoint);

  00137	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0013a	99		 cdq
  0013b	8b c8		 mov	 ecx, eax
  0013d	8b f2		 mov	 esi, edx
  0013f	8b 55 d0	 mov	 edx, DWORD PTR _pSegNode$70348[ebp]
  00142	8b 45 d0	 mov	 eax, DWORD PTR _pSegNode$70348[ebp]
  00145	8b 52 64	 mov	 edx, DWORD PTR [edx+100]
  00148	2b 50 7c	 sub	 edx, DWORD PTR [eax+124]
  0014b	8b c2		 mov	 eax, edx
  0014d	99		 cdq
  0014e	03 c8		 add	 ecx, eax
  00150	13 f2		 adc	 esi, edx
  00152	89 4d c8	 mov	 DWORD PTR _llEnd$70351[ebp], ecx
  00155	89 75 cc	 mov	 DWORD PTR _llEnd$70351[ebp+4], esi

; 2821 :             if(llEnd > 0x7fffffff) llEnd = 0x7fffffff;

  00158	83 7d cc 00	 cmp	 DWORD PTR _llEnd$70351[ebp+4], 0
  0015c	7c 19		 jl	 SHORT $L70353
  0015e	7f 09		 jg	 SHORT $L75345
  00160	81 7d c8 ff ff
	ff 7f		 cmp	 DWORD PTR _llEnd$70351[ebp], 2147483647 ; 7fffffffH
  00167	76 0e		 jbe	 SHORT $L70353
$L75345:
  00169	c7 45 c8 ff ff
	ff 7f		 mov	 DWORD PTR _llEnd$70351[ebp], 2147483647 ; 7fffffffH
  00170	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _llEnd$70351[ebp+4], 0
$L70353:

; 2822 :             mtTime = (MUSIC_TIME) llEnd;

  00177	8b 45 c8	 mov	 eax, DWORD PTR _llEnd$70351[ebp]
  0017a	89 45 08	 mov	 DWORD PTR _mtTime$[ebp], eax

; 2823 :             return mtTime;

  0017d	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00180	e9 0b 01 00 00	 jmp	 $L70324
$L70347:

; 2824 : 
; 2825 :         }
; 2826 :         // If there was no segment, we should fail and try the other flags.
; 2827 :     }
; 2828 :     long        lQuantize;
; 2829 :     MUSIC_TIME  mtNewTime;
; 2830 :     MUSIC_TIME  mtStartOfTimeSig = 0;

  00185	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mtStartOfTimeSig$[ebp], 0

; 2831 :     DMUS_TIMESIGNATURE  timeSig;
; 2832 :     if (!(dwResolution & DMUS_SEGF_TIMESIG_ALWAYS))

  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwResolution$[ebp]
  0018f	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  00195	85 c9		 test	 ecx, ecx
  00197	75 18		 jne	 SHORT $L70359

; 2833 :     {
; 2834 :         if (!GetPrimarySegmentAtTime(mtTime))

  00199	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0019c	52		 push	 edx
  0019d	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  001a5	85 c0		 test	 eax, eax
  001a7	75 08		 jne	 SHORT $L70359

; 2835 :         {
; 2836 :             return mtTime;

  001a9	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  001ac	e9 df 00 00 00	 jmp	 $L70324
$L70359:

; 2837 :         }
; 2838 :     }
; 2839 :     GetParam(GUID_TimeSignature,-1,0,mtTime,NULL,(void *) &timeSig);

  001b1	8d 45 f0	 lea	 eax, DWORD PTR _timeSig$[ebp]
  001b4	50		 push	 eax
  001b5	6a 00		 push	 0
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  001ba	51		 push	 ecx
  001bb	6a 00		 push	 0
  001bd	6a ff		 push	 -1
  001bf	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TimeSignature
  001c4	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  001c7	8b 02		 mov	 eax, DWORD PTR [edx]
  001c9	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	51		 push	 ecx
  001cd	ff 50 6c	 call	 DWORD PTR [eax+108]

; 2840 :     mtStartOfTimeSig = timeSig.mtTime + mtTime;

  001d0	8b 55 f0	 mov	 edx, DWORD PTR _timeSig$[ebp]
  001d3	03 55 08	 add	 edx, DWORD PTR _mtTime$[ebp]
  001d6	89 55 f8	 mov	 DWORD PTR _mtStartOfTimeSig$[ebp], edx

; 2841 :     mtNewTime = mtTime - mtStartOfTimeSig;

  001d9	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  001dc	2b 45 f8	 sub	 eax, DWORD PTR _mtStartOfTimeSig$[ebp]
  001df	89 45 ec	 mov	 DWORD PTR _mtNewTime$[ebp], eax

; 2842 :     if (dwResolution & DMUS_SEGF_MEASURE)

  001e2	8b 4d 0c	 mov	 ecx, DWORD PTR _dwResolution$[ebp]
  001e5	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  001eb	85 c9		 test	 ecx, ecx
  001ed	74 16		 je	 SHORT $L70362

; 2843 :     {
; 2844 :         lQuantize = ( DMUS_PPQ * 4 * timeSig.bBeatsPerMeasure ) / timeSig.bBeat;

  001ef	0f b6 45 f4	 movzx	 eax, BYTE PTR _timeSig$[ebp+4]
  001f3	69 c0 00 0c 00
	00		 imul	 eax, 3072		; 00000c00H
  001f9	0f b6 4d f5	 movzx	 ecx, BYTE PTR _timeSig$[ebp+5]
  001fd	99		 cdq
  001fe	f7 f9		 idiv	 ecx
  00200	89 45 fc	 mov	 DWORD PTR _lQuantize$[ebp], eax

; 2845 :     }
; 2846 :     else if (dwResolution & DMUS_SEGF_BEAT)

  00203	eb 4a		 jmp	 SHORT $L70363
$L70362:
  00205	8b 55 0c	 mov	 edx, DWORD PTR _dwResolution$[ebp]
  00208	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  0020e	85 d2		 test	 edx, edx
  00210	74 11		 je	 SHORT $L70364

; 2847 :     {
; 2848 :         lQuantize = ( DMUS_PPQ * 4 ) / timeSig.bBeat;

  00212	0f b6 4d f5	 movzx	 ecx, BYTE PTR _timeSig$[ebp+5]
  00216	b8 00 0c 00 00	 mov	 eax, 3072		; 00000c00H
  0021b	99		 cdq
  0021c	f7 f9		 idiv	 ecx
  0021e	89 45 fc	 mov	 DWORD PTR _lQuantize$[ebp], eax

; 2849 :     }
; 2850 :     else if (dwResolution & DMUS_SEGF_GRID)

  00221	eb 2c		 jmp	 SHORT $L70363
$L70364:
  00223	8b 55 0c	 mov	 edx, DWORD PTR _dwResolution$[ebp]
  00226	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0022c	85 d2		 test	 edx, edx
  0022e	74 18		 je	 SHORT $L70366

; 2851 :     {
; 2852 :         lQuantize = ( ( DMUS_PPQ * 4 ) / timeSig.bBeat ) / timeSig.wGridsPerBeat;

  00230	0f b6 4d f5	 movzx	 ecx, BYTE PTR _timeSig$[ebp+5]
  00234	b8 00 0c 00 00	 mov	 eax, 3072		; 00000c00H
  00239	99		 cdq
  0023a	f7 f9		 idiv	 ecx
  0023c	0f b7 4d f6	 movzx	 ecx, WORD PTR _timeSig$[ebp+6]
  00240	99		 cdq
  00241	f7 f9		 idiv	 ecx
  00243	89 45 fc	 mov	 DWORD PTR _lQuantize$[ebp], eax

; 2853 :     }
; 2854 :     else

  00246	eb 07		 jmp	 SHORT $L70363
$L70366:

; 2855 :     {
; 2856 :         lQuantize = 1;

  00248	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _lQuantize$[ebp], 1
$L70363:

; 2857 :     }
; 2858 :     if (lQuantize == 0) // Avoid divide by 0 error.

  0024f	83 7d fc 00	 cmp	 DWORD PTR _lQuantize$[ebp], 0
  00253	75 07		 jne	 SHORT $L70368

; 2859 :     {
; 2860 :         lQuantize = 1;

  00255	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _lQuantize$[ebp], 1
$L70368:

; 2861 :     }
; 2862 :     if (pmtIntervalSize)

  0025c	83 7d 10 00	 cmp	 DWORD PTR _pmtIntervalSize$[ebp], 0
  00260	74 08		 je	 SHORT $L70369

; 2863 :     {
; 2864 :         *pmtIntervalSize = lQuantize;

  00262	8b 55 10	 mov	 edx, DWORD PTR _pmtIntervalSize$[ebp]
  00265	8b 45 fc	 mov	 eax, DWORD PTR _lQuantize$[ebp]
  00268	89 02		 mov	 DWORD PTR [edx], eax
$L70369:

; 2865 :     }
; 2866 :     if( mtNewTime ) // if it's 0 it stays 0

  0026a	83 7d ec 00	 cmp	 DWORD PTR _mtNewTime$[ebp], 0
  0026e	74 1a		 je	 SHORT $L70370

; 2867 :     {
; 2868 :         // round up to next boundary
; 2869 :         mtNewTime = ((mtNewTime-1) / lQuantize ) * lQuantize;

  00270	8b 45 ec	 mov	 eax, DWORD PTR _mtNewTime$[ebp]
  00273	83 e8 01	 sub	 eax, 1
  00276	99		 cdq
  00277	f7 7d fc	 idiv	 DWORD PTR _lQuantize$[ebp]
  0027a	0f af 45 fc	 imul	 eax, DWORD PTR _lQuantize$[ebp]
  0027e	89 45 ec	 mov	 DWORD PTR _mtNewTime$[ebp], eax

; 2870 :         mtNewTime += lQuantize;

  00281	8b 4d ec	 mov	 ecx, DWORD PTR _mtNewTime$[ebp]
  00284	03 4d fc	 add	 ecx, DWORD PTR _lQuantize$[ebp]
  00287	89 4d ec	 mov	 DWORD PTR _mtNewTime$[ebp], ecx
$L70370:

; 2871 :     }
; 2872 :     return (mtNewTime + mtStartOfTimeSig);

  0028a	8b 45 ec	 mov	 eax, DWORD PTR _mtNewTime$[ebp]
  0028d	03 45 f8	 add	 eax, DWORD PTR _mtStartOfTimeSig$[ebp]
$L70324:

; 2873 : }

  00290	5e		 pop	 esi
  00291	8b e5		 mov	 esp, ebp
  00293	5d		 pop	 ebp
  00294	c2 0c 00	 ret	 12			; 0000000cH
?ResolveTime@CPerformance@@AAEJJKPAJ@Z ENDP		; CPerformance::ResolveTime
_TEXT	ENDS
PUBLIC	?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue
PUBLIC	?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z	; GetInvalidationStatus
EXTRN	?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z:NEAR ; CPMsgQueue::Dequeue
; Function compile flags: /Odt
;	COMDAT ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z
_TEXT	SEGMENT
tv392 = -156
tv814 = -152
tv774 = -148
tv698 = -140
tv665 = -136
tv175 = -132
_this$ = -128
_mtFlush$70589 = -124
_rtEnd$70587 = -120
_pCurve$70579 = -112
_mtEnd$70583 = -108
_mtStart$70584 = -104
_mtTime$70572 = -100
_mtFlush$70573 = -96
_pWave$70562 = -92
_rtNoteOff$70557 = -88
_mtNoteOff$70556 = -76
_pNote$70548 = -72
_mtFlush$70534 = -68
_pWave$70525 = -64
_fFlush$70523 = -57
_mt$70518 = -56
_mt$70515 = -52
_mtCurve$70510 = -48
_pCurve$70506 = -44
_mtStart$70511 = -40
_pWave$70492 = -36
_mtNote$70487 = -32
_pNote$70482 = -28
_rtTime$70480 = -24
_rtTemp$ = -16
_pEvent$ = -8
_pNext$ = -4
_dwId$ = 8
_pQueue$ = 12
_rtFlush$ = 16
_rtFlushUnresolved$ = 24
_dwFlushFlags$ = 32
?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z PROC NEAR ; CPerformance::FlushEventQueue, COMDAT
; _this$ = ecx

; 3138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 3139 :     PRIV_PMSG* pEvent;
; 3140 :     PRIV_PMSG* pNext;
; 3141 :     REFERENCE_TIME rtTemp;
; 3142 :     GetQueueTime(&rtTemp);

  0000c	8d 45 f0	 lea	 eax, DWORD PTR _rtTemp$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00018	50		 push	 eax
  00019	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 3143 :     pNext = NULL;

  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0

; 3144 :     for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  00029	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  0002e	89 45 f8	 mov	 DWORD PTR _pEvent$[ebp], eax
  00031	eb 06		 jmp	 SHORT $L70475
$L70476:
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00036	89 4d f8	 mov	 DWORD PTR _pEvent$[ebp], ecx
$L70475:
  00039	83 7d f8 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0003d	0f 84 a5 08 00
	00		 je	 $L70477

; 3145 :     {
; 3146 :         pNext = pEvent->pNext;

  00043	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 3147 :         // Clear the remove bit. This will be set for each event that should be removed from the queue.
; 3148 :         pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0004e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00051	83 e2 fd	 and	 edx, -3			; fffffffdH
  00054	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00057	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3149 :         // Also clear the requeue bit, which will be set for each event that needs to be requeued.
; 3150 :         pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;

  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0005d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00060	81 e2 ff ff ef
	ff		 and	 edx, -1048577		; ffefffffH
  00066	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00069	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3151 :         if( ( 0 == dwId ) || ( pEvent->dwVirtualTrackID == dwId ) )

  0006c	83 7d 08 00	 cmp	 DWORD PTR _dwId$[ebp], 0
  00070	74 0f		 je	 SHORT $L70479
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00075	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00078	3b 55 08	 cmp	 edx, DWORD PTR _dwId$[ebp]
  0007b	0f 85 62 08 00
	00		 jne	 $L70478
$L70479:

; 3152 :         {
; 3153 :             // First, create the correct mtTime and rtTime for invalidation.
; 3154 :             REFERENCE_TIME rtTime = pEvent->rtTime;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00084	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00087	89 4d e8	 mov	 DWORD PTR _rtTime$70480[ebp], ecx
  0008a	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0008d	89 55 ec	 mov	 DWORD PTR _rtTime$70480[ebp+4], edx

; 3155 :             if( pEvent->dwType == DMUS_PMSGT_NOTE )

  00090	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00093	83 78 40 01	 cmp	 DWORD PTR [eax+64], 1
  00097	75 5e		 jne	 SHORT $L70481

; 3156 :             {
; 3157 :                 DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);

  00099	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0009c	83 c1 18	 add	 ecx, 24			; 00000018H
  0009f	89 4d e4	 mov	 DWORD PTR _pNote$70482[ebp], ecx

; 3158 :                 if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  000a2	8b 55 e4	 mov	 edx, DWORD PTR _pNote$70482[ebp]
  000a5	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  000a9	83 e0 01	 and	 eax, 1
  000ac	85 c0		 test	 eax, eax
  000ae	74 28		 je	 SHORT $L70486

; 3159 :                 {
; 3160 :                     // If this is a note on, we want to take the offset into consideration for
; 3161 :                     // determining whether or not to invalidate. 
; 3162 :                     MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset; 

  000b0	8b 4d e4	 mov	 ecx, DWORD PTR _pNote$70482[ebp]
  000b3	0f bf 51 40	 movsx	 edx, WORD PTR [ecx+64]
  000b7	8b 45 e4	 mov	 eax, DWORD PTR _pNote$70482[ebp]
  000ba	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000bd	2b ca		 sub	 ecx, edx
  000bf	89 4d e0	 mov	 DWORD PTR _mtNote$70487[ebp], ecx

; 3163 :                     MusicToReferenceTime( mtNote, &rtTime );

  000c2	8d 55 e8	 lea	 edx, DWORD PTR _rtTime$70480[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 e0	 mov	 eax, DWORD PTR _mtNote$70487[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cf	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	50		 push	 eax
  000d3	ff 52 14	 call	 DWORD PTR [edx+20]

; 3164 :                 }
; 3165 :                 // If note off and we want to leave notes playing, turn on the noinvalidate flag.
; 3166 :                 else if (dwFlushFlags & FLUSH_LEAVE_ON)

  000d6	eb 1a		 jmp	 SHORT $L70488
$L70486:
  000d8	8b 4d 20	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  000db	83 e1 01	 and	 ecx, 1
  000de	85 c9		 test	 ecx, ecx
  000e0	74 10		 je	 SHORT $L70488

; 3167 :                 {
; 3168 :                     pNote->bFlags |= DMUS_NOTEF_NOINVALIDATE;

  000e2	8b 55 e4	 mov	 edx, DWORD PTR _pNote$70482[ebp]
  000e5	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  000e9	83 c8 02	 or	 eax, 2
  000ec	8b 4d e4	 mov	 ecx, DWORD PTR _pNote$70482[ebp]
  000ef	88 41 45	 mov	 BYTE PTR [ecx+69], al
$L70488:

; 3169 :                 }
; 3170 :             }
; 3171 :             else if( pEvent->dwType == DMUS_PMSGT_WAVE )

  000f2	e9 67 02 00 00	 jmp	 $L70490
$L70481:
  000f7	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000fa	83 7a 40 0c	 cmp	 DWORD PTR [edx+64], 12	; 0000000cH
  000fe	0f 85 8a 00 00
	00		 jne	 $L70491

; 3172 :             {
; 3173 :                 DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);

  00104	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00107	83 c0 18	 add	 eax, 24			; 00000018H
  0010a	89 45 dc	 mov	 DWORD PTR _pWave$70492[ebp], eax

; 3174 :                 if ((pWave->bFlags & DMUS_WAVEF_IGNORELOOPS) && (dwFlushFlags & FLUSH_ON_REPEAT))

  0010d	8b 4d dc	 mov	 ecx, DWORD PTR _pWave$70492[ebp]
  00110	0f b6 51 58	 movzx	 edx, BYTE PTR [ecx+88]
  00114	83 e2 20	 and	 edx, 32			; 00000020H
  00117	85 d2		 test	 edx, edx
  00119	74 0f		 je	 SHORT $L70496
  0011b	8b 45 20	 mov	 eax, DWORD PTR _dwFlushFlags$[ebp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	74 05		 je	 SHORT $L70496

; 3175 :                 {
; 3176 :                     // If this invalidation was caused by a loop track repeating and this
; 3177 :                     // is a wave that should continue playing on loop, let it do so.
; 3178 :                     continue;

  00125	e9 09 ff ff ff	 jmp	 $L70476
$L70496:

; 3179 :                 }
; 3180 :                 if( !(pWave->bFlags & DMUS_WAVEF_OFF) )

  0012a	8b 4d dc	 mov	 ecx, DWORD PTR _pWave$70492[ebp]
  0012d	0f b6 51 58	 movzx	 edx, BYTE PTR [ecx+88]
  00131	83 e2 01	 and	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	75 37		 jne	 SHORT $L70497

; 3181 :                 {
; 3182 :                     if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)

  00138	8b 45 dc	 mov	 eax, DWORD PTR _pWave$70492[ebp]
  0013b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0013e	83 e1 40	 and	 ecx, 64			; 00000040H
  00141	85 c9		 test	 ecx, ecx
  00143	74 11		 je	 SHORT $L70498

; 3183 :                     {
; 3184 :                         rtTime = pWave->rtTime;

  00145	8b 55 dc	 mov	 edx, DWORD PTR _pWave$70492[ebp]
  00148	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0014b	89 45 e8	 mov	 DWORD PTR _rtTime$70480[ebp], eax
  0014e	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00151	89 4d ec	 mov	 DWORD PTR _rtTime$70480[ebp+4], ecx

; 3185 :                     }
; 3186 :                     else

  00154	eb 17		 jmp	 SHORT $L70499
$L70498:

; 3187 :                     {
; 3188 :                         MusicToReferenceTime(pWave->mtTime, &rtTime);

  00156	8d 55 e8	 lea	 edx, DWORD PTR _rtTime$70480[ebp]
  00159	52		 push	 edx
  0015a	8b 45 dc	 mov	 eax, DWORD PTR _pWave$70492[ebp]
  0015d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00160	51		 push	 ecx
  00161	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  00164	8b 02		 mov	 eax, DWORD PTR [edx]
  00166	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	51		 push	 ecx
  0016a	ff 50 14	 call	 DWORD PTR [eax+20]
$L70499:

; 3189 :                     }
; 3190 :                 }
; 3191 :                 // If wave off and we want to leave waves playing, turn on the noinvalidate flag.
; 3192 :                 else if (dwFlushFlags & FLUSH_LEAVE_ON)

  0016d	eb 1a		 jmp	 SHORT $L70500
$L70497:
  0016f	8b 55 20	 mov	 edx, DWORD PTR _dwFlushFlags$[ebp]
  00172	83 e2 01	 and	 edx, 1
  00175	85 d2		 test	 edx, edx
  00177	74 10		 je	 SHORT $L70500

; 3193 :                 {
; 3194 :                     pWave->bFlags |= DMUS_WAVEF_NOINVALIDATE;

  00179	8b 45 dc	 mov	 eax, DWORD PTR _pWave$70492[ebp]
  0017c	0f b6 48 58	 movzx	 ecx, BYTE PTR [eax+88]
  00180	83 c9 04	 or	 ecx, 4
  00183	8b 55 dc	 mov	 edx, DWORD PTR _pWave$70492[ebp]
  00186	88 4a 58	 mov	 BYTE PTR [edx+88], cl
$L70500:

; 3195 :                 }
; 3196 :             }
; 3197 :             else if( pEvent->dwType == DMUS_PMSGT_CURVE )

  00189	e9 d0 01 00 00	 jmp	 $L70490
$L70491:
  0018e	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00191	83 78 40 05	 cmp	 DWORD PTR [eax+64], 5
  00195	0f 85 c3 01 00
	00		 jne	 $L70490

; 3198 :             {
; 3199 :                 if (dwFlushFlags & FLUSH_LEAVE_ON)

  0019b	8b 4d 20	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  0019e	83 e1 01	 and	 ecx, 1
  001a1	85 c9		 test	 ecx, ecx
  001a3	74 13		 je	 SHORT $L70504

; 3200 :                 {
; 3201 :                     rtTime = 0;

  001a5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rtTime$70480[ebp], 0
  001ac	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _rtTime$70480[ebp+4], 0

; 3202 :                 }
; 3203 :                 else

  001b3	e9 a6 01 00 00	 jmp	 $L70490
$L70504:

; 3204 :                 {
; 3205 :                     DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);

  001b8	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  001bb	83 c2 18	 add	 edx, 24			; 00000018H
  001be	89 55 d4	 mov	 DWORD PTR _pCurve$70506[ebp], edx

; 3206 :                     MUSIC_TIME mtCurve;
; 3207 :                     MUSIC_TIME mtStart;
; 3208 :                     mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

  001c1	8b 45 d4	 mov	 eax, DWORD PTR _pCurve$70506[ebp]
  001c4	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  001c8	74 0e		 je	 SHORT $L75349
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR _pCurve$70506[ebp]
  001cd	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001d0	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv175[ebp], edx
  001d6	eb 0c		 jmp	 SHORT $L75350
$L75349:
  001d8	8b 45 d4	 mov	 eax, DWORD PTR _pCurve$70506[ebp]
  001db	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001de	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv175[ebp], ecx
$L75350:
  001e4	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv175[ebp]
  001ea	89 55 d8	 mov	 DWORD PTR _mtStart$70511[ebp], edx

; 3209 :                 
; 3210 :                     // if rtFlush is before the beginning of the curve minus the offset of 
; 3211 :                     // the curve, we want to prevent the curve from playing
; 3212 :                     mtCurve = mtStart - pCurve->nOffset; 

  001ed	8b 45 d4	 mov	 eax, DWORD PTR _pCurve$70506[ebp]
  001f0	0f bf 48 4c	 movsx	 ecx, WORD PTR [eax+76]
  001f4	8b 55 d8	 mov	 edx, DWORD PTR _mtStart$70511[ebp]
  001f7	2b d1		 sub	 edx, ecx
  001f9	89 55 d0	 mov	 DWORD PTR _mtCurve$70510[ebp], edx

; 3213 :                     MusicToReferenceTime( mtCurve, &rtTime );

  001fc	8d 45 e8	 lea	 eax, DWORD PTR _rtTime$70480[ebp]
  001ff	50		 push	 eax
  00200	8b 4d d0	 mov	 ecx, DWORD PTR _mtCurve$70510[ebp]
  00203	51		 push	 ecx
  00204	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  00207	8b 02		 mov	 eax, DWORD PTR [edx]
  00209	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	51		 push	 ecx
  0020d	ff 50 14	 call	 DWORD PTR [eax+20]

; 3214 :                     if( rtFlush > rtTime ) // if it isn't...

  00210	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  00213	3b 55 ec	 cmp	 edx, DWORD PTR _rtTime$70480[ebp+4]
  00216	0f 8c 42 01 00
	00		 jl	 $L70490
  0021c	7f 0c		 jg	 SHORT $L75353
  0021e	8b 45 10	 mov	 eax, DWORD PTR _rtFlush$[ebp]
  00221	3b 45 e8	 cmp	 eax, DWORD PTR _rtTime$70480[ebp]
  00224	0f 86 34 01 00
	00		 jbe	 $L70490
$L75353:

; 3215 :                     {
; 3216 :                         // if the curve has a reset value and has already begun,
; 3217 :                         // we may want to flush right away.
; 3218 :                         if( ( pCurve->bFlags & DMUS_CURVE_RESET) && 
; 3219 :                               pCurve->mtOriginalStart && 
; 3220 :                               rtFlush <= rtFlushUnresolved )

  0022a	8b 4d d4	 mov	 ecx, DWORD PTR _pCurve$70506[ebp]
  0022d	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  00231	83 e2 01	 and	 edx, 1
  00234	85 d2		 test	 edx, edx
  00236	0f 84 14 01 00
	00		 je	 $L70513
  0023c	8b 45 d4	 mov	 eax, DWORD PTR _pCurve$70506[ebp]
  0023f	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00243	0f 84 07 01 00
	00		 je	 $L70513
  00249	8b 4d 14	 mov	 ecx, DWORD PTR _rtFlush$[ebp+4]
  0024c	3b 4d 1c	 cmp	 ecx, DWORD PTR _rtFlushUnresolved$[ebp+4]
  0024f	0f 8f fb 00 00
	00		 jg	 $L70513
  00255	7c 0c		 jl	 SHORT $L75354
  00257	8b 55 10	 mov	 edx, DWORD PTR _rtFlush$[ebp]
  0025a	3b 55 18	 cmp	 edx, DWORD PTR _rtFlushUnresolved$[ebp]
  0025d	0f 87 ed 00 00
	00		 ja	 $L70513
$L75354:

; 3221 :                         {
; 3222 :                             mtCurve = mtStart + pCurve->mtDuration;

  00263	8b 45 d4	 mov	 eax, DWORD PTR _pCurve$70506[ebp]
  00266	8b 4d d8	 mov	 ecx, DWORD PTR _mtStart$70511[ebp]
  00269	03 48 38	 add	 ecx, DWORD PTR [eax+56]
  0026c	89 4d d0	 mov	 DWORD PTR _mtCurve$70510[ebp], ecx

; 3223 :                             MusicToReferenceTime( mtCurve, &rtTime );

  0026f	8d 55 e8	 lea	 edx, DWORD PTR _rtTime$70480[ebp]
  00272	52		 push	 edx
  00273	8b 45 d0	 mov	 eax, DWORD PTR _mtCurve$70510[ebp]
  00276	50		 push	 eax
  00277	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027c	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  0027f	50		 push	 eax
  00280	ff 52 14	 call	 DWORD PTR [edx+20]

; 3224 :                             if( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )

  00283	8b 4d ec	 mov	 ecx, DWORD PTR _rtTime$70480[ebp+4]
  00286	3b 4d 14	 cmp	 ecx, DWORD PTR _rtFlush$[ebp+4]
  00289	7c 51		 jl	 SHORT $L70514
  0028b	7f 08		 jg	 SHORT $L75355
  0028d	8b 55 e8	 mov	 edx, DWORD PTR _rtTime$70480[ebp]
  00290	3b 55 10	 cmp	 edx, DWORD PTR _rtFlush$[ebp]
  00293	72 47		 jb	 SHORT $L70514
$L75355:
  00295	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00298	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0029b	83 e1 08	 and	 ecx, 8
  0029e	85 c9		 test	 ecx, ecx
  002a0	75 3a		 jne	 SHORT $L70514

; 3225 :                             {
; 3226 :                                 MUSIC_TIME mt = 0;

  002a2	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _mt$70515[ebp], 0

; 3227 :                                 ReferenceToMusicTime(rtFlush, &mt);

  002a9	8d 55 cc	 lea	 edx, DWORD PTR _mt$70515[ebp]
  002ac	52		 push	 edx
  002ad	8b 45 14	 mov	 eax, DWORD PTR _rtFlush$[ebp+4]
  002b0	50		 push	 eax
  002b1	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  002b4	51		 push	 ecx
  002b5	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  002b8	8b 02		 mov	 eax, DWORD PTR [edx]
  002ba	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  002bd	51		 push	 ecx
  002be	ff 50 18	 call	 DWORD PTR [eax+24]

; 3228 :                                 pCurve->mtDuration = (mt - mtStart) - 1;

  002c1	8b 55 cc	 mov	 edx, DWORD PTR _mt$70515[ebp]
  002c4	2b 55 d8	 sub	 edx, DWORD PTR _mtStart$70511[ebp]
  002c7	83 ea 01	 sub	 edx, 1
  002ca	8b 45 d4	 mov	 eax, DWORD PTR _pCurve$70506[ebp]
  002cd	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 3229 :                                 pCurve->mtResetDuration = 1;

  002d0	8b 4d d4	 mov	 ecx, DWORD PTR _pCurve$70506[ebp]
  002d3	c7 41 40 01 00
	00 00		 mov	 DWORD PTR [ecx+64], 1

; 3230 :                             }
; 3231 :                             else 

  002da	eb 72		 jmp	 SHORT $L70516
$L70514:

; 3232 :                             {
; 3233 :                                 mtCurve += pCurve->mtResetDuration;

  002dc	8b 55 d4	 mov	 edx, DWORD PTR _pCurve$70506[ebp]
  002df	8b 45 d0	 mov	 eax, DWORD PTR _mtCurve$70510[ebp]
  002e2	03 42 40	 add	 eax, DWORD PTR [edx+64]
  002e5	89 45 d0	 mov	 DWORD PTR _mtCurve$70510[ebp], eax

; 3234 :                                 MusicToReferenceTime( mtCurve, &rtTime );

  002e8	8d 4d e8	 lea	 ecx, DWORD PTR _rtTime$70480[ebp]
  002eb	51		 push	 ecx
  002ec	8b 55 d0	 mov	 edx, DWORD PTR _mtCurve$70510[ebp]
  002ef	52		 push	 edx
  002f0	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  002f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f5	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  002f8	52		 push	 edx
  002f9	ff 51 14	 call	 DWORD PTR [ecx+20]

; 3235 :                                 if ( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )

  002fc	8b 45 ec	 mov	 eax, DWORD PTR _rtTime$70480[ebp+4]
  002ff	3b 45 14	 cmp	 eax, DWORD PTR _rtFlush$[ebp+4]
  00302	7c 4a		 jl	 SHORT $L70516
  00304	7f 08		 jg	 SHORT $L75356
  00306	8b 4d e8	 mov	 ecx, DWORD PTR _rtTime$70480[ebp]
  00309	3b 4d 10	 cmp	 ecx, DWORD PTR _rtFlush$[ebp]
  0030c	72 40		 jb	 SHORT $L70516
$L75356:
  0030e	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00311	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00314	83 e0 08	 and	 eax, 8
  00317	85 c0		 test	 eax, eax
  00319	75 33		 jne	 SHORT $L70516

; 3236 :                                 {
; 3237 :                                     MUSIC_TIME mt = 0;

  0031b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _mt$70518[ebp], 0

; 3238 :                                     ReferenceToMusicTime(rtFlush, &mt);

  00322	8d 4d c8	 lea	 ecx, DWORD PTR _mt$70518[ebp]
  00325	51		 push	 ecx
  00326	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  00329	52		 push	 edx
  0032a	8b 45 10	 mov	 eax, DWORD PTR _rtFlush$[ebp]
  0032d	50		 push	 eax
  0032e	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  00331	8b 11		 mov	 edx, DWORD PTR [ecx]
  00333	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00336	50		 push	 eax
  00337	ff 52 18	 call	 DWORD PTR [edx+24]

; 3239 :                                     pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);

  0033a	8b 4d d4	 mov	 ecx, DWORD PTR _pCurve$70506[ebp]
  0033d	8b 55 d8	 mov	 edx, DWORD PTR _mtStart$70511[ebp]
  00340	03 51 38	 add	 edx, DWORD PTR [ecx+56]
  00343	8b 45 c8	 mov	 eax, DWORD PTR _mt$70518[ebp]
  00346	2b c2		 sub	 eax, edx
  00348	8b 4d d4	 mov	 ecx, DWORD PTR _pCurve$70506[ebp]
  0034b	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$L70516:

; 3240 :                                 }
; 3241 :                             }
; 3242 :                         }
; 3243 :                         else 

  0034e	eb 0e		 jmp	 SHORT $L70490
$L70513:

; 3244 :                         {
; 3245 :                             // Otherwise, we may cut the curve short in the code below.
; 3246 :                             rtTime = 0;

  00350	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rtTime$70480[ebp], 0
  00357	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _rtTime$70480[ebp+4], 0
$L70490:

; 3247 :                         }
; 3248 :                     }
; 3249 :                 }
; 3250 :             }
; 3251 :             // now flush the event if needed
; 3252 :             if( rtTime >= rtFlush )

  0035e	8b 55 ec	 mov	 edx, DWORD PTR _rtTime$70480[ebp+4]
  00361	3b 55 14	 cmp	 edx, DWORD PTR _rtFlush$[ebp+4]
  00364	0f 8c be 01 00
	00		 jl	 $L70520
  0036a	7f 0c		 jg	 SHORT $L75357
  0036c	8b 45 e8	 mov	 eax, DWORD PTR _rtTime$70480[ebp]
  0036f	3b 45 10	 cmp	 eax, DWORD PTR _rtFlush$[ebp]
  00372	0f 82 b0 01 00
	00		 jb	 $L70520
$L75357:

; 3253 :             {
; 3254 :                 if (!(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH))

  00378	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0037b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0037e	83 e2 08	 and	 edx, 8
  00381	85 d2		 test	 edx, edx
  00383	0f 85 9a 01 00
	00		 jne	 $L70521

; 3255 :                 {
; 3256 :                     if( pEvent->pTool)

  00389	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0038c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00390	0f 84 7e 01 00
	00		 je	 $L70522

; 3257 :                     {
; 3258 :                         bool fFlush = false;

  00396	c6 45 c7 00	 mov	 BYTE PTR _fFlush$70523[ebp], 0

; 3259 :                         if (pEvent->dwType == DMUS_PMSGT_WAVE)

  0039a	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0039d	83 79 40 0c	 cmp	 DWORD PTR [ecx+64], 12	; 0000000cH
  003a1	0f 85 a3 00 00
	00		 jne	 $L70524

; 3260 :                         {
; 3261 :                             DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);

  003a7	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  003aa	83 c2 18	 add	 edx, 24			; 00000018H
  003ad	89 55 c0	 mov	 DWORD PTR _pWave$70525[ebp], edx

; 3262 :                             if( !(pWave->bFlags & DMUS_WAVEF_OFF) )

  003b0	8b 45 c0	 mov	 eax, DWORD PTR _pWave$70525[ebp]
  003b3	0f b6 48 58	 movzx	 ecx, BYTE PTR [eax+88]
  003b7	83 e1 01	 and	 ecx, 1
  003ba	85 c9		 test	 ecx, ecx
  003bc	75 09		 jne	 SHORT $L70529

; 3263 :                             {
; 3264 :                                 // this wave on is due to start after the flush time.
; 3265 :                                 // we never want to hear it.
; 3266 :                                 fFlush = true;

  003be	c6 45 c7 01	 mov	 BYTE PTR _fFlush$70523[ebp], 1

; 3267 :                             }
; 3268 :                             else 

  003c2	e9 83 00 00 00	 jmp	 $L70524
$L70529:

; 3269 :                             {
; 3270 :                                 // cut the duration short, but don't actually flush here,
; 3271 :                                 // since it's possible to invalidate the same wave more
; 3272 :                                 // than once, and the second invalidation might have a
; 3273 :                                 // time prior to the first one (e.g., first is from a loop,
; 3274 :                                 // second is from a transition)
; 3275 :                                 if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)) &&
; 3276 :                                     rtFlush < pWave->rtTime)

  003c7	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  003ca	83 c2 18	 add	 edx, 24			; 00000018H
  003cd	52		 push	 edx
  003ce	e8 00 00 00 00	 call	 ?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z ; GetInvalidationStatus
  003d3	0f b6 c0	 movzx	 eax, al
  003d6	85 c0		 test	 eax, eax
  003d8	74 70		 je	 SHORT $L70524
  003da	8b 4d c0	 mov	 ecx, DWORD PTR _pWave$70525[ebp]
  003dd	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv665[ebp], ecx
  003e3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv665[ebp]
  003e9	8b 45 14	 mov	 eax, DWORD PTR _rtFlush$[ebp+4]
  003ec	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  003ef	7f 59		 jg	 SHORT $L70524
  003f1	7c 0e		 jl	 SHORT $L75358
  003f3	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv665[ebp]
  003f9	8b 55 10	 mov	 edx, DWORD PTR _rtFlush$[ebp]
  003fc	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  003ff	73 49		 jae	 SHORT $L70524
$L75358:

; 3277 :                                 {
; 3278 :                                     pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;

  00401	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00404	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00407	81 c9 00 00 10
	00		 or	 ecx, 1048576		; 00100000H
  0040d	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00410	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3279 :                                     MUSIC_TIME mtFlush = 0;

  00413	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _mtFlush$70534[ebp], 0

; 3280 :                                     ReferenceToMusicTime(rtFlush, &mtFlush);

  0041a	8d 45 bc	 lea	 eax, DWORD PTR _mtFlush$70534[ebp]
  0041d	50		 push	 eax
  0041e	8b 4d 14	 mov	 ecx, DWORD PTR _rtFlush$[ebp+4]
  00421	51		 push	 ecx
  00422	8b 55 10	 mov	 edx, DWORD PTR _rtFlush$[ebp]
  00425	52		 push	 edx
  00426	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00429	8b 08		 mov	 ecx, DWORD PTR [eax]
  0042b	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  0042e	52		 push	 edx
  0042f	ff 51 18	 call	 DWORD PTR [ecx+24]

; 3281 :                                     pWave->rtTime = rtFlush;

  00432	8b 45 c0	 mov	 eax, DWORD PTR _pWave$70525[ebp]
  00435	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  00438	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0043b	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  0043e	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 3282 :                                     pWave->mtTime = mtFlush;

  00441	8b 45 c0	 mov	 eax, DWORD PTR _pWave$70525[ebp]
  00444	8b 4d bc	 mov	 ecx, DWORD PTR _mtFlush$70534[ebp]
  00447	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L70524:

; 3283 :                                 }
; 3284 :                             }
; 3285 :                         }
; 3286 :                         if (fFlush || 
; 3287 :                             (pEvent->dwType != DMUS_PMSGT_WAVE &&
; 3288 :                              GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )

  0044a	0f b6 55 c7	 movzx	 edx, BYTE PTR _fFlush$70523[ebp]
  0044e	85 d2		 test	 edx, edx
  00450	75 24		 jne	 SHORT $L70538
  00452	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00455	83 78 40 0c	 cmp	 DWORD PTR [eax+64], 12	; 0000000cH
  00459	0f 84 b3 00 00
	00		 je	 $L70537
  0045f	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00462	83 c1 18	 add	 ecx, 24			; 00000018H
  00465	51		 push	 ecx
  00466	e8 00 00 00 00	 call	 ?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z ; GetInvalidationStatus
  0046b	0f b6 d0	 movzx	 edx, al
  0046e	85 d2		 test	 edx, edx
  00470	0f 84 9c 00 00
	00		 je	 $L70537
$L70538:

; 3289 :                         {
; 3290 :                             pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;

  00476	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00479	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0047c	83 c9 02	 or	 ecx, 2
  0047f	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00482	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3291 :                             pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;

  00485	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00488	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0048b	83 c9 20	 or	 ecx, 32			; 00000020H
  0048e	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00491	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 3292 :                             if( rtFlush <= pEvent->rtLast )

  00494	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00497	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv698[ebp], eax
  0049d	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv698[ebp]
  004a3	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  004a6	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  004a9	7f 42		 jg	 SHORT $L70539
  004ab	7c 0e		 jl	 SHORT $L75359
  004ad	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv698[ebp]
  004b3	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  004b6	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  004b9	77 32		 ja	 SHORT $L70539
$L75359:

; 3293 :                             {
; 3294 :                                 pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), pEvent->rtLast + REF_PER_MIL );

  004bb	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  004be	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  004c1	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  004c6	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  004c9	83 d1 00	 adc	 ecx, 0
  004cc	51		 push	 ecx
  004cd	50		 push	 eax
  004ce	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  004d1	83 c2 18	 add	 edx, 24			; 00000018H
  004d4	52		 push	 edx
  004d5	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  004d8	50		 push	 eax
  004d9	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  004dc	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  004df	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  004e2	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  004e5	8b 12		 mov	 edx, DWORD PTR [edx]
  004e7	51		 push	 ecx
  004e8	ff 52 20	 call	 DWORD PTR [edx+32]

; 3295 :                             }
; 3296 :                             else

  004eb	eb 25		 jmp	 SHORT $L70537
$L70539:

; 3297 :                             {
; 3298 :                                 pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlush );

  004ed	8b 45 14	 mov	 eax, DWORD PTR _rtFlush$[ebp+4]
  004f0	50		 push	 eax
  004f1	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  004f4	51		 push	 ecx
  004f5	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  004f8	83 c2 18	 add	 edx, 24			; 00000018H
  004fb	52		 push	 edx
  004fc	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  004ff	50		 push	 eax
  00500	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00503	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00506	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00509	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0050c	8b 12		 mov	 edx, DWORD PTR [edx]
  0050e	51		 push	 ecx
  0050f	ff 52 20	 call	 DWORD PTR [edx+32]
$L70537:

; 3299 :                             }
; 3300 :                         }
; 3301 :                     }
; 3302 :                     else

  00512	eb 0f		 jmp	 SHORT $L70521
$L70522:

; 3303 :                     {
; 3304 :                         pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;

  00514	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00517	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0051a	83 c9 02	 or	 ecx, 2
  0051d	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00520	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L70521:

; 3305 :                     }
; 3306 :                 }
; 3307 :             }
; 3308 :             else // cut notes, waves, and curves short if needed

  00523	e9 bb 03 00 00	 jmp	 $L70478
$L70520:

; 3309 :             {
; 3310 :                 if( pEvent->dwType == DMUS_PMSGT_NOTE && !(dwFlushFlags & FLUSH_LEAVE_ON ))

  00528	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0052b	83 78 40 01	 cmp	 DWORD PTR [eax+64], 1
  0052f	0f 85 b4 00 00
	00		 jne	 $L70547
  00535	8b 4d 20	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  00538	83 e1 01	 and	 ecx, 1
  0053b	85 c9		 test	 ecx, ecx
  0053d	0f 85 a6 00 00
	00		 jne	 $L70547

; 3311 :                 {
; 3312 :                     DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);

  00543	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00546	83 c2 18	 add	 edx, 24			; 00000018H
  00549	89 55 b8	 mov	 DWORD PTR _pNote$70548[ebp], edx

; 3313 :                     if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  0054c	8b 45 b8	 mov	 eax, DWORD PTR _pNote$70548[ebp]
  0054f	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  00553	83 e1 01	 and	 ecx, 1
  00556	85 c9		 test	 ecx, ecx
  00558	0f 84 86 00 00
	00		 je	 $L70552

; 3314 :                     {
; 3315 :                         if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)))

  0055e	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00561	83 c2 18	 add	 edx, 24			; 00000018H
  00564	52		 push	 edx
  00565	e8 00 00 00 00	 call	 ?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z ; GetInvalidationStatus
  0056a	0f b6 c0	 movzx	 eax, al
  0056d	85 c0		 test	 eax, eax
  0056f	74 73		 je	 SHORT $L70552

; 3316 :                         {
; 3317 :                             // subtract 2 from the duration to guarantee the note cuts short
; 3318 :                             // 1 clock before the flush time.
; 3319 :                             MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;

  00571	8b 4d b8	 mov	 ecx, DWORD PTR _pNote$70548[ebp]
  00574	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00577	8b 45 b8	 mov	 eax, DWORD PTR _pNote$70548[ebp]
  0057a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0057d	8d 54 0a fe	 lea	 edx, DWORD PTR [edx+ecx-2]
  00581	89 55 b4	 mov	 DWORD PTR _mtNoteOff$70556[ebp], edx

; 3320 :                             REFERENCE_TIME rtNoteOff;
; 3321 :                             MusicToReferenceTime( mtNoteOff, &rtNoteOff );

  00584	8d 45 a8	 lea	 eax, DWORD PTR _rtNoteOff$70557[ebp]
  00587	50		 push	 eax
  00588	8b 4d b4	 mov	 ecx, DWORD PTR _mtNoteOff$70556[ebp]
  0058b	51		 push	 ecx
  0058c	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  0058f	8b 02		 mov	 eax, DWORD PTR [edx]
  00591	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  00594	51		 push	 ecx
  00595	ff 50 14	 call	 DWORD PTR [eax+20]

; 3322 :                             if( rtNoteOff >= rtFlush )

  00598	8b 55 ac	 mov	 edx, DWORD PTR _rtNoteOff$70557[ebp+4]
  0059b	3b 55 14	 cmp	 edx, DWORD PTR _rtFlush$[ebp+4]
  0059e	7c 44		 jl	 SHORT $L70552
  005a0	7f 08		 jg	 SHORT $L75360
  005a2	8b 45 a8	 mov	 eax, DWORD PTR _rtNoteOff$70557[ebp]
  005a5	3b 45 10	 cmp	 eax, DWORD PTR _rtFlush$[ebp]
  005a8	72 3a		 jb	 SHORT $L70552
$L75360:

; 3323 :                             {
; 3324 :                                 ReferenceToMusicTime( rtFlush, &mtNoteOff );

  005aa	8d 4d b4	 lea	 ecx, DWORD PTR _mtNoteOff$70556[ebp]
  005ad	51		 push	 ecx
  005ae	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  005b1	52		 push	 edx
  005b2	8b 45 10	 mov	 eax, DWORD PTR _rtFlush$[ebp]
  005b5	50		 push	 eax
  005b6	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  005b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  005bb	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  005be	50		 push	 eax
  005bf	ff 52 18	 call	 DWORD PTR [edx+24]

; 3325 :                                 mtNoteOff -= pNote->mtTime;

  005c2	8b 4d b8	 mov	 ecx, DWORD PTR _pNote$70548[ebp]
  005c5	8b 55 b4	 mov	 edx, DWORD PTR _mtNoteOff$70556[ebp]
  005c8	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  005cb	89 55 b4	 mov	 DWORD PTR _mtNoteOff$70556[ebp], edx

; 3326 :                                 // Make any duration < 1 be 0; this will cause the note not to 
; 3327 :                                 // sound.  Can happen if the note's logical time is well before
; 3328 :                                 // its physical time.
; 3329 :                                 if( mtNoteOff < 1 ) mtNoteOff = 0;

  005ce	83 7d b4 01	 cmp	 DWORD PTR _mtNoteOff$70556[ebp], 1
  005d2	7d 07		 jge	 SHORT $L70559
  005d4	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _mtNoteOff$70556[ebp], 0
$L70559:

; 3330 :                                 pNote->mtDuration = mtNoteOff;

  005db	8b 45 b8	 mov	 eax, DWORD PTR _pNote$70548[ebp]
  005de	8b 4d b4	 mov	 ecx, DWORD PTR _mtNoteOff$70556[ebp]
  005e1	89 48 38	 mov	 DWORD PTR [eax+56], ecx
$L70552:

; 3331 :                             }
; 3332 :                         }
; 3333 :                     }
; 3334 :                 }
; 3335 :                 else if( pEvent->dwType == DMUS_PMSGT_WAVE && !(dwFlushFlags & FLUSH_LEAVE_ON ))

  005e4	e9 fa 02 00 00	 jmp	 $L70478
$L70547:
  005e9	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  005ec	83 7a 40 0c	 cmp	 DWORD PTR [edx+64], 12	; 0000000cH
  005f0	0f 85 36 01 00
	00		 jne	 $L70561
  005f6	8b 45 20	 mov	 eax, DWORD PTR _dwFlushFlags$[ebp]
  005f9	83 e0 01	 and	 eax, 1
  005fc	85 c0		 test	 eax, eax
  005fe	0f 85 28 01 00
	00		 jne	 $L70561

; 3336 :                 {
; 3337 :                     DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);

  00604	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00607	83 c1 18	 add	 ecx, 24			; 00000018H
  0060a	89 4d a4	 mov	 DWORD PTR _pWave$70562[ebp], ecx

; 3338 :                     if( !(pWave->bFlags & DMUS_WAVEF_OFF) &&
; 3339 :                         (GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )

  0060d	8b 55 a4	 mov	 edx, DWORD PTR _pWave$70562[ebp]
  00610	0f b6 42 58	 movzx	 eax, BYTE PTR [edx+88]
  00614	83 e0 01	 and	 eax, 1
  00617	85 c0		 test	 eax, eax
  00619	0f 85 08 01 00
	00		 jne	 $L70568
  0061f	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00622	83 c1 18	 add	 ecx, 24			; 00000018H
  00625	51		 push	 ecx
  00626	e8 00 00 00 00	 call	 ?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z ; GetInvalidationStatus
  0062b	0f b6 d0	 movzx	 edx, al
  0062e	85 d2		 test	 edx, edx
  00630	0f 84 f1 00 00
	00		 je	 $L70568

; 3340 :                     {
; 3341 :                         if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)

  00636	8b 45 a4	 mov	 eax, DWORD PTR _pWave$70562[ebp]
  00639	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0063c	83 e1 40	 and	 ecx, 64			; 00000040H
  0063f	85 c9		 test	 ecx, ecx
  00641	74 50		 je	 SHORT $L70569

; 3342 :                         {
; 3343 :                             // This is a clock time message. 
; 3344 :                             // subtract 2 from the duration to guarantee the wave cuts short
; 3345 :                             // 1 clock before the flush time.
; 3346 :                             if ((rtTime + pWave->rtDuration - 2) >= rtFlush)

  00643	8b 55 a4	 mov	 edx, DWORD PTR _pWave$70562[ebp]
  00646	8b 45 e8	 mov	 eax, DWORD PTR _rtTime$70480[ebp]
  00649	03 42 38	 add	 eax, DWORD PTR [edx+56]
  0064c	8b 4d ec	 mov	 ecx, DWORD PTR _rtTime$70480[ebp+4]
  0064f	13 4a 3c	 adc	 ecx, DWORD PTR [edx+60]
  00652	83 e8 02	 sub	 eax, 2
  00655	83 d9 00	 sbb	 ecx, 0
  00658	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv774[ebp], eax
  0065e	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv774[ebp+4], ecx
  00664	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv774[ebp+4]
  0066a	3b 55 14	 cmp	 edx, DWORD PTR _rtFlush$[ebp+4]
  0066d	7c 22		 jl	 SHORT $L70570
  0066f	7f 0b		 jg	 SHORT $L75361
  00671	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv774[ebp]
  00677	3b 45 10	 cmp	 eax, DWORD PTR _rtFlush$[ebp]
  0067a	72 15		 jb	 SHORT $L70570
$L75361:

; 3347 :                             {
; 3348 :                                 pWave->rtDuration = rtFlush - rtTime;

  0067c	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  0067f	2b 4d e8	 sub	 ecx, DWORD PTR _rtTime$70480[ebp]
  00682	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  00685	1b 55 ec	 sbb	 edx, DWORD PTR _rtTime$70480[ebp+4]
  00688	8b 45 a4	 mov	 eax, DWORD PTR _pWave$70562[ebp]
  0068b	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0068e	89 50 3c	 mov	 DWORD PTR [eax+60], edx
$L70570:

; 3349 :                             }
; 3350 :             
; 3351 :                         }
; 3352 :                         else

  00691	eb 60		 jmp	 SHORT $L70571
$L70569:

; 3353 :                         {
; 3354 :                             MUSIC_TIME mtTime = 0;

  00693	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _mtTime$70572[ebp], 0

; 3355 :                             MUSIC_TIME mtFlush = 0;

  0069a	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _mtFlush$70573[ebp], 0

; 3356 :                             ReferenceToMusicTime(rtTime, &mtTime);

  006a1	8d 4d 9c	 lea	 ecx, DWORD PTR _mtTime$70572[ebp]
  006a4	51		 push	 ecx
  006a5	8b 55 ec	 mov	 edx, DWORD PTR _rtTime$70480[ebp+4]
  006a8	52		 push	 edx
  006a9	8b 45 e8	 mov	 eax, DWORD PTR _rtTime$70480[ebp]
  006ac	50		 push	 eax
  006ad	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  006b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  006b2	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  006b5	50		 push	 eax
  006b6	ff 52 18	 call	 DWORD PTR [edx+24]

; 3357 :                             ReferenceToMusicTime(rtFlush, &mtFlush);

  006b9	8d 4d a0	 lea	 ecx, DWORD PTR _mtFlush$70573[ebp]
  006bc	51		 push	 ecx
  006bd	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  006c0	52		 push	 edx
  006c1	8b 45 10	 mov	 eax, DWORD PTR _rtFlush$[ebp]
  006c4	50		 push	 eax
  006c5	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  006c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  006ca	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  006cd	50		 push	 eax
  006ce	ff 52 18	 call	 DWORD PTR [edx+24]

; 3358 :                             // subtract 2 from the duration to guarantee the wave cuts short
; 3359 :                             // 1 clock before the flush time.
; 3360 :                             if ((mtTime + (MUSIC_TIME)pWave->rtDuration - 2) >= mtFlush)

  006d1	8b 4d a4	 mov	 ecx, DWORD PTR _pWave$70562[ebp]
  006d4	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  006d7	8b 45 9c	 mov	 eax, DWORD PTR _mtTime$70572[ebp]
  006da	8d 4c 10 fe	 lea	 ecx, DWORD PTR [eax+edx-2]
  006de	3b 4d a0	 cmp	 ecx, DWORD PTR _mtFlush$70573[ebp]
  006e1	7c 10		 jl	 SHORT $L70571

; 3361 :                             {
; 3362 :                                 pWave->rtDuration = mtFlush - mtTime;

  006e3	8b 45 a0	 mov	 eax, DWORD PTR _mtFlush$70573[ebp]
  006e6	2b 45 9c	 sub	 eax, DWORD PTR _mtTime$70572[ebp]
  006e9	99		 cdq
  006ea	8b 4d a4	 mov	 ecx, DWORD PTR _pWave$70562[ebp]
  006ed	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  006f0	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
$L70571:

; 3363 :                             }
; 3364 :                         }
; 3365 :                         if (pWave->rtDuration < 1) // disallow durations less than 1. This should never happen anyway.

  006f3	8b 55 a4	 mov	 edx, DWORD PTR _pWave$70562[ebp]
  006f6	89 95 68 ff ff
	ff		 mov	 DWORD PTR tv814[ebp], edx
  006fc	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv814[ebp]
  00702	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00706	7f 1f		 jg	 SHORT $L70568
  00708	7c 0c		 jl	 SHORT $L75362
  0070a	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv814[ebp]
  00710	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00714	73 11		 jae	 SHORT $L70568
$L75362:

; 3366 :                         {
; 3367 :                             pWave->rtDuration = 1;

  00716	8b 55 a4	 mov	 edx, DWORD PTR _pWave$70562[ebp]
  00719	c7 42 38 01 00
	00 00		 mov	 DWORD PTR [edx+56], 1
  00720	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0
$L70568:

; 3368 :                         }
; 3369 :                     }
; 3370 :                 }
; 3371 :                 else if( pEvent->dwType == DMUS_PMSGT_CURVE && !(dwFlushFlags & FLUSH_LEAVE_ON ))

  00727	e9 b7 01 00 00	 jmp	 $L70478
$L70561:
  0072c	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0072f	83 78 40 05	 cmp	 DWORD PTR [eax+64], 5
  00733	0f 85 aa 01 00
	00		 jne	 $L70478
  00739	8b 4d 20	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  0073c	83 e1 01	 and	 ecx, 1
  0073f	85 c9		 test	 ecx, ecx
  00741	0f 85 9c 01 00
	00		 jne	 $L70478

; 3372 :                 {
; 3373 :                     DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);

  00747	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0074a	83 c2 18	 add	 edx, 24			; 00000018H
  0074d	89 55 90	 mov	 DWORD PTR _pCurve$70579[ebp], edx

; 3374 :                     MUSIC_TIME mtEnd;
; 3375 :                     MUSIC_TIME mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

  00750	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  00753	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00757	74 0e		 je	 SHORT $L75351
  00759	8b 4d 90	 mov	 ecx, DWORD PTR _pCurve$70579[ebp]
  0075c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0075f	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], edx
  00765	eb 0c		 jmp	 SHORT $L75352
$L75351:
  00767	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  0076a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0076d	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], ecx
$L75352:
  00773	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv392[ebp]
  00779	89 55 98	 mov	 DWORD PTR _mtStart$70584[ebp], edx

; 3376 : 
; 3377 :                     if( pCurve->bFlags & DMUS_CURVE_RESET )

  0077c	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  0077f	0f b6 48 53	 movzx	 ecx, BYTE PTR [eax+83]
  00783	83 e1 01	 and	 ecx, 1
  00786	85 c9		 test	 ecx, ecx
  00788	74 14		 je	 SHORT $L70585

; 3378 :                     {
; 3379 :                         mtEnd = mtStart + pCurve->mtResetDuration + pCurve->mtDuration;

  0078a	8b 55 90	 mov	 edx, DWORD PTR _pCurve$70579[ebp]
  0078d	8b 45 98	 mov	 eax, DWORD PTR _mtStart$70584[ebp]
  00790	03 42 40	 add	 eax, DWORD PTR [edx+64]
  00793	8b 4d 90	 mov	 ecx, DWORD PTR _pCurve$70579[ebp]
  00796	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  00799	89 45 94	 mov	 DWORD PTR _mtEnd$70583[ebp], eax

; 3380 :                     }
; 3381 :                     else

  0079c	eb 0c		 jmp	 SHORT $L70586
$L70585:

; 3382 :                     {
; 3383 :                         mtEnd = mtStart + pCurve->mtDuration;

  0079e	8b 55 90	 mov	 edx, DWORD PTR _pCurve$70579[ebp]
  007a1	8b 45 98	 mov	 eax, DWORD PTR _mtStart$70584[ebp]
  007a4	03 42 38	 add	 eax, DWORD PTR [edx+56]
  007a7	89 45 94	 mov	 DWORD PTR _mtEnd$70583[ebp], eax
$L70586:

; 3384 :                     }
; 3385 :                     REFERENCE_TIME rtEnd;
; 3386 :                     MusicToReferenceTime( mtEnd, &rtEnd );

  007aa	8d 4d 88	 lea	 ecx, DWORD PTR _rtEnd$70587[ebp]
  007ad	51		 push	 ecx
  007ae	8b 55 94	 mov	 edx, DWORD PTR _mtEnd$70583[ebp]
  007b1	52		 push	 edx
  007b2	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  007b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  007b7	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  007ba	52		 push	 edx
  007bb	ff 51 14	 call	 DWORD PTR [ecx+20]

; 3387 :                     // Note: as a result of fixing 33987, the curve is no longer given
; 3388 :                     // a negative reset duration.  Now, the curve's duration is recomputed
; 3389 :                     // and its time slice is recalculated.
; 3390 :                     if( rtEnd >= rtFlush )

  007be	8b 45 8c	 mov	 eax, DWORD PTR _rtEnd$70587[ebp+4]
  007c1	3b 45 14	 cmp	 eax, DWORD PTR _rtFlush$[ebp+4]
  007c4	0f 8c 19 01 00
	00		 jl	 $L70478
  007ca	7f 0c		 jg	 SHORT $L75363
  007cc	8b 4d 88	 mov	 ecx, DWORD PTR _rtEnd$70587[ebp]
  007cf	3b 4d 10	 cmp	 ecx, DWORD PTR _rtFlush$[ebp]
  007d2	0f 82 0b 01 00
	00		 jb	 $L70478
$L75363:

; 3391 :                     {
; 3392 :                         // reset the curve's duration
; 3393 :                         MUSIC_TIME mtFlush;
; 3394 :                         ReferenceToMusicTime( rtFlush, &mtFlush );

  007d8	8d 55 84	 lea	 edx, DWORD PTR _mtFlush$70589[ebp]
  007db	52		 push	 edx
  007dc	8b 45 14	 mov	 eax, DWORD PTR _rtFlush$[ebp+4]
  007df	50		 push	 eax
  007e0	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  007e3	51		 push	 ecx
  007e4	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  007e7	8b 02		 mov	 eax, DWORD PTR [edx]
  007e9	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  007ec	51		 push	 ecx
  007ed	ff 50 18	 call	 DWORD PTR [eax+24]

; 3395 :                         mtEnd = mtFlush - mtStart;

  007f0	8b 55 84	 mov	 edx, DWORD PTR _mtFlush$70589[ebp]
  007f3	2b 55 98	 sub	 edx, DWORD PTR _mtStart$70584[ebp]
  007f6	89 55 94	 mov	 DWORD PTR _mtEnd$70583[ebp], edx

; 3396 :                         // get the curve value at the flush time, and make that the end value
; 3397 :                         pCurve->nEndValue = (short) RecomputeCurveEnd(pCurve, mtEnd);

  007f9	8b 45 94	 mov	 eax, DWORD PTR _mtEnd$70583[ebp]
  007fc	50		 push	 eax
  007fd	8b 4d 90	 mov	 ecx, DWORD PTR _pCurve$70579[ebp]
  00800	51		 push	 ecx
  00801	e8 00 00 00 00	 call	 ?RecomputeCurveEnd@@YGHPAU_DMUS_CURVE_PMSG@@J@Z ; RecomputeCurveEnd
  00806	8b 55 90	 mov	 edx, DWORD PTR _pCurve$70579[ebp]
  00809	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 3398 :                         // subtract 2 from the duration to guarantee the curve cuts short
; 3399 :                         // 1 clock before the flush time.
; 3400 :                         mtEnd -= 2;

  0080d	8b 45 94	 mov	 eax, DWORD PTR _mtEnd$70583[ebp]
  00810	83 e8 02	 sub	 eax, 2
  00813	89 45 94	 mov	 DWORD PTR _mtEnd$70583[ebp], eax

; 3401 :                         if ( mtEnd < 1)

  00816	83 7d 94 01	 cmp	 DWORD PTR _mtEnd$70583[ebp], 1
  0081a	7d 0c		 jge	 SHORT $L70591

; 3402 :                         {
; 3403 :                             mtEnd = 1;

  0081c	c7 45 94 01 00
	00 00		 mov	 DWORD PTR _mtEnd$70583[ebp], 1

; 3404 :                         }
; 3405 :                         else if (pCurve->bFlags & DMUS_CURVE_RESET) 

  00823	e9 bb 00 00 00	 jmp	 $L70478
$L70591:
  00828	8b 4d 90	 mov	 ecx, DWORD PTR _pCurve$70579[ebp]
  0082b	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  0082f	83 e2 01	 and	 edx, 1
  00832	85 d2		 test	 edx, edx
  00834	0f 84 9a 00 00
	00		 je	 $L70593

; 3406 :                         {
; 3407 :                             if (mtEnd > pCurve->mtDuration)

  0083a	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  0083d	8b 4d 94	 mov	 ecx, DWORD PTR _mtEnd$70583[ebp]
  00840	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00843	7e 2e		 jle	 SHORT $L70594

; 3408 :                             {
; 3409 :                                 // curve ends in the reset duration; keep regular duration the
; 3410 :                                 // same as it was and adjust reset duration
; 3411 :                                 pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;

  00845	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00848	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0084b	83 c8 08	 or	 eax, 8
  0084e	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00851	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3412 :                                 pCurve->mtResetDuration = mtFlush - (mtStart + pCurve->mtDuration);

  00854	8b 55 90	 mov	 edx, DWORD PTR _pCurve$70579[ebp]
  00857	8b 45 98	 mov	 eax, DWORD PTR _mtStart$70584[ebp]
  0085a	03 42 38	 add	 eax, DWORD PTR [edx+56]
  0085d	8b 4d 84	 mov	 ecx, DWORD PTR _mtFlush$70589[ebp]
  00860	2b c8		 sub	 ecx, eax
  00862	8b 55 90	 mov	 edx, DWORD PTR _pCurve$70579[ebp]
  00865	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 3413 :                                 mtEnd = pCurve->mtDuration;

  00868	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  0086b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0086e	89 4d 94	 mov	 DWORD PTR _mtEnd$70583[ebp], ecx

; 3414 : /* NOTE: I've commented out a bunch of code because it really seems to be redundant.
; 3415 :    And, it was exhibiting the problem of not always reseting before the invalidation.
; 3416 :    By forcing the time stamp to be just before the invalidation for all cases, it seems
; 3417 :    to clear up behavior. But, I'm leaving the old code in comments in case something
; 3418 :    breaks and we have that, "ah, that's what that was doing!" realization.
; 3419 : */
; 3420 : //                                if (pCurve->mtTime > mtEnd + pCurve->mtResetDuration + mtStart)
; 3421 : //                                {
; 3422 : //                                    pCurve->mtTime = mtEnd + pCurve->mtResetDuration + mtStart;
; 3423 :                                     // Need to requeue since the time stamp has changed.
; 3424 : //                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
; 3425 : //                            MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
; 3426 : //                                }
; 3427 :                             }
; 3428 :                             else 

  00871	eb 20		 jmp	 SHORT $L70595
$L70594:

; 3429 :                             {
; 3430 :                                 // curve ends in the regular duration; reduce it by 1 and
; 3431 :                                 // give the reset duration a value of 1
; 3432 :                                 mtEnd--;

  00873	8b 55 94	 mov	 edx, DWORD PTR _mtEnd$70583[ebp]
  00876	83 ea 01	 sub	 edx, 1
  00879	89 55 94	 mov	 DWORD PTR _mtEnd$70583[ebp], edx

; 3433 :                                 pCurve->mtResetDuration = 1;

  0087c	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  0087f	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [eax+64], 1

; 3434 :                                 if (mtEnd < 1)

  00886	83 7d 94 01	 cmp	 DWORD PTR _mtEnd$70583[ebp], 1
  0088a	7d 07		 jge	 SHORT $L70595

; 3435 :                                 {
; 3436 :                                     // this is unlikely, but the curve really should have
; 3437 :                                     // a duration...
; 3438 :                                     mtEnd = 1;

  0088c	c7 45 94 01 00
	00 00		 mov	 DWORD PTR _mtEnd$70583[ebp], 1
$L70595:

; 3439 :                                 }
; 3440 : //                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
; 3441 :                             }
; 3442 :                             // If this is an instant curve that's already started, we
; 3443 :                             // don't want it to play again, so reset its start time
; 3444 : /*                            if ( pCurve->bCurveShape == DMUS_CURVES_INSTANT && 
; 3445 :                                  pCurve->mtOriginalStart )
; 3446 :                             {
; 3447 :                                 pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart + mtEnd;
; 3448 :                                 pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
; 3449 :                                 MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
; 3450 :                             }*/
; 3451 :                             // Ensure that the end of the curve will play prior to the invalidation.
; 3452 :                             pCurve->rtTime = rtFlush - 10000; // Drop this back 1 ms to ensure rounding errors don't push it up.

  00893	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  00896	81 e9 10 27 00
	00		 sub	 ecx, 10000		; 00002710H
  0089c	8b 55 14	 mov	 edx, DWORD PTR _rtFlush$[ebp+4]
  0089f	83 da 00	 sbb	 edx, 0
  008a2	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  008a5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  008a8	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 3453 :                             pCurve->mtTime = mtFlush - 2;

  008ab	8b 4d 84	 mov	 ecx, DWORD PTR _mtFlush$70589[ebp]
  008ae	83 e9 02	 sub	 ecx, 2
  008b1	8b 55 90	 mov	 edx, DWORD PTR _pCurve$70579[ebp]
  008b4	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3454 :                             pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;

  008b7	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  008ba	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  008bd	81 c9 00 00 10
	00		 or	 ecx, 1048576		; 00100000H
  008c3	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  008c6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3455 :                             pCurve->mtDuration = mtEnd;

  008c9	8b 45 90	 mov	 eax, DWORD PTR _pCurve$70579[ebp]
  008cc	8b 4d 94	 mov	 ecx, DWORD PTR _mtEnd$70583[ebp]
  008cf	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 3456 :                         }
; 3457 :                         else

  008d2	eb 0f		 jmp	 SHORT $L70478
$L70593:

; 3458 :                         {
; 3459 :                             // If this does not have a reset, simply lose it.
; 3460 :                             pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;

  008d4	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  008d7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008da	83 c8 02	 or	 eax, 2
  008dd	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  008e0	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L70478:

; 3461 :                         }
; 3462 :                     }
; 3463 :                 }
; 3464 :             }
; 3465 :         }
; 3466 :     }

  008e3	e9 4b f7 ff ff	 jmp	 $L70476
$L70477:

; 3467 :     // remove (and unmark) all marked PMsgs from the current queue
; 3468 :     for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )

  008e8	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  008eb	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  008f0	89 45 f8	 mov	 DWORD PTR _pEvent$[ebp], eax
  008f3	eb 06		 jmp	 SHORT $L70598
$L70599:
  008f5	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  008f8	89 55 f8	 mov	 DWORD PTR _pEvent$[ebp], edx
$L70598:
  008fb	83 7d f8 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  008ff	74 73		 je	 SHORT $L70471

; 3469 :     {
; 3470 :         pNext = pEvent->pNext;

  00901	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00904	8b 08		 mov	 ecx, DWORD PTR [eax]
  00906	89 4d fc	 mov	 DWORD PTR _pNext$[ebp], ecx

; 3471 :         if (pEvent->dwPrivFlags & (PRIV_FLAG_REMOVE | PRIV_FLAG_REQUEUE))

  00909	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0090c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0090f	25 02 00 10 00	 and	 eax, 1048578		; 00100002H
  00914	85 c0		 test	 eax, eax
  00916	74 5a		 je	 SHORT $L70601

; 3472 :         {
; 3473 :             pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;

  00918	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0091b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0091e	83 e2 fd	 and	 edx, -3			; fffffffdH
  00921	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00924	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3474 :             if (pQueue->Dequeue(pEvent))

  00927	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0092a	51		 push	 ecx
  0092b	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  0092e	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z ; CPMsgQueue::Dequeue
  00933	85 c0		 test	 eax, eax
  00935	74 3b		 je	 SHORT $L70601

; 3475 :             {
; 3476 :                 if (pEvent->dwPrivFlags & PRIV_FLAG_REQUEUE)

  00937	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0093a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0093d	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00942	85 c0		 test	 eax, eax
  00944	74 20		 je	 SHORT $L70603

; 3477 :                 {
; 3478 :                     pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;

  00946	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00949	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0094c	81 e2 ff ff ef
	ff		 and	 edx, -1048577		; ffefffffH
  00952	8b 45 f8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00955	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3479 :                     pQueue->Enqueue(pEvent);

  00958	8b 4d f8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0095b	51		 push	 ecx
  0095c	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  0095f	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 3480 :                 }
; 3481 :                 else

  00964	eb 0c		 jmp	 SHORT $L70601
$L70603:

; 3482 :                 {
; 3483 :                     FreePMsg(pEvent);

  00966	8b 55 f8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00969	52		 push	 edx
  0096a	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  0096d	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L70601:

; 3484 :                 }
; 3485 :             }
; 3486 :             else
; 3487 :             {
; 3488 :                 TraceI(0,"Error dequeing event for flushing\n");
; 3489 :             }
; 3490 :         }
; 3491 :     }

  00972	eb 81		 jmp	 SHORT $L70599
$L70471:

; 3492 :     SendBuffers();
; 3493 : }

  00974	8b e5		 mov	 esp, ebp
  00976	5d		 pop	 ebp
  00977	c2 1c 00	 ret	 28			; 0000001cH
?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ENDP ; CPerformance::FlushEventQueue
_TEXT	ENDS
EXTRN	_GUID_NOTIFICATION_SEGMENT:BYTE
; Function compile flags: /Odt
;	COMDAT ?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
_pNotification$70386 = -16
_pWave$70381 = -12
_pNote$70376 = -8
_fResult$ = -1
_pPMsg$ = 8
?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z PROC NEAR	; GetInvalidationStatus, COMDAT

; 2879 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2880 :     bool fResult = true; // default: invalidate the note

  00006	c6 45 ff 01	 mov	 BYTE PTR _fResult$[ebp], 1

; 2881 : 
; 2882 :     if( pPMsg->dwType == DMUS_PMSGT_NOTE )

  0000a	8b 45 08	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0000d	83 78 28 01	 cmp	 DWORD PTR [eax+40], 1
  00011	75 1a		 jne	 SHORT $L70375

; 2883 :     {
; 2884 :         DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR _pNote$70376[ebp], ecx

; 2885 :         if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE)

  00019	8b 55 f8	 mov	 edx, DWORD PTR _pNote$70376[ebp]
  0001c	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00020	83 e0 02	 and	 eax, 2
  00023	85 c0		 test	 eax, eax
  00025	74 04		 je	 SHORT $L70378

; 2886 :         {
; 2887 :             fResult = false;

  00027	c6 45 ff 00	 mov	 BYTE PTR _fResult$[ebp], 0
$L70378:

; 2888 :         }
; 2889 :     }
; 2890 :     else if( pPMsg->dwType == DMUS_PMSGT_WAVE )

  0002b	eb 54		 jmp	 SHORT $L70379
$L70375:
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00030	83 79 28 0c	 cmp	 DWORD PTR [ecx+40], 12	; 0000000cH
  00034	75 1a		 jne	 SHORT $L70380

; 2891 :     {
; 2892 :         DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;

  00036	8b 55 08	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00039	89 55 f4	 mov	 DWORD PTR _pWave$70381[ebp], edx

; 2893 :         if(pWave->bFlags & DMUS_WAVEF_NOINVALIDATE)

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _pWave$70381[ebp]
  0003f	0f b6 48 58	 movzx	 ecx, BYTE PTR [eax+88]
  00043	83 e1 04	 and	 ecx, 4
  00046	85 c9		 test	 ecx, ecx
  00048	74 04		 je	 SHORT $L70383

; 2894 :         {
; 2895 :             fResult = false;

  0004a	c6 45 ff 00	 mov	 BYTE PTR _fResult$[ebp], 0
$L70383:

; 2896 :         }
; 2897 :     }
; 2898 :     else if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )

  0004e	eb 31		 jmp	 SHORT $L70379
$L70380:
  00050	8b 55 08	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00053	83 7a 28 03	 cmp	 DWORD PTR [edx+40], 3
  00057	75 28		 jne	 SHORT $L70379

; 2899 :     {
; 2900 :         // Don't invalidate segment abort messages
; 2901 :         DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;

  00059	8b 45 08	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0005c	89 45 f0	 mov	 DWORD PTR _pNotification$70386[ebp], eax

; 2902 :         if ((pNotification->guidNotificationType == GUID_NOTIFICATION_SEGMENT) &&
; 2903 :             (pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT))

  0005f	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_NOTIFICATION_SEGMENT
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _pNotification$70386[ebp]
  00067	83 c1 38	 add	 ecx, 56			; 00000038H
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _==@8
  00070	85 c0		 test	 eax, eax
  00072	74 0d		 je	 SHORT $L70379
  00074	8b 55 f0	 mov	 edx, DWORD PTR _pNotification$70386[ebp]
  00077	83 7a 48 04	 cmp	 DWORD PTR [edx+72], 4
  0007b	75 04		 jne	 SHORT $L70379

; 2904 : 		{
; 2905 :             fResult = false;

  0007d	c6 45 ff 00	 mov	 BYTE PTR _fResult$[ebp], 0
$L70379:

; 2906 : 		}
; 2907 :     }
; 2908 :     return fResult;

  00081	8a 45 ff	 mov	 al, BYTE PTR _fResult$[ebp]

; 2909 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?GetInvalidationStatus@@YG_NPAU_DMUS_PMSG@@@Z ENDP	; GetInvalidationStatus
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RecomputeCurveEnd@@YGHPAU_DMUS_CURVE_PMSG@@J@Z
_TEXT	SEGMENT
tv66 = -16
_lIndex$70460 = -12
_nRet$ = -8
_panTable$ = -4
_pCurve$ = 8
_mtCurrent$ = 12
?RecomputeCurveEnd@@YGHPAU_DMUS_CURVE_PMSG@@J@Z PROC NEAR ; RecomputeCurveEnd, COMDAT

; 3075 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3076 :     int nRet = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nRet$[ebp], 0

; 3077 :     short *panTable;
; 3078 : 
; 3079 :     switch( pCurve->bCurveShape )
; 3080 :     {

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00010	0f b6 48 51	 movzx	 ecx, BYTE PTR [eax+81]
  00014	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  00017	83 7d f0 04	 cmp	 DWORD PTR tv66[ebp], 4
  0001b	77 0a		 ja	 SHORT $L70452
  0001d	8b 55 f0	 mov	 edx, DWORD PTR tv66[ebp]
  00020	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L75370[edx*4]
$L70452:

; 3081 :     case DMUS_CURVES_INSTANT:
; 3082 :     default:
; 3083 :         return pCurve->nEndValue;

  00027	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0002a	0f bf 40 46	 movsx	 eax, WORD PTR [eax+70]
  0002e	e9 af 00 00 00	 jmp	 $L70445
$L70453:

; 3084 :         break;
; 3085 :     case DMUS_CURVES_LINEAR:
; 3086 :         panTable = &ganCT_Linear[ 0 ];

  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Linear

; 3087 :         break;

  0003a	eb 19		 jmp	 SHORT $L70449
$L70454:

; 3088 :     case DMUS_CURVES_EXP:
; 3089 :         panTable = &ganCT_Exp[ 0 ];

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Exp

; 3090 :         break;

  00043	eb 10		 jmp	 SHORT $L70449
$L70455:

; 3091 :     case DMUS_CURVES_LOG:
; 3092 :         panTable = &ganCT_Log[ 0 ];

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Log

; 3093 :         break;

  0004c	eb 07		 jmp	 SHORT $L70449
$L70456:

; 3094 :     case DMUS_CURVES_SINE:
; 3095 :         panTable = &ganCT_Sine[ 0 ];

  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Sine
$L70449:

; 3096 :         break;
; 3097 :     }
; 3098 : 
; 3099 :     if( (pCurve->mtDuration == 0) || (mtCurrent >= pCurve->mtDuration ))

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00058	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0005c	74 0b		 je	 SHORT $L70458
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00061	8b 45 0c	 mov	 eax, DWORD PTR _mtCurrent$[ebp]
  00064	3b 42 38	 cmp	 eax, DWORD PTR [edx+56]
  00067	7c 09		 jl	 SHORT $L70457
$L70458:

; 3100 :     {
; 3101 :         return pCurve->nEndValue;

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0006c	0f bf 41 46	 movsx	 eax, WORD PTR [ecx+70]
  00070	eb 70		 jmp	 SHORT $L70445
$L70457:

; 3102 :     }
; 3103 :     else
; 3104 :     {
; 3105 :         // Calculate how far into the table we should be.
; 3106 :         long lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

  00072	8b 45 0c	 mov	 eax, DWORD PTR _mtCurrent$[ebp]
  00075	69 c0 c1 00 00
	00		 imul	 eax, 193		; 000000c1H
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0007e	99		 cdq
  0007f	f7 79 38	 idiv	 DWORD PTR [ecx+56]
  00082	89 45 f4	 mov	 DWORD PTR _lIndex$70460[ebp], eax

; 3107 : 
; 3108 :         // find an amount of time to add to the curve event such that there is at
; 3109 :         // least a change by CT_FACTOR. This will be used as the time stamp
; 3110 :         // for the next iteration of the curve.
; 3111 : 
; 3112 :         // clamp lIndex
; 3113 :         if( lIndex < 0 )

  00085	83 7d f4 00	 cmp	 DWORD PTR _lIndex$70460[ebp], 0
  00089	7d 07		 jge	 SHORT $L70461

; 3114 :         {
; 3115 :             lIndex = 0;

  0008b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lIndex$70460[ebp], 0
$L70461:

; 3116 :         }
; 3117 :         if( lIndex >= CT_MAX )

  00092	81 7d f4 c0 00
	00 00		 cmp	 DWORD PTR _lIndex$70460[ebp], 192 ; 000000c0H
  00099	7c 13		 jl	 SHORT $L70462

; 3118 :         {
; 3119 :             lIndex = CT_MAX;

  0009b	c7 45 f4 c0 00
	00 00		 mov	 DWORD PTR _lIndex$70460[ebp], 192 ; 000000c0H

; 3120 :             nRet = pCurve->nEndValue;

  000a2	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  000a5	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  000a9	89 45 f8	 mov	 DWORD PTR _nRet$[ebp], eax

; 3121 :         }
; 3122 :         else

  000ac	eb 31		 jmp	 SHORT $L70459
$L70462:

; 3123 :         {
; 3124 :             // Okay, in the curve, so calculate the return value.
; 3125 :             nRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) / 
; 3126 :                 CT_DIVFACTOR) + pCurve->nStartValue;

  000ae	8b 4d f4	 mov	 ecx, DWORD PTR _lIndex$70460[ebp]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _panTable$[ebp]
  000b4	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000bb	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000c2	0f bf 49 44	 movsx	 ecx, WORD PTR [ecx+68]
  000c6	2b d1		 sub	 edx, ecx
  000c8	0f af c2	 imul	 eax, edx
  000cb	99		 cdq
  000cc	b9 00 4b 00 00	 mov	 ecx, 19200		; 00004b00H
  000d1	f7 f9		 idiv	 ecx
  000d3	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  000d6	0f bf 4a 44	 movsx	 ecx, WORD PTR [edx+68]
  000da	03 c1		 add	 eax, ecx
  000dc	89 45 f8	 mov	 DWORD PTR _nRet$[ebp], eax
$L70459:

; 3127 :         }
; 3128 :     }
; 3129 :     return nRet;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]
$L70445:

; 3130 : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 08 00	 ret	 8
$L75370:
  000e8	00 00 00 00	 DD	 $L70453
  000ec	00 00 00 00	 DD	 $L70452
  000f0	00 00 00 00	 DD	 $L70454
  000f4	00 00 00 00	 DD	 $L70455
  000f8	00 00 00 00	 DD	 $L70456
?RecomputeCurveEnd@@YGHPAU_DMUS_CURVE_PMSG@@J@Z ENDP	; RecomputeCurveEnd
_TEXT	ENDS
PUBLIC	?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z	; CPerformance::FlushMainEventQueues
; Function compile flags: /Odt
;	COMDAT ?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z
_TEXT	SEGMENT
_this$ = -24
_mtTime$70621 = -20
_rtUnresolved$ = -16
_rt$ = -8
_dwId$ = 8
_mtFlush$ = 12
_mtFlushUnresolved$ = 16
_dwFlushFlags$ = 20
?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z PROC NEAR ; CPerformance::FlushMainEventQueues, COMDAT
; _this$ = ecx

; 3507 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 3508 :     REFERENCE_TIME rt;
; 3509 :     if( mtFlush )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _mtFlush$[ebp], 0
  0000d	74 16		 je	 SHORT $L70615

; 3510 :     {
; 3511 :         MusicToReferenceTime( mtFlush, &rt );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _rt$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _mtFlush$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	ff 50 14	 call	 DWORD PTR [eax+20]

; 3512 :     }
; 3513 :     else

  00023	eb 0e		 jmp	 SHORT $L70616
$L70615:

; 3514 :     {
; 3515 :         rt = 0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _rt$[ebp], 0
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rt$[ebp+4], 0
$L70616:

; 3516 :     }
; 3517 :     REFERENCE_TIME rtUnresolved;
; 3518 :     if( mtFlushUnresolved && mtFlushUnresolved != mtFlush)

  00033	83 7d 10 00	 cmp	 DWORD PTR _mtFlushUnresolved$[ebp], 0
  00037	74 1e		 je	 SHORT $L70618
  00039	8b 55 10	 mov	 edx, DWORD PTR _mtFlushUnresolved$[ebp]
  0003c	3b 55 0c	 cmp	 edx, DWORD PTR _mtFlush$[ebp]
  0003f	74 16		 je	 SHORT $L70618

; 3519 :     {
; 3520 :         MusicToReferenceTime( mtFlushUnresolved, &rtUnresolved );

  00041	8d 45 f0	 lea	 eax, DWORD PTR _rtUnresolved$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 10	 mov	 ecx, DWORD PTR _mtFlushUnresolved$[ebp]
  00048	51		 push	 ecx
  00049	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 02		 mov	 eax, DWORD PTR [edx]
  0004e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	51		 push	 ecx
  00052	ff 50 14	 call	 DWORD PTR [eax+20]

; 3521 :     }
; 3522 :     else

  00055	eb 0c		 jmp	 SHORT $L70619
$L70618:

; 3523 :     {
; 3524 :         rtUnresolved = rt;

  00057	8b 55 f8	 mov	 edx, DWORD PTR _rt$[ebp]
  0005a	89 55 f0	 mov	 DWORD PTR _rtUnresolved$[ebp], edx
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _rt$[ebp+4]
  00060	89 45 f4	 mov	 DWORD PTR _rtUnresolved$[ebp+4], eax
$L70619:

; 3525 :     }
; 3526 :     FlushEventQueue( dwId, &m_OnTimeQueue, rt, rtUnresolved, dwFlushFlags );

  00063	8b 4d 14	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 f4	 mov	 edx, DWORD PTR _rtUnresolved$[ebp+4]
  0006a	52		 push	 edx
  0006b	8b 45 f0	 mov	 eax, DWORD PTR _rtUnresolved$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  00072	51		 push	 ecx
  00073	8b 55 f8	 mov	 edx, DWORD PTR _rt$[ebp]
  00076	52		 push	 edx
  00077	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0007f	50		 push	 eax
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _dwId$[ebp]
  00083	51		 push	 ecx
  00084	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue

; 3527 :     FlushEventQueue( dwId, &m_NearTimeQueue, rt, rtUnresolved, dwFlushFlags );

  0008c	8b 55 14	 mov	 edx, DWORD PTR _dwFlushFlags$[ebp]
  0008f	52		 push	 edx
  00090	8b 45 f4	 mov	 eax, DWORD PTR _rtUnresolved$[ebp+4]
  00093	50		 push	 eax
  00094	8b 4d f0	 mov	 ecx, DWORD PTR _rtUnresolved$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR _rt$[ebp+4]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _rt$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  000a9	51		 push	 ecx
  000aa	8b 55 08	 mov	 edx, DWORD PTR _dwId$[ebp]
  000ad	52		 push	 edx
  000ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue

; 3528 :     FlushEventQueue( dwId, &m_EarlyQueue, rt, rtUnresolved, dwFlushFlags );

  000b6	8b 45 14	 mov	 eax, DWORD PTR _dwFlushFlags$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _rtUnresolved$[ebp+4]
  000bd	51		 push	 ecx
  000be	8b 55 f0	 mov	 edx, DWORD PTR _rtUnresolved$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 fc	 mov	 eax, DWORD PTR _rt$[ebp+4]
  000c5	50		 push	 eax
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _rt$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000cd	81 c2 14 01 00
	00		 add	 edx, 276		; 00000114H
  000d3	52		 push	 edx
  000d4	8b 45 08	 mov	 eax, DWORD PTR _dwId$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	e8 00 00 00 00	 call	 ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue

; 3529 :     if (dwId == 0)

  000e0	83 7d 08 00	 cmp	 DWORD PTR _dwId$[ebp], 0
  000e4	75 51		 jne	 SHORT $L70613

; 3530 :     {
; 3531 :         MUSIC_TIME mtTime;
; 3532 :         ReferenceToMusicTime(rt,&mtTime);

  000e6	8d 4d ec	 lea	 ecx, DWORD PTR _mtTime$70621[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 fc	 mov	 edx, DWORD PTR _rt$[ebp+4]
  000ed	52		 push	 edx
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _rt$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	50		 push	 eax
  000fb	ff 52 18	 call	 DWORD PTR [edx+24]

; 3533 :         FlushEventQueue( dwId, &m_TempoMap, rt, rtUnresolved, dwFlushFlags );

  000fe	8b 4d 14	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  00101	51		 push	 ecx
  00102	8b 55 f4	 mov	 edx, DWORD PTR _rtUnresolved$[ebp+4]
  00105	52		 push	 edx
  00106	8b 45 f0	 mov	 eax, DWORD PTR _rtUnresolved$[ebp]
  00109	50		 push	 eax
  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  0010d	51		 push	 ecx
  0010e	8b 55 f8	 mov	 edx, DWORD PTR _rt$[ebp]
  00111	52		 push	 edx
  00112	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	05 38 01 00 00	 add	 eax, 312		; 00000138H
  0011a	50		 push	 eax
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _dwId$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	e8 00 00 00 00	 call	 ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue

; 3534 :         RecalcTempoMap(NULL, mtTime );

  00127	6a 01		 push	 1
  00129	8b 55 ec	 mov	 edx, DWORD PTR _mtTime$70621[ebp]
  0012c	52		 push	 edx
  0012d	6a 00		 push	 0
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap
$L70613:

; 3535 :     }
; 3536 : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H
?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z ENDP	; CPerformance::FlushMainEventQueues
_TEXT	ENDS
PUBLIC	?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z ; CPerformance::GetChordNotificationStatus
PUBLIC	?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z ; CPerformance::OnChordUpdateEventQueue
; Function compile flags: /Odt
;	COMDAT ?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z
_TEXT	SEGMENT
tv136 = -104
tv268 = -96
_this$ = -92
_rtNoteOff$70664 = -88
_mtNoteOff$70663 = -76
_rtFlushTime$70650 = -72
_mtNote$70648 = -64
_pNote$70643 = -60
_rtTime$70642 = -56
_pNew$70639 = -48
_dwTrackGroup$ = -44
_rtTemp$ = -40
_hr$ = -28
_pEvent$ = -24
_UpdateQueue$ = -20
_pNext$ = -8
_dwId$ = -4
_pNotify$ = 8
_pQueue$ = 12
_rtFlush$ = 16
?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z PROC NEAR ; CPerformance::OnChordUpdateEventQueue, COMDAT
; _this$ = ecx

; 3540 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 3541 :     PRIV_PMSG* pEvent;
; 3542 :     PRIV_PMSG* pNext;
; 3543 :     HRESULT hr = S_OK;

  00009	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 3544 :     DWORD dwId = pNotify->dwVirtualTrackID;

  00010	8b 45 08	 mov	 eax, DWORD PTR _pNotify$[ebp]
  00013	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00016	89 4d fc	 mov	 DWORD PTR _dwId$[ebp], ecx

; 3545 :     DWORD dwTrackGroup = pNotify->dwGroupID;

  00019	8b 55 08	 mov	 edx, DWORD PTR _pNotify$[ebp]
  0001c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0001f	89 45 d4	 mov	 DWORD PTR _dwTrackGroup$[ebp], eax

; 3546 :     CPMsgQueue UpdateQueue;        // List of PMsgs to be inserted into a queue during update.

  00022	8d 4d ec	 lea	 ecx, DWORD PTR _UpdateQueue$[ebp]
  00025	e8 00 00 00 00	 call	 ??0CPMsgQueue@@QAE@XZ	; CPMsgQueue::CPMsgQueue

; 3547 : 
; 3548 :     REFERENCE_TIME rtTemp;
; 3549 :     GetQueueTime(&rtTemp);

  0002a	8d 4d d8	 lea	 ecx, DWORD PTR _rtTemp$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	51		 push	 ecx
  00037	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]

; 3550 :     pNext = NULL;

  0003d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0

; 3551 :     for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )

  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  00047	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  0004c	89 45 e8	 mov	 DWORD PTR _pEvent$[ebp], eax
  0004f	eb 06		 jmp	 SHORT $L70636
$L70637:
  00051	8b 55 f8	 mov	 edx, DWORD PTR _pNext$[ebp]
  00054	89 55 e8	 mov	 DWORD PTR _pEvent$[ebp], edx
$L70636:
  00057	83 7d e8 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0005b	0f 84 5f 02 00
	00		 je	 $L70638

; 3552 :     {
; 3553 :         pNext = pEvent->pNext;

  00061	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	89 4d f8	 mov	 DWORD PTR _pNext$[ebp], ecx

; 3554 :         pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;

  00069	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0006c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006f	83 e0 fd	 and	 eax, -3			; fffffffdH
  00072	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00075	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3555 :         DMUS_PMSG* pNew = NULL;

  00078	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pNew$70639[ebp], 0

; 3556 :         if( ( 0 == dwId || pEvent->dwVirtualTrackID == dwId ) && 
; 3557 :             (pEvent->dwType == DMUS_PMSGT_NOTE) )

  0007f	83 7d fc 00	 cmp	 DWORD PTR _dwId$[ebp], 0
  00083	74 0f		 je	 SHORT $L70641
  00085	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00088	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0008b	3b 45 fc	 cmp	 eax, DWORD PTR _dwId$[ebp]
  0008e	0f 85 27 02 00
	00		 jne	 $L70640
$L70641:
  00094	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00097	83 79 40 01	 cmp	 DWORD PTR [ecx+64], 1
  0009b	0f 85 1a 02 00
	00		 jne	 $L70640

; 3558 :         {
; 3559 :             REFERENCE_TIME rtTime = pEvent->rtTime;

  000a1	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000a4	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000a7	89 45 c8	 mov	 DWORD PTR _rtTime$70642[ebp], eax
  000aa	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  000ad	89 4d cc	 mov	 DWORD PTR _rtTime$70642[ebp+4], ecx

; 3560 :             DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);

  000b0	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000b3	83 c2 18	 add	 edx, 24			; 00000018H
  000b6	89 55 c4	 mov	 DWORD PTR _pNote$70643[ebp], edx

; 3561 :             if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  000b9	8b 45 c4	 mov	 eax, DWORD PTR _pNote$70643[ebp]
  000bc	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  000c0	83 e1 01	 and	 ecx, 1
  000c3	85 c9		 test	 ecx, ecx
  000c5	74 26		 je	 SHORT $L70647

; 3562 :             {
; 3563 :                 MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset; 

  000c7	8b 55 c4	 mov	 edx, DWORD PTR _pNote$70643[ebp]
  000ca	0f bf 42 40	 movsx	 eax, WORD PTR [edx+64]
  000ce	8b 4d c4	 mov	 ecx, DWORD PTR _pNote$70643[ebp]
  000d1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d4	2b d0		 sub	 edx, eax
  000d6	89 55 c0	 mov	 DWORD PTR _mtNote$70648[ebp], edx

; 3564 :                 MusicToReferenceTime( mtNote, &rtTime );

  000d9	8d 45 c8	 lea	 eax, DWORD PTR _rtTime$70642[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d c0	 mov	 ecx, DWORD PTR _mtNote$70648[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  000e4	8b 02		 mov	 eax, DWORD PTR [edx]
  000e6	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	51		 push	 ecx
  000ea	ff 50 14	 call	 DWORD PTR [eax+20]
$L70647:

; 3565 :             }
; 3566 :             // now flush the event if needed
; 3567 :             if( rtTime >= rtFlush )

  000ed	8b 55 cc	 mov	 edx, DWORD PTR _rtTime$70642[ebp+4]
  000f0	3b 55 14	 cmp	 edx, DWORD PTR _rtFlush$[ebp+4]
  000f3	0f 8c fd 00 00
	00		 jl	 $L70649
  000f9	7f 0c		 jg	 SHORT $L75379
  000fb	8b 45 c8	 mov	 eax, DWORD PTR _rtTime$70642[ebp]
  000fe	3b 45 10	 cmp	 eax, DWORD PTR _rtFlush$[ebp]
  00101	0f 82 ef 00 00
	00		 jb	 $L70649
$L75379:

; 3568 :             {
; 3569 :                 REFERENCE_TIME rtFlushTime = (rtFlush <= pEvent->rtLast) ? pEvent->rtLast + REF_PER_MIL : rtFlush;

  00107	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0010a	89 4d a0	 mov	 DWORD PTR tv268[ebp], ecx
  0010d	8b 55 a0	 mov	 edx, DWORD PTR tv268[ebp]
  00110	8b 45 14	 mov	 eax, DWORD PTR _rtFlush$[ebp+4]
  00113	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00116	7f 27		 jg	 SHORT $L75377
  00118	7c 0b		 jl	 SHORT $L75380
  0011a	8b 4d a0	 mov	 ecx, DWORD PTR tv268[ebp]
  0011d	8b 55 10	 mov	 edx, DWORD PTR _rtFlush$[ebp]
  00120	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00123	77 1a		 ja	 SHORT $L75377
$L75380:
  00125	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00128	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0012b	81 c1 10 27 00
	00		 add	 ecx, 10000		; 00002710H
  00131	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00134	83 d2 00	 adc	 edx, 0
  00137	89 4d 98	 mov	 DWORD PTR tv136[ebp], ecx
  0013a	89 55 9c	 mov	 DWORD PTR tv136[ebp+4], edx
  0013d	eb 0c		 jmp	 SHORT $L75378
$L75377:
  0013f	8b 45 10	 mov	 eax, DWORD PTR _rtFlush$[ebp]
  00142	89 45 98	 mov	 DWORD PTR tv136[ebp], eax
  00145	8b 4d 14	 mov	 ecx, DWORD PTR _rtFlush$[ebp+4]
  00148	89 4d 9c	 mov	 DWORD PTR tv136[ebp+4], ecx
$L75378:
  0014b	8b 55 98	 mov	 edx, DWORD PTR tv136[ebp]
  0014e	89 55 b8	 mov	 DWORD PTR _rtFlushTime$70650[ebp], edx
  00151	8b 45 9c	 mov	 eax, DWORD PTR tv136[ebp+4]
  00154	89 45 bc	 mov	 DWORD PTR _rtFlushTime$70650[ebp+4], eax

; 3570 :                 if( pEvent->pTool && 
; 3571 :                     !(pNote->bFlags & DMUS_NOTEF_NOTEON) &&
; 3572 :                     S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlushTime, &pNew)))

  00157	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0015a	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0015e	74 76		 je	 SHORT $L70652
  00160	8b 55 c4	 mov	 edx, DWORD PTR _pNote$70643[ebp]
  00163	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00167	83 e0 01	 and	 eax, 1
  0016a	85 c0		 test	 eax, eax
  0016c	75 68		 jne	 SHORT $L70652
  0016e	8d 4d d0	 lea	 ecx, DWORD PTR _pNew$70639[ebp]
  00171	51		 push	 ecx
  00172	8b 55 bc	 mov	 edx, DWORD PTR _rtFlushTime$70650[ebp+4]
  00175	52		 push	 edx
  00176	8b 45 b8	 mov	 eax, DWORD PTR _rtFlushTime$70650[ebp]
  00179	50		 push	 eax
  0017a	8b 4d d4	 mov	 ecx, DWORD PTR _dwTrackGroup$[ebp]
  0017d	51		 push	 ecx
  0017e	8b 55 c4	 mov	 edx, DWORD PTR _pNote$70643[ebp]
  00181	52		 push	 edx
  00182	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	e8 00 00 00 00	 call	 ?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z ; CPerformance::GetChordNotificationStatus
  0018a	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  0018d	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00191	75 43		 jne	 SHORT $L70652

; 3573 :                 {
; 3574 :                     pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;

  00193	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00196	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00199	83 c9 02	 or	 ecx, 2
  0019c	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0019f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3575 :                     pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;

  001a2	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  001a5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001a8	83 c9 20	 or	 ecx, 32			; 00000020H
  001ab	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  001ae	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 3576 :                     pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlushTime );

  001b1	8b 45 bc	 mov	 eax, DWORD PTR _rtFlushTime$70650[ebp+4]
  001b4	50		 push	 eax
  001b5	8b 4d b8	 mov	 ecx, DWORD PTR _rtFlushTime$70650[ebp]
  001b8	51		 push	 ecx
  001b9	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  001bc	83 c2 18	 add	 edx, 24			; 00000018H
  001bf	52		 push	 edx
  001c0	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	50		 push	 eax
  001c4	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  001c7	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001ca	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  001cd	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001d0	8b 12		 mov	 edx, DWORD PTR [edx]
  001d2	51		 push	 ecx
  001d3	ff 52 20	 call	 DWORD PTR [edx+32]
$L70652:

; 3577 :                 }
; 3578 :                 if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue

  001d6	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001da	7c 15		 jl	 SHORT $L70656
  001dc	83 7d d0 00	 cmp	 DWORD PTR _pNew$70639[ebp], 0
  001e0	74 0f		 je	 SHORT $L70656

; 3579 :                 {
; 3580 :                     UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );

  001e2	8b 45 d0	 mov	 eax, DWORD PTR _pNew$70639[ebp]
  001e5	83 e8 18	 sub	 eax, 24			; 00000018H
  001e8	50		 push	 eax
  001e9	8d 4d ec	 lea	 ecx, DWORD PTR _UpdateQueue$[ebp]
  001ec	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue
$L70656:

; 3581 :                 }
; 3582 :             } 
; 3583 :             else // cut notes short if needed

  001f1	e9 c5 00 00 00	 jmp	 $L70640
$L70649:

; 3584 :             {
; 3585 :                 if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  001f6	8b 4d c4	 mov	 ecx, DWORD PTR _pNote$70643[ebp]
  001f9	0f b6 51 45	 movzx	 edx, BYTE PTR [ecx+69]
  001fd	83 e2 01	 and	 edx, 1
  00200	85 d2		 test	 edx, edx
  00202	0f 84 b3 00 00
	00		 je	 $L70640

; 3586 :                 {
; 3587 :                     if (S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlush, &pNew)))

  00208	8d 45 d0	 lea	 eax, DWORD PTR _pNew$70639[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 14	 mov	 ecx, DWORD PTR _rtFlush$[ebp+4]
  0020f	51		 push	 ecx
  00210	8b 55 10	 mov	 edx, DWORD PTR _rtFlush$[ebp]
  00213	52		 push	 edx
  00214	8b 45 d4	 mov	 eax, DWORD PTR _dwTrackGroup$[ebp]
  00217	50		 push	 eax
  00218	8b 4d c4	 mov	 ecx, DWORD PTR _pNote$70643[ebp]
  0021b	51		 push	 ecx
  0021c	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0021f	e8 00 00 00 00	 call	 ?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z ; CPerformance::GetChordNotificationStatus
  00224	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  00227	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0022b	75 73		 jne	 SHORT $L70662

; 3588 :                     {
; 3589 :                         // subtract 2 from the duration to guarantee the note cuts short
; 3590 :                         // 1 clock before the flush time.
; 3591 :                         MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;

  0022d	8b 55 c4	 mov	 edx, DWORD PTR _pNote$70643[ebp]
  00230	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00233	8b 4d c4	 mov	 ecx, DWORD PTR _pNote$70643[ebp]
  00236	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00239	8d 44 10 fe	 lea	 eax, DWORD PTR [eax+edx-2]
  0023d	89 45 b4	 mov	 DWORD PTR _mtNoteOff$70663[ebp], eax

; 3592 :                         REFERENCE_TIME rtNoteOff;
; 3593 :                         MusicToReferenceTime( mtNoteOff, &rtNoteOff );

  00240	8d 4d a8	 lea	 ecx, DWORD PTR _rtNoteOff$70664[ebp]
  00243	51		 push	 ecx
  00244	8b 55 b4	 mov	 edx, DWORD PTR _mtNoteOff$70663[ebp]
  00247	52		 push	 edx
  00248	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  0024b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024d	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  00250	52		 push	 edx
  00251	ff 51 14	 call	 DWORD PTR [ecx+20]

; 3594 :                         if( rtNoteOff >= rtFlush )

  00254	8b 45 ac	 mov	 eax, DWORD PTR _rtNoteOff$70664[ebp+4]
  00257	3b 45 14	 cmp	 eax, DWORD PTR _rtFlush$[ebp+4]
  0025a	7c 44		 jl	 SHORT $L70662
  0025c	7f 08		 jg	 SHORT $L75381
  0025e	8b 4d a8	 mov	 ecx, DWORD PTR _rtNoteOff$70664[ebp]
  00261	3b 4d 10	 cmp	 ecx, DWORD PTR _rtFlush$[ebp]
  00264	72 3a		 jb	 SHORT $L70662
$L75381:

; 3595 :                         {
; 3596 :                             ReferenceToMusicTime( rtFlush, &mtNoteOff );

  00266	8d 55 b4	 lea	 edx, DWORD PTR _mtNoteOff$70663[ebp]
  00269	52		 push	 edx
  0026a	8b 45 14	 mov	 eax, DWORD PTR _rtFlush$[ebp+4]
  0026d	50		 push	 eax
  0026e	8b 4d 10	 mov	 ecx, DWORD PTR _rtFlush$[ebp]
  00271	51		 push	 ecx
  00272	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  00275	8b 02		 mov	 eax, DWORD PTR [edx]
  00277	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	51		 push	 ecx
  0027b	ff 50 18	 call	 DWORD PTR [eax+24]

; 3597 :                             mtNoteOff -= pNote->mtTime;

  0027e	8b 55 c4	 mov	 edx, DWORD PTR _pNote$70643[ebp]
  00281	8b 45 b4	 mov	 eax, DWORD PTR _mtNoteOff$70663[ebp]
  00284	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00287	89 45 b4	 mov	 DWORD PTR _mtNoteOff$70663[ebp], eax

; 3598 :                             if( mtNoteOff < 1 ) mtNoteOff = 1; // disallow durations less than 1. This should never happen anyway.

  0028a	83 7d b4 01	 cmp	 DWORD PTR _mtNoteOff$70663[ebp], 1
  0028e	7d 07		 jge	 SHORT $L70666
  00290	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _mtNoteOff$70663[ebp], 1
$L70666:

; 3599 :                             pNote->mtDuration = mtNoteOff;

  00297	8b 4d c4	 mov	 ecx, DWORD PTR _pNote$70643[ebp]
  0029a	8b 55 b4	 mov	 edx, DWORD PTR _mtNoteOff$70663[ebp]
  0029d	89 51 38	 mov	 DWORD PTR [ecx+56], edx
$L70662:

; 3600 :                         }
; 3601 :                     }
; 3602 :                     if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue

  002a0	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002a4	7c 15		 jl	 SHORT $L70640
  002a6	83 7d d0 00	 cmp	 DWORD PTR _pNew$70639[ebp], 0
  002aa	74 0f		 je	 SHORT $L70640

; 3603 :                     {
; 3604 :                         UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );

  002ac	8b 45 d0	 mov	 eax, DWORD PTR _pNew$70639[ebp]
  002af	83 e8 18	 sub	 eax, 24			; 00000018H
  002b2	50		 push	 eax
  002b3	8d 4d ec	 lea	 ecx, DWORD PTR _UpdateQueue$[ebp]
  002b6	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue
$L70640:

; 3605 :                     }
; 3606 :                 }
; 3607 :             }
; 3608 :         }
; 3609 :     }

  002bb	e9 91 fd ff ff	 jmp	 $L70637
$L70638:

; 3610 :     // remove (and unmark) all marked PMsgs from the current queue
; 3611 :     for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )

  002c0	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  002c3	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  002c8	89 45 e8	 mov	 DWORD PTR _pEvent$[ebp], eax
  002cb	eb 06		 jmp	 SHORT $L70671
$L70672:
  002cd	8b 4d f8	 mov	 ecx, DWORD PTR _pNext$[ebp]
  002d0	89 4d e8	 mov	 DWORD PTR _pEvent$[ebp], ecx
$L70671:
  002d3	83 7d e8 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  002d7	74 42		 je	 SHORT $L70678

; 3612 :     {
; 3613 :         pNext = pEvent->pNext;

  002d9	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  002dc	8b 02		 mov	 eax, DWORD PTR [edx]
  002de	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax

; 3614 :         if (pEvent->dwPrivFlags & PRIV_FLAG_REMOVE)

  002e1	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  002e4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002e7	83 e2 02	 and	 edx, 2
  002ea	85 d2		 test	 edx, edx
  002ec	74 2b		 je	 SHORT $L70674

; 3615 :         {
; 3616 :             pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;

  002ee	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  002f1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002f4	83 e1 fd	 and	 ecx, -3			; fffffffdH
  002f7	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  002fa	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3617 :             if (pQueue->Dequeue(pEvent))

  002fd	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00300	50		 push	 eax
  00301	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  00304	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z ; CPMsgQueue::Dequeue
  00309	85 c0		 test	 eax, eax
  0030b	74 0c		 je	 SHORT $L70674

; 3618 :             {
; 3619 :                 FreePMsg(pEvent);

  0030d	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00310	51		 push	 ecx
  00311	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00314	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L70674:

; 3620 :             }
; 3621 :             else
; 3622 :             {
; 3623 :                 TraceI(0,"Error dequeing event for flushing\n");
; 3624 :             }
; 3625 :         }
; 3626 :     }

  00319	eb b2		 jmp	 SHORT $L70672
$L70678:

; 3627 :     // empty the Update queue into the current queue
; 3628 :     while( pEvent = UpdateQueue.Dequeue() )

  0031b	8d 4d ec	 lea	 ecx, DWORD PTR _UpdateQueue$[ebp]
  0031e	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00323	89 45 e8	 mov	 DWORD PTR _pEvent$[ebp], eax
  00326	83 7d e8 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0032a	74 0e		 je	 SHORT $L70679

; 3629 :     {
; 3630 :         pQueue->Enqueue(pEvent);

  0032c	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0032f	52		 push	 edx
  00330	8b 4d 0c	 mov	 ecx, DWORD PTR _pQueue$[ebp]
  00333	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 3631 :     }

  00338	eb e1		 jmp	 SHORT $L70678
$L70679:

; 3632 :     SendBuffers();
; 3633 : }

  0033a	8d 4d ec	 lea	 ecx, DWORD PTR _UpdateQueue$[ebp]
  0033d	e8 00 00 00 00	 call	 ??1CPMsgQueue@@QAE@XZ	; CPMsgQueue::~CPMsgQueue
  00342	8b e5		 mov	 esp, ebp
  00344	5d		 pop	 ebp
  00345	c2 10 00	 ret	 16			; 00000010H
?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z ENDP ; CPerformance::OnChordUpdateEventQueue
_TEXT	ENDS
PUBLIC	?OnChordUpdateEventQueues@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@@Z ; CPerformance::OnChordUpdateEventQueues
; Function compile flags: /Odt
;	COMDAT ?OnChordUpdateEventQueues@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@@Z
_TEXT	SEGMENT
_this$ = -16
_pSegState$ = -12
_rt$ = -8
_pNotify$ = 8
?OnChordUpdateEventQueues@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@@Z PROC NEAR ; CPerformance::OnChordUpdateEventQueues, COMDAT
; _this$ = ecx

; 3642 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3643 :     IDirectMusicSegmentState* pSegState = NULL;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pSegState$[ebp], 0

; 3644 :     if (!pNotify || !pNotify->punkUser) return;

  00010	83 7d 08 00	 cmp	 DWORD PTR _pNotify$[ebp], 0
  00014	74 09		 je	 SHORT $L70686
  00016	8b 45 08	 mov	 eax, DWORD PTR _pNotify$[ebp]
  00019	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0001d	75 05		 jne	 SHORT $L70685
$L70686:
  0001f	e9 87 00 00 00	 jmp	 $L70683
$L70685:

; 3645 :     REFERENCE_TIME rt = 0;

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _rt$[ebp], 0
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rt$[ebp+4], 0

; 3646 :     if( pNotify->mtTime )

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _pNotify$[ebp]
  00035	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00039	74 17		 je	 SHORT $L70688

; 3647 :     {
; 3648 :         MusicToReferenceTime( pNotify->mtTime, &rt );

  0003b	8d 55 f8	 lea	 edx, DWORD PTR _rt$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pNotify$[ebp]
  00042	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00045	51		 push	 ecx
  00046	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00049	8b 02		 mov	 eax, DWORD PTR [edx]
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	51		 push	 ecx
  0004f	ff 50 14	 call	 DWORD PTR [eax+20]
$L70688:

; 3649 :     }
; 3650 :     OnChordUpdateEventQueue( pNotify, &m_OnTimeQueue, rt );

  00052	8b 55 fc	 mov	 edx, DWORD PTR _rt$[ebp+4]
  00055	52		 push	 edx
  00056	8b 45 f8	 mov	 eax, DWORD PTR _rt$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00063	51		 push	 ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR _pNotify$[ebp]
  00067	52		 push	 edx
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z ; CPerformance::OnChordUpdateEventQueue

; 3651 :     OnChordUpdateEventQueue( pNotify, &m_NearTimeQueue, rt );

  00070	8b 45 fc	 mov	 eax, DWORD PTR _rt$[ebp+4]
  00073	50		 push	 eax
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _rt$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  00081	52		 push	 edx
  00082	8b 45 08	 mov	 eax, DWORD PTR _pNotify$[ebp]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z ; CPerformance::OnChordUpdateEventQueue

; 3652 :     OnChordUpdateEventQueue( pNotify, &m_EarlyQueue, rt );

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  00091	51		 push	 ecx
  00092	8b 55 f8	 mov	 edx, DWORD PTR _rt$[ebp]
  00095	52		 push	 edx
  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	05 14 01 00 00	 add	 eax, 276		; 00000114H
  0009e	50		 push	 eax
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _pNotify$[ebp]
  000a2	51		 push	 ecx
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?OnChordUpdateEventQueue@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@PAVCPMsgQueue@@_J@Z ; CPerformance::OnChordUpdateEventQueue
$L70683:

; 3653 : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
?OnChordUpdateEventQueues@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@@Z ENDP ; CPerformance::OnChordUpdateEventQueues
_TEXT	ENDS
PUBLIC	??_C@_0CL@HJCDHGLG@DM?5Worker?3?5Track?5Playback?5?$CIMilsP@ ; `string'
PUBLIC	??_C@_0CI@EBDOGOG@DM?5Worker?3?5MIDI?5Process?5?$CIMilsPer@ ; `string'
PUBLIC	?CreateThreads@CPerformance@@AAEJXZ		; CPerformance::CreateThreads
EXTRN	?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z:NEAR ; CBossMan::SetMasterClock
EXTRN	?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z:NEAR ; CBossMan::InstallWorker
EXTRN	?g_BossMan@@3VCBossMan@@A:QWORD			; g_BossMan
;	COMDAT ??_C@_0CL@HJCDHGLG@DM?5Worker?3?5Track?5Playback?5?$CIMilsP@
CONST	SEGMENT
??_C@_0CL@HJCDHGLG@DM?5Worker?3?5Track?5Playback?5?$CIMilsP@ DB 'DM Worke'
	DB	'r: Track Playback (MilsPerSecond) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EBDOGOG@DM?5Worker?3?5MIDI?5Process?5?$CIMilsPer@
CONST	SEGMENT
??_C@_0CI@EBDOGOG@DM?5Worker?3?5MIDI?5Process?5?$CIMilsPer@ DB 'DM Worker'
	DB	': MIDI Process (MilsPerSecond)', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateThreads@CPerformance@@AAEJXZ
_TEXT	SEGMENT
_this$ = -4
?CreateThreads@CPerformance@@AAEJXZ PROC NEAR		; CPerformance::CreateThreads, COMDAT
; _this$ = ecx

; 3660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3661 : #ifdef DXAPI
; 3662 :     // initialize the realtime thread
; 3663 :     m_hRealtimeThread = CreateThread(NULL, 1024, _Realtime, this, 0, &m_dwRealtimeThreadID);
; 3664 :     if( m_hRealtimeThread )
; 3665 :     {
; 3666 :         m_hRealtime = CreateEvent(NULL,FALSE,FALSE,NULL);
; 3667 :         SetThreadPriority( m_hRealtimeThread, THREAD_PRIORITY_HIGHEST );
; 3668 :     }
; 3669 :     else
; 3670 :     {
; 3671 :         TraceI(0, "Major error! Realtime thread not created.\n");
; 3672 :         return E_OUTOFMEMORY;
; 3673 :     }
; 3674 :     // initialize the transport thread
; 3675 :     m_hTransportThread = CreateThread(NULL, 1024, _Transport, this, 0, &m_dwTransportThreadID);
; 3676 :     if( m_hTransportThread )
; 3677 :     {
; 3678 :         m_hTransport = CreateEvent(NULL, FALSE, FALSE, NULL);
; 3679 :         SetThreadPriority( m_hTransportThread, THREAD_PRIORITY_ABOVE_NORMAL );
; 3680 :     }
; 3681 :     else
; 3682 :     {
; 3683 :         TraceI(0, "Major error! Transport thread not created.\n");
; 3684 :         m_fKillRealtimeThread = TRUE;
; 3685 :         if( m_hRealtime ) SetEvent( m_hRealtime );
; 3686 :         return E_OUTOFMEMORY;
; 3687 :     }
; 3688 :     m_pDirectMusic->GetMasterClock( NULL, &m_pClock );
; 3689 : #else
; 3690 :     m_pSynth->GetMasterClock(&m_pClock );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 30	 add	 eax, 48			; 00000030H
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001a	8b 12		 mov	 edx, DWORD PTR [edx]
  0001c	51		 push	 ecx
  0001d	ff 52 28	 call	 DWORD PTR [edx+40]

; 3691 :     g_BossMan.SetMasterClock(m_pClock);

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00026	51		 push	 ecx
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  0002c	e8 00 00 00 00	 call	 ?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z ; CBossMan::SetMasterClock

; 3692 :     m_pTransportWorker = g_BossMan.InstallWorker(_Transport,this,10,"DM Worker: Track Playback (MilsPerSecond) ");

  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@HJCDHGLG@DM?5Worker?3?5Track?5Playback?5?$CIMilsP@
  00036	6a 0a		 push	 10			; 0000000aH
  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	52		 push	 edx
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:?_Transport@@YGXPAXPA_J@Z ; _Transport
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00046	e8 00 00 00 00	 call	 ?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z ; CBossMan::InstallWorker
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	89 81 bc 03 00
	00		 mov	 DWORD PTR [ecx+956], eax

; 3693 :     m_pRealtimeWorker = g_BossMan.InstallWorker(_Realtime,this,20,"DM Worker: MIDI Process (MilsPerSecond)");

  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@EBDOGOG@DM?5Worker?3?5MIDI?5Process?5?$CIMilsPer@
  00059	6a 14		 push	 20			; 00000014H
  0005b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	52		 push	 edx
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:?_Realtime@@YGXPAXPA_J@Z ; _Realtime
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00069	e8 00 00 00 00	 call	 ?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z ; CBossMan::InstallWorker
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	89 81 c0 03 00
	00		 mov	 DWORD PTR [ecx+960], eax

; 3694 : #endif
; 3695 :     m_rtStart = GetTime();

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	89 81 98 02 00
	00		 mov	 DWORD PTR [ecx+664], eax
  00088	89 91 9c 02 00
	00		 mov	 DWORD PTR [ecx+668], edx

; 3696 :     m_rtQueuePosition = m_rtStart;

  0008e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 88 98 02 00
	00		 mov	 ecx, DWORD PTR [eax+664]
  0009a	89 8a b8 02 00
	00		 mov	 DWORD PTR [edx+696], ecx
  000a0	8b 80 9c 02 00
	00		 mov	 eax, DWORD PTR [eax+668]
  000a6	89 82 bc 02 00
	00		 mov	 DWORD PTR [edx+700], eax

; 3697 :     return S_OK;

  000ac	33 c0		 xor	 eax, eax

; 3698 : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?CreateThreads@CPerformance@@AAEJXZ ENDP		; CPerformance::CreateThreads
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Realtime@@YGXPAXPA_J@Z
_TEXT	SEGMENT
_lpParam$ = 8
_prtWakeUp$ = 12
?_Realtime@@YGXPAXPA_J@Z PROC NEAR			; _Realtime, COMDAT

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1118 :     ((CPerformance *)lpParam)->Realtime(prtWakeUp);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _prtWakeUp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpParam$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Realtime@CPerformance@@AAEXPA_J@Z ; CPerformance::Realtime

; 1119 : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?_Realtime@@YGXPAXPA_J@Z ENDP				; _Realtime
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Transport@@YGXPAXPA_J@Z
_TEXT	SEGMENT
_lpParam$ = 8
_prtWakeUp$ = 12
?_Transport@@YGXPAXPA_J@Z PROC NEAR			; _Transport, COMDAT

; 1460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1461 :     ((CPerformance *)lpParam)->Transport(prtWakeUp);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _prtWakeUp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpParam$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Transport@CPerformance@@AAEXPA_J@Z ; CPerformance::Transport

; 1462 : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?_Transport@@YGXPAXPA_J@Z ENDP				; _Transport
_TEXT	ENDS
PUBLIC	?InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z ; CPerformance::InitAudio
EXTRN	?SetDoWorkThreadMode@@YGXK@Z:NEAR		; SetDoWorkThreadMode
EXTRN	_CLSID_DirectMusicSynth:BYTE
; Function compile flags: /Odt
;	COMDAT ?InitAudioX@CPerformance@@UAGJKKKK@Z
_TEXT	SEGMENT
_Params$ = -44
_hr$ = -4
_this$ = 8
_dwDefaultPathType$ = 12
_dwPChannelCount$ = 16
_dwVoiceCount$ = 20
_dwFlags$ = 24
?InitAudioX@CPerformance@@UAGJKKKK@Z PROC NEAR		; CPerformance::InitAudioX, COMDAT

; 3707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 3708 : 	DMUS_AUDIOPARAMS Params;
; 3709 :     Params.dwSampleRate = SAMPLERATE;

  00006	c7 45 e8 80 bb
	00 00		 mov	 DWORD PTR _Params$[ebp+20], 48000 ; 0000bb80H

; 3710 :     Params.dwSize = sizeof (Params);

  0000d	c7 45 d4 28 00
	00 00		 mov	 DWORD PTR _Params$[ebp], 40 ; 00000028H

; 3711 :     Params.dwValidData = DMUS_AUDIOPARAMS_VOICES; // DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;

  00014	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _Params$[ebp+8], 2

; 3712 :     Params.fInitNow = TRUE;

  0001b	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _Params$[ebp+4], 1

; 3713 :     Params.clsidDefaultSynth = CLSID_DirectMusicSynth;

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSynth
  00027	89 45 ec	 mov	 DWORD PTR _Params$[ebp+24], eax
  0002a	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _CLSID_DirectMusicSynth+4
  00030	89 4d f0	 mov	 DWORD PTR _Params$[ebp+28], ecx
  00033	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSynth+8
  00039	89 55 f4	 mov	 DWORD PTR _Params$[ebp+32], edx
  0003c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSynth+12
  00041	89 45 f8	 mov	 DWORD PTR _Params$[ebp+36], eax

; 3714 :     Params.dwVoices = dwVoiceCount;

  00044	8b 4d 14	 mov	 ecx, DWORD PTR _dwVoiceCount$[ebp]
  00047	89 4d e4	 mov	 DWORD PTR _Params$[ebp+16], ecx

; 3715 :     SetDoWorkThreadMode(dwFlags & DMUS_INITAUDIO_NOTHREADS);

  0004a	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0004d	83 e2 01	 and	 edx, 1
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?SetDoWorkThreadMode@@YGXK@Z ; SetDoWorkThreadMode

; 3716 :     ENTER_API_CRITICAL_SECTION;
; 3717 : 	HRESULT hr = InitAudio(NULL,NULL,NULL,dwDefaultPathType,dwPChannelCount,0,&Params);

  00056	8d 45 d4	 lea	 eax, DWORD PTR _Params$[ebp]
  00059	50		 push	 eax
  0005a	6a 00		 push	 0
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR _dwPChannelCount$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 0c	 mov	 edx, DWORD PTR _dwDefaultPathType$[ebp]
  00063	52		 push	 edx
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z ; CPerformance::InitAudio
  00073	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3718 :     LEAVE_API_CRITICAL_SECTION;
; 3719 :     return hr;

  00076	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 3720 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 14 00	 ret	 20			; 00000014H
?InitAudioX@CPerformance@@UAGJKKKK@Z ENDP		; CPerformance::InitAudioX
_TEXT	ENDS
PUBLIC	??_C@_0CD@CEAFEFFF@?$CFs?3?5Invalid?5pointer?5ppDirectMusi@ ; `string'
PUBLIC	??_C@_0CD@KGHBFIKH@?$CFs?3?5Invalid?5pointer?5ppDirectSoun@ ; `string'
PUBLIC	??_C@_0EA@HENHECCJ@Error?3?5InitAudio?5called?5on?5an?5al@ ; `string'
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
PUBLIC	??_C@_0DB@MNLLPNCN@Warning?3?5Default?5synth?5choice?5ha@ ; `string'
PUBLIC	??_C@_0DC@EJJPIBFI@Warning?3?5Features?5flags?5has?5been@ ; `string'
PUBLIC	??_C@_0CP@JAPGDOLO@Warning?3?5Sample?5rate?5has?5been?5ch@ ; `string'
PUBLIC	??_C@_0DO@MKDNBMAL@Warning?3?5Number?5of?5requested?5voi@ ; `string'
PUBLIC	_!=@8
EXTRN	?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z:NEAR ; CBufferManager::Init
EXTRN	_DirectSoundCreate@12:NEAR
EXTRN	_g_fDirectSoundDisableBusyWaitWarning:DWORD
EXTRN	_IID_IDirectMusicSynthX:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::InitAudio', 00H	; `CPerformance::InitAudio'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CD@CEAFEFFF@?$CFs?3?5Invalid?5pointer?5ppDirectMusi@
CONST	SEGMENT
??_C@_0CD@CEAFEFFF@?$CFs?3?5Invalid?5pointer?5ppDirectMusi@ DB '%s: Inval'
	DB	'id pointer ppDirectMusic', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KGHBFIKH@?$CFs?3?5Invalid?5pointer?5ppDirectSoun@
CONST	SEGMENT
??_C@_0CD@KGHBFIKH@?$CFs?3?5Invalid?5pointer?5ppDirectSoun@ DB '%s: Inval'
	DB	'id pointer ppDirectSound', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HENHECCJ@Error?3?5InitAudio?5called?5on?5an?5al@
CONST	SEGMENT
??_C@_0EA@HENHECCJ@Error?3?5InitAudio?5called?5on?5an?5al@ DB 'Error: Ini'
	DB	'tAudio called on an already initialized Performance.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_0DB@MNLLPNCN@Warning?3?5Default?5synth?5choice?5ha@
CONST	SEGMENT
??_C@_0DB@MNLLPNCN@Warning?3?5Default?5synth?5choice?5ha@ DB 'Warning: De'
	DB	'fault synth choice has been changed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EJJPIBFI@Warning?3?5Features?5flags?5has?5been@
CONST	SEGMENT
??_C@_0DC@EJJPIBFI@Warning?3?5Features?5flags?5has?5been@ DB 'Warning: Fe'
	DB	'atures flags has been changed to %lx.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JAPGDOLO@Warning?3?5Sample?5rate?5has?5been?5ch@
CONST	SEGMENT
??_C@_0CP@JAPGDOLO@Warning?3?5Sample?5rate?5has?5been?5ch@ DB 'Warning: S'
	DB	'ample rate has been changed to %ld.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MKDNBMAL@Warning?3?5Number?5of?5requested?5voi@
CONST	SEGMENT
??_C@_0DO@MKDNBMAL@Warning?3?5Number?5of?5requested?5voi@ DB 'Warning: Nu'
	DB	'mber of requested voices has been changed to %ld.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z
_TEXT	SEGMENT
_pPath$70760 = -8
_hr$ = -4
_this$ = 8
_ppDirectMusic$ = 12
_ppDirectSound$ = 16
_hWnd$ = 20
_dwDefaultPathType$ = 24
_dwPChannelCount$ = 28
_dwFlags$ = 32
_pParams$ = 36
?InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z PROC NEAR ; CPerformance::InitAudio, COMDAT

; 3731 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3732 :     V_INAME(IDirectMusicPerformance::InitAudio);
; 3733 :     V_PTRPTR_WRITE_OPT(ppDirectMusic);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _ppDirectMusic$[ebp], 0
  0000a	74 28		 je	 SHORT $L70718
  0000c	6a 04		 push	 4
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _ppDirectMusic$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L70718
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@CEAFEFFF@?$CFs?3?5Invalid?5pointer?5ppDirectMusi@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70718:

; 3734 :     V_PTRPTR_WRITE_OPT(ppDirectSound);

  00034	83 7d 10 00	 cmp	 DWORD PTR _ppDirectSound$[ebp], 0
  00038	74 28		 je	 SHORT $L70722
  0003a	6a 04		 push	 4
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _ppDirectSound$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00045	85 c0		 test	 eax, eax
  00047	74 19		 je	 SHORT $L70722
  00049	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z@4QBDB
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@KGHBFIKH@?$CFs?3?5Invalid?5pointer?5ppDirectSoun@
  00053	6a ff		 push	 -1
  00055	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	e8 00 00 00 00	 call	 _DebugBreak@0
$L70722:

; 3735 : #ifndef XBOX
; 3736 :     V_HWND_OPT(hWnd);
; 3737 : #endif
; 3738 :     HRESULT hr = S_OK;

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 3739 : 
; 3740 : 	//
; 3741 : 	// disable dsound warning
; 3742 : 	//
; 3743 : 
; 3744 : 	g_fDirectSoundDisableBusyWaitWarning = TRUE;

  00069	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g_fDirectSoundDisableBusyWaitWarning, 1

; 3745 : 
; 3746 : #ifndef XBOX
; 3747 :     // Further validate, checking for a pointer to a bad interface pointer...
; 3748 :     if (ppDirectMusic)
; 3749 :     {
; 3750 :         V_INTERFACE_OPT(*ppDirectMusic);
; 3751 :     }
; 3752 :     if (ppDirectSound)
; 3753 :     {
; 3754 :         V_INTERFACE_OPT(*ppDirectSound);
; 3755 :     }
; 3756 : #endif
; 3757 :     if( m_dwAudioPathMode )

  00073	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00076	83 ba 08 01 00
	00 00		 cmp	 DWORD PTR [edx+264], 0
  0007d	74 19		 je	 SHORT $L70728

; 3758 :     {
; 3759 :         Trace(0,"Error: InitAudio called on an already initialized Performance.\n");

  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@HENHECCJ@Error?3?5InitAudio?5called?5on?5an?5al@
  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0008b	83 c4 08	 add	 esp, 8

; 3760 :         return DMUS_E_ALREADY_INITED;

  0008e	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00093	e9 35 04 00 00	 jmp	 $L70715
$L70728:

; 3761 :     }
; 3762 :     if (dwFlags == 0)

  00098	83 7d 20 00	 cmp	 DWORD PTR _dwFlags$[ebp], 0
  0009c	75 07		 jne	 SHORT $L70731

; 3763 :     {
; 3764 :         dwFlags = DMUS_AUDIOF_ALL;

  0009e	c7 45 20 3f 00
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 63 ; 0000003fH
$L70731:

; 3765 :     }
; 3766 :     Init();

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?Init@CPerformance@@AAEXXZ ; CPerformance::Init

; 3767 :     m_AudioParams.dwFeatures = dwFlags;

  000ad	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d 20	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  000b3	89 88 d4 00 00
	00		 mov	 DWORD PTR [eax+212], ecx

; 3768 :     m_AudioParams.dwSampleRate = SAMPLERATE;

  000b9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000bc	c7 82 dc 00 00
	00 80 bb 00 00	 mov	 DWORD PTR [edx+220], 48000 ; 0000bb80H

; 3769 :     m_AudioParams.dwSize = sizeof (m_AudioParams);

  000c6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	c7 80 c8 00 00
	00 28 00 00 00	 mov	 DWORD PTR [eax+200], 40	; 00000028H

; 3770 :     m_AudioParams.dwValidData = DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;

  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	c7 81 d0 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [ecx+208], 15	; 0000000fH

; 3771 :     m_AudioParams.dwVoices = 64;

  000e0	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	c7 82 d8 00 00
	00 40 00 00 00	 mov	 DWORD PTR [edx+216], 64	; 00000040H

; 3772 :     m_AudioParams.fInitNow = TRUE;

  000ed	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	c7 80 cc 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+204], 1

; 3773 :     m_AudioParams.clsidDefaultSynth = CLSID_DirectMusicSynth;

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSynth
  00109	89 11		 mov	 DWORD PTR [ecx], edx
  0010b	a1 04 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSynth+4
  00110	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00113	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSynth+8
  00119	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0011c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSynth+12
  00121	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 3774 :     if (pParams)

  00124	83 7d 24 00	 cmp	 DWORD PTR _pParams$[ebp], 0
  00128	0f 84 f1 00 00
	00		 je	 $L70732

; 3775 :     {
; 3776 :         if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)

  0012e	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  00131	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00134	83 e2 01	 and	 edx, 1
  00137	85 d2		 test	 edx, edx
  00139	74 0f		 je	 SHORT $L70733

; 3777 :         {
; 3778 :             m_AudioParams.dwFeatures = pParams->dwFeatures;

  0013b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  00141	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00144	89 90 d4 00 00
	00		 mov	 DWORD PTR [eax+212], edx
$L70733:

; 3779 :         }
; 3780 :         if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)

  0014a	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  0014d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00150	83 e1 02	 and	 ecx, 2
  00153	85 c9		 test	 ecx, ecx
  00155	74 0f		 je	 SHORT $L70734

; 3781 :         {
; 3782 :             m_AudioParams.dwVoices = pParams->dwVoices;

  00157	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  0015d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00160	89 8a d8 00 00
	00		 mov	 DWORD PTR [edx+216], ecx
$L70734:

; 3783 :         }
; 3784 :         if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)

  00166	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  00169	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0016c	83 e0 08	 and	 eax, 8
  0016f	85 c0		 test	 eax, eax
  00171	74 5a		 je	 SHORT $L70735

; 3785 :         {
; 3786 :             // If they requested the DX7 default synth and yet also asked for audiopath
; 3787 :             // features, force to DX8 default synth.
; 3788 :             if ((pParams->clsidDefaultSynth != GUID_NULL) || 
; 3789 :                 !((m_AudioParams.dwValidData & DMUS_AUDIOPARAMS_FEATURES) &&
; 3790 :                 (m_AudioParams.dwFeatures & DMUS_AUDIOF_ALL)))

  00173	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  00178	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  0017b	83 c1 18	 add	 ecx, 24			; 00000018H
  0017e	51		 push	 ecx
  0017f	e8 00 00 00 00	 call	 _!=@8
  00184	85 c0		 test	 eax, eax
  00186	75 20		 jne	 SHORT $L70738
  00188	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0018b	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  00191	83 e0 01	 and	 eax, 1
  00194	85 c0		 test	 eax, eax
  00196	74 10		 je	 SHORT $L70738
  00198	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  001a1	83 e2 3f	 and	 edx, 63			; 0000003fH
  001a4	85 d2		 test	 edx, edx
  001a6	75 25		 jne	 SHORT $L70735
$L70738:

; 3791 :             {
; 3792 :                 m_AudioParams.clsidDefaultSynth = pParams->clsidDefaultSynth;

  001a8	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  001ab	83 c0 18	 add	 eax, 24			; 00000018H
  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  001b7	8b 10		 mov	 edx, DWORD PTR [eax]
  001b9	89 11		 mov	 DWORD PTR [ecx], edx
  001bb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001be	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001c1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001c4	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  001c7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001ca	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L70735:

; 3793 :             }
; 3794 :         }
; 3795 :         if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)

  001cd	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  001d0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001d3	83 e2 04	 and	 edx, 4
  001d6	85 d2		 test	 edx, edx
  001d8	74 45		 je	 SHORT $L70732

; 3796 :         {
; 3797 :             if (pParams->dwSampleRate > 96000)

  001da	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  001dd	81 78 14 00 77
	01 00		 cmp	 DWORD PTR [eax+20], 96000 ; 00017700H
  001e4	76 0f		 jbe	 SHORT $L70741

; 3798 :             {
; 3799 :                 m_AudioParams.dwSampleRate = 96000;

  001e6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	c7 81 dc 00 00
	00 00 77 01 00	 mov	 DWORD PTR [ecx+220], 96000 ; 00017700H

; 3800 :             }
; 3801 :             else if (pParams->dwSampleRate < 11025)

  001f3	eb 2a		 jmp	 SHORT $L70732
$L70741:
  001f5	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  001f8	81 7a 14 11 2b
	00 00		 cmp	 DWORD PTR [edx+20], 11025 ; 00002b11H
  001ff	73 0f		 jae	 SHORT $L70743

; 3802 :             {
; 3803 :                 m_AudioParams.dwSampleRate = 11025;

  00201	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00204	c7 80 dc 00 00
	00 11 2b 00 00	 mov	 DWORD PTR [eax+220], 11025 ; 00002b11H

; 3804 :             }
; 3805 :             else

  0020e	eb 0f		 jmp	 SHORT $L70732
$L70743:

; 3806 :             {
; 3807 :                 m_AudioParams.dwSampleRate = pParams->dwSampleRate;

  00210	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  00216	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00219	89 81 dc 00 00
	00		 mov	 DWORD PTR [ecx+220], eax
$L70732:

; 3808 :             }
; 3809 :         }
; 3810 :     }
; 3811 :     m_dwAudioPathMode = 2;

  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00222	c7 81 08 01 00
	00 02 00 00 00	 mov	 DWORD PTR [ecx+264], 2

; 3812 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0022c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0022f	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  00235	52		 push	 edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 3813 : #ifndef XBOX
; 3814 :     if (ppDirectMusic && *ppDirectMusic)
; 3815 :     {
; 3816 :         hr = (*ppDirectMusic)->QueryInterface(IID_IDirectMusic8,(void **) &m_pDirectMusic);
; 3817 :     }
; 3818 : #endif
; 3819 :     if (SUCCEEDED(hr))

  0023c	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00240	7c 5c		 jl	 SHORT $L70746

; 3820 :     {
; 3821 : #ifndef XBOX
; 3822 :         if (ppDirectSound && *ppDirectSound)
; 3823 :         {
; 3824 :             hr = (*ppDirectSound)->QueryInterface(IID_IDirectSound8,(void **) &m_pDirectSound);
; 3825 :         }
; 3826 : #endif // XBOX
; 3827 :         if (SUCCEEDED(hr))

  00242	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00246	7c 56		 jl	 SHORT $L70746

; 3828 :         {
; 3829 : #ifdef DXAPI
; 3830 :             if (!m_pDirectSound)
; 3831 :             {
; 3832 :                 hr = DirectSoundCreate8(NULL,&m_pDirectSound,NULL);
; 3833 :                 if (SUCCEEDED(hr))
; 3834 :                 {
; 3835 :                     if (!hWnd)
; 3836 :                     {
; 3837 :                         hWnd = GetForegroundWindow();
; 3838 :                         if (!hWnd)
; 3839 :                         {
; 3840 :                             hWnd = GetDesktopWindow();
; 3841 :                         }
; 3842 :                     }
; 3843 :                     m_pDirectSound->SetCooperativeLevel(hWnd, DSSCL_PRIORITY);
; 3844 :                 }
; 3845 :             }
; 3846 : #endif // ! XBOX
; 3847 :             
; 3848 :             if (SUCCEEDED(hr))

  00248	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0024c	7c 50		 jl	 SHORT $L70746

; 3849 :             {
; 3850 : #ifdef DXAPI
; 3851 :                 if (!m_pDirectMusic)
; 3852 :                 {
; 3853 :                     hr = DirectMusicCreateInstance(CLSID_DirectMusic,
; 3854 :                                           NULL,
; 3855 :                                           IID_IDirectMusic8, 
; 3856 :                                           (LPVOID*)&m_pDirectMusic);
; 3857 :                     if (SUCCEEDED(hr))
; 3858 :                     {
; 3859 :                         hr = m_pDirectMusic->SetDirectSound(m_pDirectSound,hWnd);
; 3860 :                     }
; 3861 :                 }
; 3862 : #else
; 3863 :                 DirectSoundCreate(NULL, &m_pDirectSound, 0);

  0024e	6a 00		 push	 0
  00250	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00253	83 c0 1c	 add	 eax, 28			; 0000001cH
  00256	50		 push	 eax
  00257	6a 00		 push	 0
  00259	e8 00 00 00 00	 call	 _DirectSoundCreate@12

; 3864 :                 hr = DirectMusicCreateInstance(CLSID_DirectMusicSynth,
; 3865 :                                       NULL,
; 3866 :                                       IID_IDirectMusicSynthX, 
; 3867 :                                       (LPVOID*)&m_pSynth);

  0025e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00261	83 c1 18	 add	 ecx, 24			; 00000018H
  00264	51		 push	 ecx
  00265	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSynthX
  0026a	6a 00		 push	 0
  0026c	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicSynth
  00271	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
  00276	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3868 :                 if (m_pSynth)

  00279	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0027c	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00280	74 1c		 je	 SHORT $L70746

; 3869 :                 {
; 3870 :                     m_pSynth->Init(m_AudioParams.dwVoices);

  00282	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00285	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  0028b	51		 push	 ecx
  0028c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0028f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00292	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00298	8b 00		 mov	 eax, DWORD PTR [eax]
  0029a	52		 push	 edx
  0029b	ff 50 0c	 call	 DWORD PTR [eax+12]
$L70746:

; 3871 :                 }
; 3872 : #endif
; 3873 :             }
; 3874 :         }
; 3875 :     }
; 3876 :     if (SUCCEEDED(hr))

  0029e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002a2	0f 8c 86 00 00
	00		 jl	 $L70754

; 3877 :     {
; 3878 :         hr = m_BufferManager.Init(this,&m_AudioParams);

  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002ab	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  002b1	51		 push	 ecx
  002b2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002b5	52		 push	 edx
  002b6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  002bf	e8 00 00 00 00	 call	 ?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z ; CBufferManager::Init
  002c4	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3879 :         if (SUCCEEDED(hr))

  002c7	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002cb	7c 61		 jl	 SHORT $L70754

; 3880 :         {
; 3881 : #ifdef DXAPI
; 3882 :             // If we are going to be connecting the synth to Buffers, 
; 3883 :             // force the use of the dsound clock.
; 3884 :             // This is automatically handed in BufferManager.Init() for non-DX versions.
; 3885 :             if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
; 3886 :             {
; 3887 :                 DMUS_CLOCKINFO ClockInfo;
; 3888 :                 ClockInfo.dwSize = sizeof(ClockInfo);
; 3889 :                 DWORD dwIndex;
; 3890 :                 GUID guidMasterClock = GUID_NULL;
; 3891 :                 for (dwIndex = 0; ;dwIndex++)
; 3892 :                 {
; 3893 :                     if (S_OK == m_pDirectMusic->EnumMasterClock(dwIndex, &ClockInfo))
; 3894 :                     {
; 3895 :                         if (!wcscmp(ClockInfo.wszDescription, L"DirectSound Clock"))
; 3896 :                         {
; 3897 :                             guidMasterClock = ClockInfo.guidClock;
; 3898 :                             break;
; 3899 :                         }
; 3900 :                     }
; 3901 :                     else
; 3902 :                     {
; 3903 :                         break;
; 3904 :                     }
; 3905 :                 }
; 3906 :                 m_pDirectMusic->SetMasterClock(guidMasterClock);
; 3907 :             }
; 3908 : #endif
; 3909 :             hr = CreateThreads();

  002cd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002d0	e8 00 00 00 00	 call	 ?CreateThreads@CPerformance@@AAEJXZ ; CPerformance::CreateThreads
  002d5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3910 :             if (SUCCEEDED(hr))

  002d8	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002dc	7c 50		 jl	 SHORT $L70754

; 3911 :             {
; 3912 :                 if (dwDefaultPathType)

  002de	83 7d 18 00	 cmp	 DWORD PTR _dwDefaultPathType$[ebp], 0
  002e2	74 4a		 je	 SHORT $L70754

; 3913 :                 {
; 3914 :                     IDirectMusicAudioPath *pPath;
; 3915 :                     hr = CreateStandardAudioPath(dwDefaultPathType,dwPChannelCount,m_AudioParams.fInitNow,&pPath);

  002e4	8d 45 f8	 lea	 eax, DWORD PTR _pPath$70760[ebp]
  002e7	50		 push	 eax
  002e8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002eb	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  002f1	52		 push	 edx
  002f2	8b 45 1c	 mov	 eax, DWORD PTR _dwPChannelCount$[ebp]
  002f5	50		 push	 eax
  002f6	8b 4d 18	 mov	 ecx, DWORD PTR _dwDefaultPathType$[ebp]
  002f9	51		 push	 ecx
  002fa	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002fd	8b 02		 mov	 eax, DWORD PTR [edx]
  002ff	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00302	51		 push	 ecx
  00303	ff 50 50	 call	 DWORD PTR [eax+80]
  00306	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3916 :                     if (SUCCEEDED(hr))

  00309	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0030d	7c 1f		 jl	 SHORT $L70754

; 3917 :                     {
; 3918 :                         hr = SetDefaultAudioPath(pPath);

  0030f	8b 55 f8	 mov	 edx, DWORD PTR _pPath$70760[ebp]
  00312	52		 push	 edx
  00313	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00316	8b 08		 mov	 ecx, DWORD PTR [eax]
  00318	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0031b	52		 push	 edx
  0031c	ff 51 54	 call	 DWORD PTR [ecx+84]
  0031f	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3919 :                         pPath->Release();

  00322	8b 45 f8	 mov	 eax, DWORD PTR _pPath$70760[ebp]
  00325	8b 08		 mov	 ecx, DWORD PTR [eax]
  00327	8b 55 f8	 mov	 edx, DWORD PTR _pPath$70760[ebp]
  0032a	52		 push	 edx
  0032b	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70754:

; 3920 :                     }
; 3921 :                 }
; 3922 :                 // Hack to make timing work for now...
; 3923 : //                CreateStandardAudioPath(DMUS_APATH_DYNAMIC_MONO,1,TRUE,&m_pDummy);
; 3924 :             }
; 3925 :         }
; 3926 :     }
; 3927 :     if (SUCCEEDED(hr))

  0032e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00332	0f 8c 76 01 00
	00		 jl	 $L70764

; 3928 :     {
; 3929 : #ifndef XBOX
; 3930 :         if (m_pDirectMusic && ppDirectMusic && !*ppDirectMusic)
; 3931 :         {
; 3932 :             *ppDirectMusic = m_pDirectMusic;
; 3933 :             m_pDirectMusic->AddRef();
; 3934 :         }
; 3935 :         if (m_pDirectSound && ppDirectSound && !*ppDirectSound)
; 3936 :         {
; 3937 :             *ppDirectSound = m_pDirectSound;
; 3938 :             m_pDirectSound->AddRef();
; 3939 :         }
; 3940 : #endif !XBOX
; 3941 :         if (pParams && pParams->fInitNow)

  00338	83 7d 24 00	 cmp	 DWORD PTR _pParams$[ebp], 0
  0033c	0f 84 5b 01 00
	00		 je	 $L70765
  00342	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  00345	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00349	0f 84 4e 01 00
	00		 je	 $L70765

; 3942 :         {
; 3943 :             if (pParams->clsidDefaultSynth != m_AudioParams.clsidDefaultSynth)

  0034f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00352	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  00358	51		 push	 ecx
  00359	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  0035c	83 c2 18	 add	 edx, 24			; 00000018H
  0035f	52		 push	 edx
  00360	e8 00 00 00 00	 call	 _!=@8
  00365	85 c0		 test	 eax, eax
  00367	74 47		 je	 SHORT $L70766

; 3944 :             {
; 3945 :                 pParams->clsidDefaultSynth = m_AudioParams.clsidDefaultSynth;

  00369	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0036c	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  00371	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  00374	83 c1 18	 add	 ecx, 24			; 00000018H
  00377	8b 10		 mov	 edx, DWORD PTR [eax]
  00379	89 11		 mov	 DWORD PTR [ecx], edx
  0037b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0037e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00381	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00384	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00387	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0038a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 3946 :                 if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH) 

  0038d	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  00390	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00393	83 e2 08	 and	 edx, 8
  00396	85 d2		 test	 edx, edx
  00398	74 16		 je	 SHORT $L70766

; 3947 :                 {
; 3948 :                     Trace(2,"Warning: Default synth choice has been changed.\n");

  0039a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@MNLLPNCN@Warning?3?5Default?5synth?5choice?5ha@
  0039f	6a 02		 push	 2
  003a1	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  003a6	83 c4 08	 add	 esp, 8

; 3949 :                     hr = S_FALSE;

  003a9	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L70766:

; 3950 :                 }
; 3951 :             }
; 3952 :             if (pParams->dwFeatures != m_AudioParams.dwFeatures)

  003b0	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  003b3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003b6	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  003b9	3b 91 d4 00 00
	00		 cmp	 edx, DWORD PTR [ecx+212]
  003bf	74 39		 je	 SHORT $L70770

; 3953 :             {
; 3954 :                 pParams->dwFeatures = m_AudioParams.dwFeatures;

  003c1	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  003c4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003c7	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  003cd	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 3955 :                 if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES) 

  003d0	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  003d3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003d6	83 e1 01	 and	 ecx, 1
  003d9	85 c9		 test	 ecx, ecx
  003db	74 1d		 je	 SHORT $L70770

; 3956 :                 {
; 3957 :                     Trace(2,"Warning: Features flags has been changed to %lx.\n",pParams->dwFeatures);

  003dd	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  003e0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  003e3	50		 push	 eax
  003e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@EJJPIBFI@Warning?3?5Features?5flags?5has?5been@
  003e9	6a 02		 push	 2
  003eb	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  003f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3958 :                     hr = S_FALSE;

  003f3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L70770:

; 3959 :                 }
; 3960 :             }
; 3961 :             if (pParams->dwSampleRate != m_AudioParams.dwSampleRate)

  003fa	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  003fd	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00400	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00403	3b 82 dc 00 00
	00		 cmp	 eax, DWORD PTR [edx+220]
  00409	74 39		 je	 SHORT $L70774

; 3962 :             {
; 3963 :                 pParams->dwSampleRate = m_AudioParams.dwSampleRate;

  0040b	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  0040e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00411	8b 82 dc 00 00
	00		 mov	 eax, DWORD PTR [edx+220]
  00417	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 3964 :                 if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE) 

  0041a	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  0041d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00420	83 e2 04	 and	 edx, 4
  00423	85 d2		 test	 edx, edx
  00425	74 1d		 je	 SHORT $L70774

; 3965 :                 {
; 3966 :                     Trace(2,"Warning: Sample rate has been changed to %ld.\n",pParams->dwSampleRate);

  00427	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  0042a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0042d	51		 push	 ecx
  0042e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@JAPGDOLO@Warning?3?5Sample?5rate?5has?5been?5ch@
  00433	6a 02		 push	 2
  00435	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0043a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3967 :                     hr = S_FALSE;

  0043d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L70774:

; 3968 :                 }
; 3969 :             }
; 3970 :             if (pParams->dwVoices != m_AudioParams.dwVoices)

  00444	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  00447	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0044a	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0044d	3b 88 d8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+216]
  00453	74 39		 je	 SHORT $L70778

; 3971 :             {
; 3972 :                 pParams->dwVoices = m_AudioParams.dwVoices;

  00455	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  00458	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0045b	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  00461	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3973 :                 if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES) 

  00464	8b 55 24	 mov	 edx, DWORD PTR _pParams$[ebp]
  00467	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0046a	83 e0 02	 and	 eax, 2
  0046d	85 c0		 test	 eax, eax
  0046f	74 1d		 je	 SHORT $L70778

; 3974 :                 {
; 3975 :                     Trace(2,"Warning: Number of requested voices has been changed to %ld.\n",pParams->dwVoices);

  00471	8b 4d 24	 mov	 ecx, DWORD PTR _pParams$[ebp]
  00474	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00477	52		 push	 edx
  00478	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@MKDNBMAL@Warning?3?5Number?5of?5requested?5voi@
  0047d	6a 02		 push	 2
  0047f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00484	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3976 :                     hr = S_FALSE;

  00487	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L70778:

; 3977 :                 }
; 3978 :             }
; 3979 :             pParams->dwValidData = m_AudioParams.dwValidData;

  0048e	8b 45 24	 mov	 eax, DWORD PTR _pParams$[ebp]
  00491	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00494	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  0049a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L70765:

; 3980 :         }
; 3981 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0049d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  004a0	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  004a5	50		 push	 eax
  004a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 3982 :     }
; 3983 :     else

  004ac	eb 1c		 jmp	 SHORT $L70782
$L70764:

; 3984 :     {
; 3985 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  004ae	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  004b1	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  004b7	51		 push	 ecx
  004b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 3986 :         CloseDown();

  004be	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  004c1	8b 02		 mov	 eax, DWORD PTR [edx]
  004c3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  004c6	51		 push	 ecx
  004c7	ff 50 64	 call	 DWORD PTR [eax+100]
$L70782:

; 3987 :     }
; 3988 :     return hr;

  004ca	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L70715:

; 3989 : }

  004cd	8b e5		 mov	 esp, ebp
  004cf	5d		 pop	 ebp
  004d0	c2 20 00	 ret	 32			; 00000020H
?InitAudio@CPerformance@@QAGJPAPAUIDirectMusic@@PAPAUIDirectSound@@PAUHWND__@@KKKPAU_DMUS_AUDIOPARAMS@@@Z ENDP ; CPerformance::InitAudio
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
_TEXT	ENDS
;	COMDAT _!=@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_!=@8	PROC NEAR					; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  :     return !(guidOne == guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _==@8
  00010	f7 d8		 neg	 eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax

; 195  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_!=@8	ENDP
_TEXT	ENDS
PUBLIC	?Init@CPerformance@@QAGJPAPAUIDirectMusic@@PAUIDirectSound@@PAUHWND__@@@Z ; CPerformance::Init
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
;	COMDAT ?Init@CPerformance@@QAGJPAPAUIDirectMusic@@PAUIDirectSound@@PAUHWND__@@@Z
_TEXT	SEGMENT
_this$ = 8
_ppDirectMusic$ = 12
_pDirectSound$ = 16
_hWnd$ = 20
?Init@CPerformance@@QAGJPAPAUIDirectMusic@@PAUIDirectSound@@PAUHWND__@@@Z PROC NEAR ; CPerformance::Init, COMDAT

; 3993 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3994 : #ifndef DXAPI
; 3995 :     return E_FAIL; // THis is not supported on XBox.

  00003	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 3996 : #else
; 3997 :     V_INAME(IDirectMusicPerformance::Init);
; 3998 :     V_PTRPTR_WRITE_OPT(ppDirectMusic);
; 3999 :     V_INTERFACE_OPT(pDirectSound);
; 4000 :     V_HWND_OPT(hWnd);
; 4001 :     HRESULT hr = S_OK;
; 4002 : 
; 4003 :     // Further validate, checking for a pointer to a bad interface pointer...
; 4004 :     if (ppDirectMusic)
; 4005 :     {
; 4006 :         V_INTERFACE_OPT(*ppDirectMusic);
; 4007 :     }
; 4008 :     if( m_dwAudioPathMode )
; 4009 :     {
; 4010 :         Trace(0,"Error: Init called on an already initialized Performance.\n");
; 4011 :         return DMUS_E_ALREADY_INITED;
; 4012 :     }
; 4013 :     Init();
; 4014 :     m_dwAudioPathMode = 1;
; 4015 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);
; 4016 : 
; 4017 :     if(( NULL == ppDirectMusic ) || ( NULL == *ppDirectMusic ))
; 4018 :     {
; 4019 :         // intialize DirectMusic. 
; 4020 : 
; 4021 :         if( FAILED( DirectMusicCreateInstance(CLSID_DirectMusic,
; 4022 :                               NULL,
; 4023 :                               IID_IDirectMusic,
; 4024 :                               (LPVOID*)&m_pDirectMusic)))
; 4025 :         {
; 4026 :             m_pDirectMusic = NULL;
; 4027 :             LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 4028 :             return E_OUTOFMEMORY;
; 4029 :         }
; 4030 : 
; 4031 :         // If version2 was requested by the app (in the process of requesting the
; 4032 :         // IDirectMusicPerformance2 interface), do the same for IDirectMusic.
; 4033 :         if (m_dwVersion > 6)
; 4034 :         {
; 4035 :             IDirectMusic *pTemp = NULL;
; 4036 :             if (SUCCEEDED(m_pDirectMusic->QueryInterface(
; 4037 :                 IID_IDirectMusic2,
; 4038 :                 (LPVOID*)&pTemp)))
; 4039 :             {
; 4040 :                 // Succeeded in requesting DX7 and up behavior...
; 4041 :                 pTemp->Release();
; 4042 :             }
; 4043 :         }
; 4044 : 
; 4045 :         hr = m_pDirectMusic->SetDirectSound(pDirectSound, hWnd);
; 4046 :         if( FAILED( hr ) )
; 4047 :         {
; 4048 :             m_pDirectMusic->Release();
; 4049 :             m_pDirectMusic = NULL;
; 4050 :             LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 4051 :             return hr;
; 4052 :         }
; 4053 :                     
; 4054 :         if( ppDirectMusic )
; 4055 :         {
; 4056 :             *ppDirectMusic = m_pDirectMusic;
; 4057 :             m_pDirectMusic->AddRef();
; 4058 :         }
; 4059 :     }
; 4060 :     else
; 4061 :     {
; 4062 :         m_pDirectMusic = (IDirectMusic8 *) *ppDirectMusic;
; 4063 :         m_pDirectMusic->AddRef();
; 4064 :     }
; 4065 :     if (FAILED(hr = CreateThreads()))
; 4066 :     {
; 4067 :         if( m_pDirectMusic )
; 4068 :         {
; 4069 :             m_pDirectMusic->Release();
; 4070 :             m_pDirectMusic = NULL;
; 4071 :         }
; 4072 :     }
; 4073 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 4074 :     return hr;
; 4075 : #endif
; 4076 : }

  00008	5d		 pop	 ebp
  00009	c2 10 00	 ret	 16			; 00000010H
?Init@CPerformance@@QAGJPAPAUIDirectMusic@@PAUIDirectSound@@PAUHWND__@@@Z ENDP ; CPerformance::Init
_TEXT	ENDS
PUBLIC	?GetSegmentForTransition@CPerformance@@AAEPAVCSegState@@KJPAUIUnknown@@@Z ; CPerformance::GetSegmentForTransition
EXTRN	_IID_CSegState:BYTE
; Function compile flags: /Odt
;	COMDAT ?GetSegmentForTransition@CPerformance@@AAEPAVCSegState@@KJPAUIUnknown@@@Z
_TEXT	SEGMENT
_this$ = -8
_pSegState$ = -4
_dwFlags$ = 8
_mtTime$ = 12
_pFrom$ = 16
?GetSegmentForTransition@CPerformance@@AAEPAVCSegState@@KJPAUIUnknown@@@Z PROC NEAR ; CPerformance::GetSegmentForTransition, COMDAT
; _this$ = ecx

; 4080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4081 :     CSegState *pSegState = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pSegState$[ebp], 0

; 4082 : 
; 4083 :     // If the source segment was provided, use it. 
; 4084 :     if (pFrom)

  00010	83 7d 10 00	 cmp	 DWORD PTR _pFrom$[ebp], 0
  00014	74 24		 je	 SHORT $L70797

; 4085 :     {
; 4086 :         if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegState)))

  00016	8d 45 fc	 lea	 eax, DWORD PTR _pSegState$[ebp]
  00019	50		 push	 eax
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegState
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _pFrom$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	8b 45 10	 mov	 eax, DWORD PTR _pFrom$[ebp]
  00027	50		 push	 eax
  00028	ff 12		 call	 DWORD PTR [edx]
  0002a	85 c0		 test	 eax, eax
  0002c	7c 0c		 jl	 SHORT $L70797

; 4087 :         {
; 4088 :             pSegState->Release();

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	8b 45 fc	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00036	50		 push	 eax
  00037	ff 52 08	 call	 DWORD PTR [edx+8]
$L70797:

; 4089 :         }
; 4090 :     }
; 4091 :     // Else, if this is a primary segment, get the current primary segment.
; 4092 :     if (!pSegState && !(dwFlags & DMUS_SEGF_SECONDARY))

  0003a	83 7d fc 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  0003e	75 1c		 jne	 SHORT $L70801
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00043	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00049	85 c9		 test	 ecx, ecx
  0004b	75 0f		 jne	 SHORT $L70801

; 4093 :     {
; 4094 :         pSegState = GetPrimarySegmentAtTime(mtTime);

  0004d	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00050	52		 push	 edx
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  00059	89 45 fc	 mov	 DWORD PTR _pSegState$[ebp], eax
$L70801:

; 4095 :     }
; 4096 :     return pSegState;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _pSegState$[ebp]

; 4097 : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
?GetSegmentForTransition@CPerformance@@AAEPAVCSegState@@KJPAUIUnknown@@@Z ENDP ; CPerformance::GetSegmentForTransition
_TEXT	ENDS
PUBLIC	?ClearMusicStoppedNotification@CPerformance@@AAEXXZ ; CPerformance::ClearMusicStoppedNotification
; Function compile flags: /Odt
;	COMDAT ?ClearMusicStoppedNotification@CPerformance@@AAEXXZ
_TEXT	SEGMENT
_this$ = -16
_pNotification$ = -12
_pPMsg$ = -8
_pNext$ = -4
?ClearMusicStoppedNotification@CPerformance@@AAEXXZ PROC NEAR ; CPerformance::ClearMusicStoppedNotification, COMDAT
; _this$ = ecx

; 4101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 4102 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 4103 :     PRIV_PMSG* pPMsg;
; 4104 :     PRIV_PMSG* pNext;
; 4105 :     DMUS_NOTIFICATION_PMSG* pNotification;
; 4106 : 
; 4107 :     pPMsg = m_OnTimeQueue.GetHead(); // where notifications live normally

  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00021	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00026	89 45 f8	 mov	 DWORD PTR _pPMsg$[ebp], eax

; 4108 :     for (; pPMsg ; pPMsg = pNext)

  00029	eb 06		 jmp	 SHORT $L70808
$L70809:
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0002e	89 4d f8	 mov	 DWORD PTR _pPMsg$[ebp], ecx
$L70808:
  00031	83 7d f8 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  00035	74 6e		 je	 SHORT $L70810

; 4109 :     {
; 4110 :         pNext = pPMsg->pNext;

  00037	8b 55 f8	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0003a	8b 02		 mov	 eax, DWORD PTR [edx]
  0003c	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 4111 :         pNotification = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPMsg);

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00042	83 c1 18	 add	 ecx, 24			; 00000018H
  00045	89 4d f4	 mov	 DWORD PTR _pNotification$[ebp], ecx

; 4112 :         if( ( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION ) &&
; 4113 :             ( pNotification->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE ) && 
; 4114 :             ( pNotification->dwNotificationOption == DMUS_NOTIFICATION_MUSICSTOPPED ) )

  00048	8b 55 f8	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0004b	83 7a 40 03	 cmp	 DWORD PTR [edx+64], 3
  0004f	75 52		 jne	 SHORT $L70814
  00051	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_NOTIFICATION_PERFORMANCE
  00056	8b 45 f4	 mov	 eax, DWORD PTR _pNotification$[ebp]
  00059	83 c0 38	 add	 eax, 56			; 00000038H
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _==@8
  00062	85 c0		 test	 eax, eax
  00064	74 3d		 je	 SHORT $L70814
  00066	8b 4d f4	 mov	 ecx, DWORD PTR _pNotification$[ebp]
  00069	83 79 48 01	 cmp	 DWORD PTR [ecx+72], 1
  0006d	75 34		 jne	 SHORT $L70814

; 4115 :         {
; 4116 :             pPMsg = m_OnTimeQueue.Dequeue(pPMsg);

  0006f	8b 55 f8	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00072	52		 push	 edx
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  0007c	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z ; CPMsgQueue::Dequeue
  00081	89 45 f8	 mov	 DWORD PTR _pPMsg$[ebp], eax

; 4117 :             if( pPMsg ) // Should always succeeed

  00084	83 7d f8 00	 cmp	 DWORD PTR _pPMsg$[ebp], 0
  00088	74 0c		 je	 SHORT $L70815

; 4118 :             {
; 4119 :                 FreePMsg(pPMsg);

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg
$L70815:

; 4120 :             }
; 4121 :             m_fMusicStopped = FALSE;

  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	c7 81 c8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+968], 0
$L70814:

; 4122 :         }
; 4123 :     }

  000a3	eb 86		 jmp	 SHORT $L70809
$L70810:

; 4124 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000a5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000ae	52		 push	 edx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 4125 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?ClearMusicStoppedNotification@CPerformance@@AAEXXZ ENDP ; CPerformance::ClearMusicStoppedNotification
_TEXT	ENDS
PUBLIC	??_C@_0FG@GDKLNKDJ@Error?3?5Unable?5to?5play?5segment?0?5r@ ; `string'
PUBLIC	??_C@_0FE@CECAKFA@Error?3?5Unable?5to?5play?5segment?0?5r@ ; `string'
PUBLIC	??_C@_0EK@HFOOBOAG@Error?3?5Unable?5to?5play?5segment?5be@ ; `string'
PUBLIC	?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z ; CPerformance::PlayOneSegment
EXTRN	?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z:NEAR ; CSegment::AddNotificationType
EXTRN	?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z:NEAR ; CSegment::RemoveNotificationType
EXTRN	?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z:NEAR ; CSegment::CreateSegmentState
EXTRN	?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z:NEAR	; CBossMan::WakeUp
;	COMDAT ??_C@_0FG@GDKLNKDJ@Error?3?5Unable?5to?5play?5segment?0?5r@
CONST	SEGMENT
??_C@_0FG@GDKLNKDJ@Error?3?5Unable?5to?5play?5segment?0?5r@ DB 'Error: Un'
	DB	'able to play segment, requested clock time %I64d is past curr'
	DB	'ent time %I64d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@CECAKFA@Error?3?5Unable?5to?5play?5segment?0?5r@
CONST	SEGMENT
??_C@_0FE@CECAKFA@Error?3?5Unable?5to?5play?5segment?0?5r@ DB 'Error: Una'
	DB	'ble to play segment, requested music time %I64d is past curre'
	DB	'nt time %ld', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@HFOOBOAG@Error?3?5Unable?5to?5play?5segment?5be@
CONST	SEGMENT
??_C@_0EK@HFOOBOAG@Error?3?5Unable?5to?5play?5segment?5be@ DB 'Error: Una'
	DB	'ble to play segment because of failure creating segment state'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z
_TEXT	SEGMENT
tv392 = -80
tv391 = -72
tv366 = -68
tv340 = -64
tv339 = -56
tv312 = -52
tv241 = -48
_this$ = -40
_mtStart$70866 = -36
_rtStart$70862 = -32
_rtTrans$70856 = -24
_mtPrePlay$70836 = -16
_pSegState$ = -12
_hr$ = -8
_pItem$ = -4
_pSegment$ = 8
_dwFlags$ = 12
_i64StartTime$ = 16
_ppSegState$ = 24
_pAudioPath$ = 28
?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z PROC NEAR ; CPerformance::PlayOneSegment, COMDAT
; _this$ = ecx

; 4133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 4134 :     HRESULT hr;
; 4135 : #ifdef DBG_PROFILE
; 4136 :     DWORD dwDebugTime;
; 4137 :     dwDebugTime = timeGetTime();
; 4138 : #endif
; 4139 : 
; 4140 : //    TraceI(0,"Play Segment %lx (%ls) at time %ld with flags %lx\n",pSegment,pSegment->m_wszName,(long)i64StartTime,dwFlags);
; 4141 :     if( dwFlags & DMUS_SEGF_CONTROL )

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0000c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00011	85 c0		 test	 eax, eax
  00013	74 0c		 je	 SHORT $L70825

; 4142 :     {
; 4143 :         dwFlags |= DMUS_SEGF_SECONDARY;

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00018	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0001e	89 4d 0c	 mov	 DWORD PTR _dwFlags$[ebp], ecx
$L70825:

; 4144 :     }
; 4145 :     if( i64StartTime )

  00021	8b 55 10	 mov	 edx, DWORD PTR _i64StartTime$[ebp]
  00024	0b 55 14	 or	 edx, DWORD PTR _i64StartTime$[ebp+4]
  00027	85 d2		 test	 edx, edx
  00029	0f 84 c6 00 00
	00		 je	 $L70826

; 4146 :     {
; 4147 :         if (!(dwFlags & DMUS_SEGF_ALIGN))

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00032	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00037	85 c0		 test	 eax, eax
  00039	0f 85 b6 00 00
	00		 jne	 $L70826

; 4148 :         {
; 4149 :             if(dwFlags & DMUS_SEGF_REFTIME)

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00042	83 e1 40	 and	 ecx, 64			; 00000040H
  00045	85 c9		 test	 ecx, ecx
  00047	74 5d		 je	 SHORT $L70828

; 4150 :             {
; 4151 :                 // Give a grace period of 100ms.
; 4152 :                 if( i64StartTime < (GetLatency() - (100 * REF_PER_MIL)))

  00049	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00051	2d 40 42 0f 00	 sub	 eax, 1000000		; 000f4240H
  00056	83 da 00	 sbb	 edx, 0
  00059	89 45 d0	 mov	 DWORD PTR tv241[ebp], eax
  0005c	89 55 d4	 mov	 DWORD PTR tv241[ebp+4], edx
  0005f	8b 55 14	 mov	 edx, DWORD PTR _i64StartTime$[ebp+4]
  00062	3b 55 d4	 cmp	 edx, DWORD PTR tv241[ebp+4]
  00065	7f 3d		 jg	 SHORT $L70829
  00067	7c 08		 jl	 SHORT $L75415
  00069	8b 45 10	 mov	 eax, DWORD PTR _i64StartTime$[ebp]
  0006c	3b 45 d0	 cmp	 eax, DWORD PTR tv241[ebp]
  0006f	73 33		 jae	 SHORT $L70829
$L75415:

; 4153 :                 {
; 4154 :                     Trace(1,"Error: Unable to play segment, requested clock time %I64d is past current time %I64d\n",
; 4155 :                         i64StartTime,GetLatency() - (100 * REF_PER_MIL));

  00071	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00079	2d 40 42 0f 00	 sub	 eax, 1000000		; 000f4240H
  0007e	83 da 00	 sbb	 edx, 0
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	8b 4d 14	 mov	 ecx, DWORD PTR _i64StartTime$[ebp+4]
  00086	51		 push	 ecx
  00087	8b 55 10	 mov	 edx, DWORD PTR _i64StartTime$[ebp]
  0008a	52		 push	 edx
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FG@GDKLNKDJ@Error?3?5Unable?5to?5play?5segment?0?5r@
  00090	6a 01		 push	 1
  00092	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00097	83 c4 18	 add	 esp, 24			; 00000018H

; 4156 :                     return DMUS_E_TIME_PAST;

  0009a	b8 65 11 78 88	 mov	 eax, -2005397147	; 88781165H
  0009f	e9 1c 03 00 00	 jmp	 $L70823
$L70829:

; 4157 :                 }
; 4158 :             }
; 4159 :             else

  000a4	eb 4f		 jmp	 SHORT $L70826
$L70828:

; 4160 :             {
; 4161 :                 MUSIC_TIME mtPrePlay;
; 4162 :                 // Give a grace period of 100ms.
; 4163 :                 ReferenceToMusicTime( (GetLatency() - (100 * REF_PER_MIL)), &mtPrePlay );

  000a6	8d 45 f0	 lea	 eax, DWORD PTR _mtPrePlay$70836[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  000b2	2d 40 42 0f 00	 sub	 eax, 1000000		; 000f4240H
  000b7	83 da 00	 sbb	 edx, 0
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c1	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	50		 push	 eax
  000c5	ff 52 18	 call	 DWORD PTR [edx+24]

; 4164 :                 if( (MUSIC_TIME)i64StartTime < mtPrePlay )

  000c8	8b 4d 10	 mov	 ecx, DWORD PTR _i64StartTime$[ebp]
  000cb	3b 4d f0	 cmp	 ecx, DWORD PTR _mtPrePlay$70836[ebp]
  000ce	7d 25		 jge	 SHORT $L70826

; 4165 :                 {
; 4166 :                     Trace(1,"Error: Unable to play segment, requested music time %I64d is past current time %ld\n",
; 4167 :                         i64StartTime,(long)mtPrePlay);

  000d0	8b 55 f0	 mov	 edx, DWORD PTR _mtPrePlay$70836[ebp]
  000d3	52		 push	 edx
  000d4	8b 45 14	 mov	 eax, DWORD PTR _i64StartTime$[ebp+4]
  000d7	50		 push	 eax
  000d8	8b 4d 10	 mov	 ecx, DWORD PTR _i64StartTime$[ebp]
  000db	51		 push	 ecx
  000dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FE@CECAKFA@Error?3?5Unable?5to?5play?5segment?0?5r@
  000e1	6a 01		 push	 1
  000e3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000e8	83 c4 14	 add	 esp, 20			; 00000014H

; 4168 :                     return DMUS_E_TIME_PAST;

  000eb	b8 65 11 78 88	 mov	 eax, -2005397147	; 88781165H
  000f0	e9 cb 02 00 00	 jmp	 $L70823
$L70826:

; 4169 :                 }
; 4170 :             }
; 4171 :         }
; 4172 :     }
; 4173 : 
; 4174 :     CSegState *pSegState = NULL;

  000f5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pSegState$[ebp], 0

; 4175 :     hr = pSegment->CreateSegmentState( &pSegState, this, pAudioPath, dwFlags);

  000fc	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  000ff	52		 push	 edx
  00100	8b 45 1c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00103	50		 push	 eax
  00104	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	51		 push	 ecx
  00108	8d 55 f4	 lea	 edx, DWORD PTR _pSegState$[ebp]
  0010b	52		 push	 edx
  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  0010f	e8 00 00 00 00	 call	 ?CreateSegmentState@CSegment@@QAEJPAPAVCSegState@@PAVCPerformance@@PAUIDirectMusicAudioPath@@K@Z ; CSegment::CreateSegmentState
  00114	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 4176 :     *ppSegState = pSegState;

  00117	8b 45 18	 mov	 eax, DWORD PTR _ppSegState$[ebp]
  0011a	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  0011d	89 08		 mov	 DWORD PTR [eax], ecx

; 4177 :     if (FAILED(hr))

  0011f	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00123	7d 19		 jge	 SHORT $L70847

; 4178 :     {
; 4179 :         Trace(1,"Error: Unable to play segment because of failure creating segment state.\n");

  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EK@HFOOBOAG@Error?3?5Unable?5to?5play?5segment?5be@
  0012a	6a 01		 push	 1
  0012c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00131	83 c4 08	 add	 esp, 8

; 4180 :         return DMUS_E_SEGMENT_INIT_FAILED;

  00134	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00139	e9 82 02 00 00	 jmp	 $L70823
$L70847:

; 4181 :     }
; 4182 :     pSegState->m_rtGivenStart = i64StartTime;

  0013e	8b 55 f4	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00141	8b 45 10	 mov	 eax, DWORD PTR _i64StartTime$[ebp]
  00144	89 82 a0 00 00
	00		 mov	 DWORD PTR [edx+160], eax
  0014a	8b 4d 14	 mov	 ecx, DWORD PTR _i64StartTime$[ebp+4]
  0014d	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 4183 : 
; 4184 :     pSegState->m_dwPlaySegFlags = dwFlags;

  00153	8b 55 f4	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00156	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00159	89 42 5c	 mov	 DWORD PTR [edx+92], eax

; 4185 : 
; 4186 :     // add the pSegState to the appropriate queue
; 4187 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  0015c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00165	51		 push	 ecx
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 4188 :     m_fPlaying = 1; // turn on the transport

  0016c	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0016f	c7 82 c4 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+964], 1

; 4189 :     // add all notifications to the segment. First, clear it, in case old notifications
; 4190 :     // are in effect.
; 4191 :     pSegment->RemoveNotificationType(GUID_NULL,TRUE);

  00179	6a 01		 push	 1
  0017b	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  00180	8b 4d 08	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  00183	e8 00 00 00 00	 call	 ?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::RemoveNotificationType

; 4192 :     CNotificationItem* pItem;
; 4193 :     pItem = m_NotificationList.GetHead();

  00188	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00191	e8 00 00 00 00	 call	 ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
  00196	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
$L70852:

; 4194 :     while( pItem )

  00199	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0019d	74 1e		 je	 SHORT $L70853

; 4195 :     {
; 4196 :         pSegment->AddNotificationType( pItem->guidNotificationType, TRUE );

  0019f	6a 01		 push	 1
  001a1	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  001a4	83 c0 04	 add	 eax, 4
  001a7	50		 push	 eax
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  001ab	e8 00 00 00 00	 call	 ?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::AddNotificationType

; 4197 :         pItem = pItem->GetNext();

  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001b3	e8 00 00 00 00	 call	 ?GetNext@CNotificationItem@@QAEPAV1@XZ ; CNotificationItem::GetNext
  001b8	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax

; 4198 :     }

  001bb	eb dc		 jmp	 SHORT $L70852
$L70853:

; 4199 : 
; 4200 :     if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )

  001bd	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  001c0	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  001c3	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  001c9	85 d2		 test	 edx, edx
  001cb	0f 84 c7 00 00
	00		 je	 $L70854

; 4201 :     {
; 4202 :         // we want to queue this at the last transported time,
; 4203 :         // so we don't need to do an invalidate
; 4204 :         if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )

  001d1	8b 45 f4	 mov	 eax, DWORD PTR _pSegState$[ebp]
  001d4	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  001d7	83 e1 40	 and	 ecx, 64			; 00000040H
  001da	85 c9		 test	 ecx, ecx
  001dc	74 68		 je	 SHORT $L70855

; 4205 :         {
; 4206 :             REFERENCE_TIME rtTrans;
; 4207 :             MusicToReferenceTime( m_mtTransported, &rtTrans );

  001de	8d 55 e8	 lea	 edx, DWORD PTR _rtTrans$70856[ebp]
  001e1	52		 push	 edx
  001e2	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  001e5	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  001eb	51		 push	 ecx
  001ec	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  001ef	8b 02		 mov	 eax, DWORD PTR [edx]
  001f1	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	51		 push	 ecx
  001f5	ff 50 14	 call	 DWORD PTR [eax+20]

; 4208 :             if( pSegState->m_rtGivenStart < rtTrans )

  001f8	8b 55 f4	 mov	 edx, DWORD PTR _pSegState$[ebp]
  001fb	89 55 cc	 mov	 DWORD PTR tv312[ebp], edx
  001fe	8b 45 cc	 mov	 eax, DWORD PTR tv312[ebp]
  00201	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00207	3b 4d ec	 cmp	 ecx, DWORD PTR _rtTrans$70856[ebp+4]
  0020a	7f 38		 jg	 SHORT $L70857
  0020c	7c 0e		 jl	 SHORT $L75416
  0020e	8b 55 cc	 mov	 edx, DWORD PTR tv312[ebp]
  00211	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00217	3b 45 e8	 cmp	 eax, DWORD PTR _rtTrans$70856[ebp]
  0021a	73 28		 jae	 SHORT $L70857
$L75416:

; 4209 :             {
; 4210 :                 pSegState->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;

  0021c	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  0021f	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00222	83 e2 bf	 and	 edx, -65		; ffffffbfH
  00225	8b 45 f4	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00228	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 4211 :                 pSegState->m_rtGivenStart = m_mtTransported;

  0022b	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	8b 81 d0 02 00
	00		 mov	 eax, DWORD PTR [ecx+720]
  00234	99		 cdq
  00235	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00238	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  0023e	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx
$L70857:

; 4212 :             }
; 4213 :         }
; 4214 :         else

  00244	eb 4d		 jmp	 SHORT $L70858
$L70855:

; 4215 :         {
; 4216 :             if( pSegState->m_rtGivenStart < m_mtTransported )

  00246	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00249	8b 82 d0 02 00
	00		 mov	 eax, DWORD PTR [edx+720]
  0024f	99		 cdq
  00250	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00253	89 4d c8	 mov	 DWORD PTR tv339[ebp], ecx
  00256	89 45 c0	 mov	 DWORD PTR tv340[ebp], eax
  00259	89 55 c4	 mov	 DWORD PTR tv340[ebp+4], edx
  0025c	8b 55 c8	 mov	 edx, DWORD PTR tv339[ebp]
  0025f	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00265	3b 45 c4	 cmp	 eax, DWORD PTR tv340[ebp+4]
  00268	7f 29		 jg	 SHORT $L70858
  0026a	7c 0e		 jl	 SHORT $L75417
  0026c	8b 4d c8	 mov	 ecx, DWORD PTR tv339[ebp]
  0026f	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  00275	3b 55 c0	 cmp	 edx, DWORD PTR tv340[ebp]
  00278	73 19		 jae	 SHORT $L70858
$L75417:

; 4217 :             {
; 4218 :                 pSegState->m_rtGivenStart = m_mtTransported;

  0027a	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0027d	8b 80 d0 02 00
	00		 mov	 eax, DWORD PTR [eax+720]
  00283	99		 cdq
  00284	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00287	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  0028d	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx
$L70858:

; 4219 :             }
; 4220 :         }
; 4221 :     }
; 4222 :     else if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERQUEUETIME )

  00293	e9 c7 00 00 00	 jmp	 $L70860
$L70854:
  00298	8b 55 f4	 mov	 edx, DWORD PTR _pSegState$[ebp]
  0029b	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0029e	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  002a3	85 c0		 test	 eax, eax
  002a5	0f 84 b4 00 00
	00		 je	 $L70860

; 4223 :     {
; 4224 :         // we want to queue this at the queue time, as opposed to latency time,
; 4225 :         // which is an option for secondary segments.
; 4226 :         REFERENCE_TIME rtStart;
; 4227 :         GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations

  002ab	8d 4d e0	 lea	 ecx, DWORD PTR _rtStart$70862[ebp]
  002ae	51		 push	 ecx
  002af	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  002b2	8b 02		 mov	 eax, DWORD PTR [edx]
  002b4	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b7	51		 push	 ecx
  002b8	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]

; 4228 :         if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )

  002be	8b 55 f4	 mov	 edx, DWORD PTR _pSegState$[ebp]
  002c1	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  002c4	83 e0 40	 and	 eax, 64			; 00000040H
  002c7	85 c0		 test	 eax, eax
  002c9	74 3b		 je	 SHORT $L70863

; 4229 :         {
; 4230 :             if( pSegState->m_rtGivenStart < rtStart )

  002cb	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  002ce	89 4d bc	 mov	 DWORD PTR tv366[ebp], ecx
  002d1	8b 55 bc	 mov	 edx, DWORD PTR tv366[ebp]
  002d4	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  002da	3b 45 e4	 cmp	 eax, DWORD PTR _rtStart$70862[ebp+4]
  002dd	7f 25		 jg	 SHORT $L70864
  002df	7c 0e		 jl	 SHORT $L75418
  002e1	8b 4d bc	 mov	 ecx, DWORD PTR tv366[ebp]
  002e4	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  002ea	3b 55 e0	 cmp	 edx, DWORD PTR _rtStart$70862[ebp]
  002ed	73 15		 jae	 SHORT $L70864
$L75418:

; 4231 :             {
; 4232 :                 pSegState->m_rtGivenStart = rtStart;

  002ef	8b 45 f4	 mov	 eax, DWORD PTR _pSegState$[ebp]
  002f2	8b 4d e0	 mov	 ecx, DWORD PTR _rtStart$70862[ebp]
  002f5	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx
  002fb	8b 55 e4	 mov	 edx, DWORD PTR _rtStart$70862[ebp+4]
  002fe	89 90 a4 00 00
	00		 mov	 DWORD PTR [eax+164], edx
$L70864:

; 4233 :             }
; 4234 :         }
; 4235 :         else

  00304	eb 59		 jmp	 SHORT $L70860
$L70863:

; 4236 :         {
; 4237 :             MUSIC_TIME mtStart;
; 4238 :             ReferenceToMusicTime( rtStart, &mtStart );

  00306	8d 45 dc	 lea	 eax, DWORD PTR _mtStart$70866[ebp]
  00309	50		 push	 eax
  0030a	8b 4d e4	 mov	 ecx, DWORD PTR _rtStart$70862[ebp+4]
  0030d	51		 push	 ecx
  0030e	8b 55 e0	 mov	 edx, DWORD PTR _rtStart$70862[ebp]
  00311	52		 push	 edx
  00312	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00315	8b 08		 mov	 ecx, DWORD PTR [eax]
  00317	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0031a	52		 push	 edx
  0031b	ff 51 18	 call	 DWORD PTR [ecx+24]

; 4239 :             if( pSegState->m_rtGivenStart < mtStart )

  0031e	8b 45 dc	 mov	 eax, DWORD PTR _mtStart$70866[ebp]
  00321	99		 cdq
  00322	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00325	89 4d b8	 mov	 DWORD PTR tv391[ebp], ecx
  00328	89 45 b0	 mov	 DWORD PTR tv392[ebp], eax
  0032b	89 55 b4	 mov	 DWORD PTR tv392[ebp+4], edx
  0032e	8b 55 b8	 mov	 edx, DWORD PTR tv391[ebp]
  00331	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00337	3b 45 b4	 cmp	 eax, DWORD PTR tv392[ebp+4]
  0033a	7f 23		 jg	 SHORT $L70860
  0033c	7c 0e		 jl	 SHORT $L75419
  0033e	8b 4d b8	 mov	 ecx, DWORD PTR tv391[ebp]
  00341	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  00347	3b 55 b0	 cmp	 edx, DWORD PTR tv392[ebp]
  0034a	73 13		 jae	 SHORT $L70860
$L75419:

; 4240 :             {
; 4241 :                 pSegState->m_rtGivenStart = mtStart;

  0034c	8b 45 dc	 mov	 eax, DWORD PTR _mtStart$70866[ebp]
  0034f	99		 cdq
  00350	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00353	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
  00359	89 91 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], edx
$L70860:

; 4242 :             }
; 4243 :         }
; 4244 :     }
; 4245 :     // need to get rid of any pending musicstopped notifications
; 4246 :     ClearMusicStoppedNotification();

  0035f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00362	e8 00 00 00 00	 call	 ?ClearMusicStoppedNotification@CPerformance@@AAEXXZ ; CPerformance::ClearMusicStoppedNotification

; 4247 : 
; 4248 :     pSegState->AddRef(); 

  00367	8b 55 f4	 mov	 edx, DWORD PTR _pSegState$[ebp]
  0036a	8b 02		 mov	 eax, DWORD PTR [edx]
  0036c	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  0036f	51		 push	 ecx
  00370	ff 50 04	 call	 DWORD PTR [eax+4]

; 4249 : 
; 4250 :     if( dwFlags & DMUS_SEGF_SECONDARY ) // queue a secondary segment

  00373	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00376	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0037c	85 d2		 test	 edx, edx
  0037e	74 0e		 je	 SHORT $L70868

; 4251 :     {
; 4252 :         QueueSecondarySegment( pSegState );

  00380	8b 45 f4	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00383	50		 push	 eax
  00384	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00387	e8 00 00 00 00	 call	 ?QueueSecondarySegment@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::QueueSecondarySegment

; 4253 :     }
; 4254 :     else // queue a primary segment

  0038c	eb 0c		 jmp	 SHORT $L70869
$L70868:

; 4255 :     {
; 4256 :         QueuePrimarySegment( pSegState );

  0038e	8b 4d f4	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00391	51		 push	 ecx
  00392	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00395	e8 00 00 00 00	 call	 ?QueuePrimarySegment@CPerformance@@AAEXPAVCSegState@@@Z ; CPerformance::QueuePrimarySegment
$L70869:

; 4257 :     }
; 4258 : 
; 4259 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0039a	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0039d	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  003a3	52		 push	 edx
  003a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 4260 :     
; 4261 : #ifdef DBG_PROFILE
; 4262 :     dwDebugTime = timeGetTime() - dwDebugTime;
; 4263 :     TraceI(5, "perf, debugtime PlaySegment %u\n", dwDebugTime);
; 4264 : #endif
; 4265 : 
; 4266 : #ifdef DXAPI
; 4267 :     // signal the transport thread so we don't have to wait for it to wake up on its own
; 4268 :     if( m_hTransport ) SetEvent( m_hTransport );
; 4269 : #else
; 4270 :     g_BossMan.WakeUp(m_pRealtimeWorker);

  003aa	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  003ad	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [eax+960]
  003b3	51		 push	 ecx
  003b4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  003b9	e8 00 00 00 00	 call	 ?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z ; CBossMan::WakeUp

; 4271 : 
; 4272 : //    m_pTransportWorker->WakeUp();
; 4273 : #endif
; 4274 :     return S_OK;

  003be	33 c0		 xor	 eax, eax
$L70823:

; 4275 : }

  003c0	8b e5		 mov	 esp, ebp
  003c2	5d		 pop	 ebp
  003c3	c2 18 00	 ret	 24			; 00000018H
?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z ENDP ; CPerformance::PlayOneSegment
_TEXT	ENDS
PUBLIC	??_C@_0EM@MKDFHMPO@Error?3?5Can?5not?5play?5segment?5beca@ ; `string'
PUBLIC	??_C@_0FA@FFKFHOKE@Error?3?5Audiopath?5can?8t?5be?5used?5f@ ; `string'
PUBLIC	??_C@_0CG@FAPEFEL@Error?3?5No?5segment?5?9?5nothing?5to?5p@ ; `string'
PUBLIC	??_C@_0EE@JFGFJCDJ@Error?3?5Embedded?5audiopath?5failed@ ; `string'
PUBLIC	??_C@_0DD@HKONIOHL@Error?3?5Can?5not?5play?5segment?5on?5i@ ; `string'
PUBLIC	??_C@_0CJ@MGJJPPFG@Error?3?5No?5audiopath?5to?5play?5segm@ ; `string'
PUBLIC	??_C@_0BM@DACIMFKH@Error?3?5No?5segment?5to?5play?4?6?$AA@ ; `string'
PUBLIC	?IsActive@CAudioPath@@QAEHXZ			; CAudioPath::IsActive
PUBLIC	?NoPorts@CAudioPath@@QAEHXZ			; CAudioPath::NoPorts
PUBLIC	?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z ; CPerformance::PlaySegmentInternal
EXTRN	_IID_CAudioPath:BYTE
EXTRN	?GetTransitionSegment@CSong@@QAEJPAVCSegment@@0PAU_DMUS_IO_TRANSITION_DEF@@@Z:NEAR ; CSong::GetTransitionSegment
EXTRN	?GetPlaySegment@CSong@@QAEJKPAPAVCSegment@@@Z:NEAR ; CSong::GetPlaySegment
;	COMDAT ??_C@_0EM@MKDFHMPO@Error?3?5Can?5not?5play?5segment?5beca@
CONST	SEGMENT
??_C@_0EM@MKDFHMPO@Error?3?5Can?5not?5play?5segment?5beca@ DB 'Error: Can'
	DB	' not play segment because master clock has not been initializ'
	DB	'ed.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FFKFHOKE@Error?3?5Audiopath?5can?8t?5be?5used?5f@
CONST	SEGMENT
??_C@_0FA@FFKFHOKE@Error?3?5Audiopath?5can?8t?5be?5used?5f@ DB 'Error: Au'
	DB	'diopath can''t be used for playback because it doesn''t have '
	DB	'any ports.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FAPEFEL@Error?3?5No?5segment?5?9?5nothing?5to?5p@
CONST	SEGMENT
??_C@_0CG@FAPEFEL@Error?3?5No?5segment?5?9?5nothing?5to?5p@ DB 'Error: No'
	DB	' segment - nothing to play!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JFGFJCDJ@Error?3?5Embedded?5audiopath?5failed@
CONST	SEGMENT
??_C@_0EE@JFGFJCDJ@Error?3?5Embedded?5audiopath?5failed@ DB 'Error: Embed'
	DB	'ded audiopath failed to create, segment will not play.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HKONIOHL@Error?3?5Can?5not?5play?5segment?5on?5i@
CONST	SEGMENT
??_C@_0DD@HKONIOHL@Error?3?5Can?5not?5play?5segment?5on?5i@ DB 'Error: Ca'
	DB	'n not play segment on inactive audiopath', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MGJJPPFG@Error?3?5No?5audiopath?5to?5play?5segm@
CONST	SEGMENT
??_C@_0CJ@MGJJPPFG@Error?3?5No?5audiopath?5to?5play?5segm@ DB 'Error: No '
	DB	'audiopath to play segment on.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DACIMFKH@Error?3?5No?5segment?5to?5play?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@DACIMFKH@Error?3?5No?5segment?5to?5play?4?6?$AA@ DB 'Error: No '
	DB	'segment to play.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z
_TEXT	SEGMENT
_this$ = -104
_mtStartTime$70976 = -100
_pSegState$70961 = -96
_pITransSegment$70955 = -92
_Transition$70947 = -88
_pPriorState$70944 = -76
_rtResolved$70941 = -72
_rtTime$70935 = -64
_mtTime$70942 = -52
_pPriorSeg$70943 = -48
_mtStartTime$70931 = -44
_pSegFrom$70927 = -40
_pNewPath$70915 = -36
_pSegConfig$70910 = -32
_dwResTemp$70908 = -28
_pISegment$70893 = -24
_hr$ = -20
_pConfig$ = -16
_pPlayAfter$ = -12
_pInternalPath$ = -8
_dwFlagsAfter$ = -4
_pSegment$ = 8
_pSong$ = 12
_pwzSegmentName$ = 16
_pTransition$ = 20
_dwFlags$ = 24
_i64StartTime$ = 28
_ppSegmentState$ = 36
_pFrom$ = 40
_pAudioPath$ = 44
?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z PROC NEAR ; CPerformance::PlaySegmentInternal, COMDAT
; _this$ = ecx

; 4288 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d 98	 mov	 DWORD PTR _this$[ebp], ecx

; 4289 :     HRESULT hr;
; 4290 :     CAudioPath *pInternalPath = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pInternalPath$[ebp], 0

; 4291 :     if( m_pClock == NULL )

  00010	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00017	75 19		 jne	 SHORT $L70885

; 4292 :     {
; 4293 :         Trace(0,"Error: Can not play segment because master clock has not been initialized.\n");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@MKDFHMPO@Error?3?5Can?5not?5play?5segment?5beca@
  0001e	6a 00		 push	 0
  00020	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00025	83 c4 08	 add	 esp, 8

; 4294 :         return DMUS_E_NO_MASTER_CLOCK;

  00028	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0002d	e9 68 05 00 00	 jmp	 $L70882
$L70885:

; 4295 :     }
; 4296 :     if (pAudioPath && (pAudioPath->NoPorts()))

  00032	83 7d 2c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  00036	74 25		 je	 SHORT $L70888
  00038	8b 4d 2c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  0003b	e8 00 00 00 00	 call	 ?NoPorts@CAudioPath@@QAEHXZ ; CAudioPath::NoPorts
  00040	85 c0		 test	 eax, eax
  00042	74 19		 je	 SHORT $L70888

; 4297 :     {
; 4298 :         // This audiopath can't be used for playback since it doesn't have any ports.
; 4299 :         Trace(0,"Error: Audiopath can't be used for playback because it doesn't have any ports.\n");

  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@FFKFHOKE@Error?3?5Audiopath?5can?8t?5be?5used?5f@
  00049	6a 00		 push	 0
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 08	 add	 esp, 8

; 4300 :         return DMUS_E_AUDIOPATH_NOPORT;

  00053	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00058	e9 3d 05 00 00	 jmp	 $L70882
$L70888:

; 4301 :     }
; 4302 : 
; 4303 :     // Pointer to segment or song provided audio path config.
; 4304 :     IUnknown *pConfig = NULL;

  0005d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pConfig$[ebp], 0

; 4305 : 
; 4306 :     /*  If this is a song, use the segment name to get the segment.
; 4307 :         Then, it looks like a normal segment except the 
; 4308 :         existence of the pSong will let the segstate know
; 4309 :         that it is a member of a song, so it should chain segments.
; 4310 :     */
; 4311 :     if (pSong)

  00064	83 7d 0c 00	 cmp	 DWORD PTR _pSong$[ebp], 0
  00068	74 53		 je	 SHORT $L70892

; 4312 :     {
; 4313 :         IDirectMusicSegment *pISegment = NULL;

  0006a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pISegment$70893[ebp], 0

; 4314 :         hr = pSong->GetSegment(pwzSegmentName,&pISegment);

  00071	8d 4d e8	 lea	 ecx, DWORD PTR _pISegment$70893[ebp]
  00074	51		 push	 ecx
  00075	8b 55 10	 mov	 edx, DWORD PTR _pwzSegmentName$[ebp]
  00078	52		 push	 edx
  00079	8b 45 0c	 mov	 eax, DWORD PTR _pSong$[ebp]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _pSong$[ebp]
  00081	52		 push	 edx
  00082	ff 51 14	 call	 DWORD PTR [ecx+20]
  00085	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 4315 :         if (hr != S_OK)

  00088	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008c	74 0a		 je	 SHORT $L70895

; 4316 :         {
; 4317 :             return DMUS_E_NOT_FOUND;

  0008e	b8 61 11 78 88	 mov	 eax, -2005397151	; 88781161H
  00093	e9 02 05 00 00	 jmp	 $L70882
$L70895:

; 4318 :         }
; 4319 :         pSegment = (CSegment *) pISegment;

  00098	8b 45 e8	 mov	 eax, DWORD PTR _pISegment$70893[ebp]
  0009b	89 45 08	 mov	 DWORD PTR _pSegment$[ebp], eax

; 4320 :         // If the app wants an audiopath created dynamically from the song, find it and use it.
; 4321 :         if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)

  0009e	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  000a1	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  000a7	85 c9		 test	 ecx, ecx
  000a9	74 10		 je	 SHORT $L70901

; 4322 :         {
; 4323 :             pSong->GetAudioPathConfig(&pConfig);

  000ab	8d 55 f0	 lea	 edx, DWORD PTR _pConfig$[ebp]
  000ae	52		 push	 edx
  000af	8b 45 0c	 mov	 eax, DWORD PTR _pSong$[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	8b 55 0c	 mov	 edx, DWORD PTR _pSong$[ebp]
  000b7	52		 push	 edx
  000b8	ff 51 18	 call	 DWORD PTR [ecx+24]
$L70901:

; 4324 :         }
; 4325 :     }
; 4326 :     else if (pSegment)

  000bb	eb 2d		 jmp	 SHORT $L70902
$L70892:
  000bd	83 7d 08 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  000c1	74 0e		 je	 SHORT $L70903

; 4327 :     {
; 4328 :         // Addref so we can release later.
; 4329 :         pSegment->AddRef();

  000c3	8b 45 08	 mov	 eax, DWORD PTR _pSegment$[ebp]
  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	8b 55 08	 mov	 edx, DWORD PTR _pSegment$[ebp]
  000cb	52		 push	 edx
  000cc	ff 51 04	 call	 DWORD PTR [ecx+4]

; 4330 :     }
; 4331 :     else

  000cf	eb 19		 jmp	 SHORT $L70902
$L70903:

; 4332 :     {
; 4333 :         // No Segment!
; 4334 :         Trace(0,"Error: No segment - nothing to play!\n");

  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@FAPEFEL@Error?3?5No?5segment?5?9?5nothing?5to?5p@
  000d6	6a 00		 push	 0
  000d8	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000dd	83 c4 08	 add	 esp, 8

; 4335 :         return E_FAIL;

  000e0	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000e5	e9 b0 04 00 00	 jmp	 $L70882
$L70902:

; 4336 :     }
; 4337 :     if (dwFlags & DMUS_SEGF_DEFAULT ) 

  000ea	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  000ed	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  000f2	85 c0		 test	 eax, eax
  000f4	74 25		 je	 SHORT $L70907

; 4338 :     {
; 4339 :         DWORD   dwResTemp;
; 4340 :         pSegment->GetDefaultResolution( &dwResTemp );

  000f6	8d 4d e4	 lea	 ecx, DWORD PTR _dwResTemp$70908[ebp]
  000f9	51		 push	 ecx
  000fa	8b 55 08	 mov	 edx, DWORD PTR _pSegment$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  00102	51		 push	 ecx
  00103	ff 50 4c	 call	 DWORD PTR [eax+76]

; 4341 :         dwFlags &= ~DMUS_SEGF_DEFAULT;

  00106	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00109	81 e2 ff bf ff
	ff		 and	 edx, -16385		; ffffbfffH
  0010f	89 55 18	 mov	 DWORD PTR _dwFlags$[ebp], edx

; 4342 :         dwFlags |= dwResTemp;

  00112	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00115	0b 45 e4	 or	 eax, DWORD PTR _dwResTemp$70908[ebp]
  00118	89 45 18	 mov	 DWORD PTR _dwFlags$[ebp], eax
$L70907:

; 4343 :     }
; 4344 :     // If the app wants an audiopath created dynamically from the segment, find it and use it.
; 4345 :     // Note that this overrides an audiopath created from the song. 
; 4346 :     if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)

  0011b	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0011e	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  00124	85 c9		 test	 ecx, ecx
  00126	74 2c		 je	 SHORT $L70909

; 4347 :     {
; 4348 :         IUnknown *pSegConfig;
; 4349 :         if (SUCCEEDED(pSegment->GetAudioPathConfig(&pSegConfig)))

  00128	8d 55 e0	 lea	 edx, DWORD PTR _pSegConfig$70910[ebp]
  0012b	52		 push	 edx
  0012c	8b 45 08	 mov	 eax, DWORD PTR _pSegment$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	8b 55 08	 mov	 edx, DWORD PTR _pSegment$[ebp]
  00134	52		 push	 edx
  00135	ff 51 7c	 call	 DWORD PTR [ecx+124]
  00138	85 c0		 test	 eax, eax
  0013a	7c 18		 jl	 SHORT $L70909

; 4350 :         {
; 4351 :             if (pConfig)

  0013c	83 7d f0 00	 cmp	 DWORD PTR _pConfig$[ebp], 0
  00140	74 0c		 je	 SHORT $L70913

; 4352 :             {
; 4353 :                 pConfig->Release();

  00142	8b 45 f0	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	8b 55 f0	 mov	 edx, DWORD PTR _pConfig$[ebp]
  0014a	52		 push	 edx
  0014b	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70913:

; 4354 :             }
; 4355 :             pConfig = pSegConfig;

  0014e	8b 45 e0	 mov	 eax, DWORD PTR _pSegConfig$70910[ebp]
  00151	89 45 f0	 mov	 DWORD PTR _pConfig$[ebp], eax
$L70909:

; 4356 :         }
; 4357 :     }
; 4358 : 
; 4359 :     // If we got an audiopath config from the segment or song, use it.
; 4360 :     if (pConfig)

  00154	83 7d f0 00	 cmp	 DWORD PTR _pConfig$[ebp], 0
  00158	74 77		 je	 SHORT $L70914

; 4361 :     {
; 4362 :         IDirectMusicAudioPath *pNewPath;
; 4363 :         if (SUCCEEDED(CreateAudioPath(pConfig,TRUE,&pNewPath)))

  0015a	8d 4d dc	 lea	 ecx, DWORD PTR _pNewPath$70915[ebp]
  0015d	51		 push	 ecx
  0015e	6a 01		 push	 1
  00160	8b 55 f0	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00163	52		 push	 edx
  00164	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 08		 mov	 ecx, DWORD PTR [eax]
  00169	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  0016c	52		 push	 edx
  0016d	ff 51 4c	 call	 DWORD PTR [ecx+76]
  00170	85 c0		 test	 eax, eax
  00172	7c 2c		 jl	 SHORT $L70917

; 4364 :         {
; 4365 :             // Now, get the CAudioPath structure.
; 4366 :             if (SUCCEEDED(pNewPath->QueryInterface(IID_CAudioPath,(void **) &pInternalPath)))

  00174	8d 45 f8	 lea	 eax, DWORD PTR _pInternalPath$[ebp]
  00177	50		 push	 eax
  00178	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  0017d	8b 4d dc	 mov	 ecx, DWORD PTR _pNewPath$70915[ebp]
  00180	8b 11		 mov	 edx, DWORD PTR [ecx]
  00182	8b 45 dc	 mov	 eax, DWORD PTR _pNewPath$70915[ebp]
  00185	50		 push	 eax
  00186	ff 12		 call	 DWORD PTR [edx]
  00188	85 c0		 test	 eax, eax
  0018a	7c 06		 jl	 SHORT $L70920

; 4367 :             {
; 4368 :                 pAudioPath = pInternalPath;

  0018c	8b 4d f8	 mov	 ecx, DWORD PTR _pInternalPath$[ebp]
  0018f	89 4d 2c	 mov	 DWORD PTR _pAudioPath$[ebp], ecx
$L70920:

; 4369 :             }
; 4370 :             pNewPath->Release();

  00192	8b 55 dc	 mov	 edx, DWORD PTR _pNewPath$70915[ebp]
  00195	8b 02		 mov	 eax, DWORD PTR [edx]
  00197	8b 4d dc	 mov	 ecx, DWORD PTR _pNewPath$70915[ebp]
  0019a	51		 push	 ecx
  0019b	ff 50 08	 call	 DWORD PTR [eax+8]

; 4371 :         }
; 4372 :         else

  0019e	eb 25		 jmp	 SHORT $L70921
$L70917:

; 4373 :         {
; 4374 :             pConfig->Release();

  001a0	8b 55 f0	 mov	 edx, DWORD PTR _pConfig$[ebp]
  001a3	8b 02		 mov	 eax, DWORD PTR [edx]
  001a5	8b 4d f0	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  001a8	51		 push	 ecx
  001a9	ff 50 08	 call	 DWORD PTR [eax+8]

; 4375 :             Trace(0,"Error: Embedded audiopath failed to create, segment will not play.\n");

  001ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EE@JFGFJCDJ@Error?3?5Embedded?5audiopath?5failed@
  001b1	6a 00		 push	 0
  001b3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001b8	83 c4 08	 add	 esp, 8

; 4376 :             return DMUS_E_NO_AUDIOPATH;

  001bb	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  001c0	e9 d5 03 00 00	 jmp	 $L70882
$L70921:

; 4377 :         }
; 4378 :         pConfig->Release();

  001c5	8b 55 f0	 mov	 edx, DWORD PTR _pConfig$[ebp]
  001c8	8b 02		 mov	 eax, DWORD PTR [edx]
  001ca	8b 4d f0	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  001cd	51		 push	 ecx
  001ce	ff 50 08	 call	 DWORD PTR [eax+8]
$L70914:

; 4379 :     }
; 4380 :     
; 4381 :     if (pTransition)

  001d1	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  001d5	74 0c		 je	 SHORT $L70924

; 4382 :     {
; 4383 :         pTransition->AddRef();

  001d7	8b 55 14	 mov	 edx, DWORD PTR _pTransition$[ebp]
  001da	8b 02		 mov	 eax, DWORD PTR [edx]
  001dc	8b 4d 14	 mov	 ecx, DWORD PTR _pTransition$[ebp]
  001df	51		 push	 ecx
  001e0	ff 50 04	 call	 DWORD PTR [eax+4]
$L70924:

; 4384 :     }
; 4385 : 
; 4386 :     if ((dwFlags & DMUS_SEGF_SECONDARY) && (dwFlags & DMUS_SEGF_QUEUE))

  001e3	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  001e6	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  001ec	85 d2		 test	 edx, edx
  001ee	74 62		 je	 SHORT $L70925
  001f0	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  001f3	25 00 01 00 00	 and	 eax, 256		; 00000100H
  001f8	85 c0		 test	 eax, eax
  001fa	74 56		 je	 SHORT $L70925

; 4387 :     {
; 4388 :         // Can only queue if there's a segment to queue after.
; 4389 :         if (pFrom)

  001fc	83 7d 28 00	 cmp	 DWORD PTR _pFrom$[ebp], 0
  00200	74 50		 je	 SHORT $L70925

; 4390 :         {
; 4391 :             CSegState *pSegFrom = NULL;

  00202	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pSegFrom$70927[ebp], 0

; 4392 :             if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegFrom)))

  00209	8d 4d d8	 lea	 ecx, DWORD PTR _pSegFrom$70927[ebp]
  0020c	51		 push	 ecx
  0020d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegState
  00212	8b 55 28	 mov	 edx, DWORD PTR _pFrom$[ebp]
  00215	8b 02		 mov	 eax, DWORD PTR [edx]
  00217	8b 4d 28	 mov	 ecx, DWORD PTR _pFrom$[ebp]
  0021a	51		 push	 ecx
  0021b	ff 10		 call	 DWORD PTR [eax]
  0021d	85 c0		 test	 eax, eax
  0021f	7c 31		 jl	 SHORT $L70925

; 4393 :             {
; 4394 :                 // Calculate the time at which the preceding segment will stop.
; 4395 :                 MUSIC_TIME mtStartTime = pSegFrom->GetEndTime( pSegFrom->m_mtResolvedStart );

  00221	8b 55 d8	 mov	 edx, DWORD PTR _pSegFrom$70927[ebp]
  00224	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00227	50		 push	 eax
  00228	8b 4d d8	 mov	 ecx, DWORD PTR _pSegFrom$70927[ebp]
  0022b	e8 00 00 00 00	 call	 ?GetEndTime@CSegState@@QAEJJ@Z ; CSegState::GetEndTime
  00230	89 45 d4	 mov	 DWORD PTR _mtStartTime$70931[ebp], eax

; 4396 :                 i64StartTime = mtStartTime;

  00233	8b 45 d4	 mov	 eax, DWORD PTR _mtStartTime$70931[ebp]
  00236	99		 cdq
  00237	89 45 1c	 mov	 DWORD PTR _i64StartTime$[ebp], eax
  0023a	89 55 20	 mov	 DWORD PTR _i64StartTime$[ebp+4], edx

; 4397 :                 dwFlags &= ~DMUS_SEGF_REFTIME;

  0023d	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00240	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  00243	89 4d 18	 mov	 DWORD PTR _dwFlags$[ebp], ecx

; 4398 :                 pSegFrom->Release();

  00246	8b 55 d8	 mov	 edx, DWORD PTR _pSegFrom$70927[ebp]
  00249	8b 02		 mov	 eax, DWORD PTR [edx]
  0024b	8b 4d d8	 mov	 ecx, DWORD PTR _pSegFrom$70927[ebp]
  0024e	51		 push	 ecx
  0024f	ff 50 08	 call	 DWORD PTR [eax+8]
$L70925:

; 4399 :             }
; 4400 :         }
; 4401 :     }
; 4402 : 
; 4403 :     // If auto-transition is requested,
; 4404 :     // get the transition template, if it exists,
; 4405 :     // and compose a segment with it.
; 4406 :     CSegment *pPlayAfter = NULL;    // This will hold the second segment, if we end up with a transition.

  00252	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pPlayAfter$[ebp], 0

; 4407 :     DWORD dwFlagsAfter = dwFlags & (DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL);

  00259	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0025c	81 e2 80 02 00
	00		 and	 edx, 640		; 00000280H
  00262	89 55 fc	 mov	 DWORD PTR _dwFlagsAfter$[ebp], edx

; 4408 :     if ( dwFlags & DMUS_SEGF_AUTOTRANSITION )

  00265	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00268	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0026d	85 c0		 test	 eax, eax
  0026f	0f 84 5e 01 00
	00		 je	 $L70934

; 4409 :     {
; 4410 :         // First, calculate the time to start the transition.
; 4411 :         // Note: this will be done again later. We really need to fold this all together.
; 4412 :         REFERENCE_TIME rtTime;
; 4413 :         if (i64StartTime == 0)

  00275	8b 4d 1c	 mov	 ecx, DWORD PTR _i64StartTime$[ebp]
  00278	0b 4d 20	 or	 ecx, DWORD PTR _i64StartTime$[ebp+4]
  0027b	85 c9		 test	 ecx, ecx
  0027d	75 15		 jne	 SHORT $L70936

; 4414 :         {
; 4415 :             GetQueueTime( &rtTime );

  0027f	8d 55 c0	 lea	 edx, DWORD PTR _rtTime$70935[ebp]
  00282	52		 push	 edx
  00283	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00286	8b 08		 mov	 ecx, DWORD PTR [eax]
  00288	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  0028b	52		 push	 edx
  0028c	ff 91 84 00 00
	00		 call	 DWORD PTR [ecx+132]

; 4416 :         }
; 4417 :         else if (dwFlags & DMUS_SEGF_REFTIME)

  00292	eb 2c		 jmp	 SHORT $L70937
$L70936:
  00294	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00297	83 e0 40	 and	 eax, 64			; 00000040H
  0029a	85 c0		 test	 eax, eax
  0029c	74 0e		 je	 SHORT $L70938

; 4418 :         {
; 4419 :             rtTime = i64StartTime;

  0029e	8b 4d 1c	 mov	 ecx, DWORD PTR _i64StartTime$[ebp]
  002a1	89 4d c0	 mov	 DWORD PTR _rtTime$70935[ebp], ecx
  002a4	8b 55 20	 mov	 edx, DWORD PTR _i64StartTime$[ebp+4]
  002a7	89 55 c4	 mov	 DWORD PTR _rtTime$70935[ebp+4], edx

; 4420 :         }
; 4421 :         else

  002aa	eb 14		 jmp	 SHORT $L70937
$L70938:

; 4422 :         {
; 4423 :             MusicToReferenceTime((MUSIC_TIME) i64StartTime,&rtTime);

  002ac	8d 45 c0	 lea	 eax, DWORD PTR _rtTime$70935[ebp]
  002af	50		 push	 eax
  002b0	8b 4d 1c	 mov	 ecx, DWORD PTR _i64StartTime$[ebp]
  002b3	51		 push	 ecx
  002b4	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  002b7	8b 02		 mov	 eax, DWORD PTR [edx]
  002b9	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	51		 push	 ecx
  002bd	ff 50 14	 call	 DWORD PTR [eax+20]
$L70937:

; 4424 :         }
; 4425 :         REFERENCE_TIME rtResolved;
; 4426 :         GetResolvedTime(rtTime, &rtResolved,dwFlags);

  002c0	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  002c3	52		 push	 edx
  002c4	8d 45 b8	 lea	 eax, DWORD PTR _rtResolved$70941[ebp]
  002c7	50		 push	 eax
  002c8	8b 4d c4	 mov	 ecx, DWORD PTR _rtTime$70935[ebp+4]
  002cb	51		 push	 ecx
  002cc	8b 55 c0	 mov	 edx, DWORD PTR _rtTime$70935[ebp]
  002cf	52		 push	 edx
  002d0	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  002d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d5	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  002d8	52		 push	 edx
  002d9	ff 91 88 00 00
	00		 call	 DWORD PTR [ecx+136]

; 4427 :         MUSIC_TIME mtTime;  // Actual time to start transition.
; 4428 :         ReferenceToMusicTime(rtResolved,&mtTime);

  002df	8d 45 cc	 lea	 eax, DWORD PTR _mtTime$70942[ebp]
  002e2	50		 push	 eax
  002e3	8b 4d bc	 mov	 ecx, DWORD PTR _rtResolved$70941[ebp+4]
  002e6	51		 push	 ecx
  002e7	8b 55 b8	 mov	 edx, DWORD PTR _rtResolved$70941[ebp]
  002ea	52		 push	 edx
  002eb	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  002f3	52		 push	 edx
  002f4	ff 51 18	 call	 DWORD PTR [ecx+24]

; 4429 : 
; 4430 :         CSegment *pPriorSeg = NULL;

  002f7	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pPriorSeg$70943[ebp], 0

; 4431 :         // Find the segment that is active at transition time.
; 4432 :         CSegState *pPriorState = GetSegmentForTransition(dwFlags,mtTime,pFrom);

  002fe	8b 45 28	 mov	 eax, DWORD PTR _pFrom$[ebp]
  00301	50		 push	 eax
  00302	8b 4d cc	 mov	 ecx, DWORD PTR _mtTime$70942[ebp]
  00305	51		 push	 ecx
  00306	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00309	52		 push	 edx
  0030a	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  0030d	e8 00 00 00 00	 call	 ?GetSegmentForTransition@CPerformance@@AAEPAVCSegState@@KJPAUIUnknown@@@Z ; CPerformance::GetSegmentForTransition
  00312	89 45 b4	 mov	 DWORD PTR _pPriorState$70944[ebp], eax

; 4433 :         if (pPriorState)

  00315	83 7d b4 00	 cmp	 DWORD PTR _pPriorState$70944[ebp], 0
  00319	74 09		 je	 SHORT $L70945

; 4434 :         {
; 4435 :             pPriorSeg = pPriorState->m_pSegment;

  0031b	8b 45 b4	 mov	 eax, DWORD PTR _pPriorState$70944[ebp]
  0031e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00321	89 4d d0	 mov	 DWORD PTR _pPriorSeg$70943[ebp], ecx
$L70945:

; 4436 :         }
; 4437 :         // If this is a song, use the id to get the transition.
; 4438 :         if (pSong && !pTransition)

  00324	83 7d 0c 00	 cmp	 DWORD PTR _pSong$[ebp], 0
  00328	74 46		 je	 SHORT $L70946
  0032a	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  0032e	75 40		 jne	 SHORT $L70946

; 4439 :         {
; 4440 :             DMUS_IO_TRANSITION_DEF Transition;
; 4441 :             // Now, find out what sort of transition is expected.
; 4442 :             if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,pSegment,&Transition)))

  00330	8d 55 a8	 lea	 edx, DWORD PTR _Transition$70947[ebp]
  00333	52		 push	 edx
  00334	8b 45 08	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00337	50		 push	 eax
  00338	8b 4d d0	 mov	 ecx, DWORD PTR _pPriorSeg$70943[ebp]
  0033b	51		 push	 ecx
  0033c	8b 4d 0c	 mov	 ecx, DWORD PTR _pSong$[ebp]
  0033f	e8 00 00 00 00	 call	 ?GetTransitionSegment@CSong@@QAEJPAVCSegment@@0PAU_DMUS_IO_TRANSITION_DEF@@@Z ; CSong::GetTransitionSegment
  00344	85 c0		 test	 eax, eax
  00346	7c 28		 jl	 SHORT $L70946

; 4443 :             {
; 4444 :                 if (Transition.dwTransitionID != DMUS_SONG_NOSEG)

  00348	83 7d ac ff	 cmp	 DWORD PTR _Transition$70947[ebp+4], -1
  0034c	74 1c		 je	 SHORT $L70950

; 4445 :                 {
; 4446 :                     if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))

  0034e	8d 55 14	 lea	 edx, DWORD PTR _pTransition$[ebp]
  00351	52		 push	 edx
  00352	8b 45 ac	 mov	 eax, DWORD PTR _Transition$70947[ebp+4]
  00355	50		 push	 eax
  00356	8b 4d 0c	 mov	 ecx, DWORD PTR _pSong$[ebp]
  00359	e8 00 00 00 00	 call	 ?GetPlaySegment@CSong@@QAEJKPAPAVCSegment@@@Z ; CSong::GetPlaySegment
  0035e	85 c0		 test	 eax, eax
  00360	75 06		 jne	 SHORT $L70952

; 4447 :                     {
; 4448 :                         dwFlags = Transition.dwPlayFlags;

  00362	8b 4d b0	 mov	 ecx, DWORD PTR _Transition$70947[ebp+8]
  00365	89 4d 18	 mov	 DWORD PTR _dwFlags$[ebp], ecx
$L70952:

; 4449 :                     }
; 4450 :                 }
; 4451 :                 else

  00368	eb 06		 jmp	 SHORT $L70946
$L70950:

; 4452 :                 {
; 4453 :                     dwFlags = Transition.dwPlayFlags;

  0036a	8b 55 b0	 mov	 edx, DWORD PTR _Transition$70947[ebp+8]
  0036d	89 55 18	 mov	 DWORD PTR _dwFlags$[ebp], edx
$L70946:

; 4454 :                 }
; 4455 :             }
; 4456 :         }
; 4457 :         if (pTransition)

  00370	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  00374	74 5d		 je	 SHORT $L70934

; 4458 :         {
; 4459 :             IDirectMusicSegment *pITransSegment = NULL;

  00376	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pITransSegment$70955[ebp], 0

; 4460 :             if (pPriorState)

  0037d	83 7d b4 00	 cmp	 DWORD PTR _pPriorState$70944[ebp], 0
  00381	74 24		 je	 SHORT $L70956

; 4461 :             {
; 4462 :                 pTransition->Compose(mtTime - pPriorState->m_mtOffset, pPriorSeg, pSegment, &pITransSegment);

  00383	8d 45 a4	 lea	 eax, DWORD PTR _pITransSegment$70955[ebp]
  00386	50		 push	 eax
  00387	8b 4d 08	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  0038a	51		 push	 ecx
  0038b	8b 55 d0	 mov	 edx, DWORD PTR _pPriorSeg$70943[ebp]
  0038e	52		 push	 edx
  0038f	8b 45 b4	 mov	 eax, DWORD PTR _pPriorState$70944[ebp]
  00392	8b 4d cc	 mov	 ecx, DWORD PTR _mtTime$70942[ebp]
  00395	2b 48 6c	 sub	 ecx, DWORD PTR [eax+108]
  00398	51		 push	 ecx
  00399	8b 55 14	 mov	 edx, DWORD PTR _pTransition$[ebp]
  0039c	8b 02		 mov	 eax, DWORD PTR [edx]
  0039e	8b 4d 14	 mov	 ecx, DWORD PTR _pTransition$[ebp]
  003a1	51		 push	 ecx
  003a2	ff 50 10	 call	 DWORD PTR [eax+16]

; 4463 :             }
; 4464 :             else

  003a5	eb 1a		 jmp	 SHORT $L70957
$L70956:

; 4465 :             {
; 4466 :                 pTransition->Compose(0,pPriorSeg,pSegment,&pITransSegment);

  003a7	8d 55 a4	 lea	 edx, DWORD PTR _pITransSegment$70955[ebp]
  003aa	52		 push	 edx
  003ab	8b 45 08	 mov	 eax, DWORD PTR _pSegment$[ebp]
  003ae	50		 push	 eax
  003af	8b 4d d0	 mov	 ecx, DWORD PTR _pPriorSeg$70943[ebp]
  003b2	51		 push	 ecx
  003b3	6a 00		 push	 0
  003b5	8b 55 14	 mov	 edx, DWORD PTR _pTransition$[ebp]
  003b8	8b 02		 mov	 eax, DWORD PTR [edx]
  003ba	8b 4d 14	 mov	 ecx, DWORD PTR _pTransition$[ebp]
  003bd	51		 push	 ecx
  003be	ff 50 10	 call	 DWORD PTR [eax+16]
$L70957:

; 4467 :             }
; 4468 :             // Now, if we successfully composed a transition segment, set it up to be the one we
; 4469 :             // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
; 4470 :             // to play after the transition.
; 4471 :             if (pITransSegment)

  003c1	83 7d a4 00	 cmp	 DWORD PTR _pITransSegment$70955[ebp], 0
  003c5	74 0c		 je	 SHORT $L70934

; 4472 :             {
; 4473 :                 pPlayAfter = pSegment;

  003c7	8b 55 08	 mov	 edx, DWORD PTR _pSegment$[ebp]
  003ca	89 55 f4	 mov	 DWORD PTR _pPlayAfter$[ebp], edx

; 4474 :                 pSegment = (CSegment *) pITransSegment;

  003cd	8b 45 a4	 mov	 eax, DWORD PTR _pITransSegment$70955[ebp]
  003d0	89 45 08	 mov	 DWORD PTR _pSegment$[ebp], eax
$L70934:

; 4475 :             }
; 4476 :         }
; 4477 :     }
; 4478 :     if (pSegment)

  003d3	83 7d 08 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  003d7	0f 84 5c 01 00
	00		 je	 $L70960

; 4479 :     {
; 4480 :         CSegState *pSegState;
; 4481 :         if (!pAudioPath)

  003dd	83 7d 2c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  003e1	75 09		 jne	 SHORT $L70962

; 4482 :         {
; 4483 :             pAudioPath = m_pDefaultAudioPath;

  003e3	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  003e6	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  003e9	89 55 2c	 mov	 DWORD PTR _pAudioPath$[ebp], edx
$L70962:

; 4484 :         }
; 4485 :         if (pAudioPath && !pAudioPath->IsActive())

  003ec	83 7d 2c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  003f0	74 27		 je	 SHORT $L70963
  003f2	8b 4d 2c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  003f5	e8 00 00 00 00	 call	 ?IsActive@CAudioPath@@QAEHXZ ; CAudioPath::IsActive
  003fa	85 c0		 test	 eax, eax
  003fc	75 1b		 jne	 SHORT $L70963

; 4486 :         {
; 4487 :             Trace(1,"Error: Can not play segment on inactive audiopath\n");

  003fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@HKONIOHL@Error?3?5Can?5not?5play?5segment?5on?5i@
  00403	6a 01		 push	 1
  00405	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0040a	83 c4 08	 add	 esp, 8

; 4488 :             hr = DMUS_E_AUDIOPATH_INACTIVE;

  0040d	c7 45 ec 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 4489 :         }
; 4490 :         else if ((m_dwAudioPathMode != 1) && !pAudioPath)

  00414	e9 1e 01 00 00	 jmp	 $L70966
$L70963:
  00419	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  0041c	83 b8 08 01 00
	00 01		 cmp	 DWORD PTR [eax+264], 1
  00423	74 21		 je	 SHORT $L70967
  00425	83 7d 2c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  00429	75 1b		 jne	 SHORT $L70967

; 4491 :         {
; 4492 :             Trace(1,"Error: No audiopath to play segment on.\n");

  0042b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@MGJJPPFG@Error?3?5No?5audiopath?5to?5play?5segm@
  00430	6a 01		 push	 1
  00432	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00437	83 c4 08	 add	 esp, 8

; 4493 :             hr = DMUS_E_NO_AUDIOPATH;

  0043a	c7 45 ec 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 4494 :         }
; 4495 :         else

  00441	e9 f1 00 00 00	 jmp	 $L70966
$L70967:

; 4496 :         {
; 4497 :             if (ppSegmentState)

  00446	83 7d 24 00	 cmp	 DWORD PTR _ppSegmentState$[ebp], 0
  0044a	74 09		 je	 SHORT $L70971

; 4498 :             {
; 4499 :                 *ppSegmentState = NULL;

  0044c	8b 4d 24	 mov	 ecx, DWORD PTR _ppSegmentState$[ebp]
  0044f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L70971:

; 4500 :             }
; 4501 :             hr = PlayOneSegment(
; 4502 :                 pSegment, 
; 4503 :                 dwFlags, 
; 4504 :                 i64StartTime, 
; 4505 :                 &pSegState,
; 4506 :                 pAudioPath);

  00455	8b 55 2c	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  00458	52		 push	 edx
  00459	8d 45 a0	 lea	 eax, DWORD PTR _pSegState$70961[ebp]
  0045c	50		 push	 eax
  0045d	8b 4d 20	 mov	 ecx, DWORD PTR _i64StartTime$[ebp+4]
  00460	51		 push	 ecx
  00461	8b 55 1c	 mov	 edx, DWORD PTR _i64StartTime$[ebp]
  00464	52		 push	 edx
  00465	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00468	50		 push	 eax
  00469	8b 4d 08	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  0046c	51		 push	 ecx
  0046d	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00470	e8 00 00 00 00	 call	 ?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z ; CPerformance::PlayOneSegment
  00475	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 4507 :             if (SUCCEEDED(hr))

  00478	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0047c	0f 8c b5 00 00
	00		 jl	 $L70966

; 4508 :             {
; 4509 :                 if (pFrom)

  00482	83 7d 28 00	 cmp	 DWORD PTR _pFrom$[ebp], 0
  00486	74 35		 je	 SHORT $L70974

; 4510 :                 {
; 4511 :                     pSegState->m_fCanStop = FALSE;

  00488	8b 55 a0	 mov	 edx, DWORD PTR _pSegState$70961[ebp]
  0048b	c7 82 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+284], 0

; 4512 :                     StopEx(pFrom,pSegState->m_mtResolvedStart,0);

  00495	6a 00		 push	 0
  00497	8b 45 a0	 mov	 eax, DWORD PTR _pSegState$70961[ebp]
  0049a	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  0049d	99		 cdq
  0049e	52		 push	 edx
  0049f	50		 push	 eax
  004a0	8b 4d 28	 mov	 ecx, DWORD PTR _pFrom$[ebp]
  004a3	51		 push	 ecx
  004a4	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  004a7	8b 02		 mov	 eax, DWORD PTR [edx]
  004a9	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  004ac	51		 push	 ecx
  004ad	ff 50 44	 call	 DWORD PTR [eax+68]

; 4513 :                     pSegState->m_fCanStop = TRUE;

  004b0	8b 55 a0	 mov	 edx, DWORD PTR _pSegState$70961[ebp]
  004b3	c7 82 1c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+284], 1
$L70974:

; 4514 :                 }
; 4515 :                 // If this was actually a transition segment, now we need to play the original segment!
; 4516 :                 if (pPlayAfter)

  004bd	83 7d f4 00	 cmp	 DWORD PTR _pPlayAfter$[ebp], 0
  004c1	74 3f		 je	 SHORT $L70975

; 4517 :                 {
; 4518 :                     MUSIC_TIME mtStartTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart );

  004c3	8b 45 a0	 mov	 eax, DWORD PTR _pSegState$70961[ebp]
  004c6	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  004c9	51		 push	 ecx
  004ca	8b 4d a0	 mov	 ecx, DWORD PTR _pSegState$70961[ebp]
  004cd	e8 00 00 00 00	 call	 ?GetEndTime@CSegState@@QAEJJ@Z ; CSegState::GetEndTime
  004d2	89 45 9c	 mov	 DWORD PTR _mtStartTime$70976[ebp], eax

; 4519 :                     pSegState->Release();

  004d5	8b 55 a0	 mov	 edx, DWORD PTR _pSegState$70961[ebp]
  004d8	8b 02		 mov	 eax, DWORD PTR [edx]
  004da	8b 4d a0	 mov	 ecx, DWORD PTR _pSegState$70961[ebp]
  004dd	51		 push	 ecx
  004de	ff 50 08	 call	 DWORD PTR [eax+8]

; 4520 :                     hr = PlayOneSegment(pPlayAfter,dwFlagsAfter,mtStartTime,&pSegState,pAudioPath);

  004e1	8b 55 2c	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  004e4	52		 push	 edx
  004e5	8d 45 a0	 lea	 eax, DWORD PTR _pSegState$70961[ebp]
  004e8	50		 push	 eax
  004e9	8b 45 9c	 mov	 eax, DWORD PTR _mtStartTime$70976[ebp]
  004ec	99		 cdq
  004ed	52		 push	 edx
  004ee	50		 push	 eax
  004ef	8b 4d fc	 mov	 ecx, DWORD PTR _dwFlagsAfter$[ebp]
  004f2	51		 push	 ecx
  004f3	8b 55 f4	 mov	 edx, DWORD PTR _pPlayAfter$[ebp]
  004f6	52		 push	 edx
  004f7	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  004fa	e8 00 00 00 00	 call	 ?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z ; CPerformance::PlayOneSegment
  004ff	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax
$L70975:

; 4521 :                 }
; 4522 :                 if (SUCCEEDED(hr))

  00502	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00506	7c 2f		 jl	 SHORT $L70966

; 4523 :                 {
; 4524 :                     if (pSong)

  00508	83 7d 0c 00	 cmp	 DWORD PTR _pSong$[ebp], 0
  0050c	74 0d		 je	 SHORT $L70979

; 4525 :                     {
; 4526 :                         pSegState->m_fSongMode = TRUE;

  0050e	8b 45 a0	 mov	 eax, DWORD PTR _pSegState$70961[ebp]
  00511	c7 80 18 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+280], 1
$L70979:

; 4527 :                     }
; 4528 :                     if (ppSegmentState)

  0051b	83 7d 24 00	 cmp	 DWORD PTR _ppSegmentState$[ebp], 0
  0051f	74 0a		 je	 SHORT $L70980

; 4529 :                     {
; 4530 :                         *ppSegmentState = pSegState;

  00521	8b 4d 24	 mov	 ecx, DWORD PTR _ppSegmentState$[ebp]
  00524	8b 55 a0	 mov	 edx, DWORD PTR _pSegState$70961[ebp]
  00527	89 11		 mov	 DWORD PTR [ecx], edx

; 4531 :                     }
; 4532 :                     else

  00529	eb 0c		 jmp	 SHORT $L70966
$L70980:

; 4533 :                     {
; 4534 :                         pSegState->Release();

  0052b	8b 45 a0	 mov	 eax, DWORD PTR _pSegState$70961[ebp]
  0052e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00530	8b 55 a0	 mov	 edx, DWORD PTR _pSegState$70961[ebp]
  00533	52		 push	 edx
  00534	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70966:

; 4535 :                     }
; 4536 :                 }
; 4537 :             }   
; 4538 :         }
; 4539 :     }
; 4540 :     else

  00537	eb 16		 jmp	 SHORT $L70982
$L70960:

; 4541 :     {
; 4542 :         // There never was a segment to play, not even a transition. 
; 4543 :         Trace(1,"Error: No segment to play.\n");

  00539	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@DACIMFKH@Error?3?5No?5segment?5to?5play?4?6?$AA@
  0053e	6a 01		 push	 1
  00540	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00545	83 c4 08	 add	 esp, 8

; 4544 :         hr = E_INVALIDARG;

  00548	c7 45 ec 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L70982:

; 4545 :     }
; 4546 :     // Before leaving, reduce the reference counts on variables that have been addref'd.
; 4547 :     if (pSegment)

  0054f	83 7d 08 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  00553	74 0c		 je	 SHORT $L70985

; 4548 :     {
; 4549 :         pSegment->Release();

  00555	8b 45 08	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00558	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055a	8b 55 08	 mov	 edx, DWORD PTR _pSegment$[ebp]
  0055d	52		 push	 edx
  0055e	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70985:

; 4550 :     }
; 4551 :     if (pTransition)

  00561	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  00565	74 0c		 je	 SHORT $L70986

; 4552 :     {
; 4553 :         pTransition->Release();

  00567	8b 45 14	 mov	 eax, DWORD PTR _pTransition$[ebp]
  0056a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0056c	8b 55 14	 mov	 edx, DWORD PTR _pTransition$[ebp]
  0056f	52		 push	 edx
  00570	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70986:

; 4554 :     }
; 4555 :     if (pPlayAfter)

  00573	83 7d f4 00	 cmp	 DWORD PTR _pPlayAfter$[ebp], 0
  00577	74 0c		 je	 SHORT $L70987

; 4556 :     {
; 4557 :         pPlayAfter->Release();

  00579	8b 45 f4	 mov	 eax, DWORD PTR _pPlayAfter$[ebp]
  0057c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0057e	8b 55 f4	 mov	 edx, DWORD PTR _pPlayAfter$[ebp]
  00581	52		 push	 edx
  00582	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70987:

; 4558 :     }
; 4559 :     if (pInternalPath)

  00585	83 7d f8 00	 cmp	 DWORD PTR _pInternalPath$[ebp], 0
  00589	74 0c		 je	 SHORT $L70988

; 4560 :     {
; 4561 :         pInternalPath->Release();

  0058b	8b 45 f8	 mov	 eax, DWORD PTR _pInternalPath$[ebp]
  0058e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00590	8b 55 f8	 mov	 edx, DWORD PTR _pInternalPath$[ebp]
  00593	52		 push	 edx
  00594	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70988:

; 4562 :     }
; 4563 :     return hr;

  00597	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
$L70882:

; 4564 : }

  0059a	8b e5		 mov	 esp, ebp
  0059c	5d		 pop	 ebp
  0059d	c2 28 00	 ret	 40			; 00000028H
?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z ENDP ; CPerformance::PlaySegmentInternal
_TEXT	ENDS
PUBLIC	??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@ ; `string'
PUBLIC	??_C@_0HH@NOBOKFIC@Error?3?5Invalid?5segment?5object?5pa@ ; `string'
EXTRN	_IsBadCodePtr@4:NEAR
EXTRN	_IID_CSegment:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::PlaySegment', 00H	; `CPerformance::PlaySegment'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
CONST	SEGMENT
??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pSegment', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@
CONST	SEGMENT
??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@ DB '%s: Inval'
	DB	'id pointer ppSegmentState', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@NOBOKFIC@Error?3?5Invalid?5segment?5object?5pa@
CONST	SEGMENT
??_C@_0HH@NOBOKFIC@Error?3?5Invalid?5segment?5object?5pa@ DB 'Error: Inva'
	DB	'lid segment object passed to PlaySegment(). Segment must be c'
	DB	'reated using CLSID_DirectMusicSegment object.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z
_TEXT	SEGMENT
_pCSourceSegment$ = -4
_this$ = 8
_pSegment$ = 12
_dwFlags$ = 16
_i64StartTime$ = 20
_ppSegmentState$ = 28
?PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z PROC NEAR ; CPerformance::PlaySegment, COMDAT

; 4571 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4572 :     V_INAME(IDirectMusicPerformance::PlaySegment);
; 4573 :     V_INTERFACE(pSegment);

  00004	6a 04		 push	 4
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L70999
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70999:
  0002c	6a 04		 push	 4
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L71003
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L71003:
  00056	8b 45 0c	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00063	85 c0		 test	 eax, eax
  00065	74 19		 je	 SHORT $L71005
  00067	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
  00071	6a ff		 push	 -1
  00073	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	e8 00 00 00 00	 call	 _DebugBreak@0
$L71005:

; 4574 :     V_PTRPTR_WRITE_OPT(ppSegmentState);

  00080	83 7d 1c 00	 cmp	 DWORD PTR _ppSegmentState$[ebp], 0
  00084	74 28		 je	 SHORT $L71006
  00086	6a 04		 push	 4
  00088	8b 45 1c	 mov	 eax, DWORD PTR _ppSegmentState$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00091	85 c0		 test	 eax, eax
  00093	74 19		 je	 SHORT $L71006
  00095	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z@4QBDB
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@
  0009f	6a ff		 push	 -1
  000a1	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	e8 00 00 00 00	 call	 _DebugBreak@0
$L71006:

; 4575 :     CSegment *pCSourceSegment = NULL;

  000ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pCSourceSegment$[ebp], 0

; 4576 :     if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))

  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _pCSourceSegment$[ebp]
  000b8	51		 push	 ecx
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegment
  000be	8b 55 0c	 mov	 edx, DWORD PTR _pSegment$[ebp]
  000c1	8b 02		 mov	 eax, DWORD PTR [edx]
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  000c6	51		 push	 ecx
  000c7	ff 10		 call	 DWORD PTR [eax]
  000c9	85 c0		 test	 eax, eax
  000cb	7c 0e		 jl	 SHORT $L71013

; 4577 :     {
; 4578 :         pCSourceSegment->Release();

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _pCSourceSegment$[ebp]
  000d0	8b 02		 mov	 eax, DWORD PTR [edx]
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _pCSourceSegment$[ebp]
  000d5	51		 push	 ecx
  000d6	ff 50 08	 call	 DWORD PTR [eax+8]

; 4579 :     }
; 4580 :     else

  000d9	eb 16		 jmp	 SHORT $L71014
$L71013:

; 4581 :     {
; 4582 :         Trace(0,"Error: Invalid segment object passed to PlaySegment(). Segment must be created using CLSID_DirectMusicSegment object.\n"); 

  000db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0HH@NOBOKFIC@Error?3?5Invalid?5segment?5object?5pa@
  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000e7	83 c4 08	 add	 esp, 8

; 4583 :         return E_POINTER;

  000ea	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  000ef	eb 26		 jmp	 SHORT $L70995
$L71014:

; 4584 :     }
; 4585 :     return PlaySegmentInternal(pCSourceSegment,NULL,0,NULL,dwFlags,i64StartTime,ppSegmentState,NULL,NULL);

  000f1	6a 00		 push	 0
  000f3	6a 00		 push	 0
  000f5	8b 55 1c	 mov	 edx, DWORD PTR _ppSegmentState$[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 18	 mov	 eax, DWORD PTR _i64StartTime$[ebp+4]
  000fc	50		 push	 eax
  000fd	8b 4d 14	 mov	 ecx, DWORD PTR _i64StartTime$[ebp]
  00100	51		 push	 ecx
  00101	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00104	52		 push	 edx
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	8b 45 fc	 mov	 eax, DWORD PTR _pCSourceSegment$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z ; CPerformance::PlaySegmentInternal
$L70995:

; 4586 : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 18 00	 ret	 24			; 00000018H
?PlaySegment@CPerformance@@UAGJPAUIDirectMusicSegment@@K_JPAPAUIDirectMusicSegmentState@@@Z ENDP ; CPerformance::PlaySegment
_TEXT	ENDS
PUBLIC	??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@ ; `string'
PUBLIC	??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@ ; `string'
PUBLIC	??_C@_0EM@JNGHOFGH@Error?3?5Must?5pass?5either?5a?5segmen@ ; `string'
PUBLIC	??_C@_0DL@OFGFJIEM@Error?3?5Invalid?5segment?5or?5song?5p@ ; `string'
PUBLIC	??_C@_0DG@EGKKGOCA@Error?3?5Invalid?5transition?5passed@ ; `string'
PUBLIC	??_C@_0DF@HJGGCODG@Error?3?5Invalid?5audiopath?5passed?5@ ; `string'
EXTRN	_mbstowcs:NEAR
EXTRN	_IID_CSong:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::PlaySegmentEx', 00H	; `CPerformance::PlaySegmentEx'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@
CONST	SEGMENT
??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@ DB '%s: Inva'
	DB	'lid pointer pSource', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@
CONST	SEGMENT
??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@ DB '%s: Inva'
	DB	'lid pointer pTransition', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@
CONST	SEGMENT
??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@ DB '%s: Invali'
	DB	'd pointer pFrom', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
CONST	SEGMENT
??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pAudioPath', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JNGHOFGH@Error?3?5Must?5pass?5either?5a?5segmen@
CONST	SEGMENT
??_C@_0EM@JNGHOFGH@Error?3?5Must?5pass?5either?5a?5segmen@ DB 'Error: Mus'
	DB	't pass either a segment or transition segment to PlaySegmentE'
	DB	'x()', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OFGFJIEM@Error?3?5Invalid?5segment?5or?5song?5p@
CONST	SEGMENT
??_C@_0DL@OFGFJIEM@Error?3?5Invalid?5segment?5or?5song?5p@ DB 'Error: Inv'
	DB	'alid segment or song passed to PlaySegmentEx().', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EGKKGOCA@Error?3?5Invalid?5transition?5passed@
CONST	SEGMENT
??_C@_0DG@EGKKGOCA@Error?3?5Invalid?5transition?5passed@ DB 'Error: Inval'
	DB	'id transition passed to PlaySegmentEx().', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HJGGCODG@Error?3?5Invalid?5audiopath?5passed?5@
CONST	SEGMENT
??_C@_0DF@HJGGCODG@Error?3?5Invalid?5audiopath?5passed?5@ DB 'Error: Inva'
	DB	'lid audiopath passed to PlaySegmentEx().', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z
_TEXT	SEGMENT
_hr$ = -64
_pCAudioPath$ = -60
_pCTransition$ = -56
_wzSegmentName$ = -52
_pCSourceSegment$ = -12
_pwzSegmentName$ = -8
_pCSourceSong$ = -4
_this$ = 8
_pSource$ = 12
_pszSegmentName$ = 16
_pTransition$ = 20
_dwFlags$ = 24
_i64StartTime$ = 28
_ppSegmentState$ = 36
_pFrom$ = 40
_pAudioPath$ = 44
?PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z PROC NEAR ; CPerformance::PlaySegmentEx, COMDAT

; 4601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 4602 :     V_INAME(IDirectMusicPerformance::PlaySegmentEx);
; 4603 :     V_INTERFACE_OPT(pSource);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  0000a	74 7c		 je	 SHORT $L71030
  0000c	6a 04		 push	 4
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L71032
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L71032:
  00034	6a 04		 push	 4
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $L71036
  00045	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@
  0004f	6a ff		 push	 -1
  00051	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 _DebugBreak@0
$L71036:
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0006b	85 c0		 test	 eax, eax
  0006d	74 19		 je	 SHORT $L71030
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NMKDEHGA@?$CFs?3?5Invalid?5pointer?5pSource?6?$AA@
  00079	6a ff		 push	 -1
  0007b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	e8 00 00 00 00	 call	 _DebugBreak@0
$L71030:

; 4604 :     V_INTERFACE_OPT(pTransition);

  00088	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  0008c	74 7c		 je	 SHORT $L71039
  0008e	6a 04		 push	 4
  00090	8b 45 14	 mov	 eax, DWORD PTR _pTransition$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00099	85 c0		 test	 eax, eax
  0009b	74 19		 je	 SHORT $L71041
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@
  000a7	6a ff		 push	 -1
  000a9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	e8 00 00 00 00	 call	 _DebugBreak@0
$L71041:
  000b6	6a 04		 push	 4
  000b8	8b 4d 14	 mov	 ecx, DWORD PTR _pTransition$[ebp]
  000bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000c3	85 c0		 test	 eax, eax
  000c5	74 19		 je	 SHORT $L71045
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@
  000d1	6a ff		 push	 -1
  000d3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	e8 00 00 00 00	 call	 _DebugBreak@0
$L71045:
  000e0	8b 45 14	 mov	 eax, DWORD PTR _pTransition$[ebp]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  000ed	85 c0		 test	 eax, eax
  000ef	74 19		 je	 SHORT $L71039
  000f1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@PEAFCGAA@?$CFs?3?5Invalid?5pointer?5pTransition?6@
  000fb	6a ff		 push	 -1
  000fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	e8 00 00 00 00	 call	 _DebugBreak@0
$L71039:

; 4605 :     V_PTRPTR_WRITE_OPT(ppSegmentState);

  0010a	83 7d 24 00	 cmp	 DWORD PTR _ppSegmentState$[ebp], 0
  0010e	74 28		 je	 SHORT $L71048
  00110	6a 04		 push	 4
  00112	8b 45 24	 mov	 eax, DWORD PTR _ppSegmentState$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0011b	85 c0		 test	 eax, eax
  0011d	74 19		 je	 SHORT $L71048
  0011f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  00124	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@
  00129	6a ff		 push	 -1
  0012b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	e8 00 00 00 00	 call	 _DebugBreak@0
$L71048:

; 4606 :     V_INTERFACE_OPT(pFrom);

  00138	83 7d 28 00	 cmp	 DWORD PTR _pFrom$[ebp], 0
  0013c	74 7c		 je	 SHORT $L71051
  0013e	6a 04		 push	 4
  00140	8b 4d 28	 mov	 ecx, DWORD PTR _pFrom$[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00149	85 c0		 test	 eax, eax
  0014b	74 19		 je	 SHORT $L71053
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  00152	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@
  00157	6a ff		 push	 -1
  00159	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0015e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00161	e8 00 00 00 00	 call	 _DebugBreak@0
$L71053:
  00166	6a 04		 push	 4
  00168	8b 55 28	 mov	 edx, DWORD PTR _pFrom$[ebp]
  0016b	8b 02		 mov	 eax, DWORD PTR [edx]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00173	85 c0		 test	 eax, eax
  00175	74 19		 je	 SHORT $L71057
  00177	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  0017c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@
  00181	6a ff		 push	 -1
  00183	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018b	e8 00 00 00 00	 call	 _DebugBreak@0
$L71057:
  00190	8b 4d 28	 mov	 ecx, DWORD PTR _pFrom$[ebp]
  00193	8b 11		 mov	 edx, DWORD PTR [ecx]
  00195	8b 02		 mov	 eax, DWORD PTR [edx]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0019d	85 c0		 test	 eax, eax
  0019f	74 19		 je	 SHORT $L71051
  001a1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@EKFOGEFM@?$CFs?3?5Invalid?5pointer?5pFrom?6?$AA@
  001ab	6a ff		 push	 -1
  001ad	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	e8 00 00 00 00	 call	 _DebugBreak@0
$L71051:

; 4607 :     V_INTERFACE_OPT(pAudioPath);

  001ba	83 7d 2c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  001be	74 7c		 je	 SHORT $L71060
  001c0	6a 04		 push	 4
  001c2	8b 4d 2c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  001cb	85 c0		 test	 eax, eax
  001cd	74 19		 je	 SHORT $L71062
  001cf	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  001d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  001d9	6a ff		 push	 -1
  001db	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e3	e8 00 00 00 00	 call	 _DebugBreak@0
$L71062:
  001e8	6a 04		 push	 4
  001ea	8b 55 2c	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  001ed	8b 02		 mov	 eax, DWORD PTR [edx]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  001f5	85 c0		 test	 eax, eax
  001f7	74 19		 je	 SHORT $L71066
  001f9	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  001fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00203	6a ff		 push	 -1
  00205	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020d	e8 00 00 00 00	 call	 _DebugBreak@0
$L71066:
  00212	8b 4d 2c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00215	8b 11		 mov	 edx, DWORD PTR [ecx]
  00217	8b 02		 mov	 eax, DWORD PTR [edx]
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0021f	85 c0		 test	 eax, eax
  00221	74 19		 je	 SHORT $L71060
  00223	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z@4QBDB
  00228	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  0022d	6a ff		 push	 -1
  0022f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00234	83 c4 0c	 add	 esp, 12			; 0000000cH
  00237	e8 00 00 00 00	 call	 _DebugBreak@0
$L71060:

; 4608 : 
; 4609 : #ifdef XBOX
; 4610 :     WCHAR *pwzSegmentName;
; 4611 : 	WCHAR wzSegmentName[20];
; 4612 :     if (pszSegmentName)

  0023c	83 7d 10 00	 cmp	 DWORD PTR _pszSegmentName$[ebp], 0
  00240	74 1a		 je	 SHORT $L71071

; 4613 : 	{
; 4614 : 		mbstowcs( wzSegmentName, pszSegmentName, 20 );

  00242	6a 14		 push	 20			; 00000014H
  00244	8b 4d 10	 mov	 ecx, DWORD PTR _pszSegmentName$[ebp]
  00247	51		 push	 ecx
  00248	8d 55 cc	 lea	 edx, DWORD PTR _wzSegmentName$[ebp]
  0024b	52		 push	 edx
  0024c	e8 00 00 00 00	 call	 _mbstowcs
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4615 : 		pwzSegmentName = wzSegmentName;

  00254	8d 45 cc	 lea	 eax, DWORD PTR _wzSegmentName$[ebp]
  00257	89 45 f8	 mov	 DWORD PTR _pwzSegmentName$[ebp], eax

; 4616 : 	}
; 4617 : 	else pwzSegmentName = NULL;

  0025a	eb 07		 jmp	 SHORT $L71072
$L71071:
  0025c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pwzSegmentName$[ebp], 0
$L71072:

; 4618 : #endif
; 4619 : 
; 4620 :     CSegment *pCSourceSegment = NULL;

  00263	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pCSourceSegment$[ebp], 0

; 4621 :     CSong *pCSourceSong = NULL;

  0026a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pCSourceSong$[ebp], 0

; 4622 :     CSegment *pCTransition = NULL;

  00271	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _pCTransition$[ebp], 0

; 4623 :     CAudioPath *pCAudioPath = NULL;

  00278	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _pCAudioPath$[ebp], 0

; 4624 : //    TraceI(0,"Playing %lx at time %ld, flags %lx, Transition %lx\n",pSource,(long)i64StartTime,dwFlags,pTransition);
; 4625 : 
; 4626 :     // We may not have a source segment in the special case of transitioning from NULL.
; 4627 :     if (!pSource && !pTransition)

  0027f	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00283	75 1f		 jne	 SHORT $L71077
  00285	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  00289	75 19		 jne	 SHORT $L71077

; 4628 :     {
; 4629 :         Trace(0,"Error: Must pass either a segment or transition segment to PlaySegmentEx()\n"); 

  0028b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@JNGHOFGH@Error?3?5Must?5pass?5either?5a?5segmen@
  00290	6a 00		 push	 0
  00292	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00297	83 c4 08	 add	 esp, 8

; 4630 :         return E_POINTER;

  0029a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0029f	e9 25 01 00 00	 jmp	 $L71027
$L71077:

; 4631 :     }
; 4632 :     if (pSource)

  002a4	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  002a8	74 65		 je	 SHORT $L71080

; 4633 :     {
; 4634 :         // Figure out if we have a source song or segment and get the internal representations.
; 4635 :         if (SUCCEEDED(pSource->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))

  002aa	8d 4d f4	 lea	 ecx, DWORD PTR _pCSourceSegment$[ebp]
  002ad	51		 push	 ecx
  002ae	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegment
  002b3	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  002b6	8b 02		 mov	 eax, DWORD PTR [edx]
  002b8	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  002bb	51		 push	 ecx
  002bc	ff 10		 call	 DWORD PTR [eax]
  002be	85 c0		 test	 eax, eax
  002c0	7c 0e		 jl	 SHORT $L71083

; 4636 :         {
; 4637 :             pCSourceSegment->Release();

  002c2	8b 55 f4	 mov	 edx, DWORD PTR _pCSourceSegment$[ebp]
  002c5	8b 02		 mov	 eax, DWORD PTR [edx]
  002c7	8b 4d f4	 mov	 ecx, DWORD PTR _pCSourceSegment$[ebp]
  002ca	51		 push	 ecx
  002cb	ff 50 08	 call	 DWORD PTR [eax+8]

; 4638 :         }
; 4639 :         else if (SUCCEEDED(pSource->QueryInterface(IID_CSong,(void **) &pCSourceSong)))

  002ce	eb 3f		 jmp	 SHORT $L71080
$L71083:
  002d0	8d 55 fc	 lea	 edx, DWORD PTR _pCSourceSong$[ebp]
  002d3	52		 push	 edx
  002d4	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSong
  002d9	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  002dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002de	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  002e1	52		 push	 edx
  002e2	ff 11		 call	 DWORD PTR [ecx]
  002e4	85 c0		 test	 eax, eax
  002e6	7c 0e		 jl	 SHORT $L71087

; 4640 :         {
; 4641 :             pCSourceSong->Release();

  002e8	8b 45 fc	 mov	 eax, DWORD PTR _pCSourceSong$[ebp]
  002eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ed	8b 55 fc	 mov	 edx, DWORD PTR _pCSourceSong$[ebp]
  002f0	52		 push	 edx
  002f1	ff 51 08	 call	 DWORD PTR [ecx+8]

; 4642 :         }
; 4643 :         else

  002f4	eb 19		 jmp	 SHORT $L71080
$L71087:

; 4644 :         {
; 4645 :             Trace(0,"Error: Invalid segment or song passed to PlaySegmentEx().\n"); 

  002f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@OFGFJIEM@Error?3?5Invalid?5segment?5or?5song?5p@
  002fb	6a 00		 push	 0
  002fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00302	83 c4 08	 add	 esp, 8

; 4646 :             return E_POINTER;

  00305	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0030a	e9 ba 00 00 00	 jmp	 $L71027
$L71080:

; 4647 :         }
; 4648 :     }
; 4649 :     // If we have a transition segment, get the CSegment representation.
; 4650 :     if (pTransition)

  0030f	83 7d 14 00	 cmp	 DWORD PTR _pTransition$[ebp], 0
  00313	74 3c		 je	 SHORT $L71091

; 4651 :     {
; 4652 :         if (SUCCEEDED(pTransition->QueryInterface(IID_CSegment,(void **) &pCTransition)))

  00315	8d 45 c8	 lea	 eax, DWORD PTR _pCTransition$[ebp]
  00318	50		 push	 eax
  00319	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegment
  0031e	8b 4d 14	 mov	 ecx, DWORD PTR _pTransition$[ebp]
  00321	8b 11		 mov	 edx, DWORD PTR [ecx]
  00323	8b 45 14	 mov	 eax, DWORD PTR _pTransition$[ebp]
  00326	50		 push	 eax
  00327	ff 12		 call	 DWORD PTR [edx]
  00329	85 c0		 test	 eax, eax
  0032b	7c 0e		 jl	 SHORT $L71094

; 4653 :         {
; 4654 :             pCTransition->Release();

  0032d	8b 4d c8	 mov	 ecx, DWORD PTR _pCTransition$[ebp]
  00330	8b 11		 mov	 edx, DWORD PTR [ecx]
  00332	8b 45 c8	 mov	 eax, DWORD PTR _pCTransition$[ebp]
  00335	50		 push	 eax
  00336	ff 52 08	 call	 DWORD PTR [edx+8]

; 4655 :         }
; 4656 :         else

  00339	eb 16		 jmp	 SHORT $L71091
$L71094:

; 4657 :         {
; 4658 :             Trace(0,"Error: Invalid transition passed to PlaySegmentEx().\n"); 

  0033b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@EGKKGOCA@Error?3?5Invalid?5transition?5passed@
  00340	6a 00		 push	 0
  00342	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00347	83 c4 08	 add	 esp, 8

; 4659 :             return E_POINTER;

  0034a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0034f	eb 78		 jmp	 SHORT $L71027
$L71091:

; 4660 :         }
; 4661 :     }
; 4662 :     if (pAudioPath)

  00351	83 7d 2c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  00355	74 3c		 je	 SHORT $L71098

; 4663 :     {
; 4664 :         if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCAudioPath)))

  00357	8d 4d c4	 lea	 ecx, DWORD PTR _pCAudioPath$[ebp]
  0035a	51		 push	 ecx
  0035b	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  00360	8b 55 2c	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  00363	8b 02		 mov	 eax, DWORD PTR [edx]
  00365	8b 4d 2c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00368	51		 push	 ecx
  00369	ff 10		 call	 DWORD PTR [eax]
  0036b	85 c0		 test	 eax, eax
  0036d	7c 0e		 jl	 SHORT $L71101

; 4665 :         {
; 4666 :             pCAudioPath->Release();

  0036f	8b 55 c4	 mov	 edx, DWORD PTR _pCAudioPath$[ebp]
  00372	8b 02		 mov	 eax, DWORD PTR [edx]
  00374	8b 4d c4	 mov	 ecx, DWORD PTR _pCAudioPath$[ebp]
  00377	51		 push	 ecx
  00378	ff 50 08	 call	 DWORD PTR [eax+8]

; 4667 :         }
; 4668 :         else

  0037b	eb 16		 jmp	 SHORT $L71098
$L71101:

; 4669 :         {
; 4670 :             Trace(0,"Error: Invalid audiopath passed to PlaySegmentEx().\n"); 

  0037d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@HJGGCODG@Error?3?5Invalid?5audiopath?5passed?5@
  00382	6a 00		 push	 0
  00384	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00389	83 c4 08	 add	 esp, 8

; 4671 :             return E_POINTER;

  0038c	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00391	eb 36		 jmp	 SHORT $L71027
$L71098:

; 4672 :         }
; 4673 :     }
; 4674 :     ENTER_API_CRITICAL_SECTION;
; 4675 :     HRESULT hr = PlaySegmentInternal(pCSourceSegment,pCSourceSong,pwzSegmentName,
; 4676 :         pCTransition,dwFlags,i64StartTime,
; 4677 :         ppSegmentState,pFrom,
; 4678 :         pCAudioPath);

  00393	8b 55 c4	 mov	 edx, DWORD PTR _pCAudioPath$[ebp]
  00396	52		 push	 edx
  00397	8b 45 28	 mov	 eax, DWORD PTR _pFrom$[ebp]
  0039a	50		 push	 eax
  0039b	8b 4d 24	 mov	 ecx, DWORD PTR _ppSegmentState$[ebp]
  0039e	51		 push	 ecx
  0039f	8b 55 20	 mov	 edx, DWORD PTR _i64StartTime$[ebp+4]
  003a2	52		 push	 edx
  003a3	8b 45 1c	 mov	 eax, DWORD PTR _i64StartTime$[ebp]
  003a6	50		 push	 eax
  003a7	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  003aa	51		 push	 ecx
  003ab	8b 55 c8	 mov	 edx, DWORD PTR _pCTransition$[ebp]
  003ae	52		 push	 edx
  003af	8b 45 f8	 mov	 eax, DWORD PTR _pwzSegmentName$[ebp]
  003b2	50		 push	 eax
  003b3	8b 4d fc	 mov	 ecx, DWORD PTR _pCSourceSong$[ebp]
  003b6	51		 push	 ecx
  003b7	8b 55 f4	 mov	 edx, DWORD PTR _pCSourceSegment$[ebp]
  003ba	52		 push	 edx
  003bb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003be	e8 00 00 00 00	 call	 ?PlaySegmentInternal@CPerformance@@AAEJPAVCSegment@@PAVCSong@@PAG0K_JPAPAUIDirectMusicSegmentState@@PAUIUnknown@@PAVCAudioPath@@@Z ; CPerformance::PlaySegmentInternal
  003c3	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax

; 4679 :     LEAVE_API_CRITICAL_SECTION;
; 4680 :     return hr;

  003c6	8b 45 c0	 mov	 eax, DWORD PTR _hr$[ebp]
$L71027:

; 4681 : 
; 4682 : }

  003c9	8b e5		 mov	 esp, ebp
  003cb	5d		 pop	 ebp
  003cc	c2 28 00	 ret	 40			; 00000028H
?PlaySegmentEx@CPerformance@@UAGJPAUIUnknown@@PBD0K_JPAPAUIDirectMusicSegmentState@@00@Z ENDP ; CPerformance::PlaySegmentEx
_TEXT	ENDS
PUBLIC	?IsMember@CAudioPathList@@QAEHPAVCAudioPath@@@Z	; CAudioPathList::IsMember
PUBLIC	??_C@_0DN@NCCCEEPA@Error?3?5Invalid?5audiopath?5?9?5not?5c@ ; `string'
PUBLIC	??_C@_0FO@KKMIOIMC@Error?3?5Failure?5setting?5default?5a@ ; `string'
PUBLIC	??_C@_0FD@ICBNMMBJ@Error?3?5Invalid?5audiopath?5?9?5not?5c@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::SetDefaultAudioPath', 00H ; `CPerformance::SetDefaultAudioPath'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0DN@NCCCEEPA@Error?3?5Invalid?5audiopath?5?9?5not?5c@
CONST	SEGMENT
??_C@_0DN@NCCCEEPA@Error?3?5Invalid?5audiopath?5?9?5not?5c@ DB 'Error: In'
	DB	'valid audiopath - not created by this Performance.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@KKMIOIMC@Error?3?5Failure?5setting?5default?5a@
CONST	SEGMENT
??_C@_0FO@KKMIOIMC@Error?3?5Failure?5setting?5default?5a@ DB 'Error: Fail'
	DB	'ure setting default audiopath - does not have any ports, so c'
	DB	'an not be played on.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@ICBNMMBJ@Error?3?5Invalid?5audiopath?5?9?5not?5c@
CONST	SEGMENT
??_C@_0FD@ICBNMMBJ@Error?3?5Invalid?5audiopath?5?9?5not?5c@ DB 'Error: In'
	DB	'valid audiopath - not created by call to Performance->CreateA'
	DB	'udioPath().', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT
_pCPath$ = -4
_this$ = 8
_pAudioPath$ = 12
?SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z PROC NEAR ; CPerformance::SetDefaultAudioPath, COMDAT

; 4685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4686 :     V_INAME(IDirectMusicPerformance::SetDefaultAudioPath);
; 4687 :     V_INTERFACE_OPT(pAudioPath);

  00004	83 7d 0c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  00008	74 7c		 je	 SHORT $L71112
  0000a	6a 04		 push	 4
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00015	85 c0		 test	 eax, eax
  00017	74 19		 je	 SHORT $L71114
  00019	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z@4QBDB
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00023	6a ff		 push	 -1
  00025	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	e8 00 00 00 00	 call	 _DebugBreak@0
$L71114:
  00032	6a 04		 push	 4
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00037	8b 11		 mov	 edx, DWORD PTR [ecx]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003f	85 c0		 test	 eax, eax
  00041	74 19		 je	 SHORT $L71117
  00043	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z@4QBDB
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  0004d	6a ff		 push	 -1
  0004f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	e8 00 00 00 00	 call	 _DebugBreak@0
$L71117:
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00069	85 c0		 test	 eax, eax
  0006b	74 19		 je	 SHORT $L71112
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z@4QBDB
  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@MBMPAIOH@?$CFs?3?5Invalid?5pointer?5pAudioPath?6?$AA@
  00077	6a ff		 push	 -1
  00079	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	e8 00 00 00 00	 call	 _DebugBreak@0
$L71112:

; 4688 :     if (m_dwAudioPathMode == 0)

  00086	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00090	75 19		 jne	 SHORT $L71120

; 4689 :     {
; 4690 :         Trace(0,"Error: Performance not initialized.\n");

  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  00097	6a 00		 push	 0
  00099	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0009e	83 c4 08	 add	 esp, 8

; 4691 :         return DMUS_E_NOT_INIT;

  000a1	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  000a6	e9 ee 00 00 00	 jmp	 $L71109
$L71120:

; 4692 :     }
; 4693 : #ifndef XBOX
; 4694 :     if (m_dwAudioPathMode == 1)
; 4695 :     {
; 4696 :         Trace(0,"Error: Performance initialized not to support Audiopaths.\n"); 
; 4697 :         return DMUS_E_AUDIOPATHS_NOT_VALID;
; 4698 :     }
; 4699 : #endif
; 4700 :     ENTER_API_CRITICAL_SECTION;
; 4701 :     CAudioPath *pCPath = NULL;

  000ab	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pCPath$[ebp], 0

; 4702 :     if (pAudioPath)

  000b2	83 7d 0c 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  000b6	0f 84 8d 00 00
	00		 je	 $L71126

; 4703 :     {
; 4704 :         if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCPath)))

  000bc	8d 4d fc	 lea	 ecx, DWORD PTR _pCPath$[ebp]
  000bf	51		 push	 ecx
  000c0	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  000c5	8b 55 0c	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  000c8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  000cd	51		 push	 ecx
  000ce	ff 10		 call	 DWORD PTR [eax]
  000d0	85 c0		 test	 eax, eax
  000d2	7c 5f		 jl	 SHORT $L71129

; 4705 :         {
; 4706 :             pCPath->Release();

  000d4	8b 55 fc	 mov	 edx, DWORD PTR _pCPath$[ebp]
  000d7	8b 02		 mov	 eax, DWORD PTR [edx]
  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _pCPath$[ebp]
  000dc	51		 push	 ecx
  000dd	ff 50 08	 call	 DWORD PTR [eax+8]

; 4707 :             if (!m_AudioPathList.IsMember(pCPath))

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _pCPath$[ebp]
  000e3	52		 push	 edx
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  000ed	e8 00 00 00 00	 call	 ?IsMember@CAudioPathList@@QAEHPAVCAudioPath@@@Z ; CAudioPathList::IsMember
  000f2	85 c0		 test	 eax, eax
  000f4	75 19		 jne	 SHORT $L71130

; 4708 :             {
; 4709 :                 // This is not a legal audiopath, since it wasn't created by this performance.
; 4710 :                 Trace(0,"Error: Invalid audiopath - not created by this Performance.\n"); 

  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@NCCCEEPA@Error?3?5Invalid?5audiopath?5?9?5not?5c@
  000fb	6a 00		 push	 0
  000fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00102	83 c4 08	 add	 esp, 8

; 4711 :                 LEAVE_API_CRITICAL_SECTION;
; 4712 :                 return E_INVALIDARG;

  00105	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0010a	e9 8a 00 00 00	 jmp	 $L71109
$L71130:

; 4713 :             }
; 4714 :             if (pCPath->NoPorts())

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _pCPath$[ebp]
  00112	e8 00 00 00 00	 call	 ?NoPorts@CAudioPath@@QAEHXZ ; CAudioPath::NoPorts
  00117	85 c0		 test	 eax, eax
  00119	74 16		 je	 SHORT $L71133

; 4715 :             {
; 4716 :                 // This is an audiopath that doesn't have any port configurations. 
; 4717 :                 // For example, it might be environmental reverb.
; 4718 :                 Trace(0,"Error: Failure setting default audiopath - does not have any ports, so can not be played on.\n"); 

  0011b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FO@KKMIOIMC@Error?3?5Failure?5setting?5default?5a@
  00120	6a 00		 push	 0
  00122	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00127	83 c4 08	 add	 esp, 8

; 4719 :                 LEAVE_API_CRITICAL_SECTION;
; 4720 :                 return DMUS_E_AUDIOPATH_NOPORT;

  0012a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0012f	eb 68		 jmp	 SHORT $L71109
$L71133:

; 4721 :             }
; 4722 :         }
; 4723 :         else

  00131	eb 16		 jmp	 SHORT $L71126
$L71129:

; 4724 :         {
; 4725 :             // This is not a legal audiopath object at all.
; 4726 :             Trace(0,"Error: Invalid audiopath - not created by call to Performance->CreateAudioPath().\n"); 

  00133	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FD@ICBNMMBJ@Error?3?5Invalid?5audiopath?5?9?5not?5c@
  00138	6a 00		 push	 0
  0013a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0013f	83 c4 08	 add	 esp, 8

; 4727 :             LEAVE_API_CRITICAL_SECTION;
; 4728 :             return E_INVALIDARG;

  00142	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00147	eb 50		 jmp	 SHORT $L71109
$L71126:

; 4729 :         }
; 4730 :     }
; 4731 :     if (m_pDefaultAudioPath)

  00149	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00150	74 1c		 je	 SHORT $L71139

; 4732 :     {
; 4733 :         m_pDefaultAudioPath->Release();

  00152	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00158	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0015b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0015e	8b 12		 mov	 edx, DWORD PTR [edx]
  00160	51		 push	 ecx
  00161	ff 52 08	 call	 DWORD PTR [edx+8]

; 4734 :         m_pDefaultAudioPath = NULL;

  00164	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00167	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$L71139:

; 4735 :     }
; 4736 :     m_pDefaultAudioPath = pCPath;

  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	8b 55 fc	 mov	 edx, DWORD PTR _pCPath$[ebp]
  00174	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 4737 :     if (pCPath)

  00177	83 7d fc 00	 cmp	 DWORD PTR _pCPath$[ebp], 0
  0017b	74 1a		 je	 SHORT $L71140

; 4738 :     {
; 4739 :         pCPath->AddRef();

  0017d	8b 45 fc	 mov	 eax, DWORD PTR _pCPath$[ebp]
  00180	8b 08		 mov	 ecx, DWORD PTR [eax]
  00182	8b 55 fc	 mov	 edx, DWORD PTR _pCPath$[ebp]
  00185	52		 push	 edx
  00186	ff 51 04	 call	 DWORD PTR [ecx+4]

; 4740 :         pCPath->Activate(TRUE);

  00189	6a 01		 push	 1
  0018b	8b 45 fc	 mov	 eax, DWORD PTR _pCPath$[ebp]
  0018e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00190	8b 55 fc	 mov	 edx, DWORD PTR _pCPath$[ebp]
  00193	52		 push	 edx
  00194	ff 51 10	 call	 DWORD PTR [ecx+16]
$L71140:

; 4741 :     }
; 4742 :     LEAVE_API_CRITICAL_SECTION;
; 4743 :     return S_OK;

  00197	33 c0		 xor	 eax, eax
$L71109:

; 4744 : }

  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c2 08 00	 ret	 8
?SetDefaultAudioPath@CPerformance@@UAGJPAUIDirectMusicAudioPath@@@Z ENDP ; CPerformance::SetDefaultAudioPath
_TEXT	ENDS
PUBLIC	??_C@_0CB@EEKCPIIC@?$CFs?3?5Invalid?5pointer?5ppAudioPath?6@ ; `string'
PUBLIC	??_C@_0BP@DFONJGHO@Warning?3?5No?5default?5audiopath?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetDefaultAudioPath', 00H ; `CPerformance::GetDefaultAudioPath'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CB@EEKCPIIC@?$CFs?3?5Invalid?5pointer?5ppAudioPath?6@
CONST	SEGMENT
??_C@_0CB@EEKCPIIC@?$CFs?3?5Invalid?5pointer?5ppAudioPath?6@ DB '%s: Inva'
	DB	'lid pointer ppAudioPath', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DFONJGHO@Warning?3?5No?5default?5audiopath?6?$AA@
CONST	SEGMENT
??_C@_0BP@DFONJGHO@Warning?3?5No?5default?5audiopath?6?$AA@ DB 'Warning: '
	DB	'No default audiopath', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT
_this$ = 8
_ppAudioPath$ = 12
?GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z PROC NEAR ; CPerformance::GetDefaultAudioPath, COMDAT

; 4747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4748 :     V_INAME(IDirectMusicPerformance::GetDefaultAudioPath);
; 4749 :     V_PTRPTR_WRITE(ppAudioPath);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _ppAudioPath$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L71149
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EEKCPIIC@?$CFs?3?5Invalid?5pointer?5ppAudioPath?6@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L71149:

; 4750 :     if (m_dwAudioPathMode == 0)

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 b9 08 01 00
	00 00		 cmp	 DWORD PTR [ecx+264], 0
  00035	75 16		 jne	 SHORT $L71151

; 4751 :     {
; 4752 :         Trace(0,"Error: Performance not initialized.\n");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  0003c	6a 00		 push	 0
  0003e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00043	83 c4 08	 add	 esp, 8

; 4753 :         return DMUS_E_NOT_INIT;

  00046	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  0004b	eb 3e		 jmp	 SHORT $L71145
$L71151:

; 4754 :     }
; 4755 : #ifndef XBOX
; 4756 :     if (m_dwAudioPathMode == 1)
; 4757 :     {
; 4758 :         Trace(0,"Error: Performance was initialized not to support audiopaths.\n"); 
; 4759 :         return DMUS_E_AUDIOPATHS_NOT_VALID;
; 4760 :     }
; 4761 : #endif
; 4762 :     if (m_pDefaultAudioPath)

  0004d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00054	74 21		 je	 SHORT $L71156

; 4763 :     {
; 4764 :         *ppAudioPath = (IDirectMusicAudioPath *) m_pDefaultAudioPath;

  00056	8b 45 0c	 mov	 eax, DWORD PTR _ppAudioPath$[ebp]
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0005f	89 10		 mov	 DWORD PTR [eax], edx

; 4765 :         m_pDefaultAudioPath->AddRef();

  00061	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00067	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0006d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0006f	50		 push	 eax
  00070	ff 51 04	 call	 DWORD PTR [ecx+4]

; 4766 :         return S_OK;

  00073	33 c0		 xor	 eax, eax
  00075	eb 14		 jmp	 SHORT $L71145
$L71156:

; 4767 :     }
; 4768 :     Trace(3,"Warning: No default audiopath\n"); 

  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DFONJGHO@Warning?3?5No?5default?5audiopath?6?$AA@
  0007c	6a 03		 push	 3
  0007e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00083	83 c4 08	 add	 esp, 8

; 4769 :     return DMUS_E_NOT_FOUND;

  00086	b8 61 11 78 88	 mov	 eax, -2005397151	; 88781161H
$L71145:

; 4770 : }

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
?GetDefaultAudioPath@CPerformance@@UAGJPAPAUIDirectMusicAudioPath@@@Z ENDP ; CPerformance::GetDefaultAudioPath
_TEXT	ENDS
PUBLIC	??_GCAudioPath@@QAEPAXI@Z			; CAudioPath::`scalar deleting destructor'
PUBLIC	??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@ ; `string'
PUBLIC	??_C@_0BP@NCIDCFPG@?$CFs?3?5Invalid?5pointer?5ppNewPath?6?$AA@ ; `string'
PUBLIC	??_C@_0FG@BMDMNOHG@Error?3?5Audiopath?5creation?5failed@ ; `string'
EXTRN	??0CAudioPath@@QAE@XZ:NEAR			; CAudioPath::CAudioPath
EXTRN	?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z:NEAR ; CAudioPath::Init
EXTRN	_IID_IDirectMusicAudioPath:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::CreateAudioPath', 00H ; `CPerformance::CreateAudioPath'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@
CONST	SEGMENT
??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@ DB '%s: Inval'
	DB	'id pointer pSourceConfig', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NCIDCFPG@?$CFs?3?5Invalid?5pointer?5ppNewPath?6?$AA@
CONST	SEGMENT
??_C@_0BP@NCIDCFPG@?$CFs?3?5Invalid?5pointer?5ppNewPath?6?$AA@ DB '%s: In'
	DB	'valid pointer ppNewPath', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@BMDMNOHG@Error?3?5Audiopath?5creation?5failed@
CONST	SEGMENT
??_C@_0FG@BMDMNOHG@Error?3?5Audiopath?5creation?5failed@ DB 'Error: Audio'
	DB	'path creation failed because one or more buffers could not be'
	DB	' activated.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT
tv161 = -28
tv134 = -24
$T75442 = -20
$T75441 = -16
$T75438 = -12
_pPath$ = -8
_hr$ = -4
_this$ = 8
_pSourceConfig$ = 12
_fActivate$ = 16
_ppNewPath$ = 20
?CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z PROC NEAR ; CPerformance::CreateAudioPath, COMDAT

; 4776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 4777 :     V_INAME(IDirectMusicPerformance::CreateAudioPath);
; 4778 :     V_INTERFACE(pSourceConfig);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pSourceConfig$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71173
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71173:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourceConfig$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L71177
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L71177:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pSourceConfig$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L71179
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@KHJDHFBH@?$CFs?3?5Invalid?5pointer?5pSourceConfi@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L71179:

; 4779 :     V_PTRPTR_WRITE_OPT(ppNewPath);

  00082	83 7d 14 00	 cmp	 DWORD PTR _ppNewPath$[ebp], 0
  00086	74 28		 je	 SHORT $L71180
  00088	6a 04		 push	 4
  0008a	8b 45 14	 mov	 eax, DWORD PTR _ppNewPath$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $L71180
  00097	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z@4QBDB
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@NCIDCFPG@?$CFs?3?5Invalid?5pointer?5ppNewPath?6?$AA@
  000a1	6a ff		 push	 -1
  000a3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	e8 00 00 00 00	 call	 _DebugBreak@0
$L71180:

; 4780 : 
; 4781 :     if (m_dwAudioPathMode == 0)

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	83 b9 08 01 00
	00 00		 cmp	 DWORD PTR [ecx+264], 0
  000ba	75 19		 jne	 SHORT $L71184

; 4782 :     {
; 4783 :         Trace(0,"Error: Performance not initialized.\n");

  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  000c1	6a 00		 push	 0
  000c3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c8	83 c4 08	 add	 esp, 8

; 4784 :         return DMUS_E_NOT_INIT;

  000cb	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  000d0	e9 cd 00 00 00	 jmp	 $L71169
$L71184:

; 4785 :     }
; 4786 : #ifndef XBOX
; 4787 :     if (m_dwAudioPathMode == 1)
; 4788 :     {
; 4789 :         Trace(0,"Error: Performance not initialized to support audiopaths (must use InitAudio.)\n"); 
; 4790 :         return DMUS_E_AUDIOPATHS_NOT_VALID;
; 4791 :     }
; 4792 : #endif
; 4793 :     ENTER_API_CRITICAL_SECTION;
; 4794 :     HRESULT hr = E_OUTOFMEMORY;

  000d5	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 4795 :     CAudioPath *pPath = new CAudioPath;

  000dc	6a 78		 push	 120			; 00000078H
  000de	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e3	83 c4 04	 add	 esp, 4
  000e6	89 45 f4	 mov	 DWORD PTR $T75438[ebp], eax
  000e9	83 7d f4 00	 cmp	 DWORD PTR $T75438[ebp], 0
  000ed	74 0d		 je	 SHORT $L75439
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR $T75438[ebp]
  000f2	e8 00 00 00 00	 call	 ??0CAudioPath@@QAE@XZ	; CAudioPath::CAudioPath
  000f7	89 45 e8	 mov	 DWORD PTR tv134[ebp], eax
  000fa	eb 07		 jmp	 SHORT $L75440
$L75439:
  000fc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
$L75440:
  00103	8b 55 e8	 mov	 edx, DWORD PTR tv134[ebp]
  00106	89 55 f8	 mov	 DWORD PTR _pPath$[ebp], edx

; 4796 :     if (pPath)

  00109	83 7d f8 00	 cmp	 DWORD PTR _pPath$[ebp], 0
  0010d	0f 84 8c 00 00
	00		 je	 $L71194

; 4797 :     {
; 4798 :         hr = pPath->Init(pSourceConfig,this);

  00113	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00116	50		 push	 eax
  00117	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourceConfig$[ebp]
  0011a	51		 push	 ecx
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _pPath$[ebp]
  0011e	e8 00 00 00 00	 call	 ?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z ; CAudioPath::Init
  00123	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 4799 :         if (SUCCEEDED(hr) && fActivate)

  00126	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0012a	7c 2c		 jl	 SHORT $L71196
  0012c	83 7d 10 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  00130	74 26		 je	 SHORT $L71196

; 4800 :         {
; 4801 :             hr = pPath->Activate(TRUE);

  00132	6a 01		 push	 1
  00134	8b 55 f8	 mov	 edx, DWORD PTR _pPath$[ebp]
  00137	8b 02		 mov	 eax, DWORD PTR [edx]
  00139	8b 4d f8	 mov	 ecx, DWORD PTR _pPath$[ebp]
  0013c	51		 push	 ecx
  0013d	ff 50 10	 call	 DWORD PTR [eax+16]
  00140	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 4802 : #ifdef DBG
; 4803 :             if (FAILED(hr))

  00143	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00147	7d 0f		 jge	 SHORT $L71196

; 4804 :             {
; 4805 :                 Trace(1,"Error: Audiopath creation failed because one or more buffers could not be activated.\n");

  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FG@BMDMNOHG@Error?3?5Audiopath?5creation?5failed@
  0014e	6a 01		 push	 1
  00150	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00155	83 c4 08	 add	 esp, 8
$L71196:

; 4806 :             }
; 4807 : #endif
; 4808 :         }
; 4809 :         if (SUCCEEDED(hr))

  00158	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015c	7c 19		 jl	 SHORT $L71201

; 4810 :         {
; 4811 :             hr = pPath->QueryInterface(IID_IDirectMusicAudioPath,(void **) ppNewPath);

  0015e	8b 55 14	 mov	 edx, DWORD PTR _ppNewPath$[ebp]
  00161	52		 push	 edx
  00162	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicAudioPath
  00167	8b 45 f8	 mov	 eax, DWORD PTR _pPath$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	8b 55 f8	 mov	 edx, DWORD PTR _pPath$[ebp]
  0016f	52		 push	 edx
  00170	ff 11		 call	 DWORD PTR [ecx]
  00172	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 4812 :         }
; 4813 :         else

  00175	eb 28		 jmp	 SHORT $L71194
$L71201:

; 4814 :         {
; 4815 :             delete pPath;

  00177	8b 45 f8	 mov	 eax, DWORD PTR _pPath$[ebp]
  0017a	89 45 ec	 mov	 DWORD PTR $T75442[ebp], eax
  0017d	8b 4d ec	 mov	 ecx, DWORD PTR $T75442[ebp]
  00180	89 4d f0	 mov	 DWORD PTR $T75441[ebp], ecx
  00183	83 7d f0 00	 cmp	 DWORD PTR $T75441[ebp], 0
  00187	74 0f		 je	 SHORT $L75443
  00189	6a 01		 push	 1
  0018b	8b 4d f0	 mov	 ecx, DWORD PTR $T75441[ebp]
  0018e	e8 00 00 00 00	 call	 ??_GCAudioPath@@QAEPAXI@Z
  00193	89 45 e4	 mov	 DWORD PTR tv161[ebp], eax
  00196	eb 07		 jmp	 SHORT $L71194
$L75443:
  00198	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv161[ebp], 0
$L71194:

; 4816 :         }
; 4817 :     }
; 4818 :     LEAVE_API_CRITICAL_SECTION;
; 4819 :     return hr;

  0019f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L71169:

; 4820 : }

  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c2 10 00	 ret	 16			; 00000010H
?CreateAudioPath@CPerformance@@UAGJPAUIUnknown@@HPAPAUIDirectMusicAudioPath@@@Z ENDP ; CPerformance::CreateAudioPath
_TEXT	ENDS
EXTRN	??1CAudioPath@@QAE@XZ:NEAR			; CAudioPath::~CAudioPath
; Function compile flags: /Odt
;	COMDAT ??_GCAudioPath@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCAudioPath@@QAEPAXI@Z PROC NEAR			; CAudioPath::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAudioPath@@QAE@XZ	; CAudioPath::~CAudioPath
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L71209
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L71209:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAudioPath@@QAEPAXI@Z ENDP				; CAudioPath::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0GB@GEIFAAMI@Warning?3?5Creating?5a?5standard?5aud@ ; `string'
PUBLIC	??_C@_0DB@MMNNHIEN@Error?3?5?$CFld?5is?5not?5a?5valid?5predef@ ; `string'
PUBLIC	??_C@_0DL@LBFDOJPJ@Error?3?5Performance?5not?5initializ@ ; `string'
EXTRN	?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z:NEAR ; CAudioPathConfig::CreateStandardConfig
;	COMDAT ?__szValidateInterfaceName@?1??CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::CreateStandardAudioPath', 00H ; `CPerformance::CreateStandardAudioPath'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0GB@GEIFAAMI@Warning?3?5Creating?5a?5standard?5aud@
CONST	SEGMENT
??_C@_0GB@GEIFAAMI@Warning?3?5Creating?5a?5standard?5aud@ DB 'Warning: Cr'
	DB	'eating a standard audiopath without buffers - InitAudio speci'
	DB	'fied no buffer support.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MMNNHIEN@Error?3?5?$CFld?5is?5not?5a?5valid?5predef@
CONST	SEGMENT
??_C@_0DB@MMNNHIEN@Error?3?5?$CFld?5is?5not?5a?5valid?5predef@ DB 'Error:'
	DB	' %ld is not a valid predefined audiopath.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LBFDOJPJ@Error?3?5Performance?5not?5initializ@
CONST	SEGMENT
??_C@_0DL@LBFDOJPJ@Error?3?5Performance?5not?5initializ@ DB 'Error: Perfo'
	DB	'rmance not initialized to support audiopaths.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT
_pConfig$71235 = -16
_dwMixCount$71226 = -12
_dwMixBins$71225 = -8
_hr$ = -4
_this$ = 8
_dwType$ = 12
_dwPChannelCount$ = 16
_fActivate$ = 20
_ppNewPath$ = 24
?CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z PROC NEAR ; CPerformance::CreateStandardAudioPath, COMDAT

; 4826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4827 :     V_INAME(IDirectMusicPerformance::CreateStandardAudioPath);
; 4828 :     V_PTRPTR_WRITE_OPT(ppNewPath);

  00006	83 7d 18 00	 cmp	 DWORD PTR _ppNewPath$[ebp], 0
  0000a	74 28		 je	 SHORT $L71219
  0000c	6a 04		 push	 4
  0000e	8b 45 18	 mov	 eax, DWORD PTR _ppNewPath$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L71219
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@NCIDCFPG@?$CFs?3?5Invalid?5pointer?5ppNewPath?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L71219:

; 4829 :     HRESULT hr = S_OK;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 4830 :     if (m_dwAudioPathMode == 2)

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 b9 08 01 00
	00 02		 cmp	 DWORD PTR [ecx+264], 2
  00045	0f 85 e8 00 00
	00		 jne	 $L71224

; 4831 :     {
; 4832 :         // Count the number of bits to make sure this is a legal mixbin path.
; 4833 :         DWORD dwMixBins = dwType;

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _dwType$[ebp]
  0004e	89 55 f8	 mov	 DWORD PTR _dwMixBins$71225[ebp], edx

; 4834 :         DWORD dwMixCount = 0;

  00051	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwMixCount$71226[ebp], 0

; 4835 :         for (; (dwMixBins != 0) && (dwMixCount < 8); dwMixBins >>= 1)

  00058	eb 08		 jmp	 SHORT $L71227
$L71228:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _dwMixBins$71225[ebp]
  0005d	d1 e8		 shr	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _dwMixBins$71225[ebp], eax
$L71227:
  00062	83 7d f8 00	 cmp	 DWORD PTR _dwMixBins$71225[ebp], 0
  00066	74 1b		 je	 SHORT $L71229
  00068	83 7d f4 08	 cmp	 DWORD PTR _dwMixCount$71226[ebp], 8
  0006c	73 15		 jae	 SHORT $L71229

; 4836 :         {
; 4837 :             if (dwMixBins & 1) 

  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _dwMixBins$71225[ebp]
  00071	83 e1 01	 and	 ecx, 1
  00074	85 c9		 test	 ecx, ecx
  00076	74 09		 je	 SHORT $L71230

; 4838 :             {
; 4839 :                 dwMixCount++;

  00078	8b 55 f4	 mov	 edx, DWORD PTR _dwMixCount$71226[ebp]
  0007b	83 c2 01	 add	 edx, 1
  0007e	89 55 f4	 mov	 DWORD PTR _dwMixCount$71226[ebp], edx
$L71230:

; 4840 :             }
; 4841 :         }

  00081	eb d7		 jmp	 SHORT $L71228
$L71229:

; 4842 :         // A valid path has less than 8 bits set (for mixbin paths) or is one of 4 predefined types.
; 4843 :         if ((dwMixCount <= 8) || ((dwType >= DMUS_APATH_SHARED_STEREO) && (dwType <= DMUS_APATH_DYNAMIC_3D)))

  00083	83 7d f4 08	 cmp	 DWORD PTR _dwMixCount$71226[ebp], 8
  00087	76 16		 jbe	 SHORT $L71232
  00089	81 7d 0c 01 00
	ff ff		 cmp	 DWORD PTR _dwType$[ebp], -65535 ; ffff0001H
  00090	0f 82 81 00 00
	00		 jb	 $L71231
  00096	81 7d 0c 04 00
	ff ff		 cmp	 DWORD PTR _dwType$[ebp], -65532 ; ffff0004H
  0009d	77 78		 ja	 SHORT $L71231
$L71232:

; 4844 :         {
; 4845 :             if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))

  0009f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 88 d4 00 00
	00		 mov	 ecx, DWORD PTR [eax+212]
  000a8	83 e1 20	 and	 ecx, 32			; 00000020H
  000ab	85 c9		 test	 ecx, ecx
  000ad	75 16		 jne	 SHORT $L71233

; 4846 :             {
; 4847 :                 Trace(4,"Warning: Creating a standard audiopath without buffers - InitAudio specified no buffer support.\n");

  000af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GB@GEIFAAMI@Warning?3?5Creating?5a?5standard?5aud@
  000b4	6a 04		 push	 4
  000b6	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000bb	83 c4 08	 add	 esp, 8

; 4848 :                 // If the default synth doesn't support buffers, then create a simple port with no buffers.
; 4849 :                 dwType = 0;

  000be	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _dwType$[ebp], 0
$L71233:

; 4850 :             }
; 4851 :             CAudioPathConfig *pConfig = CAudioPathConfig::CreateStandardConfig(dwType,dwPChannelCount,m_AudioParams.dwSampleRate);

  000c5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c8	8b 82 dc 00 00
	00		 mov	 eax, DWORD PTR [edx+220]
  000ce	50		 push	 eax
  000cf	8b 4d 10	 mov	 ecx, DWORD PTR _dwPChannelCount$[ebp]
  000d2	51		 push	 ecx
  000d3	8b 55 0c	 mov	 edx, DWORD PTR _dwType$[ebp]
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 ?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z ; CAudioPathConfig::CreateStandardConfig
  000dc	89 45 f0	 mov	 DWORD PTR _pConfig$71235[ebp], eax

; 4852 :             if (pConfig)

  000df	83 7d f0 00	 cmp	 DWORD PTR _pConfig$71235[ebp], 0
  000e3	74 29		 je	 SHORT $L71236

; 4853 :             {
; 4854 :                 hr = CreateAudioPath((IPersistStream *) pConfig,fActivate,ppNewPath);

  000e5	8b 45 18	 mov	 eax, DWORD PTR _ppNewPath$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d 14	 mov	 ecx, DWORD PTR _fActivate$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 f0	 mov	 edx, DWORD PTR _pConfig$71235[ebp]
  000f0	52		 push	 edx
  000f1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	52		 push	 edx
  000fa	ff 51 4c	 call	 DWORD PTR [ecx+76]
  000fd	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 4855 :                 pConfig->Release();

  00100	8b 45 f0	 mov	 eax, DWORD PTR _pConfig$71235[ebp]
  00103	8b 08		 mov	 ecx, DWORD PTR [eax]
  00105	8b 55 f0	 mov	 edx, DWORD PTR _pConfig$71235[ebp]
  00108	52		 push	 edx
  00109	ff 51 08	 call	 DWORD PTR [ecx+8]

; 4856 :             }
; 4857 :             else

  0010c	eb 07		 jmp	 SHORT $L71238
$L71236:

; 4858 :             {
; 4859 :                 // CreateStandardConfig only returns NULL if we've run out of memory.
; 4860 :                 hr = E_OUTOFMEMORY;

  0010e	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L71238:

; 4861 :             }
; 4862 :         }
; 4863 :         else

  00115	eb 1a		 jmp	 SHORT $L71240
$L71231:

; 4864 :         {
; 4865 :             Trace(0,"Error: %ld is not a valid predefined audiopath.\n",dwType);

  00117	8b 45 0c	 mov	 eax, DWORD PTR _dwType$[ebp]
  0011a	50		 push	 eax
  0011b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@MMNNHIEN@Error?3?5?$CFld?5is?5not?5a?5valid?5predef@
  00120	6a 00		 push	 0
  00122	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4866 :             hr  = E_INVALIDARG;

  0012a	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L71240:

; 4867 :         }
; 4868 :     }
; 4869 :     else

  00131	eb 16		 jmp	 SHORT $L71243
$L71224:

; 4870 :     {
; 4871 :         Trace(0,"Error: Performance not initialized to support audiopaths.\n"); 

  00133	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@LBFDOJPJ@Error?3?5Performance?5not?5initializ@
  00138	6a 00		 push	 0
  0013a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0013f	83 c4 08	 add	 esp, 8

; 4872 :         hr = DMUS_E_AUDIOPATHS_NOT_VALID;

  00142	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L71243:

; 4873 :     }
; 4874 :     return hr;

  00149	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 4875 : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 14 00	 ret	 20			; 00000014H
?CreateStandardAudioPath@CPerformance@@UAGJKKHPAPAUIDirectMusicAudioPath@@@Z ENDP ; CPerformance::CreateStandardAudioPath
_TEXT	ENDS
PUBLIC	?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z	; CPerformance::DoStop
PUBLIC	?GetCount@AList@@QBEJXZ				; AList::GetCount
; Function compile flags: /Odt
;	COMDAT ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z
_TEXT	SEGMENT
_this$ = -36
_rtTime$71280 = -32
_mtNow$71270 = -24
_hrAbort$ = -20
_pDestList$ = -16
_pSourceList$ = -12
_pNode$ = -8
_dwCount$ = -4
_pSegState$ = 8
_mtTime$ = 12
_fInvalidate$ = 16
?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z PROC NEAR	; CPerformance::DoStop, COMDAT
; _this$ = ecx

; 4880 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 4881 :     HRESULT hrAbort = S_OK;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hrAbort$[ebp], 0

; 4882 :     DWORD dwCount;
; 4883 :     if( NULL == pSegState ) return;

  00010	83 7d 08 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  00014	75 05		 jne	 SHORT $L71255
  00016	e9 2b 04 00 00	 jmp	 $L71251
$L71255:

; 4884 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  0001b	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 4885 :     CSegStateList *pSourceList = NULL;

  0002a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pSourceList$[ebp], 0

; 4886 :     CSegStateList *pDestList = NULL;

  00031	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pDestList$[ebp], 0

; 4887 :     CSegState *pNode = NULL;

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pNode$[ebp], 0

; 4888 :     // Mark the length of the segstate to be only as far as it played
; 4889 :     // to keep GetParam() from accessing the unplayed portion.
; 4890 :     if (pSegState)  

  0003f	83 7d 08 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  00043	74 3f		 je	 SHORT $L71259

; 4891 :     {
; 4892 :         if (mtTime < pSegState->m_mtEndTime) 

  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00048	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0004b	3b 51 68	 cmp	 edx, DWORD PTR [ecx+104]
  0004e	7d 34		 jge	 SHORT $L71259

; 4893 :         {
; 4894 :             pSegState->m_mtLength = mtTime - pSegState->m_mtResolvedStart + 
; 4895 :                 pSegState->m_mtStartPoint;

  00050	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00056	2b 48 64	 sub	 ecx, DWORD PTR [eax+100]
  00059	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  0005c	03 4a 7c	 add	 ecx, DWORD PTR [edx+124]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00062	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4896 :             if (pSegState->m_mtLength < 0)

  00065	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00068	83 79 54 00	 cmp	 DWORD PTR [ecx+84], 0
  0006c	7d 0a		 jge	 SHORT $L71261

; 4897 :             {
; 4898 :                 pSegState->m_mtLength = 0;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  00071	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0
$L71261:

; 4899 :             }
; 4900 :             // Make endtime one greater than mtTime so Abort notification will still happen.
; 4901 :             pSegState->m_mtEndTime = mtTime + 1;   

  00078	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0007b	83 c0 01	 add	 eax, 1
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00081	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$L71259:

; 4902 :         }
; 4903 :     }
; 4904 :     RecalcTempoMap(pSegState,mtTime);

  00084	6a 01		 push	 1
  00086	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00089	52		 push	 edx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap

; 4905 :     // check each play queue
; 4906 :     for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)

  00096	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 3
  0009d	eb 09		 jmp	 SHORT $L71262
$L71263:
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  000a2	83 c1 01	 add	 ecx, 1
  000a5	89 4d fc	 mov	 DWORD PTR _dwCount$[ebp], ecx
$L71262:
  000a8	83 7d fc 05	 cmp	 DWORD PTR _dwCount$[ebp], 5
  000ac	0f 87 91 00 00
	00		 ja	 $L71264

; 4907 :     {
; 4908 :         for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())

  000b2	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  000b5	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  000bc	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  000c1	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
  000c4	eb 0b		 jmp	 SHORT $L71265
$L71266:
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  000c9	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  000ce	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
$L71265:
  000d1	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  000d5	74 67		 je	 SHORT $L71267

; 4909 :         {
; 4910 :             if( pNode == pSegState )

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  000da	3b 4d 08	 cmp	 ecx, DWORD PTR _pSegState$[ebp]
  000dd	75 5d		 jne	 SHORT $L71268

; 4911 :             {
; 4912 :                 // we want to move this to the approprate done queue
; 4913 :                 pDestList = &m_SegStateQueues[SQ_PRI_DONE - SQ_PRI_PLAY + dwCount];

  000df	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  000e2	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	8d 4c d0 5c	 lea	 ecx, DWORD PTR [eax+edx*8+92]
  000e9	89 4d f0	 mov	 DWORD PTR _pDestList$[ebp], ecx

; 4914 :                 pSourceList = &m_SegStateQueues[dwCount];

  000ec	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  000ef	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  000f6	89 4d f4	 mov	 DWORD PTR _pSourceList$[ebp], ecx

; 4915 :                 if ((dwCount == SQ_PRI_PLAY) && (m_SegStateQueues[SQ_PRI_PLAY].GetCount() == 1))

  000f9	83 7d fc 03	 cmp	 DWORD PTR _dwCount$[ebp], 3
  000fd	75 34		 jne	 SHORT $L71269
  000ff	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00105	e8 00 00 00 00	 call	 ?GetCount@AList@@QBEJXZ	; AList::GetCount
  0010a	83 f8 01	 cmp	 eax, 1
  0010d	75 24		 jne	 SHORT $L71269

; 4916 :                 {
; 4917 : #ifdef DXAPI
; 4918 :                     if (m_dwVersion >= 8)
; 4919 : #endif
; 4920 :                     {
; 4921 :                         MUSIC_TIME mtNow;
; 4922 :                         GetTime( NULL, &mtNow );

  0010f	8d 55 e8	 lea	 edx, DWORD PTR _mtNow$71270[ebp]
  00112	52		 push	 edx
  00113	6a 00		 push	 0
  00115	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0011d	52		 push	 edx
  0011e	ff 51 20	 call	 DWORD PTR [ecx+32]

; 4923 :                         GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegState );

  00121	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00124	50		 push	 eax
  00125	8b 4d e8	 mov	 ecx, DWORD PTR _mtNow$71270[ebp]
  00128	51		 push	 ecx
  00129	6a 02		 push	 2
  0012b	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ; CPerformance::GenerateNotification
$L71269:

; 4924 :                     }
; 4925 :                 }
; 4926 :                 dwCount = SQ_SEC_PLAY;  // Force out of outer loop.

  00133	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 5

; 4927 :                 break;

  0013a	eb 02		 jmp	 SHORT $L71267
$L71268:

; 4928 :             }
; 4929 :         }

  0013c	eb 88		 jmp	 SHORT $L71266
$L71267:

; 4930 :     }

  0013e	e9 5c ff ff ff	 jmp	 $L71263
$L71264:

; 4931 :     if (!pNode)

  00143	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00147	75 5f		 jne	 SHORT $L71271

; 4932 :     {
; 4933 :         // check each done queue
; 4934 :         for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)

  00149	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 6
  00150	eb 09		 jmp	 SHORT $L71272
$L71273:
  00152	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00155	83 c2 01	 add	 edx, 1
  00158	89 55 fc	 mov	 DWORD PTR _dwCount$[ebp], edx
$L71272:
  0015b	83 7d fc 08	 cmp	 DWORD PTR _dwCount$[ebp], 8
  0015f	77 47		 ja	 SHORT $L71271

; 4935 :         {
; 4936 :             for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())

  00161	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  00164	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  0016b	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00170	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
  00173	eb 0b		 jmp	 SHORT $L71275
$L71276:
  00175	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00178	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0017d	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
$L71275:
  00180	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00184	74 20		 je	 SHORT $L71277

; 4937 :             {
; 4938 :                 if( pNode == pSegState )

  00186	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  00189	3b 55 08	 cmp	 edx, DWORD PTR _pSegState$[ebp]
  0018c	75 16		 jne	 SHORT $L71278

; 4939 :                 {
; 4940 :                     pSourceList = &m_SegStateQueues[dwCount];

  0018e	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  00191	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	8d 54 c1 44	 lea	 edx, DWORD PTR [ecx+eax*8+68]
  00198	89 55 f4	 mov	 DWORD PTR _pSourceList$[ebp], edx

; 4941 :                     dwCount = SQ_SEC_DONE;  // Force out of outer loop.

  0019b	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 8

; 4942 :                     break;

  001a2	eb 02		 jmp	 SHORT $L71277
$L71278:

; 4943 :                 }
; 4944 :             }

  001a4	eb cf		 jmp	 SHORT $L71276
$L71277:

; 4945 :         }

  001a6	eb aa		 jmp	 SHORT $L71273
$L71271:

; 4946 :     }
; 4947 :     if( pNode && pSourceList)

  001a8	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  001ac	0f 84 72 01 00
	00		 je	 $L71279
  001b2	83 7d f4 00	 cmp	 DWORD PTR _pSourceList$[ebp], 0
  001b6	0f 84 68 01 00
	00		 je	 $L71279

; 4948 :     {
; 4949 :         REFERENCE_TIME rtTime;
; 4950 :         MusicToReferenceTime(mtTime,&rtTime);

  001bc	8d 45 e0	 lea	 eax, DWORD PTR _rtTime$71280[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  001c3	51		 push	 ecx
  001c4	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001c7	8b 02		 mov	 eax, DWORD PTR [edx]
  001c9	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	51		 push	 ecx
  001cd	ff 50 14	 call	 DWORD PTR [eax+20]

; 4951 :         if( pNode->m_mtLastPlayed >= mtTime )

  001d0	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  001d3	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  001d6	3b 45 0c	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  001d9	7c 2b		 jl	 SHORT $L71281

; 4952 :         {
; 4953 :             pNode->Flush( mtTime );

  001db	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  001de	51		 push	 ecx
  001df	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ?Flush@CSegState@@QAGJJ@Z ; CSegState::Flush

; 4954 :             pNode->m_mtLastPlayed = mtTime; // must set this to indicate it only played until then

  001e8	8b 45 f8	 mov	 eax, DWORD PTR _pNode$[ebp]
  001eb	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  001ee	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 4955 :             pNode->m_rtLastPlayed = rtTime;

  001f1	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  001f4	8b 45 e0	 mov	 eax, DWORD PTR _rtTime$71280[ebp]
  001f7	89 82 a8 00 00
	00		 mov	 DWORD PTR [edx+168], eax
  001fd	8b 4d e4	 mov	 ecx, DWORD PTR _rtTime$71280[ebp+4]
  00200	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx
$L71281:

; 4956 :         }
; 4957 :         if( fInvalidate )

  00206	83 7d 10 00	 cmp	 DWORD PTR _fInvalidate$[ebp], 0
  0020a	74 58		 je	 SHORT $L71282

; 4958 :         {
; 4959 :             if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )

  0020c	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  0020f	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00212	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00217	85 c0		 test	 eax, eax
  00219	74 14		 je	 SHORT $L71283

; 4960 :             {
; 4961 :                 Invalidate( mtTime, 0 ); // must call Invalidate before AbortPlay so we don't

  0021b	6a 00		 push	 0
  0021d	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00220	51		 push	 ecx
  00221	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00224	8b 02		 mov	 eax, DWORD PTR [edx]
  00226	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	51		 push	 ecx
  0022a	ff 50 68	 call	 DWORD PTR [eax+104]

; 4962 :                 // invalidate the abort notification
; 4963 :             }
; 4964 :             else if ( !(pNode->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY ))

  0022d	eb 35		 jmp	 SHORT $L71282
$L71283:
  0022f	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  00232	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00235	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0023a	85 c0		 test	 eax, eax
  0023c	75 26		 jne	 SHORT $L71282

; 4965 :             {
; 4966 :                 // If this is a primary segment, kill the tempo map.
; 4967 :                 FlushEventQueue( 0, &m_TempoMap, rtTime, rtTime, 0 );

  0023e	6a 00		 push	 0
  00240	8b 4d e4	 mov	 ecx, DWORD PTR _rtTime$71280[ebp+4]
  00243	51		 push	 ecx
  00244	8b 55 e0	 mov	 edx, DWORD PTR _rtTime$71280[ebp]
  00247	52		 push	 edx
  00248	8b 45 e4	 mov	 eax, DWORD PTR _rtTime$71280[ebp+4]
  0024b	50		 push	 eax
  0024c	8b 4d e0	 mov	 ecx, DWORD PTR _rtTime$71280[ebp]
  0024f	51		 push	 ecx
  00250	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00253	81 c2 38 01 00
	00		 add	 edx, 312		; 00000138H
  00259	52		 push	 edx
  0025a	6a 00		 push	 0
  0025c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	e8 00 00 00 00	 call	 ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue
$L71282:

; 4968 :             }
; 4969 :         }
; 4970 :         hrAbort = pNode->AbortPlay( mtTime, FALSE );

  00264	6a 00		 push	 0
  00266	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00269	50		 push	 eax
  0026a	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0026d	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay
  00272	89 45 ec	 mov	 DWORD PTR _hrAbort$[ebp], eax

; 4971 :         if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )

  00275	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00278	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0027b	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00281	85 d2		 test	 edx, edx
  00283	74 7c		 je	 SHORT $L71286

; 4972 :         {
; 4973 :             pSourceList->Remove(pNode);

  00285	8b 45 f8	 mov	 eax, DWORD PTR _pNode$[ebp]
  00288	50		 push	 eax
  00289	8b 4d f4	 mov	 ecx, DWORD PTR _pSourceList$[ebp]
  0028c	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 4974 :             m_ShutDownQueue.Insert(pNode); // we're guaranteed to never need this again

  00291	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00294	51		 push	 ecx
  00295	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00298	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0029e	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 4975 : 
; 4976 :             // set dirty flags on all other segments
; 4977 : 
; 4978 :             for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)

  002a3	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 3
  002aa	eb 09		 jmp	 SHORT $L71287
$L71288:
  002ac	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 fc	 mov	 DWORD PTR _dwCount$[ebp], edx
$L71287:
  002b5	83 7d fc 05	 cmp	 DWORD PTR _dwCount$[ebp], 5
  002b9	77 44		 ja	 SHORT $L71289

; 4979 :             {
; 4980 :                 for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  002bb	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  002be	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c1	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  002c5	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002ca	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
  002cd	eb 0b		 jmp	 SHORT $L71290
$L71291:
  002cf	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  002d2	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  002d7	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
$L71290:
  002da	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  002de	74 1d		 je	 SHORT $L71292

; 4981 :                 {
; 4982 :                     if( pNode->m_fStartedPlay )

  002e0	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  002e3	83 ba 04 01 00
	00 00		 cmp	 DWORD PTR [edx+260], 0
  002ea	74 0f		 je	 SHORT $L71293

; 4983 :                     {
; 4984 :                         pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;

  002ec	8b 45 f8	 mov	 eax, DWORD PTR _pNode$[ebp]
  002ef	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  002f2	83 c9 10	 or	 ecx, 16			; 00000010H
  002f5	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  002f8	89 4a 58	 mov	 DWORD PTR [edx+88], ecx
$L71293:

; 4985 :                     }
; 4986 :                 }

  002fb	eb d2		 jmp	 SHORT $L71291
$L71292:

; 4987 :             }

  002fd	eb ad		 jmp	 SHORT $L71288
$L71289:

; 4988 :         }
; 4989 :         else if( pDestList )

  002ff	eb 1e		 jmp	 SHORT $L71294
$L71286:
  00301	83 7d f0 00	 cmp	 DWORD PTR _pDestList$[ebp], 0
  00305	74 18		 je	 SHORT $L71294

; 4990 :         {
; 4991 :             pSourceList->Remove(pNode);

  00307	8b 45 f8	 mov	 eax, DWORD PTR _pNode$[ebp]
  0030a	50		 push	 eax
  0030b	8b 4d f4	 mov	 ecx, DWORD PTR _pSourceList$[ebp]
  0030e	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 4992 :             pDestList->Insert(pNode);

  00313	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00316	51		 push	 ecx
  00317	8b 4d f0	 mov	 ecx, DWORD PTR _pDestList$[ebp]
  0031a	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L71294:

; 4993 :         }
; 4994 :     }
; 4995 :     else

  0031f	e9 96 00 00 00	 jmp	 $L71296
$L71279:

; 4996 :     {
; 4997 :         // check the wait lists.
; 4998 :         for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)

  00324	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  0032b	eb 09		 jmp	 SHORT $L71297
$L71298:
  0032d	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00330	83 c2 01	 add	 edx, 1
  00333	89 55 fc	 mov	 DWORD PTR _dwCount$[ebp], edx
$L71297:
  00336	83 7d fc 02	 cmp	 DWORD PTR _dwCount$[ebp], 2
  0033a	77 7e		 ja	 SHORT $L71296

; 4999 :         {
; 5000 :             for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  0033c	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  0033f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00342	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  00346	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0034b	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
  0034e	eb 0b		 jmp	 SHORT $L71300
$L71301:
  00350	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00353	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00358	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax
$L71300:
  0035b	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  0035f	74 54		 je	 SHORT $L71302

; 5001 :             {
; 5002 :                 if( pNode == pSegState ) 

  00361	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  00364	3b 55 08	 cmp	 edx, DWORD PTR _pSegState$[ebp]
  00367	75 4a		 jne	 SHORT $L71303

; 5003 :                 {
; 5004 :                     hrAbort = pNode->AbortPlay( mtTime, FALSE );

  00369	6a 00		 push	 0
  0036b	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0036e	50		 push	 eax
  0036f	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00372	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay
  00377	89 45 ec	 mov	 DWORD PTR _hrAbort$[ebp], eax

; 5005 :                     m_SegStateQueues[dwCount].Remove(pNode);

  0037a	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0037d	51		 push	 ecx
  0037e	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00381	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00384	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  00388	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 5006 :                     RecalcTempoMap(pNode, mtTime);

  0038d	6a 01		 push	 1
  0038f	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00392	51		 push	 ecx
  00393	8b 55 f8	 mov	 edx, DWORD PTR _pNode$[ebp]
  00396	52		 push	 edx
  00397	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap

; 5007 :                     m_ShutDownQueue.Insert(pNode); 

  0039f	8b 45 f8	 mov	 eax, DWORD PTR _pNode$[ebp]
  003a2	50		 push	 eax
  003a3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a6	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  003ac	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 5008 :                     break;

  003b1	eb 02		 jmp	 SHORT $L71302
$L71303:

; 5009 :                 }
; 5010 :             }

  003b3	eb 9b		 jmp	 SHORT $L71301
$L71302:

; 5011 :         }

  003b5	e9 73 ff ff ff	 jmp	 $L71298
$L71296:

; 5012 :     }
; 5013 :     // if there aren't any more segments to play, send a Music Stopped
; 5014 :     // notification
; 5015 :     if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
; 5016 :         m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
; 5017 :         m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty())

  003ba	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003bd	83 c1 5c	 add	 ecx, 92			; 0000005cH
  003c0	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003c5	85 c0		 test	 eax, eax
  003c7	74 6e		 je	 SHORT $L71304
  003c9	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003cc	83 c1 6c	 add	 ecx, 108		; 0000006cH
  003cf	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003d4	85 c0		 test	 eax, eax
  003d6	74 5f		 je	 SHORT $L71304
  003d8	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003db	83 c1 44	 add	 ecx, 68			; 00000044H
  003de	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003e3	85 c0		 test	 eax, eax
  003e5	74 50		 je	 SHORT $L71304
  003e7	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ea	83 c1 54	 add	 ecx, 84			; 00000054H
  003ed	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  003f2	85 c0		 test	 eax, eax
  003f4	74 41		 je	 SHORT $L71304
  003f6	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f9	83 c1 64	 add	 ecx, 100		; 00000064H
  003fc	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  00401	85 c0		 test	 eax, eax
  00403	74 32		 je	 SHORT $L71304
  00405	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0040b	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  00410	85 c0		 test	 eax, eax
  00412	74 23		 je	 SHORT $L71304

; 5018 :     {
; 5019 :         m_fMusicStopped = TRUE;

  00414	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00417	c7 81 c8 03 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+968], 1

; 5020 :         // S_FALSE means we tried to abort this segstate, but it's already been aborted
; 5021 :         if (hrAbort != S_FALSE)

  00421	83 7d ec 01	 cmp	 DWORD PTR _hrAbort$[ebp], 1
  00425	74 10		 je	 SHORT $L71304

; 5022 :         {
; 5023 :             GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtTime, NULL );

  00427	6a 00		 push	 0
  00429	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0042c	52		 push	 edx
  0042d	6a 01		 push	 1
  0042f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00432	e8 00 00 00 00	 call	 ?GenerateNotification@CPerformance@@AAEXKJPAUIDirectMusicSegmentState@@@Z ; CPerformance::GenerateNotification
$L71304:

; 5024 :         }
; 5025 :     }
; 5026 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00437	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0043a	05 14 03 00 00	 add	 eax, 788		; 00000314H
  0043f	50		 push	 eax
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L71251:

; 5027 : }

  00446	8b e5		 mov	 esp, ebp
  00448	5d		 pop	 ebp
  00449	c2 0c 00	 ret	 12			; 0000000cH
?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z ENDP	; CPerformance::DoStop
_TEXT	ENDS
PUBLIC	?ResetAllControllers@CPerformance@@AAEX_J@Z	; CPerformance::ResetAllControllers
PUBLIC	?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z	; CPerformance::DoStop
; Function compile flags: /Odt
;	COMDAT ?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z
_TEXT	SEGMENT
_this$ = -16
_pNode$ = -12
_lCount$ = -8
_pNext$ = -4
_pSeg$ = 8
_mtTime$ = 12
_fInvalidate$ = 16
?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z PROC NEAR	; CPerformance::DoStop, COMDAT
; _this$ = ecx

; 5031 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 5032 :     long lCount;
; 5033 :     CSegState* pNode;
; 5034 :     CSegState* pNext;
; 5035 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5036 :     // find all seg pSegStates based off this segment that have played through time mtTime
; 5037 :     // if pSeg is NULL, go through all of the segment lists. Flush any
; 5038 :     // segment that played through time mtTime. Move any active segments
; 5039 :     // into past lists.
; 5040 :     if( pSeg )

  00018	83 7d 08 00	 cmp	 DWORD PTR _pSeg$[ebp], 0
  0001c	0f 84 93 00 00
	00		 je	 $L71316

; 5041 :     {
; 5042 :         for (lCount = SQ_SEC_DONE; lCount >= SQ_PRI_WAIT; lCount--)

  00022	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR _lCount$[ebp], 8
  00029	eb 09		 jmp	 SHORT $L71317
$L71318:
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _lCount$[ebp]
  0002e	83 e9 01	 sub	 ecx, 1
  00031	89 4d f8	 mov	 DWORD PTR _lCount$[ebp], ecx
$L71317:
  00034	83 7d f8 00	 cmp	 DWORD PTR _lCount$[ebp], 0
  00038	7c 76		 jl	 SHORT $L71319

; 5043 :         {
; 5044 :             pNode = m_SegStateQueues[lCount].GetHead();

  0003a	8b 55 f8	 mov	 edx, DWORD PTR _lCount$[ebp]
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  00044	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00049	89 45 f4	 mov	 DWORD PTR _pNode$[ebp], eax
$L71321:

; 5045 :             while( pNode )

  0004c	83 7d f4 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00050	74 59		 je	 SHORT $L71322

; 5046 :             {
; 5047 :                 pNext = pNode->GetNext();

  00052	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00055	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0005a	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 5048 :                 if( pNode->m_pSegment == pSeg )

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00060	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00063	3b 55 08	 cmp	 edx, DWORD PTR _pSeg$[ebp]
  00066	75 3b		 jne	 SHORT $L71323

; 5049 :                 {
; 5050 :                     if (IsDoneQueue(lCount))

  00068	83 7d f8 06	 cmp	 DWORD PTR _lCount$[ebp], 6
  0006c	7c 21		 jl	 SHORT $L71324

; 5051 :                     {
; 5052 :                         if (pNode->m_mtLastPlayed >= mtTime)

  0006e	8b 45 f4	 mov	 eax, DWORD PTR _pNode$[ebp]
  00071	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00074	3b 4d 0c	 cmp	 ecx, DWORD PTR _mtTime$[ebp]
  00077	7c 14		 jl	 SHORT $L71325

; 5053 :                         {
; 5054 :                              DoStop( pNode, mtTime, fInvalidate );

  00079	8b 55 10	 mov	 edx, DWORD PTR _fInvalidate$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00080	50		 push	 eax
  00081	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00084	51		 push	 ecx
  00085	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z ; CPerformance::DoStop
$L71325:

; 5055 :                         }
; 5056 :                     }
; 5057 :                     else

  0008d	eb 14		 jmp	 SHORT $L71323
$L71324:

; 5058 :                     {
; 5059 :                         DoStop( pNode, mtTime, fInvalidate );

  0008f	8b 55 10	 mov	 edx, DWORD PTR _fInvalidate$[ebp]
  00092	52		 push	 edx
  00093	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00096	50		 push	 eax
  00097	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z ; CPerformance::DoStop
$L71323:

; 5060 :                     }
; 5061 :                 }
; 5062 :                 pNode = pNext;

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  000a6	89 55 f4	 mov	 DWORD PTR _pNode$[ebp], edx

; 5063 :             }

  000a9	eb a1		 jmp	 SHORT $L71321
$L71322:

; 5064 :         }

  000ab	e9 7b ff ff ff	 jmp	 $L71318
$L71319:

; 5065 :     }
; 5066 :     else // pSeg is NULL, stop everything.

  000b0	e9 56 01 00 00	 jmp	 $L71327
$L71316:

; 5067 :     {
; 5068 :         // go ahead and flush the event queues
; 5069 :         ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  000b5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	05 30 03 00 00	 add	 eax, 816		; 00000330H
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5070 :         FlushMainEventQueues( 0, mtTime, mtTime, 0 );

  000c4	6a 00		 push	 0
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  000cd	52		 push	 edx
  000ce	6a 00		 push	 0
  000d0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z ; CPerformance::FlushMainEventQueues

; 5071 :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000d8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000db	05 30 03 00 00	 add	 eax, 816		; 00000330H
  000e0	50		 push	 eax
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5072 :         // clear out the wait lists
; 5073 :         for (lCount = SQ_PRI_WAIT; lCount <= SQ_SEC_WAIT; lCount++)

  000e7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lCount$[ebp], 0
  000ee	eb 09		 jmp	 SHORT $L71328
$L71329:
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _lCount$[ebp]
  000f3	83 c1 01	 add	 ecx, 1
  000f6	89 4d f8	 mov	 DWORD PTR _lCount$[ebp], ecx
$L71328:
  000f9	83 7d f8 02	 cmp	 DWORD PTR _lCount$[ebp], 2
  000fd	7f 4b		 jg	 SHORT $L71330
$L71332:

; 5074 :         {
; 5075 :             while (pNode = m_SegStateQueues[lCount].GetHead())

  000ff	8b 55 f8	 mov	 edx, DWORD PTR _lCount$[ebp]
  00102	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00105	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  00109	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0010e	89 45 f4	 mov	 DWORD PTR _pNode$[ebp], eax
  00111	83 7d f4 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00115	74 31		 je	 SHORT $L71333

; 5076 :             {
; 5077 :                 pNode->AbortPlay( mtTime, FALSE );

  00117	6a 00		 push	 0
  00119	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00120	e8 00 00 00 00	 call	 ?AbortPlay@CSegState@@QAEJJH@Z ; CSegState::AbortPlay

; 5078 :                 m_SegStateQueues[lCount].RemoveHead();

  00125	8b 55 f8	 mov	 edx, DWORD PTR _lCount$[ebp]
  00128	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0012b	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  0012f	e8 00 00 00 00	 call	 ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::RemoveHead

; 5079 :                 m_ShutDownQueue.Insert(pNode); 

  00134	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00137	51		 push	 ecx
  00138	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00141	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert

; 5080 :             }

  00146	eb b7		 jmp	 SHORT $L71332
$L71333:

; 5081 :         }

  00148	eb a6		 jmp	 SHORT $L71329
$L71330:

; 5082 :         // stop any segment that is currently playing.
; 5083 :         for (lCount = SQ_PRI_DONE; lCount <= SQ_SEC_DONE; lCount++)

  0014a	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _lCount$[ebp], 6
  00151	eb 09		 jmp	 SHORT $L71334
$L71335:
  00153	8b 55 f8	 mov	 edx, DWORD PTR _lCount$[ebp]
  00156	83 c2 01	 add	 edx, 1
  00159	89 55 f8	 mov	 DWORD PTR _lCount$[ebp], edx
$L71334:
  0015c	83 7d f8 08	 cmp	 DWORD PTR _lCount$[ebp], 8
  00160	7f 48		 jg	 SHORT $L71336

; 5084 :         {
; 5085 :             for( pNode = m_SegStateQueues[lCount].GetHead(); pNode; pNode = pNode->GetNext() )

  00162	8b 45 f8	 mov	 eax, DWORD PTR _lCount$[ebp]
  00165	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  0016c	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00171	89 45 f4	 mov	 DWORD PTR _pNode$[ebp], eax
  00174	eb 0b		 jmp	 SHORT $L71337
$L71338:
  00176	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00179	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0017e	89 45 f4	 mov	 DWORD PTR _pNode$[ebp], eax
$L71337:
  00181	83 7d f4 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00185	74 21		 je	 SHORT $L71339

; 5086 :             {
; 5087 :                 if( pNode->m_mtLastPlayed >= mtTime )

  00187	8b 55 f4	 mov	 edx, DWORD PTR _pNode$[ebp]
  0018a	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0018d	3b 45 0c	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00190	7c 14		 jl	 SHORT $L71340

; 5088 :                 {
; 5089 :                     DoStop( pNode, mtTime, fInvalidate );

  00192	8b 4d 10	 mov	 ecx, DWORD PTR _fInvalidate$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00199	52		 push	 edx
  0019a	8b 45 f4	 mov	 eax, DWORD PTR _pNode$[ebp]
  0019d	50		 push	 eax
  0019e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z ; CPerformance::DoStop
$L71340:

; 5090 :                 }
; 5091 :             }

  001a6	eb ce		 jmp	 SHORT $L71338
$L71339:

; 5092 :         }

  001a8	eb a9		 jmp	 SHORT $L71335
$L71336:

; 5093 :         for (lCount = SQ_PRI_PLAY; lCount <= SQ_SEC_PLAY; lCount++)

  001aa	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _lCount$[ebp], 3
  001b1	eb 09		 jmp	 SHORT $L71341
$L71342:
  001b3	8b 4d f8	 mov	 ecx, DWORD PTR _lCount$[ebp]
  001b6	83 c1 01	 add	 ecx, 1
  001b9	89 4d f8	 mov	 DWORD PTR _lCount$[ebp], ecx
$L71341:
  001bc	83 7d f8 05	 cmp	 DWORD PTR _lCount$[ebp], 5
  001c0	7f 37		 jg	 SHORT $L71343
$L71345:

; 5094 :         {
; 5095 :             while( m_SegStateQueues[lCount].GetHead() )

  001c2	8b 55 f8	 mov	 edx, DWORD PTR _lCount$[ebp]
  001c5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001c8	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  001cc	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001d1	85 c0		 test	 eax, eax
  001d3	74 22		 je	 SHORT $L71346

; 5096 :             {
; 5097 :                 DoStop( m_SegStateQueues[lCount].GetHead(), mtTime, fInvalidate );

  001d5	8b 4d 10	 mov	 ecx, DWORD PTR _fInvalidate$[ebp]
  001d8	51		 push	 ecx
  001d9	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  001dc	52		 push	 edx
  001dd	8b 45 f8	 mov	 eax, DWORD PTR _lCount$[ebp]
  001e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  001e7	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001ec	50		 push	 eax
  001ed	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f0	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z ; CPerformance::DoStop

; 5098 :             }

  001f5	eb cb		 jmp	 SHORT $L71345
$L71346:

; 5099 :         }

  001f7	eb ba		 jmp	 SHORT $L71342
$L71343:

; 5100 :         // reset controllers and force all notes off.
; 5101 :         ResetAllControllers( GetLatency() );

  001f9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00201	52		 push	 edx
  00202	50		 push	 eax
  00203	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00206	e8 00 00 00 00	 call	 ?ResetAllControllers@CPerformance@@AAEX_J@Z ; CPerformance::ResetAllControllers
$L71327:

; 5102 :     }
; 5103 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0020b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0020e	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00214	52		 push	 edx
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5104 : }

  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c2 0c 00	 ret	 12			; 0000000cH
?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z ENDP	; CPerformance::DoStop
_TEXT	ENDS
PUBLIC	??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@ ; `string'
PUBLIC	??_C@_0CP@HMEHGHPP@DMUS_SEGF_REFTIME?5is?5not?5Support@ ; `string'
PUBLIC	??_C@_0FD@LGDDGIOF@?$CB?$CIdwFlags?5?$CG?5DMUS_SEGF_REFTIME?$CJ?5?$CG@ ; `string'
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
EXTRN	_IID_IDirectMusicSegment:BYTE
EXTRN	_IID_IDirectMusicSegmentState:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::StopEx', 00H	; `CPerformance::StopEx'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@
CONST	SEGMENT
??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@ DB '%s: Invali'
	DB	'd pointer pObjectToStop', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HMEHGHPP@DMUS_SEGF_REFTIME?5is?5not?5Support@
CONST	SEGMENT
??_C@_0CP@HMEHGHPP@DMUS_SEGF_REFTIME?5is?5not?5Support@ DB 'DMUS_SEGF_REF'
	DB	'TIME is not Supported on this API', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@LGDDGIOF@?$CB?$CIdwFlags?5?$CG?5DMUS_SEGF_REFTIME?$CJ?5?$CG@
CONST	SEGMENT
??_C@_0FD@LGDDGIOF@?$CB?$CIdwFlags?5?$CG?5DMUS_SEGF_REFTIME?$CJ?5?$CG@ DB '!'
	DB	'(dwFlags & DMUS_SEGF_REFTIME) && "DMUS_SEGF_REFTIME is not Su'
	DB	'pported on this API"', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z
_TEXT	SEGMENT
_pNode$71473 = -120
_dwCount$71474 = -116
_pNext$71462 = -112
_pNode$71457 = -108
_dwCount$71458 = -104
_pITransSegment$71440 = -100
_rtResolved$71430 = -96
_rtTime$71424 = -88
_mtTime$71431 = -80
_pTransition$71432 = -76
_Transition$71433 = -72
_pPriorSeg$71421 = -60
_pNode$71402 = -56
_dwCount$71403 = -52
_pCSong$71390 = -48
_pCAudioPath$71391 = -44
_pCSegment$71392 = -40
_hrTemp$71386 = -36
_fTransition$71384 = -32
_pCState$71385 = -28
_mtTime$71381 = -24
_pSong$ = -20
_hr$ = -16
_pState$ = -12
_pSegment$ = -8
_pAudioPath$ = -4
_this$ = 8
_pObjectToStop$ = 12
_i64StopTime$ = 16
_dwFlags$ = 24
?StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z PROC NEAR	; CPerformance::StopEx, COMDAT

; 5108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H

; 5109 :     V_INAME(IDirectMusicPerformance::StopEx);
; 5110 :     V_INTERFACE_OPT(pObjectToStop);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pObjectToStop$[ebp], 0
  0000a	74 7c		 je	 SHORT $L71355
  0000c	6a 04		 push	 4
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L71357
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L71357:
  00034	6a 04		 push	 4
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectToStop$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $L71361
  00045	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z@4QBDB
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@
  0004f	6a ff		 push	 -1
  00051	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 _DebugBreak@0
$L71361:
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0006b	85 c0		 test	 eax, eax
  0006d	74 19		 je	 SHORT $L71355
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z@4QBDB
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@GLKEPFF@?$CFs?3?5Invalid?5pointer?5pObjectToSto@
  00079	6a ff		 push	 -1
  0007b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	e8 00 00 00 00	 call	 _DebugBreak@0
$L71355:

; 5111 :     HRESULT hr = E_INVALIDARG;

  00088	c7 45 f0 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 5112 :     IDirectMusicSegmentState *pState;
; 5113 :     IDirectMusicSegment *pSegment;
; 5114 :     CSong *pSong;
; 5115 :     CAudioPath *pAudioPath;
; 5116 :     if (m_dwAudioPathMode == 0)

  0008f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00099	75 19		 jne	 SHORT $L71370

; 5117 :     {
; 5118 :         Trace(0,"Error: Performance not initialized.\n");

  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  000a0	6a 00		 push	 0
  000a2	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a7	83 c4 08	 add	 esp, 8

; 5119 :         return DMUS_E_NOT_INIT;

  000aa	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  000af	e9 d8 05 00 00	 jmp	 $L71352
$L71370:

; 5120 :     }
; 5121 : 
; 5122 :     TraceI(0,"StopExing %lx at time %ld, flags %lx\n",pObjectToStop,(long)i64StopTime,dwFlags);
; 5123 : 
; 5124 :     assert(!(dwFlags & DMUS_SEGF_REFTIME) && "DMUS_SEGF_REFTIME is not Supported on this API");

  000b4	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  000b7	83 e1 40	 and	 ecx, 64			; 00000040H
  000ba	85 c9		 test	 ecx, ecx
  000bc	75 09		 jne	 SHORT $L75460
  000be	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:??_C@_0CP@HMEHGHPP@DMUS_SEGF_REFTIME?5is?5not?5Support@
  000c3	85 d2		 test	 edx, edx
  000c5	75 14		 jne	 SHORT $L75461
$L75460:
  000c7	68 04 14 00 00	 push	 5124			; 00001404H
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FD@LGDDGIOF@?$CB?$CIdwFlags?5?$CG?5DMUS_SEGF_REFTIME?$CJ?5?$CG@
  000d6	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L75461:

; 5125 : 
; 5126 :     if (pObjectToStop == NULL)

  000db	83 7d 0c 00	 cmp	 DWORD PTR _pObjectToStop$[ebp], 0
  000df	75 23		 jne	 SHORT $L71380

; 5127 :     {
; 5128 :         MUSIC_TIME mtTime;
; 5129 :         mtTime = (MUSIC_TIME) i64StopTime;

  000e1	8b 4d 10	 mov	 ecx, DWORD PTR _i64StopTime$[ebp]
  000e4	89 4d e8	 mov	 DWORD PTR _mtTime$71381[ebp], ecx

; 5130 :         
; 5131 :         return Stop(NULL,NULL,mtTime,dwFlags);

  000e7	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 e8	 mov	 eax, DWORD PTR _mtTime$71381[ebp]
  000ee	50		 push	 eax
  000ef	6a 00		 push	 0
  000f1	6a 00		 push	 0
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	50		 push	 eax
  000fc	ff 52 74	 call	 DWORD PTR [edx+116]
  000ff	e9 88 05 00 00	 jmp	 $L71352
$L71380:

; 5132 :     }
; 5133 :     if (dwFlags & DMUS_SEGF_AUTOTRANSITION)

  00104	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00107	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  0010d	85 c9		 test	 ecx, ecx
  0010f	0f 84 42 03 00
	00		 je	 $L71383

; 5134 :     {
; 5135 :         // I this is an autotransition, it will only work if the currently playing segment in question
; 5136 :         // is a member of a song. So, check the segstate, segment, song, and audiopath
; 5137 :         // to find the segstate. And, if found, see if it is part of a song. If so,
; 5138 :         // then go ahead and do the transition.
; 5139 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00115	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00118	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  0011e	52		 push	 edx
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5140 :         BOOL fTransition = FALSE;

  00125	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fTransition$71384[ebp], 0

; 5141 :         dwFlags &= ~DMUS_SEGF_AUTOTRANSITION;

  0012c	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0012f	25 ff ff ef ff	 and	 eax, -1048577		; ffefffffH
  00134	89 45 18	 mov	 DWORD PTR _dwFlags$[ebp], eax

; 5142 :         CSegState *pCState = NULL;

  00137	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pCState$71385[ebp], 0

; 5143 :         // First, see if this is a segstate.
; 5144 :         HRESULT hrTemp = pObjectToStop->QueryInterface(IID_CSegState,(void **)&pCState);

  0013e	8d 4d e4	 lea	 ecx, DWORD PTR _pCState$71385[ebp]
  00141	51		 push	 ecx
  00142	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegState
  00147	8b 55 0c	 mov	 edx, DWORD PTR _pObjectToStop$[ebp]
  0014a	8b 02		 mov	 eax, DWORD PTR [edx]
  0014c	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectToStop$[ebp]
  0014f	51		 push	 ecx
  00150	ff 10		 call	 DWORD PTR [eax]
  00152	89 45 dc	 mov	 DWORD PTR _hrTemp$71386[ebp], eax

; 5145 :         if (FAILED(hrTemp))

  00155	83 7d dc 00	 cmp	 DWORD PTR _hrTemp$71386[ebp], 0
  00159	0f 8d 5f 01 00
	00		 jge	 $L71389

; 5146 :         {
; 5147 :             // Segstate failed. Is this a Song? If so, find the first correlating segstate.
; 5148 :             CSong *pCSong = NULL;

  0015f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pCSong$71390[ebp], 0

; 5149 :             CAudioPath *pCAudioPath = NULL;

  00166	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pCAudioPath$71391[ebp], 0

; 5150 :             CSegment *pCSegment = NULL;

  0016d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pCSegment$71392[ebp], 0

; 5151 :             hrTemp = pObjectToStop->QueryInterface(IID_CSong,(void **)&pCSong);

  00174	8d 55 d0	 lea	 edx, DWORD PTR _pCSong$71390[ebp]
  00177	52		 push	 edx
  00178	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSong
  0017d	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  00180	8b 08		 mov	 ecx, DWORD PTR [eax]
  00182	8b 55 0c	 mov	 edx, DWORD PTR _pObjectToStop$[ebp]
  00185	52		 push	 edx
  00186	ff 11		 call	 DWORD PTR [ecx]
  00188	89 45 dc	 mov	 DWORD PTR _hrTemp$71386[ebp], eax

; 5152 :             if (FAILED(hrTemp))

  0018b	83 7d dc 00	 cmp	 DWORD PTR _hrTemp$71386[ebp], 0
  0018f	7d 17		 jge	 SHORT $L71395

; 5153 :             {
; 5154 :                 hrTemp = pObjectToStop->QueryInterface(IID_CSegment,(void **)&pCSegment);

  00191	8d 45 d8	 lea	 eax, DWORD PTR _pCSegment$71392[ebp]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegment
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectToStop$[ebp]
  0019d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019f	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  001a2	50		 push	 eax
  001a3	ff 12		 call	 DWORD PTR [edx]
  001a5	89 45 dc	 mov	 DWORD PTR _hrTemp$71386[ebp], eax
$L71395:

; 5155 :             }
; 5156 :             if (FAILED(hrTemp))

  001a8	83 7d dc 00	 cmp	 DWORD PTR _hrTemp$71386[ebp], 0
  001ac	7d 17		 jge	 SHORT $L71398

; 5157 :             {
; 5158 :                 hrTemp = pObjectToStop->QueryInterface(IID_CAudioPath,(void **)&pCAudioPath);

  001ae	8d 4d d4	 lea	 ecx, DWORD PTR _pCAudioPath$71391[ebp]
  001b1	51		 push	 ecx
  001b2	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  001b7	8b 55 0c	 mov	 edx, DWORD PTR _pObjectToStop$[ebp]
  001ba	8b 02		 mov	 eax, DWORD PTR [edx]
  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectToStop$[ebp]
  001bf	51		 push	 ecx
  001c0	ff 10		 call	 DWORD PTR [eax]
  001c2	89 45 dc	 mov	 DWORD PTR _hrTemp$71386[ebp], eax
$L71398:

; 5159 :             }
; 5160 :             if (SUCCEEDED(hrTemp))

  001c5	83 7d dc 00	 cmp	 DWORD PTR _hrTemp$71386[ebp], 0
  001c9	0f 8c b5 00 00
	00		 jl	 $L71401

; 5161 :             {
; 5162 :                 CSegState *pNode;
; 5163 :                 DWORD dwCount;
; 5164 :                 for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)

  001cf	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _dwCount$71403[ebp], 0
  001d6	eb 09		 jmp	 SHORT $L71404
$L71405:
  001d8	8b 55 cc	 mov	 edx, DWORD PTR _dwCount$71403[ebp]
  001db	83 c2 01	 add	 edx, 1
  001de	89 55 cc	 mov	 DWORD PTR _dwCount$71403[ebp], edx
$L71404:
  001e1	83 7d cc 08	 cmp	 DWORD PTR _dwCount$71403[ebp], 8
  001e5	0f 87 99 00 00
	00		 ja	 $L71401

; 5165 :                 {
; 5166 :                     for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  001eb	8b 45 cc	 mov	 eax, DWORD PTR _dwCount$71403[ebp]
  001ee	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  001f5	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001fa	89 45 c8	 mov	 DWORD PTR _pNode$71402[ebp], eax
  001fd	eb 0b		 jmp	 SHORT $L71407
$L71408:
  001ff	8b 4d c8	 mov	 ecx, DWORD PTR _pNode$71402[ebp]
  00202	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00207	89 45 c8	 mov	 DWORD PTR _pNode$71402[ebp], eax
$L71407:
  0020a	83 7d c8 00	 cmp	 DWORD PTR _pNode$71402[ebp], 0
  0020e	74 67		 je	 SHORT $L71409

; 5167 :                     {
; 5168 :                         if (pNode->m_fCanStop)

  00210	8b 55 c8	 mov	 edx, DWORD PTR _pNode$71402[ebp]
  00213	83 ba 1c 01 00
	00 00		 cmp	 DWORD PTR [edx+284], 0
  0021a	74 59		 je	 SHORT $L71410

; 5169 :                         {
; 5170 :                             // Can only do this if the segstate ultimately points to a song.
; 5171 :                             if (pNode->m_pSegment && pNode->m_pSegment->m_pSong)

  0021c	8b 45 c8	 mov	 eax, DWORD PTR _pNode$71402[ebp]
  0021f	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00223	74 50		 je	 SHORT $L71410
  00225	8b 4d c8	 mov	 ecx, DWORD PTR _pNode$71402[ebp]
  00228	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0022b	83 ba c8 03 00
	00 00		 cmp	 DWORD PTR [edx+968], 0
  00232	74 41		 je	 SHORT $L71410

; 5172 :                             {
; 5173 :                                 if ((pNode->m_pSegment == pCSegment) ||
; 5174 :                                     (pNode->m_pSegment->m_pSong == pCSong) ||
; 5175 :                                     (pCAudioPath && (pNode->m_pAudioPath == pCAudioPath)))

  00234	8b 45 c8	 mov	 eax, DWORD PTR _pNode$71402[ebp]
  00237	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0023a	3b 4d d8	 cmp	 ecx, DWORD PTR _pCSegment$71392[ebp]
  0023d	74 22		 je	 SHORT $L71413
  0023f	8b 55 c8	 mov	 edx, DWORD PTR _pNode$71402[ebp]
  00242	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00245	8b 88 c8 03 00
	00		 mov	 ecx, DWORD PTR [eax+968]
  0024b	3b 4d d0	 cmp	 ecx, DWORD PTR _pCSong$71390[ebp]
  0024e	74 11		 je	 SHORT $L71413
  00250	83 7d d4 00	 cmp	 DWORD PTR _pCAudioPath$71391[ebp], 0
  00254	74 1f		 je	 SHORT $L71410
  00256	8b 55 c8	 mov	 edx, DWORD PTR _pNode$71402[ebp]
  00259	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0025c	3b 45 d4	 cmp	 eax, DWORD PTR _pCAudioPath$71391[ebp]
  0025f	75 14		 jne	 SHORT $L71410
$L71413:

; 5176 :                                 {
; 5177 :                                     pCState = pNode;

  00261	8b 4d c8	 mov	 ecx, DWORD PTR _pNode$71402[ebp]
  00264	89 4d e4	 mov	 DWORD PTR _pCState$71385[ebp], ecx

; 5178 :                                     pCState->AddRef();

  00267	8b 55 e4	 mov	 edx, DWORD PTR _pCState$71385[ebp]
  0026a	8b 02		 mov	 eax, DWORD PTR [edx]
  0026c	8b 4d e4	 mov	 ecx, DWORD PTR _pCState$71385[ebp]
  0026f	51		 push	 ecx
  00270	ff 50 04	 call	 DWORD PTR [eax+4]

; 5179 :                                     break;

  00273	eb 02		 jmp	 SHORT $L71409
$L71410:

; 5180 :                                 }
; 5181 :                             }
; 5182 :                         }
; 5183 :                     }

  00275	eb 88		 jmp	 SHORT $L71408
$L71409:

; 5184 :                     if (pCState) break;

  00277	83 7d e4 00	 cmp	 DWORD PTR _pCState$71385[ebp], 0
  0027b	74 02		 je	 SHORT $L71414
  0027d	eb 05		 jmp	 SHORT $L71401
$L71414:

; 5185 :                 }

  0027f	e9 54 ff ff ff	 jmp	 $L71405
$L71401:

; 5186 :             }
; 5187 :             if (pCSong) pCSong->Release();

  00284	83 7d d0 00	 cmp	 DWORD PTR _pCSong$71390[ebp], 0
  00288	74 0e		 je	 SHORT $L71415
  0028a	8b 55 d0	 mov	 edx, DWORD PTR _pCSong$71390[ebp]
  0028d	8b 02		 mov	 eax, DWORD PTR [edx]
  0028f	8b 4d d0	 mov	 ecx, DWORD PTR _pCSong$71390[ebp]
  00292	51		 push	 ecx
  00293	ff 50 08	 call	 DWORD PTR [eax+8]

; 5188 :             else if (pCAudioPath) pCAudioPath->Release();

  00296	eb 26		 jmp	 SHORT $L71389
$L71415:
  00298	83 7d d4 00	 cmp	 DWORD PTR _pCAudioPath$71391[ebp], 0
  0029c	74 0e		 je	 SHORT $L71417
  0029e	8b 55 d4	 mov	 edx, DWORD PTR _pCAudioPath$71391[ebp]
  002a1	8b 02		 mov	 eax, DWORD PTR [edx]
  002a3	8b 4d d4	 mov	 ecx, DWORD PTR _pCAudioPath$71391[ebp]
  002a6	51		 push	 ecx
  002a7	ff 50 08	 call	 DWORD PTR [eax+8]

; 5189 :             else if (pCSegment) pCSegment->Release();

  002aa	eb 12		 jmp	 SHORT $L71389
$L71417:
  002ac	83 7d d8 00	 cmp	 DWORD PTR _pCSegment$71392[ebp], 0
  002b0	74 0c		 je	 SHORT $L71389
  002b2	8b 55 d8	 mov	 edx, DWORD PTR _pCSegment$71392[ebp]
  002b5	8b 02		 mov	 eax, DWORD PTR [edx]
  002b7	8b 4d d8	 mov	 ecx, DWORD PTR _pCSegment$71392[ebp]
  002ba	51		 push	 ecx
  002bb	ff 50 08	 call	 DWORD PTR [eax+8]
$L71389:

; 5190 :         }
; 5191 :         if (pCState)

  002be	83 7d e4 00	 cmp	 DWORD PTR _pCState$71385[ebp], 0
  002c2	0f 84 71 01 00
	00		 je	 $L71420

; 5192 :         {
; 5193 :             CSegment *pPriorSeg = pCState->m_pSegment;

  002c8	8b 55 e4	 mov	 edx, DWORD PTR _pCState$71385[ebp]
  002cb	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  002ce	89 45 c4	 mov	 DWORD PTR _pPriorSeg$71421[ebp], eax

; 5194 :             if (pPriorSeg)

  002d1	83 7d c4 00	 cmp	 DWORD PTR _pPriorSeg$71421[ebp], 0
  002d5	0f 84 52 01 00
	00		 je	 $L71422

; 5195 :             {
; 5196 :                 pSong = pPriorSeg->m_pSong;

  002db	8b 4d c4	 mov	 ecx, DWORD PTR _pPriorSeg$71421[ebp]
  002de	8b 91 c8 03 00
	00		 mov	 edx, DWORD PTR [ecx+968]
  002e4	89 55 ec	 mov	 DWORD PTR _pSong$[ebp], edx

; 5197 :                 if (pSong)

  002e7	83 7d ec 00	 cmp	 DWORD PTR _pSong$[ebp], 0
  002eb	0f 84 3c 01 00
	00		 je	 $L71422

; 5198 :                 {
; 5199 :                     // If this is an autotransition, compose a transition segment from the
; 5200 :                     // current position in the song and play it.
; 5201 :                     // This will, in turn, call stop on the song, so we don't need to do it here.
; 5202 :                     // First, calculate the time to start the transition.
; 5203 :                     REFERENCE_TIME rtTime;
; 5204 :                     if (i64StopTime == 0)

  002f1	8b 45 10	 mov	 eax, DWORD PTR _i64StopTime$[ebp]
  002f4	0b 45 14	 or	 eax, DWORD PTR _i64StopTime$[ebp+4]
  002f7	85 c0		 test	 eax, eax
  002f9	75 15		 jne	 SHORT $L71425

; 5205 :                     {
; 5206 :                         GetQueueTime( &rtTime );

  002fb	8d 4d a8	 lea	 ecx, DWORD PTR _rtTime$71424[ebp]
  002fe	51		 push	 ecx
  002ff	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00302	8b 02		 mov	 eax, DWORD PTR [edx]
  00304	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00307	51		 push	 ecx
  00308	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]

; 5207 :                     }
; 5208 :                     else if (dwFlags & DMUS_SEGF_REFTIME)

  0030e	eb 2c		 jmp	 SHORT $L71426
$L71425:
  00310	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00313	83 e2 40	 and	 edx, 64			; 00000040H
  00316	85 d2		 test	 edx, edx
  00318	74 0e		 je	 SHORT $L71427

; 5209 :                     {
; 5210 :                         rtTime = i64StopTime;

  0031a	8b 45 10	 mov	 eax, DWORD PTR _i64StopTime$[ebp]
  0031d	89 45 a8	 mov	 DWORD PTR _rtTime$71424[ebp], eax
  00320	8b 4d 14	 mov	 ecx, DWORD PTR _i64StopTime$[ebp+4]
  00323	89 4d ac	 mov	 DWORD PTR _rtTime$71424[ebp+4], ecx

; 5211 :                     }
; 5212 :                     else

  00326	eb 14		 jmp	 SHORT $L71426
$L71427:

; 5213 :                     {
; 5214 :                         MusicToReferenceTime((MUSIC_TIME) i64StopTime,&rtTime);

  00328	8d 55 a8	 lea	 edx, DWORD PTR _rtTime$71424[ebp]
  0032b	52		 push	 edx
  0032c	8b 45 10	 mov	 eax, DWORD PTR _i64StopTime$[ebp]
  0032f	50		 push	 eax
  00330	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00333	8b 11		 mov	 edx, DWORD PTR [ecx]
  00335	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00338	50		 push	 eax
  00339	ff 52 14	 call	 DWORD PTR [edx+20]
$L71426:

; 5215 :                     }
; 5216 :                     REFERENCE_TIME rtResolved;
; 5217 :                     GetResolvedTime(rtTime, &rtResolved,dwFlags);

  0033c	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0033f	51		 push	 ecx
  00340	8d 55 a0	 lea	 edx, DWORD PTR _rtResolved$71430[ebp]
  00343	52		 push	 edx
  00344	8b 45 ac	 mov	 eax, DWORD PTR _rtTime$71424[ebp+4]
  00347	50		 push	 eax
  00348	8b 4d a8	 mov	 ecx, DWORD PTR _rtTime$71424[ebp]
  0034b	51		 push	 ecx
  0034c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0034f	8b 02		 mov	 eax, DWORD PTR [edx]
  00351	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00354	51		 push	 ecx
  00355	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 5218 :                     MUSIC_TIME mtTime;  // Actual time to start transition.
; 5219 :                     ReferenceToMusicTime(rtResolved,&mtTime);

  0035b	8d 55 b0	 lea	 edx, DWORD PTR _mtTime$71431[ebp]
  0035e	52		 push	 edx
  0035f	8b 45 a4	 mov	 eax, DWORD PTR _rtResolved$71430[ebp+4]
  00362	50		 push	 eax
  00363	8b 4d a0	 mov	 ecx, DWORD PTR _rtResolved$71430[ebp]
  00366	51		 push	 ecx
  00367	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0036a	8b 02		 mov	 eax, DWORD PTR [edx]
  0036c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0036f	51		 push	 ecx
  00370	ff 50 18	 call	 DWORD PTR [eax+24]

; 5220 : 
; 5221 :                     CSegment *pTransition = NULL;

  00373	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pTransition$71432[ebp], 0

; 5222 :                     // Now, get the transition.
; 5223 :                     DMUS_IO_TRANSITION_DEF Transition;
; 5224 :                     if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,NULL,&Transition)))

  0037a	8d 55 b8	 lea	 edx, DWORD PTR _Transition$71433[ebp]
  0037d	52		 push	 edx
  0037e	6a 00		 push	 0
  00380	8b 45 c4	 mov	 eax, DWORD PTR _pPriorSeg$71421[ebp]
  00383	50		 push	 eax
  00384	8b 4d ec	 mov	 ecx, DWORD PTR _pSong$[ebp]
  00387	e8 00 00 00 00	 call	 ?GetTransitionSegment@CSong@@QAEJPAVCSegment@@0PAU_DMUS_IO_TRANSITION_DEF@@@Z ; CSong::GetTransitionSegment
  0038c	85 c0		 test	 eax, eax
  0038e	7c 20		 jl	 SHORT $L71435

; 5225 :                     {
; 5226 :                         if (Transition.dwTransitionID != DMUS_SONG_NOSEG)

  00390	83 7d bc ff	 cmp	 DWORD PTR _Transition$71433[ebp+4], -1
  00394	74 1a		 je	 SHORT $L71435

; 5227 :                         {
; 5228 :                             if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))

  00396	8d 4d b4	 lea	 ecx, DWORD PTR _pTransition$71432[ebp]
  00399	51		 push	 ecx
  0039a	8b 55 bc	 mov	 edx, DWORD PTR _Transition$71433[ebp+4]
  0039d	52		 push	 edx
  0039e	8b 4d ec	 mov	 ecx, DWORD PTR _pSong$[ebp]
  003a1	e8 00 00 00 00	 call	 ?GetPlaySegment@CSong@@QAEJKPAPAVCSegment@@@Z ; CSong::GetPlaySegment
  003a6	85 c0		 test	 eax, eax
  003a8	75 06		 jne	 SHORT $L71435

; 5229 :                             {
; 5230 :                                 dwFlags = Transition.dwPlayFlags;

  003aa	8b 45 c0	 mov	 eax, DWORD PTR _Transition$71433[ebp+8]
  003ad	89 45 18	 mov	 DWORD PTR _dwFlags$[ebp], eax
$L71435:

; 5231 :                             }
; 5232 :                         }
; 5233 :                     }
; 5234 :                     if (pTransition)

  003b0	83 7d b4 00	 cmp	 DWORD PTR _pTransition$71432[ebp], 0
  003b4	74 77		 je	 SHORT $L71422

; 5235 :                     {
; 5236 :                         IDirectMusicSegment *pITransSegment = NULL;

  003b6	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _pITransSegment$71440[ebp], 0

; 5237 :                         pTransition->Compose(mtTime - pCState->m_mtOffset, pPriorSeg, NULL, &pITransSegment);

  003bd	8d 4d 9c	 lea	 ecx, DWORD PTR _pITransSegment$71440[ebp]
  003c0	51		 push	 ecx
  003c1	6a 00		 push	 0
  003c3	8b 55 c4	 mov	 edx, DWORD PTR _pPriorSeg$71421[ebp]
  003c6	52		 push	 edx
  003c7	8b 45 e4	 mov	 eax, DWORD PTR _pCState$71385[ebp]
  003ca	8b 4d b0	 mov	 ecx, DWORD PTR _mtTime$71431[ebp]
  003cd	2b 48 6c	 sub	 ecx, DWORD PTR [eax+108]
  003d0	51		 push	 ecx
  003d1	8b 55 b4	 mov	 edx, DWORD PTR _pTransition$71432[ebp]
  003d4	8b 02		 mov	 eax, DWORD PTR [edx]
  003d6	8b 4d b4	 mov	 ecx, DWORD PTR _pTransition$71432[ebp]
  003d9	51		 push	 ecx
  003da	ff 50 10	 call	 DWORD PTR [eax+16]

; 5238 :                         // Now, if we successfully composed a transition segment, set it up to be the one we
; 5239 :                         // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
; 5240 :                         // to play after the transition.
; 5241 :                         if (pITransSegment)

  003dd	83 7d 9c 00	 cmp	 DWORD PTR _pITransSegment$71440[ebp], 0
  003e1	74 3e		 je	 SHORT $L71441

; 5242 :                         {
; 5243 :                             hr = PlaySegmentEx(pITransSegment,NULL,NULL,dwFlags,i64StopTime,NULL,(IDirectMusicSegmentState *)pCState,NULL);

  003e3	6a 00		 push	 0
  003e5	8b 55 e4	 mov	 edx, DWORD PTR _pCState$71385[ebp]
  003e8	52		 push	 edx
  003e9	6a 00		 push	 0
  003eb	8b 45 14	 mov	 eax, DWORD PTR _i64StopTime$[ebp+4]
  003ee	50		 push	 eax
  003ef	8b 4d 10	 mov	 ecx, DWORD PTR _i64StopTime$[ebp]
  003f2	51		 push	 ecx
  003f3	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  003f6	52		 push	 edx
  003f7	6a 00		 push	 0
  003f9	6a 00		 push	 0
  003fb	8b 45 9c	 mov	 eax, DWORD PTR _pITransSegment$71440[ebp]
  003fe	50		 push	 eax
  003ff	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00402	8b 11		 mov	 edx, DWORD PTR [ecx]
  00404	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00407	50		 push	 eax
  00408	ff 52 40	 call	 DWORD PTR [edx+64]
  0040b	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 5244 :                             pITransSegment->Release();

  0040e	8b 4d 9c	 mov	 ecx, DWORD PTR _pITransSegment$71440[ebp]
  00411	8b 11		 mov	 edx, DWORD PTR [ecx]
  00413	8b 45 9c	 mov	 eax, DWORD PTR _pITransSegment$71440[ebp]
  00416	50		 push	 eax
  00417	ff 52 08	 call	 DWORD PTR [edx+8]

; 5245 :                             fTransition = TRUE;

  0041a	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fTransition$71384[ebp], 1
$L71441:

; 5246 :                         }
; 5247 :                         pTransition->Release();

  00421	8b 4d b4	 mov	 ecx, DWORD PTR _pTransition$71432[ebp]
  00424	8b 11		 mov	 edx, DWORD PTR [ecx]
  00426	8b 45 b4	 mov	 eax, DWORD PTR _pTransition$71432[ebp]
  00429	50		 push	 eax
  0042a	ff 52 08	 call	 DWORD PTR [edx+8]
$L71422:

; 5248 :                     }
; 5249 :                 }
; 5250 :             }
; 5251 :             pCState->Release();

  0042d	8b 4d e4	 mov	 ecx, DWORD PTR _pCState$71385[ebp]
  00430	8b 11		 mov	 edx, DWORD PTR [ecx]
  00432	8b 45 e4	 mov	 eax, DWORD PTR _pCState$71385[ebp]
  00435	50		 push	 eax
  00436	ff 52 08	 call	 DWORD PTR [edx+8]
$L71420:

; 5252 :         }
; 5253 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00439	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0043c	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00442	51		 push	 ecx
  00443	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5254 :         if (fTransition)

  00449	83 7d e0 00	 cmp	 DWORD PTR _fTransition$71384[ebp], 0
  0044d	74 08		 je	 SHORT $L71383

; 5255 :         {
; 5256 :             return hr;

  0044f	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00452	e9 35 02 00 00	 jmp	 $L71352
$L71383:

; 5257 :         }
; 5258 :     }
; 5259 :     if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegmentState,(void **) &pState)))

  00457	8d 55 f4	 lea	 edx, DWORD PTR _pState$[ebp]
  0045a	52		 push	 edx
  0045b	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegmentState
  00460	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  00463	8b 08		 mov	 ecx, DWORD PTR [eax]
  00465	8b 55 0c	 mov	 edx, DWORD PTR _pObjectToStop$[ebp]
  00468	52		 push	 edx
  00469	ff 11		 call	 DWORD PTR [ecx]
  0046b	85 c0		 test	 eax, eax
  0046d	7c 2e		 jl	 SHORT $L71446

; 5260 :     {
; 5261 :         hr = Stop(NULL,pState,(MUSIC_TIME)i64StopTime,dwFlags);

  0046f	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00472	50		 push	 eax
  00473	8b 4d 10	 mov	 ecx, DWORD PTR _i64StopTime$[ebp]
  00476	51		 push	 ecx
  00477	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  0047a	52		 push	 edx
  0047b	6a 00		 push	 0
  0047d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00480	8b 08		 mov	 ecx, DWORD PTR [eax]
  00482	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00485	52		 push	 edx
  00486	ff 51 74	 call	 DWORD PTR [ecx+116]
  00489	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 5262 :         pState->Release();

  0048c	8b 45 f4	 mov	 eax, DWORD PTR _pState$[ebp]
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	8b 55 f4	 mov	 edx, DWORD PTR _pState$[ebp]
  00494	52		 push	 edx
  00495	ff 51 08	 call	 DWORD PTR [ecx+8]

; 5263 :     }
; 5264 :     else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegment,(void **) &pSegment)))

  00498	e9 d8 01 00 00	 jmp	 $L71448
$L71446:
  0049d	8d 45 f8	 lea	 eax, DWORD PTR _pSegment$[ebp]
  004a0	50		 push	 eax
  004a1	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegment
  004a6	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectToStop$[ebp]
  004a9	8b 11		 mov	 edx, DWORD PTR [ecx]
  004ab	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  004ae	50		 push	 eax
  004af	ff 12		 call	 DWORD PTR [edx]
  004b1	85 c0		 test	 eax, eax
  004b3	7c 2e		 jl	 SHORT $L71451

; 5265 :     {
; 5266 :         hr = Stop(pSegment,NULL,(MUSIC_TIME)i64StopTime,dwFlags);

  004b5	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  004b8	51		 push	 ecx
  004b9	8b 55 10	 mov	 edx, DWORD PTR _i64StopTime$[ebp]
  004bc	52		 push	 edx
  004bd	6a 00		 push	 0
  004bf	8b 45 f8	 mov	 eax, DWORD PTR _pSegment$[ebp]
  004c2	50		 push	 eax
  004c3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  004c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  004c8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  004cb	50		 push	 eax
  004cc	ff 52 74	 call	 DWORD PTR [edx+116]
  004cf	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 5267 :         pSegment->Release();

  004d2	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  004d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  004d7	8b 45 f8	 mov	 eax, DWORD PTR _pSegment$[ebp]
  004da	50		 push	 eax
  004db	ff 52 08	 call	 DWORD PTR [edx+8]

; 5268 :     }
; 5269 :     else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CAudioPath,(void **) &pAudioPath)))

  004de	e9 92 01 00 00	 jmp	 $L71448
$L71451:
  004e3	8d 4d fc	 lea	 ecx, DWORD PTR _pAudioPath$[ebp]
  004e6	51		 push	 ecx
  004e7	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  004ec	8b 55 0c	 mov	 edx, DWORD PTR _pObjectToStop$[ebp]
  004ef	8b 02		 mov	 eax, DWORD PTR [edx]
  004f1	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectToStop$[ebp]
  004f4	51		 push	 ecx
  004f5	ff 10		 call	 DWORD PTR [eax]
  004f7	85 c0		 test	 eax, eax
  004f9	0f 8c ac 00 00
	00		 jl	 $L71456

; 5270 :     {
; 5271 :         pAudioPath->Release();

  004ff	8b 55 fc	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  00502	8b 02		 mov	 eax, DWORD PTR [edx]
  00504	8b 4d fc	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00507	51		 push	 ecx
  00508	ff 50 08	 call	 DWORD PTR [eax+8]

; 5272 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  0050b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0050e	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00514	52		 push	 edx
  00515	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5273 :         CSegState *pNode;
; 5274 :         DWORD dwCount;
; 5275 :         for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)

  0051b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _dwCount$71458[ebp], 0
  00522	eb 09		 jmp	 SHORT $L71459
$L71460:
  00524	8b 45 98	 mov	 eax, DWORD PTR _dwCount$71458[ebp]
  00527	83 c0 01	 add	 eax, 1
  0052a	89 45 98	 mov	 DWORD PTR _dwCount$71458[ebp], eax
$L71459:
  0052d	83 7d 98 08	 cmp	 DWORD PTR _dwCount$71458[ebp], 8
  00531	77 63		 ja	 SHORT $L71461

; 5276 :         {
; 5277 :             CSegState *pNext;
; 5278 :             for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNext )

  00533	8b 4d 98	 mov	 ecx, DWORD PTR _dwCount$71458[ebp]
  00536	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00539	8d 4c ca 44	 lea	 ecx, DWORD PTR [edx+ecx*8+68]
  0053d	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00542	89 45 94	 mov	 DWORD PTR _pNode$71457[ebp], eax
  00545	eb 06		 jmp	 SHORT $L71463
$L71464:
  00547	8b 45 90	 mov	 eax, DWORD PTR _pNext$71462[ebp]
  0054a	89 45 94	 mov	 DWORD PTR _pNode$71457[ebp], eax
$L71463:
  0054d	83 7d 94 00	 cmp	 DWORD PTR _pNode$71457[ebp], 0
  00551	74 41		 je	 SHORT $L71465

; 5279 :             {
; 5280 :                 pNext = pNode->GetNext();

  00553	8b 4d 94	 mov	 ecx, DWORD PTR _pNode$71457[ebp]
  00556	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0055b	89 45 90	 mov	 DWORD PTR _pNext$71462[ebp], eax

; 5281 :                 if (pNode->m_fCanStop && (pNode->m_pAudioPath == pAudioPath))

  0055e	8b 4d 94	 mov	 ecx, DWORD PTR _pNode$71457[ebp]
  00561	83 b9 1c 01 00
	00 00		 cmp	 DWORD PTR [ecx+284], 0
  00568	74 28		 je	 SHORT $L71466
  0056a	8b 55 94	 mov	 edx, DWORD PTR _pNode$71457[ebp]
  0056d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00570	3b 45 fc	 cmp	 eax, DWORD PTR _pAudioPath$[ebp]
  00573	75 1d		 jne	 SHORT $L71466

; 5282 :                 {
; 5283 :                     hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);

  00575	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00578	51		 push	 ecx
  00579	8b 55 10	 mov	 edx, DWORD PTR _i64StopTime$[ebp]
  0057c	52		 push	 edx
  0057d	8b 45 94	 mov	 eax, DWORD PTR _pNode$71457[ebp]
  00580	50		 push	 eax
  00581	6a 00		 push	 0
  00583	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00586	8b 11		 mov	 edx, DWORD PTR [ecx]
  00588	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0058b	50		 push	 eax
  0058c	ff 52 74	 call	 DWORD PTR [edx+116]
  0058f	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L71466:

; 5284 :                 }
; 5285 :             }

  00592	eb b3		 jmp	 SHORT $L71464
$L71465:

; 5286 :         }

  00594	eb 8e		 jmp	 SHORT $L71460
$L71461:

; 5287 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00596	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00599	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  0059f	51		 push	 ecx
  005a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5288 :     }
; 5289 :     else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CSong,(void **) &pSong)))

  005a6	e9 ca 00 00 00	 jmp	 $L71448
$L71456:
  005ab	8d 55 ec	 lea	 edx, DWORD PTR _pSong$[ebp]
  005ae	52		 push	 edx
  005af	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSong
  005b4	8b 45 0c	 mov	 eax, DWORD PTR _pObjectToStop$[ebp]
  005b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  005b9	8b 55 0c	 mov	 edx, DWORD PTR _pObjectToStop$[ebp]
  005bc	52		 push	 edx
  005bd	ff 11		 call	 DWORD PTR [ecx]
  005bf	85 c0		 test	 eax, eax
  005c1	0f 8c ae 00 00
	00		 jl	 $L71448

; 5290 :     {
; 5291 :         pSong->Release();

  005c7	8b 45 ec	 mov	 eax, DWORD PTR _pSong$[ebp]
  005ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  005cc	8b 55 ec	 mov	 edx, DWORD PTR _pSong$[ebp]
  005cf	52		 push	 edx
  005d0	ff 51 08	 call	 DWORD PTR [ecx+8]

; 5292 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  005d3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  005d6	05 14 03 00 00	 add	 eax, 788		; 00000314H
  005db	50		 push	 eax
  005dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5293 :         CSegState *pNode;
; 5294 :         DWORD dwCount;
; 5295 :         for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)

  005e2	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _dwCount$71474[ebp], 0
  005e9	eb 09		 jmp	 SHORT $L71475
$L71476:
  005eb	8b 4d 8c	 mov	 ecx, DWORD PTR _dwCount$71474[ebp]
  005ee	83 c1 01	 add	 ecx, 1
  005f1	89 4d 8c	 mov	 DWORD PTR _dwCount$71474[ebp], ecx
$L71475:
  005f4	83 7d 8c 08	 cmp	 DWORD PTR _dwCount$71474[ebp], 8
  005f8	77 6c		 ja	 SHORT $L71477

; 5296 :         {
; 5297 :             for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  005fa	8b 55 8c	 mov	 edx, DWORD PTR _dwCount$71474[ebp]
  005fd	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00600	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  00604	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00609	89 45 88	 mov	 DWORD PTR _pNode$71473[ebp], eax
  0060c	eb 0b		 jmp	 SHORT $L71478
$L71479:
  0060e	8b 4d 88	 mov	 ecx, DWORD PTR _pNode$71473[ebp]
  00611	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00616	89 45 88	 mov	 DWORD PTR _pNode$71473[ebp], eax
$L71478:
  00619	83 7d 88 00	 cmp	 DWORD PTR _pNode$71473[ebp], 0
  0061d	74 45		 je	 SHORT $L71480

; 5298 :             {
; 5299 :                 if (pNode->m_fCanStop && pNode->m_pSegment && (pNode->m_pSegment->m_pSong == pSong))

  0061f	8b 4d 88	 mov	 ecx, DWORD PTR _pNode$71473[ebp]
  00622	83 b9 1c 01 00
	00 00		 cmp	 DWORD PTR [ecx+284], 0
  00629	74 37		 je	 SHORT $L71481
  0062b	8b 55 88	 mov	 edx, DWORD PTR _pNode$71473[ebp]
  0062e	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00632	74 2e		 je	 SHORT $L71481
  00634	8b 45 88	 mov	 eax, DWORD PTR _pNode$71473[ebp]
  00637	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0063a	8b 91 c8 03 00
	00		 mov	 edx, DWORD PTR [ecx+968]
  00640	3b 55 ec	 cmp	 edx, DWORD PTR _pSong$[ebp]
  00643	75 1d		 jne	 SHORT $L71481

; 5300 :                 {
; 5301 :                     hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);

  00645	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00648	50		 push	 eax
  00649	8b 4d 10	 mov	 ecx, DWORD PTR _i64StopTime$[ebp]
  0064c	51		 push	 ecx
  0064d	8b 55 88	 mov	 edx, DWORD PTR _pNode$71473[ebp]
  00650	52		 push	 edx
  00651	6a 00		 push	 0
  00653	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00656	8b 08		 mov	 ecx, DWORD PTR [eax]
  00658	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0065b	52		 push	 edx
  0065c	ff 51 74	 call	 DWORD PTR [ecx+116]
  0065f	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L71481:

; 5302 :                 }
; 5303 :             }

  00662	eb aa		 jmp	 SHORT $L71479
$L71480:

; 5304 :         }

  00664	eb 85		 jmp	 SHORT $L71476
$L71477:

; 5305 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00666	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00669	05 14 03 00 00	 add	 eax, 788		; 00000314H
  0066e	50		 push	 eax
  0066f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L71448:

; 5306 :     }
; 5307 : #ifdef XBOX // Need to force some real time processing so the notes get cut off.
; 5308 :     g_BossMan.WakeUp(m_pRealtimeWorker);

  00675	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00678	8b 91 c0 03 00
	00		 mov	 edx, DWORD PTR [ecx+960]
  0067e	52		 push	 edx
  0067f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00684	e8 00 00 00 00	 call	 ?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z ; CBossMan::WakeUp

; 5309 : #endif
; 5310 :     return hr;

  00689	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
$L71352:

; 5311 : }

  0068c	8b e5		 mov	 esp, ebp
  0068e	5d		 pop	 ebp
  0068f	c2 14 00	 ret	 20			; 00000014H
?StopEx@CPerformance@@UAGJPAUIUnknown@@_JK@Z ENDP	; CPerformance::StopEx
_TEXT	ENDS
PUBLIC	??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@ ; `string'
PUBLIC	??_C@_0DM@NGMKGFAE@Error?3?5Pointer?5in?5SegState?5param@ ; `string'
PUBLIC	??_C@_0DL@ICEJHAPA@Error?3?5Pointer?5in?5Segment?5parame@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::Stop', 00H		; `CPerformance::Stop'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@
CONST	SEGMENT
??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@ DB '%s: In'
	DB	'valid pointer pISegment', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@
CONST	SEGMENT
??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@ DB '%s: Inval'
	DB	'id pointer pISegmentState', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NGMKGFAE@Error?3?5Pointer?5in?5SegState?5param@
CONST	SEGMENT
??_C@_0DM@NGMKGFAE@Error?3?5Pointer?5in?5SegState?5param@ DB 'Error: Poin'
	DB	'ter in SegState parameter to Stop() is invalid.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ICEJHAPA@Error?3?5Pointer?5in?5Segment?5parame@
CONST	SEGMENT
??_C@_0DL@ICEJHAPA@Error?3?5Pointer?5in?5Segment?5parame@ DB 'Error: Poin'
	DB	'ter in Segment parameter to Stop() is invalid.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z
_TEXT	SEGMENT
_pNode$71557 = -48
_dwCount$71558 = -44
_pSegTemp$71544 = -40
_dwNewRes$71540 = -36
_pNode$71530 = -32
_dwCount$71531 = -28
_mtLatency$ = -24
_pSegmentState$ = -20
_rtQueueTime$ = -16
_pSegment$ = -4
_this$ = 8
_pISegment$ = 12
_pISegmentState$ = 16
_mtTime$ = 20
_dwFlags$ = 24
?Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z PROC NEAR ; CPerformance::Stop, COMDAT

; 5325 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 5326 :     V_INAME(IDirectMusicPerformance::Stop);
; 5327 :     V_INTERFACE_OPT(pISegment);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pISegment$[ebp], 0
  0000a	74 7c		 je	 SHORT $L71493
  0000c	6a 04		 push	 4
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _pISegment$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L71495
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L71495:
  00034	6a 04		 push	 4
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _pISegment$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $L71499
  00045	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@
  0004f	6a ff		 push	 -1
  00051	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 _DebugBreak@0
$L71499:
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _pISegment$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0006b	85 c0		 test	 eax, eax
  0006d	74 19		 je	 SHORT $L71493
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BLMIOKLA@?$CFs?3?5Invalid?5pointer?5pISegment?6?$AA@
  00079	6a ff		 push	 -1
  0007b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	e8 00 00 00 00	 call	 _DebugBreak@0
$L71493:

; 5328 :     V_INTERFACE_OPT(pISegmentState);

  00088	83 7d 10 00	 cmp	 DWORD PTR _pISegmentState$[ebp], 0
  0008c	74 7c		 je	 SHORT $L71502
  0008e	6a 04		 push	 4
  00090	8b 45 10	 mov	 eax, DWORD PTR _pISegmentState$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00099	85 c0		 test	 eax, eax
  0009b	74 19		 je	 SHORT $L71504
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@
  000a7	6a ff		 push	 -1
  000a9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	e8 00 00 00 00	 call	 _DebugBreak@0
$L71504:
  000b6	6a 04		 push	 4
  000b8	8b 4d 10	 mov	 ecx, DWORD PTR _pISegmentState$[ebp]
  000bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000c3	85 c0		 test	 eax, eax
  000c5	74 19		 je	 SHORT $L71508
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@
  000d1	6a ff		 push	 -1
  000d3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	e8 00 00 00 00	 call	 _DebugBreak@0
$L71508:
  000e0	8b 45 10	 mov	 eax, DWORD PTR _pISegmentState$[ebp]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  000ed	85 c0		 test	 eax, eax
  000ef	74 19		 je	 SHORT $L71502
  000f1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z@4QBDB
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@ENINMOOO@?$CFs?3?5Invalid?5pointer?5pISegmentSta@
  000fb	6a ff		 push	 -1
  000fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	e8 00 00 00 00	 call	 _DebugBreak@0
$L71502:

; 5329 : 
; 5330 : 
; 5331 :     CSegment *pSegment = NULL;

  0010a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pSegment$[ebp], 0

; 5332 :     CSegState *pSegmentState = NULL; 

  00111	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pSegmentState$[ebp], 0

; 5333 : TraceI(0,"Stopping Segment %lx, SegState %lx at time %ld, flags %lx\n",pISegment,pISegmentState,mtTime,dwFlags);
; 5334 :     if (pISegmentState)

  00118	83 7d 10 00	 cmp	 DWORD PTR _pISegmentState$[ebp], 0
  0011c	74 3f		 je	 SHORT $L71514

; 5335 :     {
; 5336 :         if (SUCCEEDED(pISegmentState->QueryInterface(IID_CSegState,(void **)&pSegmentState)))

  0011e	8d 45 ec	 lea	 eax, DWORD PTR _pSegmentState$[ebp]
  00121	50		 push	 eax
  00122	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegState
  00127	8b 4d 10	 mov	 ecx, DWORD PTR _pISegmentState$[ebp]
  0012a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012c	8b 45 10	 mov	 eax, DWORD PTR _pISegmentState$[ebp]
  0012f	50		 push	 eax
  00130	ff 12		 call	 DWORD PTR [edx]
  00132	85 c0		 test	 eax, eax
  00134	7c 0e		 jl	 SHORT $L71517

; 5337 :         {
; 5338 :             pISegmentState->Release();

  00136	8b 4d 10	 mov	 ecx, DWORD PTR _pISegmentState$[ebp]
  00139	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013b	8b 45 10	 mov	 eax, DWORD PTR _pISegmentState$[ebp]
  0013e	50		 push	 eax
  0013f	ff 52 08	 call	 DWORD PTR [edx+8]

; 5339 :         }
; 5340 :         else

  00142	eb 19		 jmp	 SHORT $L71514
$L71517:

; 5341 :         {
; 5342 :             Trace(0,"Error: Pointer in SegState parameter to Stop() is invalid.\n");

  00144	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@NGMKGFAE@Error?3?5Pointer?5in?5SegState?5param@
  00149	6a 00		 push	 0
  0014b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00150	83 c4 08	 add	 esp, 8

; 5343 :             return E_INVALIDARG;

  00153	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00158	e9 d8 02 00 00	 jmp	 $L71490
$L71514:

; 5344 :         }
; 5345 :     }
; 5346 :     if (pISegment)

  0015d	83 7d 0c 00	 cmp	 DWORD PTR _pISegment$[ebp], 0
  00161	74 3f		 je	 SHORT $L71521

; 5347 :     {
; 5348 :         if (SUCCEEDED(pISegment->QueryInterface(IID_CSegment,(void **)&pSegment)))

  00163	8d 4d fc	 lea	 ecx, DWORD PTR _pSegment$[ebp]
  00166	51		 push	 ecx
  00167	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegment
  0016c	8b 55 0c	 mov	 edx, DWORD PTR _pISegment$[ebp]
  0016f	8b 02		 mov	 eax, DWORD PTR [edx]
  00171	8b 4d 0c	 mov	 ecx, DWORD PTR _pISegment$[ebp]
  00174	51		 push	 ecx
  00175	ff 10		 call	 DWORD PTR [eax]
  00177	85 c0		 test	 eax, eax
  00179	7c 0e		 jl	 SHORT $L71524

; 5349 :         {
; 5350 :             pISegment->Release();

  0017b	8b 55 0c	 mov	 edx, DWORD PTR _pISegment$[ebp]
  0017e	8b 02		 mov	 eax, DWORD PTR [edx]
  00180	8b 4d 0c	 mov	 ecx, DWORD PTR _pISegment$[ebp]
  00183	51		 push	 ecx
  00184	ff 50 08	 call	 DWORD PTR [eax+8]

; 5351 :         }
; 5352 :         else

  00187	eb 19		 jmp	 SHORT $L71521
$L71524:

; 5353 :         {
; 5354 :             Trace(0,"Error: Pointer in Segment parameter to Stop() is invalid.\n");

  00189	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@ICEJHAPA@Error?3?5Pointer?5in?5Segment?5parame@
  0018e	6a 00		 push	 0
  00190	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00195	83 c4 08	 add	 esp, 8

; 5355 :             return E_INVALIDARG;

  00198	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0019d	e9 93 02 00 00	 jmp	 $L71490
$L71521:

; 5356 :         }
; 5357 :     }
; 5358 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  001a2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001a5	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  001ab	52		 push	 edx
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5359 :     ENTER_API_CRITICAL_SECTION;
; 5360 :     if (pSegmentState)

  001b2	83 7d ec 00	 cmp	 DWORD PTR _pSegmentState$[ebp], 0
  001b6	74 6a		 je	 SHORT $L71528

; 5361 :     {
; 5362 :         // If this is the starting segstate from a playing song, find the
; 5363 :         // current active segstate within that song.
; 5364 :         // The current active segstate keeps a pointer to 
; 5365 :         // this segstate.
; 5366 :         if (pSegmentState->m_fSongMode)

  001b8	8b 45 ec	 mov	 eax, DWORD PTR _pSegmentState$[ebp]
  001bb	83 b8 18 01 00
	00 00		 cmp	 DWORD PTR [eax+280], 0
  001c2	74 5e		 je	 SHORT $L71528

; 5367 :         {
; 5368 :             CSegState* pNode;
; 5369 :             DWORD dwCount;
; 5370 :             for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)

  001c4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwCount$71531[ebp], 0
  001cb	eb 09		 jmp	 SHORT $L71532
$L71533:
  001cd	8b 4d e4	 mov	 ecx, DWORD PTR _dwCount$71531[ebp]
  001d0	83 c1 01	 add	 ecx, 1
  001d3	89 4d e4	 mov	 DWORD PTR _dwCount$71531[ebp], ecx
$L71532:
  001d6	83 7d e4 09	 cmp	 DWORD PTR _dwCount$71531[ebp], 9
  001da	73 46		 jae	 SHORT $L71528

; 5371 :             {
; 5372 :                 for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  001dc	8b 55 e4	 mov	 edx, DWORD PTR _dwCount$71531[ebp]
  001df	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  001e6	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001eb	89 45 e0	 mov	 DWORD PTR _pNode$71530[ebp], eax
  001ee	eb 0b		 jmp	 SHORT $L71535
$L71536:
  001f0	8b 4d e0	 mov	 ecx, DWORD PTR _pNode$71530[ebp]
  001f3	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  001f8	89 45 e0	 mov	 DWORD PTR _pNode$71530[ebp], eax
$L71535:
  001fb	83 7d e0 00	 cmp	 DWORD PTR _pNode$71530[ebp], 0
  001ff	74 1f		 je	 SHORT $L71537

; 5373 :                 {
; 5374 :                     if (pNode->m_pSongSegState == pSegmentState)

  00201	8b 4d e0	 mov	 ecx, DWORD PTR _pNode$71530[ebp]
  00204	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  0020a	3b 55 ec	 cmp	 edx, DWORD PTR _pSegmentState$[ebp]
  0020d	75 0f		 jne	 SHORT $L71538

; 5375 :                     {
; 5376 :                         pSegmentState = pNode;

  0020f	8b 45 e0	 mov	 eax, DWORD PTR _pNode$71530[ebp]
  00212	89 45 ec	 mov	 DWORD PTR _pSegmentState$[ebp], eax

; 5377 :                         dwCount = SQ_COUNT;

  00215	c7 45 e4 09 00
	00 00		 mov	 DWORD PTR _dwCount$71531[ebp], 9

; 5378 :                         break;

  0021c	eb 02		 jmp	 SHORT $L71537
$L71538:

; 5379 :                     }
; 5380 :                 }

  0021e	eb d0		 jmp	 SHORT $L71536
$L71537:

; 5381 :             }

  00220	eb ab		 jmp	 SHORT $L71533
$L71528:

; 5382 :         }
; 5383 :     }
; 5384 :     if( dwFlags & DMUS_SEGF_DEFAULT )

  00222	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00225	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0022b	85 c9		 test	 ecx, ecx
  0022d	74 7b		 je	 SHORT $L71539

; 5385 :     {
; 5386 :         DWORD   dwNewRes = 0;

  0022f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwNewRes$71540[ebp], 0

; 5387 :         if( pSegment )

  00236	83 7d fc 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  0023a	74 12		 je	 SHORT $L71541

; 5388 :         {
; 5389 :             pSegment->GetDefaultResolution( &dwNewRes );

  0023c	8d 55 dc	 lea	 edx, DWORD PTR _dwNewRes$71540[ebp]
  0023f	52		 push	 edx
  00240	8b 45 fc	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00243	8b 08		 mov	 ecx, DWORD PTR [eax]
  00245	8b 55 fc	 mov	 edx, DWORD PTR _pSegment$[ebp]
  00248	52		 push	 edx
  00249	ff 51 4c	 call	 DWORD PTR [ecx+76]

; 5390 :         }
; 5391 :         else if( pSegmentState )

  0024c	eb 48		 jmp	 SHORT $L71542
$L71541:
  0024e	83 7d ec 00	 cmp	 DWORD PTR _pSegmentState$[ebp], 0
  00252	74 3b		 je	 SHORT $L71543

; 5392 :         {
; 5393 :             IDirectMusicSegment*    pSegTemp;
; 5394 :             if( SUCCEEDED( pSegmentState->GetSegment( &pSegTemp ) ) )

  00254	8d 45 d8	 lea	 eax, DWORD PTR _pSegTemp$71544[ebp]
  00257	50		 push	 eax
  00258	8b 4d ec	 mov	 ecx, DWORD PTR _pSegmentState$[ebp]
  0025b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025d	8b 45 ec	 mov	 eax, DWORD PTR _pSegmentState$[ebp]
  00260	50		 push	 eax
  00261	ff 52 18	 call	 DWORD PTR [edx+24]
  00264	85 c0		 test	 eax, eax
  00266	7c 1e		 jl	 SHORT $L71546

; 5395 :             {
; 5396 :                 pSegTemp->GetDefaultResolution( &dwNewRes );

  00268	8d 4d dc	 lea	 ecx, DWORD PTR _dwNewRes$71540[ebp]
  0026b	51		 push	 ecx
  0026c	8b 55 d8	 mov	 edx, DWORD PTR _pSegTemp$71544[ebp]
  0026f	8b 02		 mov	 eax, DWORD PTR [edx]
  00271	8b 4d d8	 mov	 ecx, DWORD PTR _pSegTemp$71544[ebp]
  00274	51		 push	 ecx
  00275	ff 50 4c	 call	 DWORD PTR [eax+76]

; 5397 :                 pSegTemp->Release();

  00278	8b 55 d8	 mov	 edx, DWORD PTR _pSegTemp$71544[ebp]
  0027b	8b 02		 mov	 eax, DWORD PTR [edx]
  0027d	8b 4d d8	 mov	 ecx, DWORD PTR _pSegTemp$71544[ebp]
  00280	51		 push	 ecx
  00281	ff 50 08	 call	 DWORD PTR [eax+8]

; 5398 :             }
; 5399 :             else

  00284	eb 07		 jmp	 SHORT $L71547
$L71546:

; 5400 :             {
; 5401 :                 dwNewRes = 0;

  00286	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwNewRes$71540[ebp], 0
$L71547:

; 5402 :             }
; 5403 :         }
; 5404 :         else

  0028d	eb 07		 jmp	 SHORT $L71542
$L71543:

; 5405 :         {
; 5406 :             dwNewRes = 0;

  0028f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwNewRes$71540[ebp], 0
$L71542:

; 5407 :         }
; 5408 :         dwFlags |= dwNewRes;

  00296	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00299	0b 55 dc	 or	 edx, DWORD PTR _dwNewRes$71540[ebp]
  0029c	89 55 18	 mov	 DWORD PTR _dwFlags$[ebp], edx

; 5409 :         dwFlags &= ~DMUS_SEGF_DEFAULT;

  0029f	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  002a2	25 ff bf ff ff	 and	 eax, -16385		; ffffbfffH
  002a7	89 45 18	 mov	 DWORD PTR _dwFlags$[ebp], eax
$L71539:

; 5410 :     }
; 5411 :     // Make sure mtTime is greater or equal to QueueTime, which is the last time notes were
; 5412 :     // queued down (or latency time, whichever is later) so we can stop everything after it.
; 5413 :     MUSIC_TIME mtLatency;
; 5414 :     REFERENCE_TIME rtQueueTime;
; 5415 :     GetQueueTime( &rtQueueTime );

  002aa	8d 4d f0	 lea	 ecx, DWORD PTR _rtQueueTime$[ebp]
  002ad	51		 push	 ecx
  002ae	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002b1	8b 02		 mov	 eax, DWORD PTR [edx]
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002b6	51		 push	 ecx
  002b7	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]

; 5416 :     ReferenceToMusicTime( rtQueueTime, &mtLatency );

  002bd	8d 55 e8	 lea	 edx, DWORD PTR _mtLatency$[ebp]
  002c0	52		 push	 edx
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _rtQueueTime$[ebp+4]
  002c4	50		 push	 eax
  002c5	8b 4d f0	 mov	 ecx, DWORD PTR _rtQueueTime$[ebp]
  002c8	51		 push	 ecx
  002c9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002cc	8b 02		 mov	 eax, DWORD PTR [edx]
  002ce	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002d1	51		 push	 ecx
  002d2	ff 50 18	 call	 DWORD PTR [eax+24]

; 5417 :     if( mtTime < mtLatency ) mtTime = mtLatency;

  002d5	8b 55 14	 mov	 edx, DWORD PTR _mtTime$[ebp]
  002d8	3b 55 e8	 cmp	 edx, DWORD PTR _mtLatency$[ebp]
  002db	7d 06		 jge	 SHORT $L71551
  002dd	8b 45 e8	 mov	 eax, DWORD PTR _mtLatency$[ebp]
  002e0	89 45 14	 mov	 DWORD PTR _mtTime$[ebp], eax
$L71551:

; 5418 :     // Resolve the time according to the resolution
; 5419 :     mtTime = ResolveTime( mtTime, dwFlags, NULL );

  002e3	6a 00		 push	 0
  002e5	8b 4d 18	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  002e8	51		 push	 ecx
  002e9	8b 55 14	 mov	 edx, DWORD PTR _mtTime$[ebp]
  002ec	52		 push	 edx
  002ed	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002f0	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  002f5	89 45 14	 mov	 DWORD PTR _mtTime$[ebp], eax

; 5420 :     // if mtTime is less than the current transported time, we can take
; 5421 :     // care of the Stop now. Otherwise, we need to cue a Stop PMsg and
; 5422 :     // take care of it at QUEUE time.
; 5423 :     if( mtTime <= m_mtTransported )

  002f8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002fb	8b 4d 14	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  002fe	3b 88 d0 02 00
	00		 cmp	 ecx, DWORD PTR [eax+720]
  00304	7f 49		 jg	 SHORT $L71552

; 5424 :     {
; 5425 :         if( pSegmentState )

  00306	83 7d ec 00	 cmp	 DWORD PTR _pSegmentState$[ebp], 0
  0030a	74 2c		 je	 SHORT $L71553

; 5426 :         {
; 5427 :             DoStop( pSegmentState, mtTime, TRUE );

  0030c	6a 01		 push	 1
  0030e	8b 55 14	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00311	52		 push	 edx
  00312	8b 45 ec	 mov	 eax, DWORD PTR _pSegmentState$[ebp]
  00315	50		 push	 eax
  00316	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00319	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegState@@JH@Z ; CPerformance::DoStop

; 5428 :             if( pSegment )

  0031e	83 7d fc 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  00322	74 12		 je	 SHORT $L71554

; 5429 :             {
; 5430 :                 DoStop( pSegment, mtTime, TRUE );

  00324	6a 01		 push	 1
  00326	8b 4d 14	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00329	51		 push	 ecx
  0032a	8b 55 fc	 mov	 edx, DWORD PTR _pSegment$[ebp]
  0032d	52		 push	 edx
  0032e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00331	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z ; CPerformance::DoStop
$L71554:

; 5431 :             }
; 5432 :         }
; 5433 :         else

  00336	eb 12		 jmp	 SHORT $L71555
$L71553:

; 5434 :         {
; 5435 :             DoStop( pSegment, mtTime, TRUE );

  00338	6a 01		 push	 1
  0033a	8b 45 14	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0033d	50		 push	 eax
  0033e	8b 4d fc	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  00341	51		 push	 ecx
  00342	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00345	e8 00 00 00 00	 call	 ?DoStop@CPerformance@@AAEXPAVCSegment@@JH@Z ; CPerformance::DoStop
$L71555:

; 5436 :         }
; 5437 :     }
; 5438 :     else

  0034a	e9 d4 00 00 00	 jmp	 $L71556
$L71552:

; 5439 :     {
; 5440 :         // find and mark the segment and/or segment state to not play beyond
; 5441 :         // the stop point.
; 5442 :         CSegState* pNode;
; 5443 :         DWORD dwCount;
; 5444 :         for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)

  0034f	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR _dwCount$71558[ebp], 3
  00356	eb 09		 jmp	 SHORT $L71559
$L71560:
  00358	8b 55 d4	 mov	 edx, DWORD PTR _dwCount$71558[ebp]
  0035b	83 c2 01	 add	 edx, 1
  0035e	89 55 d4	 mov	 DWORD PTR _dwCount$71558[ebp], edx
$L71559:
  00361	83 7d d4 05	 cmp	 DWORD PTR _dwCount$71558[ebp], 5
  00365	0f 87 b8 00 00
	00		 ja	 $L71556

; 5445 :         {
; 5446 :             for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  0036b	8b 45 d4	 mov	 eax, DWORD PTR _dwCount$71558[ebp]
  0036e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00371	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  00375	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0037a	89 45 d0	 mov	 DWORD PTR _pNode$71557[ebp], eax
  0037d	eb 0b		 jmp	 SHORT $L71562
$L71563:
  0037f	8b 4d d0	 mov	 ecx, DWORD PTR _pNode$71557[ebp]
  00382	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00387	89 45 d0	 mov	 DWORD PTR _pNode$71557[ebp], eax
$L71562:
  0038a	83 7d d0 00	 cmp	 DWORD PTR _pNode$71557[ebp], 0
  0038e	0f 84 8a 00 00
	00		 je	 $L71564

; 5447 :             {
; 5448 :                 if( (pNode->m_pSegment == pSegment) ||
; 5449 :                     (pNode == pSegmentState) ||
; 5450 :                     (!pSegment && !pSegmentState))

  00394	8b 55 d0	 mov	 edx, DWORD PTR _pNode$71557[ebp]
  00397	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0039a	3b 45 fc	 cmp	 eax, DWORD PTR _pSegment$[ebp]
  0039d	74 14		 je	 SHORT $L71566
  0039f	8b 4d d0	 mov	 ecx, DWORD PTR _pNode$71557[ebp]
  003a2	3b 4d ec	 cmp	 ecx, DWORD PTR _pSegmentState$[ebp]
  003a5	74 0c		 je	 SHORT $L71566
  003a7	83 7d fc 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  003ab	75 6c		 jne	 SHORT $L71565
  003ad	83 7d ec 00	 cmp	 DWORD PTR _pSegmentState$[ebp], 0
  003b1	75 66		 jne	 SHORT $L71565
$L71566:

; 5451 :                 {
; 5452 :                     if (pNode->m_fCanStop)

  003b3	8b 55 d0	 mov	 edx, DWORD PTR _pNode$71557[ebp]
  003b6	83 ba 1c 01 00
	00 00		 cmp	 DWORD PTR [edx+284], 0
  003bd	74 5a		 je	 SHORT $L71565

; 5453 :                     {
; 5454 :                         pNode->m_mtStopTime = mtTime;

  003bf	8b 45 d0	 mov	 eax, DWORD PTR _pNode$71557[ebp]
  003c2	8b 4d 14	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  003c5	89 48 74	 mov	 DWORD PTR [eax+116], ecx

; 5455 :                         // Make sure GetParams ignore the rest of the segment from now on.
; 5456 :                         if (mtTime < pNode->m_mtEndTime) 

  003c8	8b 55 d0	 mov	 edx, DWORD PTR _pNode$71557[ebp]
  003cb	8b 45 14	 mov	 eax, DWORD PTR _mtTime$[ebp]
  003ce	3b 42 68	 cmp	 eax, DWORD PTR [edx+104]
  003d1	7d 34		 jge	 SHORT $L71568

; 5457 :                         {
; 5458 :                             pNode->m_mtLength = mtTime - pNode->m_mtResolvedStart + 
; 5459 :                                 pNode->m_mtStartPoint;

  003d3	8b 4d d0	 mov	 ecx, DWORD PTR _pNode$71557[ebp]
  003d6	8b 55 14	 mov	 edx, DWORD PTR _mtTime$[ebp]
  003d9	2b 51 64	 sub	 edx, DWORD PTR [ecx+100]
  003dc	8b 45 d0	 mov	 eax, DWORD PTR _pNode$71557[ebp]
  003df	03 50 7c	 add	 edx, DWORD PTR [eax+124]
  003e2	8b 4d d0	 mov	 ecx, DWORD PTR _pNode$71557[ebp]
  003e5	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 5460 :                             if (pNode->m_mtLength < 0)

  003e8	8b 55 d0	 mov	 edx, DWORD PTR _pNode$71557[ebp]
  003eb	83 7a 54 00	 cmp	 DWORD PTR [edx+84], 0
  003ef	7d 0a		 jge	 SHORT $L71569

; 5461 :                             {
; 5462 :                                 pNode->m_mtLength = 0;

  003f1	8b 45 d0	 mov	 eax, DWORD PTR _pNode$71557[ebp]
  003f4	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0
$L71569:

; 5463 :                             }
; 5464 :                             // Make endtime one greater than mtTime so Abort notification will still happen.
; 5465 :                             pNode->m_mtEndTime = mtTime + 1;   

  003fb	8b 4d 14	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  003fe	83 c1 01	 add	 ecx, 1
  00401	8b 55 d0	 mov	 edx, DWORD PTR _pNode$71557[ebp]
  00404	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
$L71568:

; 5466 :                         }
; 5467 :                         // Force the tempo map to be recalculated IF this has a tempo track.
; 5468 :                         RecalcTempoMap(pNode,mtTime);

  00407	6a 01		 push	 1
  00409	8b 45 14	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0040c	50		 push	 eax
  0040d	8b 4d d0	 mov	 ecx, DWORD PTR _pNode$71557[ebp]
  00410	51		 push	 ecx
  00411	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00414	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap
$L71565:

; 5469 :                     }
; 5470 :                 }
; 5471 :             }

  00419	e9 61 ff ff ff	 jmp	 $L71563
$L71564:

; 5472 :         }

  0041e	e9 35 ff ff ff	 jmp	 $L71560
$L71556:

; 5473 :     }
; 5474 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00423	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00426	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  0042c	52		 push	 edx
  0042d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5475 :     LEAVE_API_CRITICAL_SECTION;
; 5476 :     return S_OK;

  00433	33 c0		 xor	 eax, eax
$L71490:

; 5477 : }

  00435	8b e5		 mov	 esp, ebp
  00437	5d		 pop	 ebp
  00438	c2 14 00	 ret	 20			; 00000014H
?Stop@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@JK@Z ENDP ; CPerformance::Stop
_TEXT	ENDS
PUBLIC	?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg
PUBLIC	?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z	; CPerformance::SendLongMsg
PUBLIC	?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z ; CPerformance::ResetAllControllers
;	COMDAT ?abGMReset@?9??ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z@4PAEA
_DATA	SEGMENT
?abGMReset@?9??ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z@4PAEA DB 0f0H ; `CPerformance::ResetAllControllers'::`10'::abGMReset
	DB	07eH
	DB	07fH
	DB	09H
	DB	01H
	DB	0f7H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z
_TEXT	SEGMENT
_this$ = -16
_dwIndex$ = -12
_dwGroup$ = -8
_dwMChannel$ = -4
_pChannelMap$ = 8
_rtTime$ = 12
_fGMReset$ = 20
?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z PROC NEAR ; CPerformance::ResetAllControllers, COMDAT
; _this$ = ecx

; 5481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 5482 :     DWORD dwIndex = pChannelMap->dwPortIndex;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pChannelMap$[ebp]
  0000c	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0000f	89 4d f4	 mov	 DWORD PTR _dwIndex$[ebp], ecx

; 5483 :     DWORD dwGroup = pChannelMap->dwGroup;

  00012	8b 55 08	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  00015	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00018	89 45 f8	 mov	 DWORD PTR _dwGroup$[ebp], eax

; 5484 :     DWORD dwMChannel = pChannelMap->dwMChannel;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0001e	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00021	89 55 fc	 mov	 DWORD PTR _dwMChannel$[ebp], edx

; 5485 : 
; 5486 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00024	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00027	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5487 : #ifdef DXAPI
; 5488 :     IDirectMusicPort* pPort = m_pPortTable[dwIndex].pPort;
; 5489 :     IDirectMusicBuffer* pBuffer = m_pPortTable[dwIndex].pBuffer;
; 5490 :     if( pPort && pBuffer )
; 5491 :     {
; 5492 :         m_pPortTable[dwIndex].fBufferFilled = TRUE;
; 5493 :         if (!rtTime)
; 5494 :         {
; 5495 :             rtTime = m_pPortTable[dwIndex].rtLast + 1;
; 5496 :         }
; 5497 :         else
; 5498 :         {
; 5499 :             m_pPortTable[dwIndex].rtLast = rtTime;
; 5500 :         }
; 5501 :         pChannelMap->Reset(true);
; 5502 :         DWORD dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8); // 0x78 is all sounds off. 
; 5503 :         if( FAILED( pBuffer->PackStructured( rtTime, dwGroup, dwMsg ) ) )
; 5504 :         {
; 5505 :             pPort->PlayBuffer( pBuffer );
; 5506 :             pBuffer->Flush();
; 5507 :             // try one more time
; 5508 :             pBuffer->PackStructured( rtTime, dwGroup, dwMsg );
; 5509 :         }
; 5510 :         dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16) ; // 0x79 is reset all controllers. Data byte set to indicate volume and pan too.
; 5511 :         if( FAILED( pBuffer->PackStructured( rtTime + 30 * REF_PER_MIL, dwGroup, dwMsg ) ) )
; 5512 :         {
; 5513 :             pPort->PlayBuffer( pBuffer );
; 5514 :             pBuffer->Flush();
; 5515 :             // try one more time
; 5516 :             pBuffer->PackStructured( rtTime + (30 * REF_PER_MIL), dwGroup, dwMsg );
; 5517 :         }
; 5518 :         // Send one GM Reset per channel group, but only under DX8 (and only if we need to). 
; 5519 :         if ((dwMChannel == 0) 
; 5520 :             && (m_dwVersion >= 8) 
; 5521 :             && fGMReset)
; 5522 :         {
; 5523 :             // create a buffer of the right size
; 5524 :             DMUS_BUFFERDESC dmbd;
; 5525 :             IDirectMusicBuffer *pBuffer;
; 5526 :             static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX }; 
; 5527 :             memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
; 5528 :             dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
; 5529 :             dmbd.cbBuffer = 50;
; 5530 : 
; 5531 :             ENTER_CRITICAL_SECTION(&m_MainCrSec);
; 5532 :             if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
; 5533 :             {
; 5534 :                 if( SUCCEEDED( pBuffer->PackUnstructured( rtTime + (30 * REF_PER_MIL), dwGroup,
; 5535 :                     6, abGMReset ) ) )
; 5536 :                 {
; 5537 :                     pPort->PlayBuffer(pBuffer);
; 5538 :                 }
; 5539 :                 pBuffer->Release();
; 5540 :             }
; 5541 :             LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 5542 :         }
; 5543 :         m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize
; 5544 :                                                              // before next start.
; 5545 :     }
; 5546 : #else
; 5547 :     if (!rtTime)

  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  00036	0b 4d 10	 or	 ecx, DWORD PTR _rtTime$[ebp+4]
  00039	85 c9		 test	 ecx, ecx
  0003b	75 17		 jne	 SHORT $L71580

; 5548 :     {
; 5549 :         rtTime = m_rtLastSendTime + 1;

  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00043	83 c0 01	 add	 eax, 1
  00046	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00049	83 d1 00	 adc	 ecx, 0
  0004c	89 45 0c	 mov	 DWORD PTR _rtTime$[ebp], eax
  0004f	89 4d 10	 mov	 DWORD PTR _rtTime$[ebp+4], ecx

; 5550 :     }
; 5551 :     else

  00052	eb 0f		 jmp	 SHORT $L71581
$L71580:

; 5552 :     {
; 5553 :         m_rtLastSendTime = rtTime;

  00054	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  0005a	89 42 28	 mov	 DWORD PTR [edx+40], eax
  0005d	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  00060	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$L71581:

; 5554 :     }
; 5555 :     pChannelMap->Reset(true);

  00063	6a 01		 push	 1
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00068	e8 00 00 00 00	 call	 ?Reset@CChannelMap@@QAEXH@Z ; CChannelMap::Reset

; 5556 :     SendShortMsg(0,0,dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8), rtTime, dwGroup);

  0006d	8b 55 f8	 mov	 edx, DWORD PTR _dwGroup$[ebp]
  00070	52		 push	 edx
  00071	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  00074	50		 push	 eax
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 fc	 mov	 edx, DWORD PTR _dwMChannel$[ebp]
  0007c	81 ca b0 00 00
	00		 or	 edx, 176		; 000000b0H
  00082	81 ca 00 78 00
	00		 or	 edx, 30720		; 00007800H
  00088	52		 push	 edx
  00089	6a 00		 push	 0
  0008b	6a 00		 push	 0
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 5557 :     SendShortMsg(0,0,dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16), rtTime, dwGroup);

  00095	8b 45 f8	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  0009c	51		 push	 ecx
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _dwMChannel$[ebp]
  000a4	0d b0 00 00 00	 or	 eax, 176		; 000000b0H
  000a9	0d 00 79 00 00	 or	 eax, 30976		; 00007900H
  000ae	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 5558 :     // Send one GM Reset per channel group, but only under DX8 (and only if we need to). 
; 5559 :     if ((dwMChannel == 0) 
; 5560 :         && fGMReset)

  000c0	83 7d fc 00	 cmp	 DWORD PTR _dwMChannel$[ebp], 0
  000c4	75 2b		 jne	 SHORT $L71582
  000c6	0f b6 4d 14	 movzx	 ecx, BYTE PTR _fGMReset$[ebp]
  000ca	85 c9		 test	 ecx, ecx
  000cc	74 23		 je	 SHORT $L71582

; 5561 :     {
; 5562 :         static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX }; 
; 5563 :         SendLongMsg(abGMReset,6,rtTime + (30 * REF_PER_MIL), dwGroup);

  000ce	8b 55 f8	 mov	 edx, DWORD PTR _dwGroup$[ebp]
  000d1	52		 push	 edx
  000d2	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  000d5	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  000da	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  000dd	83 d1 00	 adc	 ecx, 0
  000e0	51		 push	 ecx
  000e1	50		 push	 eax
  000e2	6a 06		 push	 6
  000e4	68 00 00 00 00	 push	 OFFSET FLAT:?abGMReset@?9??ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z@4PAEA
  000e9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	e8 00 00 00 00	 call	 ?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z ; CPerformance::SendLongMsg
$L71582:

; 5564 :     }
; 5565 :     m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize

  000f1	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp]
  000f4	81 c2 c0 27 09
	00		 add	 edx, 600000		; 000927c0H
  000fa	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  000fd	83 d0 00	 adc	 eax, 0
  00100	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	89 91 b0 02 00
	00		 mov	 DWORD PTR [ecx+688], edx
  00109	89 81 b4 02 00
	00		 mov	 DWORD PTR [ecx+692], eax

; 5566 :                                                              // before next start.
; 5567 : #endif
; 5568 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0010f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00112	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  00118	52		 push	 edx
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5569 : }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 10 00	 ret	 16			; 00000010H
?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z ENDP ; CPerformance::ResetAllControllers
_TEXT	ENDS
PUBLIC	?GetNext@CChannelBlock@@QAEPAV1@XZ		; CChannelBlock::GetNext
PUBLIC	?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
; Function compile flags: /Odt
;	COMDAT ?ResetAllControllers@CPerformance@@AAEX_J@Z
_TEXT	SEGMENT
_this$ = -16
_dwPChannel$71596 = -12
_pChannelMap$71595 = -8
_pChannelBlock$ = -4
_rtTime$ = 8
?ResetAllControllers@CPerformance@@AAEX_J@Z PROC NEAR	; CPerformance::ResetAllControllers, COMDAT
; _this$ = ecx

; 5573 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 5574 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5575 : 
; 5576 :     CChannelBlock* pChannelBlock;
; 5577 :     SendBuffers();
; 5578 :     for( pChannelBlock = m_ChannelBlockList.GetHead(); pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0001e	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  00023	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
  00026	eb 0b		 jmp	 SHORT $L71592
$L71593:
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0002b	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00030	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L71592:
  00033	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00037	74 5b		 je	 SHORT $L71594

; 5579 :     {
; 5580 :         CChannelMap* pChannelMap;
; 5581 :         for( DWORD dwPChannel = pChannelBlock->m_dwPChannelStart;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0003c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003f	89 55 f4	 mov	 DWORD PTR _dwPChannel$71596[ebp], edx

; 5582 :             dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE;

  00042	eb 09		 jmp	 SHORT $L71597
$L71598:

; 5583 :             dwPChannel++ )

  00044	8b 45 f4	 mov	 eax, DWORD PTR _dwPChannel$71596[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f4	 mov	 DWORD PTR _dwPChannel$71596[ebp], eax
$L71597:
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00050	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00053	83 c2 10	 add	 edx, 16			; 00000010H
  00056	39 55 f4	 cmp	 DWORD PTR _dwPChannel$71596[ebp], edx
  00059	73 37		 jae	 SHORT $L71599

; 5584 :         {
; 5585 :             pChannelMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _dwPChannel$71596[ebp]
  00061	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00064	c1 e1 07	 shl	 ecx, 7
  00067	8b 55 fc	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  0006a	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  0006e	89 45 f8	 mov	 DWORD PTR _pChannelMap$71595[ebp], eax

; 5586 :             if( pChannelMap->dwGroup ) // Valid group?

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelMap$71595[ebp]
  00074	83 79 74 00	 cmp	 DWORD PTR [ecx+116], 0
  00078	74 16		 je	 SHORT $L71600

; 5587 :             {
; 5588 :                 // Reset controllers and send a GM reset.
; 5589 :                 ResetAllControllers(pChannelMap, rtTime, true);

  0007a	6a 01		 push	 1
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  0007f	52		 push	 edx
  00080	8b 45 08	 mov	 eax, DWORD PTR _rtTime$[ebp]
  00083	50		 push	 eax
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelMap$71595[ebp]
  00087	51		 push	 ecx
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z ; CPerformance::ResetAllControllers
$L71600:

; 5590 :             }
; 5591 :         }

  00090	eb b2		 jmp	 SHORT $L71598
$L71599:

; 5592 :     }

  00092	eb 94		 jmp	 SHORT $L71593
$L71594:

; 5593 :     SendBuffers();
; 5594 : 
; 5595 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00094	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00097	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  0009d	52		 push	 edx
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5596 : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
?ResetAllControllers@CPerformance@@AAEX_J@Z ENDP	; CPerformance::ResetAllControllers
_TEXT	ENDS
EXTRN	?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z:NEAR	; CSegState::ConvertToSegTime
; Function compile flags: /Odt
;	COMDAT ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z
_TEXT	SEGMENT
_this$ = -40
_dwRepeat$71626 = -36
_mtTest$71624 = -32
_mtOffset$71625 = -28
_dwRepeat$71617 = -24
_mtTest$71615 = -20
_mtOffset$71616 = -16
_pSegNode$ = -12
_pSegReturn$ = -8
_fCheckedPri$ = -4
_mtTime$ = 8
?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z PROC NEAR ; CPerformance::GetPrimarySegmentAtTime, COMDAT
; _this$ = ecx

; 5601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 5602 :     CSegState* pSegNode;
; 5603 :     CSegState* pSegReturn = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pSegReturn$[ebp], 0

; 5604 :     BOOL fCheckedPri = FALSE;

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fCheckedPri$[ebp], 0

; 5605 :     for( pSegNode = m_SegStateQueues[SQ_PRI_DONE].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )

  00017	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 74	 add	 ecx, 116		; 00000074H
  0001d	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00022	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax
  00025	eb 0b		 jmp	 SHORT $L71608
$L71609:
  00027	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0002a	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0002f	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L71608:
  00032	83 7d f4 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00036	74 20		 je	 SHORT $L71610

; 5606 :     {
; 5607 :         // if we're checking the past list, only check up until the last time played.
; 5608 :         if( (mtTime >= pSegNode->m_mtResolvedStart) && (mtTime <= pSegNode->m_mtLastPlayed) )

  00038	8b 45 f4	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0003e	3b 48 64	 cmp	 ecx, DWORD PTR [eax+100]
  00041	7c 13		 jl	 SHORT $L71611
  00043	8b 55 f4	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  00046	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00049	3b 42 70	 cmp	 eax, DWORD PTR [edx+112]
  0004c	7f 08		 jg	 SHORT $L71611

; 5609 :         {
; 5610 :             pSegReturn = pSegNode;

  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00051	89 4d f8	 mov	 DWORD PTR _pSegReturn$[ebp], ecx

; 5611 :             break;

  00054	eb 02		 jmp	 SHORT $L71610
$L71611:

; 5612 :         }
; 5613 :     }

  00056	eb cf		 jmp	 SHORT $L71609
$L71610:

; 5614 :     for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )

  00058	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0005e	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00063	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax
  00066	eb 0b		 jmp	 SHORT $L71612
$L71613:
  00068	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00070	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L71612:
  00073	83 7d f4 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00077	74 28		 je	 SHORT $L71614

; 5615 :     {
; 5616 :         MUSIC_TIME mtTest = mtTime;

  00079	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0007c	89 55 ec	 mov	 DWORD PTR _mtTest$71615[ebp], edx

; 5617 :         MUSIC_TIME mtOffset;
; 5618 :         DWORD dwRepeat;
; 5619 :         // if we're checking the current list, check the full segment time
; 5620 :         if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))

  0007f	8d 45 e8	 lea	 eax, DWORD PTR _dwRepeat$71617[ebp]
  00082	50		 push	 eax
  00083	8d 4d f0	 lea	 ecx, DWORD PTR _mtOffset$71616[ebp]
  00086	51		 push	 ecx
  00087	8d 55 ec	 lea	 edx, DWORD PTR _mtTest$71615[ebp]
  0008a	52		 push	 edx
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0008e	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  00093	85 c0		 test	 eax, eax
  00095	75 08		 jne	 SHORT $L71619

; 5621 :         {
; 5622 :             pSegReturn = pSegNode;

  00097	8b 45 f4	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  0009a	89 45 f8	 mov	 DWORD PTR _pSegReturn$[ebp], eax

; 5623 :             break;

  0009d	eb 02		 jmp	 SHORT $L71614
$L71619:

; 5624 :         }
; 5625 :     }

  0009f	eb c7		 jmp	 SHORT $L71613
$L71614:

; 5626 :     if (!pSegReturn)

  000a1	83 7d f8 00	 cmp	 DWORD PTR _pSegReturn$[ebp], 0
  000a5	75 49		 jne	 SHORT $L71620

; 5627 :     {
; 5628 :         for( pSegNode = m_SegStateQueues[SQ_PRI_WAIT].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )

  000a7	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	83 c1 44	 add	 ecx, 68			; 00000044H
  000ad	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  000b2	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax
  000b5	eb 0b		 jmp	 SHORT $L71621
$L71622:
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  000ba	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  000bf	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L71621:
  000c2	83 7d f4 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  000c6	74 28		 je	 SHORT $L71620

; 5629 :         {
; 5630 :             MUSIC_TIME mtTest = mtTime;

  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000cb	89 4d e0	 mov	 DWORD PTR _mtTest$71624[ebp], ecx

; 5631 :             MUSIC_TIME mtOffset;
; 5632 :             DWORD dwRepeat;
; 5633 :             // if we're checking the current list, check the full segment time
; 5634 :             if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))

  000ce	8d 55 dc	 lea	 edx, DWORD PTR _dwRepeat$71626[ebp]
  000d1	52		 push	 edx
  000d2	8d 45 e4	 lea	 eax, DWORD PTR _mtOffset$71625[ebp]
  000d5	50		 push	 eax
  000d6	8d 4d e0	 lea	 ecx, DWORD PTR _mtTest$71624[ebp]
  000d9	51		 push	 ecx
  000da	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  000dd	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  000e2	85 c0		 test	 eax, eax
  000e4	75 08		 jne	 SHORT $L71628

; 5635 :             {
; 5636 :                 pSegReturn = pSegNode;

  000e6	8b 55 f4	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  000e9	89 55 f8	 mov	 DWORD PTR _pSegReturn$[ebp], edx

; 5637 :                 break;

  000ec	eb 02		 jmp	 SHORT $L71620
$L71628:

; 5638 :             }
; 5639 :         }

  000ee	eb c7		 jmp	 SHORT $L71622
$L71620:

; 5640 :     }
; 5641 :     return pSegReturn;

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _pSegReturn$[ebp]

; 5642 : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 04 00	 ret	 4
?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ENDP ; CPerformance::GetPrimarySegmentAtTime
_TEXT	ENDS
PUBLIC	??_C@_0CM@FOEGMPGD@Unable?5to?5find?5a?5segment?5state?5a@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetSegmentState', 00H ; `CPerformance::GetSegmentState'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CM@FOEGMPGD@Unable?5to?5find?5a?5segment?5state?5a@
CONST	SEGMENT
??_C@_0CM@FOEGMPGD@Unable?5to?5find?5a?5segment?5state?5a@ DB 'Unable to '
	DB	'find a segment state at time %ld', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z
_TEXT	SEGMENT
_hr$ = -8
_pSegNode$ = -4
_this$ = 8
_ppSegmentState$ = 12
_mtTime$ = 16
?GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z PROC NEAR ; CPerformance::GetSegmentState, COMDAT

; 5666 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 5667 :     V_INAME(IDirectMusicPerformance::GetSegmentState);
; 5668 :     V_PTRPTR_WRITE(ppSegmentState);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _ppSegmentState$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71637
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@PHFIHIFA@?$CFs?3?5Invalid?5pointer?5ppSegmentSta@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71637:

; 5669 : 
; 5670 :     CSegState* pSegNode;
; 5671 :     HRESULT hr;
; 5672 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5673 :     ENTER_API_CRITICAL_SECTION;
; 5674 :     if( pSegNode = GetPrimarySegmentAtTime( mtTime ))

  0003e	8b 55 10	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00041	52		 push	 edx
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  0004a	89 45 fc	 mov	 DWORD PTR _pSegNode$[ebp], eax
  0004d	83 7d fc 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00051	74 1d		 je	 SHORT $L71640

; 5675 :     {
; 5676 :         *ppSegmentState = pSegNode;

  00053	8b 45 0c	 mov	 eax, DWORD PTR _ppSegmentState$[ebp]
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00059	89 08		 mov	 DWORD PTR [eax], ecx

; 5677 :         pSegNode->AddRef();

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  0005e	8b 02		 mov	 eax, DWORD PTR [edx]
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00063	51		 push	 ecx
  00064	ff 50 04	 call	 DWORD PTR [eax+4]

; 5678 :         hr = S_OK;

  00067	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 5679 :     }
; 5680 :     else

  0006e	eb 1a		 jmp	 SHORT $L71642
$L71640:

; 5681 :     {
; 5682 :         Trace(3,"Unable to find a segment state at time %ld\n",mtTime);

  00070	8b 55 10	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00073	52		 push	 edx
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@FOEGMPGD@Unable?5to?5find?5a?5segment?5state?5a@
  00079	6a 03		 push	 3
  0007b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5683 :         hr  = DMUS_E_NOT_FOUND;

  00083	c7 45 f8 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
$L71642:

; 5684 :     }
; 5685 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00092	50		 push	 eax
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5686 :     LEAVE_API_CRITICAL_SECTION;
; 5687 :     return hr;

  00099	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 5688 : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
?GetSegmentState@CPerformance@@UAGJPAPAUIDirectMusicSegmentState@@J@Z ENDP ; CPerformance::GetSegmentState
_TEXT	ENDS
PUBLIC	?SetPrepareTime@CPerformance@@QAGJK@Z		; CPerformance::SetPrepareTime
; Function compile flags: /Odt
;	COMDAT ?SetPrepareTime@CPerformance@@QAGJK@Z
_TEXT	SEGMENT
_this$ = 8
_dwMilliSeconds$ = 12
?SetPrepareTime@CPerformance@@QAGJK@Z PROC NEAR		; CPerformance::SetPrepareTime, COMDAT

; 5703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5704 :     m_dwPrepareTime = dwMilliSeconds;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwMilliSeconds$[ebp]
  00009	89 88 dc 02 00
	00		 mov	 DWORD PTR [eax+732], ecx

; 5705 :     return S_OK;

  0000f	33 c0		 xor	 eax, eax

; 5706 : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?SetPrepareTime@CPerformance@@QAGJK@Z ENDP		; CPerformance::SetPrepareTime
_TEXT	ENDS
PUBLIC	?GetPrepareTime@CPerformance@@QAGJPAK@Z		; CPerformance::GetPrepareTime
PUBLIC	??_C@_0CF@FDLOAGBG@?$CFs?3?5Invalid?5pointer?5pdwMilliSeco@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetPrepareTime@CPerformance@@QAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetPrepareTime@CPerformance@@QAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetPrepareTime', 00H ; `CPerformance::GetPrepareTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CF@FDLOAGBG@?$CFs?3?5Invalid?5pointer?5pdwMilliSeco@
CONST	SEGMENT
??_C@_0CF@FDLOAGBG@?$CFs?3?5Invalid?5pointer?5pdwMilliSeco@ DB '%s: Inval'
	DB	'id pointer pdwMilliSeconds', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetPrepareTime@CPerformance@@QAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwMilliSeconds$ = 12
?GetPrepareTime@CPerformance@@QAGJPAK@Z PROC NEAR	; CPerformance::GetPrepareTime, COMDAT

; 5722 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5723 :     V_INAME(IDirectMusicPerformance::GetPrepareTime);
; 5724 :     V_PTR_WRITE(pdwMilliSeconds,DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwMilliSeconds$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L71660
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetPrepareTime@CPerformance@@QAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@FDLOAGBG@?$CFs?3?5Invalid?5pointer?5pdwMilliSeco@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L71660:

; 5725 : 
; 5726 :     *pdwMilliSeconds = m_dwPrepareTime;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwMilliSeconds$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 82 dc 02 00
	00		 mov	 eax, DWORD PTR [edx+732]
  00037	89 01		 mov	 DWORD PTR [ecx], eax

; 5727 :     return S_OK; 

  00039	33 c0		 xor	 eax, eax

; 5728 : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?GetPrepareTime@CPerformance@@QAGJPAK@Z ENDP		; CPerformance::GetPrepareTime
_TEXT	ENDS
PUBLIC	?SetBumperLength@CPerformance@@QAGJK@Z		; CPerformance::SetBumperLength
; Function compile flags: /Odt
;	COMDAT ?SetBumperLength@CPerformance@@QAGJK@Z
_TEXT	SEGMENT
_this$ = 8
_dwMilliSeconds$ = 12
?SetBumperLength@CPerformance@@QAGJK@Z PROC NEAR	; CPerformance::SetBumperLength, COMDAT

; 5740 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5741 :     m_dwBumperLength = dwMilliSeconds; 

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwMilliSeconds$[ebp]
  00009	89 88 e0 02 00
	00		 mov	 DWORD PTR [eax+736], ecx

; 5742 :     m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 82 e0 02 00
	00		 mov	 eax, DWORD PTR [edx+736]
  00018	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  0001e	33 c9		 xor	 ecx, ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00023	89 82 c8 02 00
	00		 mov	 DWORD PTR [edx+712], eax
  00029	89 8a cc 02 00
	00		 mov	 DWORD PTR [edx+716], ecx

; 5743 :     return S_OK;

  0002f	33 c0		 xor	 eax, eax

; 5744 : }

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
?SetBumperLength@CPerformance@@QAGJK@Z ENDP		; CPerformance::SetBumperLength
_TEXT	ENDS
PUBLIC	?GetBumperLength@CPerformance@@QAGJPAK@Z	; CPerformance::GetBumperLength
;	COMDAT ?__szValidateInterfaceName@?1??GetBumperLength@CPerformance@@QAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetBumperLength@CPerformance@@QAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetBumperLength', 00H ; `CPerformance::GetBumperLength'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetBumperLength@CPerformance@@QAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwMilliSeconds$ = 12
?GetBumperLength@CPerformance@@QAGJPAK@Z PROC NEAR	; CPerformance::GetBumperLength, COMDAT

; 5757 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5758 :     V_INAME(IDirectMusicPerformance::GetBumperLength);
; 5759 :     V_PTR_WRITE(pdwMilliSeconds,DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwMilliSeconds$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L71675
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetBumperLength@CPerformance@@QAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@FDLOAGBG@?$CFs?3?5Invalid?5pointer?5pdwMilliSeco@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L71675:

; 5760 : 
; 5761 :     *pdwMilliSeconds = m_dwBumperLength;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwMilliSeconds$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 82 e0 02 00
	00		 mov	 eax, DWORD PTR [edx+736]
  00037	89 01		 mov	 DWORD PTR [ecx], eax

; 5762 :     return S_OK;

  00039	33 c0		 xor	 eax, eax

; 5763 : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?GetBumperLength@CPerformance@@QAGJPAK@Z ENDP		; CPerformance::GetBumperLength
_TEXT	ENDS
PUBLIC	??_C@_0CA@EEFNAMEA@?$CFs?3?5Invalid?5pointer?5pDMUS_PMSG?6?$AA@ ; `string'
PUBLIC	??_C@_0EB@PPKACEMH@Error?3?5Unable?5to?5Send?5PMsg?5becau@ ; `string'
PUBLIC	??_C@_0GF@JBLNGFFF@Error?3?5Attempt?5to?5send?5an?5improp@ ; `string'
PUBLIC	??_C@_0IA@IMHPKDCD@Error?3?5Unable?5to?5send?5PMsg?5becau@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::SendPMsg', 00H	; `CPerformance::SendPMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CA@EEFNAMEA@?$CFs?3?5Invalid?5pointer?5pDMUS_PMSG?6?$AA@
CONST	SEGMENT
??_C@_0CA@EEFNAMEA@?$CFs?3?5Invalid?5pointer?5pDMUS_PMSG?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pDMUS_PMSG', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PPKACEMH@Error?3?5Unable?5to?5Send?5PMsg?5becau@
CONST	SEGMENT
??_C@_0EB@PPKACEMH@Error?3?5Unable?5to?5Send?5PMsg?5becau@ DB 'Error: Una'
	DB	'ble to Send PMsg because performance not initialized.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@JBLNGFFF@Error?3?5Attempt?5to?5send?5an?5improp@
CONST	SEGMENT
??_C@_0GF@JBLNGFFF@Error?3?5Attempt?5to?5send?5an?5improp@ DB 'Error: Att'
	DB	'empt to send an improperly allocated PMsg, or trying to send '
	DB	'it after it is already sent.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@IMHPKDCD@Error?3?5Unable?5to?5send?5PMsg?5becau@
CONST	SEGMENT
??_C@_0IA@IMHPKDCD@Error?3?5Unable?5to?5send?5PMsg?5becau@ DB 'Error: Una'
	DB	'ble to send PMsg because neither clock time (DMUS_PMSGF_REFTI'
	DB	'ME) nor music time (DMUS_PMSGF_MUSICTIME) has been set.', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
tv370 = -28
tv320 = -24
tv275 = -20
_rtNew$71711 = -16
_pPrivPMsg$ = -4
_this$ = 8
_pDMUS_PMSG$ = 12
?SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z PROC NEAR	; CPerformance::SendPMsg, COMDAT

; 5778 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 5779 :     V_INAME(IDirectMusicPerformance::SendPMsg);
; 5780 : #ifdef DXAPI
; 5781 :     if( m_dwVersion < 8)
; 5782 :     {
; 5783 :         V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
; 5784 :     }
; 5785 :     else
; 5786 :     {
; 5787 : #ifdef DBG
; 5788 :         V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
; 5789 : #else
; 5790 :         if (!pDMUS_PMSG)
; 5791 :         {
; 5792 :             return E_POINTER;
; 5793 :         }
; 5794 : #endif
; 5795 :     }
; 5796 : #else
; 5797 :     V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));

  00006	6a 38		 push	 56			; 00000038H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71684
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@EEFNAMEA@?$CFs?3?5Invalid?5pointer?5pDMUS_PMSG?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71684:

; 5798 : #endif
; 5799 : 
; 5800 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5801 :     if( m_pClock == NULL )

  0003e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00045	75 28		 jne	 SHORT $L71686

; 5802 :     {
; 5803 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5804 :         Trace(0,"Error: Unable to Send PMsg because performance not initialized.\n");

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PPKACEMH@Error?3?5Unable?5to?5Send?5PMsg?5becau@
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00062	83 c4 08	 add	 esp, 8

; 5805 :         return DMUS_E_NO_MASTER_CLOCK;

  00065	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0006a	e9 0e 03 00 00	 jmp	 $L71680
$L71686:

; 5806 :     }
; 5807 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00078	51		 push	 ecx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5808 : 
; 5809 :     if (pDMUS_PMSG->dwSize < sizeof(DMUS_PMSG))
; 5810 :     {
; 5811 :         TraceI(1,"Warning: PMsg size field has been cleared.\n");
; 5812 :     }
; 5813 : 
; 5814 :     // If this is a PMsg that was marked by STampPMsg as one that should be removed,
; 5815 :     // do so now. 
; 5816 :     if (pDMUS_PMSG->dwPChannel == DMUS_PCHANNEL_KILL_ME)

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  00082	83 78 18 f0	 cmp	 DWORD PTR [eax+24], -16	; fffffff0H
  00086	75 17		 jne	 SHORT $L71692

; 5817 :     {
; 5818 :         FreePMsg(pDMUS_PMSG);

  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 02		 mov	 eax, DWORD PTR [edx]
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	51		 push	 ecx
  00095	ff 50 28	 call	 DWORD PTR [eax+40]

; 5819 :         return S_OK;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 de 02 00 00	 jmp	 $L71680
$L71692:

; 5820 :     }
; 5821 : 
; 5822 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0009f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000a8	52		 push	 edx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5823 :     ENTER_API_CRITICAL_SECTION;
; 5824 :     PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pDMUS_PMSG);

  000af	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  000b2	83 e8 18	 sub	 eax, 24			; 00000018H
  000b5	89 45 fc	 mov	 DWORD PTR _pPrivPMsg$[ebp], eax

; 5825 :     if( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED ) ||
; 5826 :         ( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK ) != PRIV_FLAG_ALLOC ) )

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  000bb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000be	83 e2 01	 and	 edx, 1
  000c1	85 d2		 test	 edx, edx
  000c3	75 14		 jne	 SHORT $L71698
  000c5	8b 45 fc	 mov	 eax, DWORD PTR _pPrivPMsg$[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	81 e1 f0 ff 0f
	00		 and	 ecx, 1048560		; 000ffff0H
  000d1	81 f9 e0 af 0c
	00		 cmp	 ecx, 831456		; 000cafe0H
  000d7	74 29		 je	 SHORT $L71697
$L71698:

; 5827 :     {
; 5828 :         Trace(1, "Error: Attempt to send an improperly allocated PMsg, or trying to send it after it is already sent.\n" );

  000d9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GF@JBLNGFFF@Error?3?5Attempt?5to?5send?5an?5improp@
  000de	6a 01		 push	 1
  000e0	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000e5	83 c4 08	 add	 esp, 8

; 5829 :         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000e8	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000f1	52		 push	 edx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5830 :         LEAVE_API_CRITICAL_SECTION;
; 5831 :         return DMUS_E_ALREADY_SENT;

  000f8	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000fd	e9 7b 02 00 00	 jmp	 $L71680
$L71697:

; 5832 :     }
; 5833 : #ifdef DXAPI
; 5834 :     if (m_dwVersion >= 8)
; 5835 : #endif
; 5836 :     {
; 5837 :         // If the music and ref times are both 0, set to latency time.
; 5838 :         if ((pDMUS_PMSG->mtTime == 0) && ( pDMUS_PMSG->rtTime == 0 ))

  00102	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  00105	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00109	75 6c		 jne	 SHORT $L71701
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  0010e	89 4d ec	 mov	 DWORD PTR tv275[ebp], ecx
  00111	8b 55 ec	 mov	 edx, DWORD PTR tv275[ebp]
  00114	8b 45 ec	 mov	 eax, DWORD PTR tv275[ebp]
  00117	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0011a	0b 48 0c	 or	 ecx, DWORD PTR [eax+12]
  0011d	85 c9		 test	 ecx, ecx
  0011f	75 56		 jne	 SHORT $L71701

; 5839 :         {
; 5840 :             // If this needs to resolve, use the worse case latency
; 5841 :             // because this needs to sync with other pmsgs. 
; 5842 :             if (pDMUS_PMSG->dwFlags & RESOLVE_FLAGS)

  00121	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  00124	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00127	25 00 3c e0 01	 and	 eax, 31472640		; 01e03c00H
  0012c	85 c0		 test	 eax, eax
  0012e	74 18		 je	 SHORT $L71702

; 5843 :             {
; 5844 :                 GetLatencyTime(&pDMUS_PMSG->rtTime);

  00130	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00133	83 c1 08	 add	 ecx, 8
  00136	51		 push	 ecx
  00137	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0013a	8b 02		 mov	 eax, DWORD PTR [edx]
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	51		 push	 ecx
  00140	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]

; 5845 :             }
; 5846 :             else

  00146	eb 11		 jmp	 SHORT $L71703
$L71702:

; 5847 :             {
; 5848 :                 // Otherwise, we want to play as soon as possible. 
; 5849 :                 pDMUS_PMSG->rtTime = GetTime();

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0014b	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  00150	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00153	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00156	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L71703:

; 5850 :             }
; 5851 :             pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;

  00159	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0015c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0015f	83 c8 01	 or	 eax, 1
  00162	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00165	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 5852 :             pDMUS_PMSG->dwFlags &= ~DMUS_PMSGF_MUSICTIME;

  00168	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0016b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0016e	83 e0 fd	 and	 eax, -3			; fffffffdH
  00171	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00174	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L71701:

; 5853 :         }
; 5854 :     }
; 5855 : 
; 5856 :     // fill in missing time value
; 5857 :     if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_MUSICTIME))

  00177	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0017a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0017d	83 e0 02	 and	 eax, 2
  00180	85 c0		 test	 eax, eax
  00182	0f 85 c8 00 00
	00		 jne	 $L71704

; 5858 :     {
; 5859 :         if( !(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME ) )

  00188	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  0018b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0018e	83 e2 01	 and	 edx, 1
  00191	85 d2		 test	 edx, edx
  00193	75 28		 jne	 SHORT $L71705

; 5860 :         {
; 5861 :             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00195	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00198	05 30 03 00 00	 add	 eax, 816		; 00000330H
  0019d	50		 push	 eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5862 :             LEAVE_API_CRITICAL_SECTION;
; 5863 :             Trace(1,"Error: Unable to send PMsg because neither clock time (DMUS_PMSGF_REFTIME) nor music time (DMUS_PMSGF_MUSICTIME) has been set.\n");

  001a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0IA@IMHPKDCD@Error?3?5Unable?5to?5send?5PMsg?5becau@
  001a9	6a 01		 push	 1
  001ab	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001b0	83 c4 08	 add	 esp, 8

; 5864 :             return E_INVALIDARG; // one or the other MUST be set

  001b3	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  001b8	e9 c0 01 00 00	 jmp	 $L71680
$L71705:

; 5865 :         }
; 5866 :         // quantize to resolution boundaries
; 5867 :         GetResolvedTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->rtTime, pDMUS_PMSG->dwFlags );

  001bd	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  001c0	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001c3	52		 push	 edx
  001c4	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  001c7	83 c0 08	 add	 eax, 8
  001ca	50		 push	 eax
  001cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  001ce	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001d1	52		 push	 edx
  001d2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001d5	50		 push	 eax
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001db	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001de	50		 push	 eax
  001df	ff 92 88 00 00
	00		 call	 DWORD PTR [edx+136]

; 5868 :         pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;

  001e5	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  001e8	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001eb	81 e2 ff c3 1f
	fe		 and	 edx, -31472641		; fe1fc3ffH
  001f1	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  001f4	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 5869 :         // if time is zero, set it to time now plus latency
; 5870 :         if( pDMUS_PMSG->rtTime == 0 )

  001f7	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  001fa	89 4d e8	 mov	 DWORD PTR tv320[ebp], ecx
  001fd	8b 55 e8	 mov	 edx, DWORD PTR tv320[ebp]
  00200	8b 45 e8	 mov	 eax, DWORD PTR tv320[ebp]
  00203	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00206	0b 48 0c	 or	 ecx, DWORD PTR [eax+12]
  00209	85 c9		 test	 ecx, ecx
  0020b	75 11		 jne	 SHORT $L71708

; 5871 :         {
; 5872 :             pDMUS_PMSG->rtTime = GetLatency();

  0020d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00210	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00215	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00218	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0021b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L71708:

; 5873 :         }
; 5874 :         ReferenceToMusicTime(pDMUS_PMSG->rtTime,
; 5875 :             &pDMUS_PMSG->mtTime);

  0021e	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  00221	83 c2 10	 add	 edx, 16			; 00000010H
  00224	52		 push	 edx
  00225	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  00228	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0022b	51		 push	 ecx
  0022c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0022f	52		 push	 edx
  00230	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00238	52		 push	 edx
  00239	ff 51 18	 call	 DWORD PTR [ecx+24]

; 5876 :         pDMUS_PMSG->dwFlags |= DMUS_PMSGF_MUSICTIME;

  0023c	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  0023f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00242	83 c9 02	 or	 ecx, 2
  00245	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  00248	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 5877 :     }
; 5878 :     else if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME))

  0024b	e9 b9 00 00 00	 jmp	 $L71709
$L71704:
  00250	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  00253	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00256	83 e1 01	 and	 ecx, 1
  00259	85 c9		 test	 ecx, ecx
  0025b	0f 85 a8 00 00
	00		 jne	 $L71709

; 5879 :     {
; 5880 :         MusicToReferenceTime(pDMUS_PMSG->mtTime,
; 5881 :             &pDMUS_PMSG->rtTime);

  00261	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  00264	83 c2 08	 add	 edx, 8
  00267	52		 push	 edx
  00268	8b 45 0c	 mov	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  0026b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0026e	51		 push	 ecx
  0026f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00272	8b 02		 mov	 eax, DWORD PTR [edx]
  00274	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00277	51		 push	 ecx
  00278	ff 50 14	 call	 DWORD PTR [eax+20]

; 5882 :         pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;

  0027b	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0027e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00281	83 c8 01	 or	 eax, 1
  00284	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00287	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 5883 :         // quantize to resolution boundaries
; 5884 :         REFERENCE_TIME rtNew;
; 5885 :         GetResolvedTime( pDMUS_PMSG->rtTime, &rtNew, pDMUS_PMSG->dwFlags );

  0028a	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0028d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00290	50		 push	 eax
  00291	8d 4d f0	 lea	 ecx, DWORD PTR _rtNew$71711[ebp]
  00294	51		 push	 ecx
  00295	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  00298	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0029b	50		 push	 eax
  0029c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0029f	51		 push	 ecx
  002a0	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002a3	8b 02		 mov	 eax, DWORD PTR [edx]
  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002a8	51		 push	 ecx
  002a9	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 5886 :         pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;

  002af	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  002b2	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  002b5	25 ff c3 1f fe	 and	 eax, -31472641		; fe1fc3ffH
  002ba	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  002bd	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 5887 :         if( rtNew != pDMUS_PMSG->rtTime )

  002c0	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  002c3	89 55 e4	 mov	 DWORD PTR tv370[ebp], edx
  002c6	8b 45 e4	 mov	 eax, DWORD PTR tv370[ebp]
  002c9	8b 4d f0	 mov	 ecx, DWORD PTR _rtNew$71711[ebp]
  002cc	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  002cf	75 0b		 jne	 SHORT $L75492
  002d1	8b 55 e4	 mov	 edx, DWORD PTR tv370[ebp]
  002d4	8b 45 f4	 mov	 eax, DWORD PTR _rtNew$71711[ebp+4]
  002d7	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  002da	74 2d		 je	 SHORT $L71709
$L75492:

; 5888 :         {
; 5889 :             pDMUS_PMSG->rtTime = rtNew;

  002dc	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  002df	8b 55 f0	 mov	 edx, DWORD PTR _rtNew$71711[ebp]
  002e2	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002e5	8b 45 f4	 mov	 eax, DWORD PTR _rtNew$71711[ebp+4]
  002e8	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 5890 :             ReferenceToMusicTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->mtTime );

  002eb	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  002ee	83 c1 10	 add	 ecx, 16			; 00000010H
  002f1	51		 push	 ecx
  002f2	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  002f5	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002f8	50		 push	 eax
  002f9	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  002fc	51		 push	 ecx
  002fd	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00300	8b 02		 mov	 eax, DWORD PTR [edx]
  00302	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00305	51		 push	 ecx
  00306	ff 50 18	 call	 DWORD PTR [eax+24]
$L71709:

; 5891 :         }
; 5892 :     }
; 5893 : 
; 5894 :     // insert into the proper queue by music value
; 5895 :     if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_QUEUE)

  00309	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0030c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0030f	83 e0 08	 and	 eax, 8
  00312	85 c0		 test	 eax, eax
  00314	74 14		 je	 SHORT $L71713

; 5896 :     {
; 5897 :         m_NearTimeQueue.Enqueue(pPrivPMsg);

  00316	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00319	51		 push	 ecx
  0031a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00323	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 5898 :     }
; 5899 :     else if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_ATTIME)

  00328	eb 42		 jmp	 SHORT $L71714
$L71713:
  0032a	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0032d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00330	83 e0 10	 and	 eax, 16			; 00000010H
  00333	85 c0		 test	 eax, eax
  00335	74 14		 je	 SHORT $L71715

; 5900 :     {
; 5901 :         m_OnTimeQueue.Enqueue(pPrivPMsg);

  00337	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  0033a	51		 push	 ecx
  0033b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0033e	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00344	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 5902 :     }
; 5903 :     else // (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)

  00349	eb 21		 jmp	 SHORT $L71714
$L71715:

; 5904 :     {
; 5905 :         pDMUS_PMSG->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;

  0034b	8b 55 0c	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  0034e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00351	83 c8 04	 or	 eax, 4
  00354	8b 4d 0c	 mov	 ecx, DWORD PTR _pDMUS_PMSG$[ebp]
  00357	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 5906 :         m_EarlyQueue.Enqueue(pPrivPMsg);

  0035a	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0035d	52		 push	 edx
  0035e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00361	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00367	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue
$L71714:

; 5907 :     }
; 5908 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  0036c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0036f	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00374	50		 push	 eax
  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 5909 :     LEAVE_API_CRITICAL_SECTION;
; 5910 :     return S_OK;

  0037b	33 c0		 xor	 eax, eax
$L71680:

; 5911 : }

  0037d	8b e5		 mov	 esp, ebp
  0037f	5d		 pop	 ebp
  00380	c2 08 00	 ret	 8
?SendPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z ENDP	; CPerformance::SendPMsg
_TEXT	ENDS
PUBLIC	?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes
EXTRN	?Sort@CPMsgQueue@@QAEXXZ:NEAR			; CPMsgQueue::Sort
; Function compile flags: /Odt
;	COMDAT ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z
_TEXT	SEGMENT
tv158 = -20
tv157 = -16
_this$ = -12
_fError$ = -8
_pCheck$ = -4
_pList$ = 8
_mtTime$ = 12
?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z PROC NEAR ; CPerformance::RevalidateRefTimes, COMDAT
; _this$ = ecx

; 5918 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 5919 :     PRIV_PMSG* pCheck;
; 5920 :     BOOL fError = FALSE;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fError$[ebp], 0

; 5921 :     for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pList$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00018	89 45 fc	 mov	 DWORD PTR _pCheck$[ebp], eax
  0001b	eb 08		 jmp	 SHORT $L71725
$L71726:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pCheck$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	89 4d fc	 mov	 DWORD PTR _pCheck$[ebp], ecx
$L71725:
  00025	83 7d fc 00	 cmp	 DWORD PTR _pCheck$[ebp], 0
  00029	74 54		 je	 SHORT $L71727

; 5922 :     {
; 5923 :         if (pCheck->mtTime > mtTime)

  0002b	8b 55 fc	 mov	 edx, DWORD PTR _pCheck$[ebp]
  0002e	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00031	3b 45 0c	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00034	7e 47		 jle	 SHORT $L71728

; 5924 :         {
; 5925 :             if (pCheck->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _pCheck$[ebp]
  00039	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0003c	83 e2 40	 and	 edx, 64			; 00000040H
  0003f	85 d2		 test	 edx, edx
  00041	74 20		 je	 SHORT $L71729

; 5926 :             {
; 5927 :                 ReferenceToMusicTime(pCheck->rtTime,&pCheck->mtTime);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _pCheck$[ebp]
  00046	83 c0 28	 add	 eax, 40			; 00000028H
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _pCheck$[ebp]
  0004d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00050	52		 push	 edx
  00051	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00054	50		 push	 eax
  00055	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	50		 push	 eax
  0005e	ff 52 18	 call	 DWORD PTR [edx+24]

; 5928 :             }
; 5929 :             else // if(pCheck->dwFlags & DMUS_PMSGF_MUSICTIME)

  00061	eb 1a		 jmp	 SHORT $L71728
$L71729:

; 5930 :             {
; 5931 :                 MusicToReferenceTime(pCheck->mtTime,&pCheck->rtTime);

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _pCheck$[ebp]
  00066	83 c1 20	 add	 ecx, 32			; 00000020H
  00069	51		 push	 ecx
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _pCheck$[ebp]
  0006d	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00070	50		 push	 eax
  00071	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00079	50		 push	 eax
  0007a	ff 52 14	 call	 DWORD PTR [edx+20]
$L71728:

; 5932 :             }
; 5933 :         }
; 5934 :     }

  0007d	eb 9e		 jmp	 SHORT $L71726
$L71727:

; 5935 :     // Make sure that we do not end up with out of order RTimes. This can happen with
; 5936 :     // DMUS_PMSGF_LOCKTOREFTIME messages or very abrupt changes in tempo.
; 5937 :     for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )

  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _pList$[ebp]
  00082	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00087	89 45 fc	 mov	 DWORD PTR _pCheck$[ebp], eax
  0008a	eb 08		 jmp	 SHORT $L71731
$L71732:
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _pCheck$[ebp]
  0008f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00091	89 55 fc	 mov	 DWORD PTR _pCheck$[ebp], edx
$L71731:
  00094	83 7d fc 00	 cmp	 DWORD PTR _pCheck$[ebp], 0
  00098	74 3d		 je	 SHORT $L71733

; 5938 :     {
; 5939 :         if (pCheck->pNext && ( pCheck->rtTime > pCheck->pNext->rtTime ))

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _pCheck$[ebp]
  0009d	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a0	74 33		 je	 SHORT $L71734
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _pCheck$[ebp]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _pCheck$[ebp]
  000aa	89 45 f0	 mov	 DWORD PTR tv157[ebp], eax
  000ad	89 55 ec	 mov	 DWORD PTR tv158[ebp], edx
  000b0	8b 4d f0	 mov	 ecx, DWORD PTR tv157[ebp]
  000b3	8b 55 ec	 mov	 edx, DWORD PTR tv158[ebp]
  000b6	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  000b9	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  000bc	7c 17		 jl	 SHORT $L71734
  000be	7f 0e		 jg	 SHORT $L75496
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR tv157[ebp]
  000c3	8b 55 ec	 mov	 edx, DWORD PTR tv158[ebp]
  000c6	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  000c9	3b 42 20	 cmp	 eax, DWORD PTR [edx+32]
  000cc	76 07		 jbe	 SHORT $L71734
$L75496:

; 5940 :         {
; 5941 :             fError = TRUE;  // Need to sort the list.

  000ce	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fError$[ebp], 1
$L71734:

; 5942 :         }
; 5943 :     }

  000d5	eb b5		 jmp	 SHORT $L71732
$L71733:

; 5944 :     if (fError)

  000d7	83 7d f8 00	 cmp	 DWORD PTR _fError$[ebp], 0
  000db	74 08		 je	 SHORT $L71722

; 5945 :     {
; 5946 :         TraceI(2,"Rearrangement of times in message list due to tempo change, resorting\n");
; 5947 :         pList->Sort();

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _pList$[ebp]
  000e0	e8 00 00 00 00	 call	 ?Sort@CPMsgQueue@@QAEXXZ ; CPMsgQueue::Sort
$L71722:

; 5948 :     }
; 5949 : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ENDP ; CPerformance::RevalidateRefTimes
_TEXT	ENDS
PUBLIC	?AllocPMsg@CPerformance@@AAEJKPAPAUPRIV_PMSG@@@Z ; CPerformance::AllocPMsg
PUBLIC	?AddToTempoMap@CPerformance@@AAEXNJ_J@Z		; CPerformance::AddToTempoMap
PUBLIC	__real@408f400000000000
PUBLIC	__real@3ff0000000000000
EXTRN	?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z:NEAR ; CPMsgQueue::FlushOldest
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AddToTempoMap@CPerformance@@AAEXNJ_J@Z
_TEXT	SEGMENT
_this$ = -24
_pITempo$ = -20
_pChange$ = -16
_pCheck$ = -12
_rtNow$ = -8
_dblTempo$ = 8
_mtTime$ = 16
_rtTime$ = 20
?AddToTempoMap@CPerformance@@AAEXNJ_J@Z PROC NEAR	; CPerformance::AddToTempoMap, COMDAT
; _this$ = ecx

; 5952 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 5953 :     DMInternalTempo* pITempo = NULL;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pITempo$[ebp], 0

; 5954 :     // The following shouldn't be necessary, so it would be nice to remove this eventually.
; 5955 :     // For some reason, duplicate tempos are being entered under some circumstances.
; 5956 :     // These can eat up a lot of memory. 
; 5957 :     // So, ignore is this was already called with the same time and tempo.
; 5958 :     if (dblTempo == m_dblLastTempo && mtTime == m_mtLastTempoTime)

  00010	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	dd 45 08	 fld	 QWORD PTR _dblTempo$[ebp]
  00016	dc 98 68 01 00
	00		 fcomp	 QWORD PTR [eax+360]
  0001c	df e0		 fnstsw	 ax
  0001e	f6 c4 44	 test	 ah, 68			; 00000044H
  00021	7a 13		 jp	 SHORT $L71744
  00023	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 10	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00029	3b 91 70 01 00
	00		 cmp	 edx, DWORD PTR [ecx+368]
  0002f	75 05		 jne	 SHORT $L71744

; 5959 :     {
; 5960 :         return;

  00031	e9 d9 01 00 00	 jmp	 $L71742
$L71744:

; 5961 :     }
; 5962 :     m_dblLastTempo = dblTempo;

  00036	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _dblTempo$[ebp]
  0003c	89 88 68 01 00
	00		 mov	 DWORD PTR [eax+360], ecx
  00042	8b 55 0c	 mov	 edx, DWORD PTR _dblTempo$[ebp+4]
  00045	89 90 6c 01 00
	00		 mov	 DWORD PTR [eax+364], edx

; 5963 :     m_mtLastTempoTime = mtTime;

  0004b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00051	89 88 70 01 00
	00		 mov	 DWORD PTR [eax+368], ecx

; 5964 :     if( FAILED( AllocPMsg( sizeof(DMInternalTempo), (PRIV_PMSG**)&pITempo )))

  00057	8d 55 ec	 lea	 edx, DWORD PTR _pITempo$[ebp]
  0005a	52		 push	 edx
  0005b	6a 60		 push	 96			; 00000060H
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?AllocPMsg@CPerformance@@AAEJKPAPAUPRIV_PMSG@@@Z ; CPerformance::AllocPMsg
  00065	85 c0		 test	 eax, eax
  00067	7d 05		 jge	 SHORT $L71748

; 5965 :     {
; 5966 :         return; // out of memory!

  00069	e9 a1 01 00 00	 jmp	 $L71742
$L71748:

; 5967 :     }
; 5968 :     if( dblTempo > DMUS_TEMPO_MAX ) dblTempo = DMUS_TEMPO_MAX;

  0006e	dd 45 08	 fld	 QWORD PTR _dblTempo$[ebp]
  00071	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@408f400000000000
  00077	df e0		 fnstsw	 ax
  00079	f6 c4 41	 test	 ah, 65			; 00000041H
  0007c	75 10		 jne	 SHORT $L71749
  0007e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _dblTempo$[ebp], 0
  00085	c7 45 0c 00 40
	8f 40		 mov	 DWORD PTR _dblTempo$[ebp+4], 1083129856 ; 408f4000H

; 5969 :     else if( dblTempo < DMUS_TEMPO_MIN ) dblTempo = DMUS_TEMPO_MIN;

  0008c	eb 1e		 jmp	 SHORT $L71750
$L71749:
  0008e	dd 45 08	 fld	 QWORD PTR _dblTempo$[ebp]
  00091	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00097	df e0		 fnstsw	 ax
  00099	f6 c4 05	 test	 ah, 5
  0009c	7a 0e		 jp	 SHORT $L71750
  0009e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _dblTempo$[ebp], 0
  000a5	c7 45 0c 00 00
	f0 3f		 mov	 DWORD PTR _dblTempo$[ebp+4], 1072693248 ; 3ff00000H
$L71750:

; 5970 :     pITempo->tempoPMsg.dblTempo = dblTempo;

  000ac	8b 45 ec	 mov	 eax, DWORD PTR _pITempo$[ebp]
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _dblTempo$[ebp]
  000b2	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  000b5	8b 55 0c	 mov	 edx, DWORD PTR _dblTempo$[ebp+4]
  000b8	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 5971 :     pITempo->tempoPMsg.rtTime = rtTime;

  000bb	8b 45 ec	 mov	 eax, DWORD PTR _pITempo$[ebp]
  000be	8b 4d 14	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  000c1	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  000c4	8b 55 18	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  000c7	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 5972 :     pITempo->tempoPMsg.mtTime = mtTime;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _pITempo$[ebp]
  000cd	8b 4d 10	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000d0	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 5973 :     pITempo->tempoPMsg.dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;

  000d3	8b 55 ec	 mov	 edx, DWORD PTR _pITempo$[ebp]
  000d6	c7 42 2c 03 00
	00 00		 mov	 DWORD PTR [edx+44], 3

; 5974 :     pITempo->pNext = NULL;

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _pITempo$[ebp]
  000e0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 5975 :     // set the relative tempo field
; 5976 :     ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);

  000e6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  000ef	51		 push	 ecx
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5977 :     pITempo->fltRelTempo = m_fltRelTempo;

  000f6	8b 55 ec	 mov	 edx, DWORD PTR _pITempo$[ebp]
  000f9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 88 e8 02 00
	00		 mov	 ecx, DWORD PTR [eax+744]
  00102	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 5978 :     // add the tempo event to the tempo map and clear the tool and graph pointers
; 5979 :     pITempo->tempoPMsg.pTool = NULL;

  00105	8b 55 ec	 mov	 edx, DWORD PTR _pITempo$[ebp]
  00108	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 5980 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0010f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00112	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00117	50		 push	 eax
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 5981 :     // remove stale tempo events from the tempo map.
; 5982 :     // as long as there is another tempo with a time stamp before the current
; 5983 :     // time, get rid of the first in the list.
; 5984 :     REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.

  0011e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  00126	2d 80 96 98 00	 sub	 eax, 10000000		; 00989680H
  0012b	83 da 00	 sbb	 edx, 0
  0012e	89 45 f8	 mov	 DWORD PTR _rtNow$[ebp], eax
  00131	89 55 fc	 mov	 DWORD PTR _rtNow$[ebp+4], edx
$L71755:

; 5985 :     PRIV_PMSG* pCheck;
; 5986 :     while (pCheck = m_TempoMap.FlushOldest(rtNow))

  00134	8b 4d fc	 mov	 ecx, DWORD PTR _rtNow$[ebp+4]
  00137	51		 push	 ecx
  00138	8b 55 f8	 mov	 edx, DWORD PTR _rtNow$[ebp]
  0013b	52		 push	 edx
  0013c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  00145	e8 00 00 00 00	 call	 ?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z ; CPMsgQueue::FlushOldest
  0014a	89 45 f4	 mov	 DWORD PTR _pCheck$[ebp], eax
  0014d	83 7d f4 00	 cmp	 DWORD PTR _pCheck$[ebp], 0
  00151	74 14		 je	 SHORT $L71756

; 5987 :     {
; 5988 :         m_OldTempoMap.Enqueue(pCheck);

  00153	8b 45 f4	 mov	 eax, DWORD PTR _pCheck$[ebp]
  00156	50		 push	 eax
  00157	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00160	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 5989 :     }

  00165	eb cd		 jmp	 SHORT $L71755
$L71756:

; 5990 :     // add the new tempo event to the queue
; 5991 :     m_TempoMap.Enqueue( (PRIV_PMSG*) pITempo );

  00167	8b 4d ec	 mov	 ecx, DWORD PTR _pITempo$[ebp]
  0016a	51		 push	 ecx
  0016b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  00174	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 5992 :     // now that it's been added, scan forward from it and change the relative tempo
; 5993 :     // times of everyone after it
; 5994 :     DMInternalTempo* pChange;
; 5995 :     for( pChange = (DMInternalTempo*)pITempo->pNext; pChange; 

  00179	8b 55 ec	 mov	 edx, DWORD PTR _pITempo$[ebp]
  0017c	8b 02		 mov	 eax, DWORD PTR [edx]
  0017e	89 45 f0	 mov	 DWORD PTR _pChange$[ebp], eax
  00181	eb 08		 jmp	 SHORT $L71761
$L71762:

; 5996 :         pChange = (DMInternalTempo*)pChange->pNext )

  00183	8b 4d f0	 mov	 ecx, DWORD PTR _pChange$[ebp]
  00186	8b 11		 mov	 edx, DWORD PTR [ecx]
  00188	89 55 f0	 mov	 DWORD PTR _pChange$[ebp], edx
$L71761:
  0018b	83 7d f0 00	 cmp	 DWORD PTR _pChange$[ebp], 0
  0018f	74 0e		 je	 SHORT $L71763

; 5997 :     {
; 5998 :         pChange->fltRelTempo = pITempo->fltRelTempo;

  00191	8b 45 f0	 mov	 eax, DWORD PTR _pChange$[ebp]
  00194	8b 4d ec	 mov	 ecx, DWORD PTR _pITempo$[ebp]
  00197	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0019a	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 5999 :     }

  0019d	eb e4		 jmp	 SHORT $L71762
$L71763:

; 6000 :     // remove stale tempo events from the old tempo map.
; 6001 :     // as long as there is another tempo with a time stamp before the current
; 6002 :     // time, get rid of the first in the list.
; 6003 :     rtNow = GetTime() - ((REFERENCE_TIME)10000 * 60 * 1000); // keep around for one minute.

  0019f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  001a7	2d 00 46 c3 23	 sub	 eax, 600000000		; 23c34600H
  001ac	83 da 00	 sbb	 edx, 0
  001af	89 45 f8	 mov	 DWORD PTR _rtNow$[ebp], eax
  001b2	89 55 fc	 mov	 DWORD PTR _rtNow$[ebp+4], edx
$L71766:

; 6004 :     while (pCheck = m_OldTempoMap.FlushOldest(rtNow))

  001b5	8b 45 fc	 mov	 eax, DWORD PTR _rtNow$[ebp+4]
  001b8	50		 push	 eax
  001b9	8b 4d f8	 mov	 ecx, DWORD PTR _rtNow$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  001c6	e8 00 00 00 00	 call	 ?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z ; CPMsgQueue::FlushOldest
  001cb	89 45 f4	 mov	 DWORD PTR _pCheck$[ebp], eax
  001ce	83 7d f4 00	 cmp	 DWORD PTR _pCheck$[ebp], 0
  001d2	74 0e		 je	 SHORT $L71767

; 6005 :     {
; 6006 :         FreePMsg(pCheck);

  001d4	8b 55 f4	 mov	 edx, DWORD PTR _pCheck$[ebp]
  001d7	52		 push	 edx
  001d8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 6007 :     }

  001e0	eb d3		 jmp	 SHORT $L71766
$L71767:

; 6008 :     m_fTempoChanged = TRUE;

  001e2	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001e5	c7 80 cc 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+972], 1

; 6009 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  001ef	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f2	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  001f8	51		 push	 ecx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6010 :     LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  001ff	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00202	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  00208	52		 push	 edx
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L71742:

; 6011 : }

  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c2 14 00	 ret	 20			; 00000014H
?AddToTempoMap@CPerformance@@AAEXNJ_J@Z ENDP		; CPerformance::AddToTempoMap
_TEXT	ENDS
PUBLIC	?AddEventToTempoMap@CPerformance@@AAEXPAUPRIV_PMSG@@@Z ; CPerformance::AddEventToTempoMap
; Function compile flags: /Odt
;	COMDAT ?AddEventToTempoMap@CPerformance@@AAEXPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT
_this$ = -12
_pTempo$ = -8
_mtTime$ = -4
_pEvent$ = 8
?AddEventToTempoMap@CPerformance@@AAEXPAUPRIV_PMSG@@@Z PROC NEAR ; CPerformance::AddEventToTempoMap, COMDAT
; _this$ = ecx

; 6014 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 6015 :     PRIV_TEMPO_PMSG* pTempo = (PRIV_TEMPO_PMSG*)pEvent;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _pTempo$[ebp], eax

; 6016 :     MUSIC_TIME mtTime = pTempo->tempoPMsg.mtTime;

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _pTempo$[ebp]
  00012	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00015	89 55 fc	 mov	 DWORD PTR _mtTime$[ebp], edx

; 6017 :     AddToTempoMap( pTempo->tempoPMsg.dblTempo, mtTime, pTempo->tempoPMsg.rtTime );

  00018	8b 45 f8	 mov	 eax, DWORD PTR _pTempo$[ebp]
  0001b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0001e	51		 push	 ecx
  0001f	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00022	52		 push	 edx
  00023	8b 45 fc	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _pTempo$[ebp]
  0002a	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0002d	52		 push	 edx
  0002e	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00031	50		 push	 eax
  00032	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AddToTempoMap@CPerformance@@AAEXNJ_J@Z ; CPerformance::AddToTempoMap

; 6018 :     pEvent->dwPrivFlags = PRIV_FLAG_ALLOC;

  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0003d	c7 41 04 e0 af
	0c 00		 mov	 DWORD PTR [ecx+4], 831456 ; 000cafe0H

; 6019 :     ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);

  00044	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00047	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  0004d	52		 push	 edx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6020 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00054	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00057	05 30 03 00 00	 add	 eax, 816		; 00000330H
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6021 :     // revalidate the ref times of the events in the queues
; 6022 :     RevalidateRefTimes( &m_TempoMap, mtTime );

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	81 c2 38 01 00
	00		 add	 edx, 312		; 00000138H
  00070	52		 push	 edx
  00071	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6023 :     RevalidateRefTimes( &m_OnTimeQueue, mtTime );

  00079	8b 45 fc	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00086	51		 push	 ecx
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6024 :     RevalidateRefTimes( &m_NearTimeQueue, mtTime );

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00096	05 20 01 00 00	 add	 eax, 288		; 00000120H
  0009b	50		 push	 eax
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6025 :     RevalidateRefTimes( &m_EarlyQueue, mtTime );

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	81 c2 14 01 00
	00		 add	 edx, 276		; 00000114H
  000b1	52		 push	 edx
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6026 :     m_fTempoChanged = TRUE;

  000ba	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	c7 80 cc 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+972], 1

; 6027 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  000d0	51		 push	 ecx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6028 :     LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  000d7	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000da	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  000e0	52		 push	 edx
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6029 :     RecalcTempoMap(NULL,mtTime+1);

  000e7	6a 01		 push	 1
  000e9	8b 45 fc	 mov	 eax, DWORD PTR _mtTime$[ebp]
  000ec	83 c0 01	 add	 eax, 1
  000ef	50		 push	 eax
  000f0	6a 00		 push	 0
  000f2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap

; 6030 : }

  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?AddEventToTempoMap@CPerformance@@AAEXPAUPRIV_PMSG@@@Z ENDP ; CPerformance::AddEventToTempoMap
_TEXT	ENDS
PUBLIC	?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z ; CPerformance::UpdateTempoMap
; Function compile flags: /Odt
;	COMDAT ?IncrementTempoMap@CPerformance@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IncrementTempoMap@CPerformance@@AAEXXZ PROC NEAR	; CPerformance::IncrementTempoMap, COMDAT
; _this$ = ecx

; 6036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 6037 :     if (m_mtTempoCursor <= (m_mtTransported + TEMPO_AHEAD))

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  00010	81 c1 00 78 00
	00		 add	 ecx, 30720		; 00007800H
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	39 8a d8 02 00
	00		 cmp	 DWORD PTR [edx+728], ecx
  0001f	7f 18		 jg	 SHORT $L71777

; 6038 :     {
; 6039 :         UpdateTempoMap(m_mtTempoCursor, false, NULL);

  00021	6a 01		 push	 1
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 88 d8 02 00
	00		 mov	 ecx, DWORD PTR [eax+728]
  00030	51		 push	 ecx
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z ; CPerformance::UpdateTempoMap
$L71777:

; 6040 :     }
; 6041 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?IncrementTempoMap@CPerformance@@AAEXXZ ENDP		; CPerformance::IncrementTempoMap
_TEXT	ENDS
EXTRN	?IsTempoSource@CSegment@@QAEHXZ:NEAR		; CSegment::IsTempoSource
; Function compile flags: /Odt
;	COMDAT ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z
_TEXT	SEGMENT
_this$ = -24
_mtCompareTime$71790 = -20
_rtCompareTime$71788 = -16
_rtAfterTime$71789 = -8
_pSegState$ = 8
_mtStart$ = 12
_fAllDeltas$ = 16
?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z PROC NEAR ; CPerformance::RecalcTempoMap, COMDAT
; _this$ = ecx

; 6056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 6057 :     if( mtStart > 0) // Don't do this for invalid values.

  00009	83 7d 0c 00	 cmp	 DWORD PTR _mtStart$[ebp], 0
  0000d	0f 8e 6b 01 00
	00		 jle	 $L71784

; 6058 :     {
; 6059 :         if (!pSegState || (pSegState->m_pSegment && pSegState->m_pSegment->IsTempoSource()))

  00013	83 7d 08 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  00017	74 20		 je	 SHORT $L71787
  00019	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  0001c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00020	0f 84 58 01 00
	00		 je	 $L71784
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  00029	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  0002c	e8 00 00 00 00	 call	 ?IsTempoSource@CSegment@@QAEHXZ ; CSegment::IsTempoSource
  00031	85 c0		 test	 eax, eax
  00033	0f 84 45 01 00
	00		 je	 $L71784
$L71787:

; 6060 :         { 
; 6061 :             REFERENCE_TIME rtCompareTime;
; 6062 :             REFERENCE_TIME rtAfterTime;
; 6063 :             MUSIC_TIME mtCompareTime = m_mtTransported;

  00039	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 82 d0 02 00
	00		 mov	 eax, DWORD PTR [edx+720]
  00042	89 45 ec	 mov	 DWORD PTR _mtCompareTime$71790[ebp], eax

; 6064 :             MusicToReferenceTime(mtCompareTime,&rtCompareTime);

  00045	8d 4d f0	 lea	 ecx, DWORD PTR _rtCompareTime$71788[ebp]
  00048	51		 push	 ecx
  00049	8b 55 ec	 mov	 edx, DWORD PTR _mtCompareTime$71790[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00055	52		 push	 edx
  00056	ff 51 14	 call	 DWORD PTR [ecx+20]

; 6065 :             ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00061	50		 push	 eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6066 :             FlushEventQueue( 0, &m_TempoMap, rtCompareTime, rtCompareTime, 0 );

  00068	6a 00		 push	 0
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _rtCompareTime$71788[ebp+4]
  0006d	51		 push	 ecx
  0006e	8b 55 f0	 mov	 edx, DWORD PTR _rtCompareTime$71788[ebp]
  00071	52		 push	 edx
  00072	8b 45 f4	 mov	 eax, DWORD PTR _rtCompareTime$71788[ebp+4]
  00075	50		 push	 eax
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _rtCompareTime$71788[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	81 c2 38 01 00
	00		 add	 edx, 312		; 00000138H
  00083	52		 push	 edx
  00084	6a 00		 push	 0
  00086	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?FlushEventQueue@CPerformance@@AAEXKPAVCPMsgQueue@@_J1K@Z ; CPerformance::FlushEventQueue

; 6067 :             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  0008e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00091	05 30 03 00 00	 add	 eax, 816		; 00000330H
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6068 :             UpdateTempoMap(mtStart, true, pSegState, fAllDeltas);

  0009d	8a 4d 10	 mov	 cl, BYTE PTR _fAllDeltas$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 55 08	 mov	 edx, DWORD PTR _pSegState$[ebp]
  000a4	52		 push	 edx
  000a5	6a 01		 push	 1
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _mtStart$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z ; CPerformance::UpdateTempoMap

; 6069 :             MusicToReferenceTime(mtCompareTime,&rtAfterTime);

  000b3	8d 4d f8	 lea	 ecx, DWORD PTR _rtAfterTime$71789[ebp]
  000b6	51		 push	 ecx
  000b7	8b 55 ec	 mov	 edx, DWORD PTR _mtCompareTime$71790[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000c3	52		 push	 edx
  000c4	ff 51 14	 call	 DWORD PTR [ecx+20]

; 6070 :             if (rtAfterTime != rtCompareTime)

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _rtAfterTime$71789[ebp]
  000ca	3b 45 f0	 cmp	 eax, DWORD PTR _rtCompareTime$71788[ebp]
  000cd	75 0c		 jne	 SHORT $L75513
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _rtAfterTime$71789[ebp+4]
  000d2	3b 4d f4	 cmp	 ecx, DWORD PTR _rtCompareTime$71788[ebp+4]
  000d5	0f 84 a3 00 00
	00		 je	 $L71784
$L75513:

; 6071 :             {
; 6072 :                 ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);

  000db	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000de	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  000e4	52		 push	 edx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6073 :                 ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  000eb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	05 30 03 00 00	 add	 eax, 816		; 00000330H
  000f3	50		 push	 eax
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6074 :                 // revalidate the ref times of the events in the queues
; 6075 :                 RevalidateRefTimes( &m_TempoMap, mtStart );

  000fa	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  000fd	51		 push	 ecx
  000fe	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00101	81 c2 38 01 00
	00		 add	 edx, 312		; 00000138H
  00107	52		 push	 edx
  00108	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6076 :                 RevalidateRefTimes( &m_OnTimeQueue, mtStart );

  00110	8b 45 0c	 mov	 eax, DWORD PTR _mtStart$[ebp]
  00113	50		 push	 eax
  00114	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  0011d	51		 push	 ecx
  0011e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6077 :                 RevalidateRefTimes( &m_NearTimeQueue, mtStart );

  00126	8b 55 0c	 mov	 edx, DWORD PTR _mtStart$[ebp]
  00129	52		 push	 edx
  0012a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	05 20 01 00 00	 add	 eax, 288		; 00000120H
  00132	50		 push	 eax
  00133	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6078 :                 RevalidateRefTimes( &m_EarlyQueue, mtStart );

  0013b	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00142	81 c2 14 01 00
	00		 add	 edx, 276		; 00000114H
  00148	52		 push	 edx
  00149	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?RevalidateRefTimes@CPerformance@@AAEXPAVCPMsgQueue@@J@Z ; CPerformance::RevalidateRefTimes

; 6079 :                 m_fTempoChanged = TRUE;

  00151	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00154	c7 80 cc 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+972], 1

; 6080 :                 LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  0015e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  00167	51		 push	 ecx
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6081 :                 LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  0016e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00171	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  00177	52		 push	 edx
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L71784:

; 6082 :             }
; 6083 :         }
; 6084 :     }
; 6085 : }

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c2 0c 00	 ret	 12			; 0000000cH
?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ENDP ; CPerformance::RecalcTempoMap
_TEXT	ENDS
PUBLIC	??0PrivateTempo@@QAE@XZ				; PrivateTempo::PrivateTempo
PUBLIC	??0?$TList@UPrivateTempo@@@@QAE@XZ		; TList<PrivateTempo>::TList<PrivateTempo>
PUBLIC	??1?$TList@UPrivateTempo@@@@QAE@XZ		; TList<PrivateTempo>::~TList<PrivateTempo>
PUBLIC	?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
PUBLIC	?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z ; TList<PrivateTempo>::AddHead
PUBLIC	??0?$TListItem@UPrivateTempo@@@@QAE@XZ		; TListItem<PrivateTempo>::TListItem<PrivateTempo>
PUBLIC	??0?$TListItem@UPrivateTempo@@@@QAE@ABUPrivateTempo@@@Z ; TListItem<PrivateTempo>::TListItem<PrivateTempo>
PUBLIC	?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ ; TListItem<PrivateTempo>::GetNext
PUBLIC	?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z ; TListItem<PrivateTempo>::SetNext
PUBLIC	?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
PUBLIC	??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z	; TListItem<PrivateTempo>::`scalar deleting destructor'
PUBLIC	??_C@_0DA@MHNFOPIF@Error?3?5Out?5of?5memory?$DL?5Tempo?5map?5@ ; `string'
EXTRN	_GUID_PrivateTempoParam:BYTE
;	COMDAT ??_C@_0DA@MHNFOPIF@Error?3?5Out?5of?5memory?$DL?5Tempo?5map?5@
CONST	SEGMENT
??_C@_0DA@MHNFOPIF@Error?3?5Out?5of?5memory?$DL?5Tempo?5map?5@ DB 'Error:'
	DB	' Out of memory; Tempo map is incomplete.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z
_TEXT	SEGMENT
tv213 = -120
tv177 = -116
tv147 = -112
_this$ = -108
$T75524 = -104
$T75521 = -100
$T75520 = -96
$T75517 = -92
_rTempo$71948 = -88
_rNew$71942 = -84
_pNew$71938 = -80
_pNext$71915 = -76
_pNew$71867 = -72
_hr$ = -68
_dwIndex$ = -64
_pScan$ = -60
_Tempo$ = -56
_TempoList$ = -28
_rtTime$ = -24
_mtTime$ = -12
_mtNext$ = -8
_mtCursor$ = -4
_mtStart$ = 8
_fFirst$ = 12
_pSegState$ = 16
_fAllDeltas$ = 20
?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z PROC NEAR ; CPerformance::UpdateTempoMap, COMDAT
; _this$ = ecx

; 6089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 6090 :     HRESULT hr = S_OK;

  0000b	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 6091 :     DWORD dwIndex = 0;

  00012	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0

; 6092 :     PrivateTempo Tempo;

  00019	8d 4d c8	 lea	 ecx, DWORD PTR _Tempo$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0PrivateTempo@@QAE@XZ	; PrivateTempo::PrivateTempo

; 6093 :     TList<PrivateTempo> TempoList;

  00021	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$TList@UPrivateTempo@@@@QAE@XZ ; TList<PrivateTempo>::TList<PrivateTempo>

; 6094 :     TListItem<PrivateTempo>* pScan = NULL;

  00029	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _pScan$[ebp], 0

; 6095 :     MUSIC_TIME mtNext = 0;

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mtNext$[ebp], 0

; 6096 :     MUSIC_TIME mtTime = mtStart;

  00037	8b 45 08	 mov	 eax, DWORD PTR _mtStart$[ebp]
  0003a	89 45 f4	 mov	 DWORD PTR _mtTime$[ebp], eax

; 6097 :     MUSIC_TIME mtCursor = mtStart;

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  00040	89 4d fc	 mov	 DWORD PTR _mtCursor$[ebp], ecx
$L71855:

; 6098 :     REFERENCE_TIME rtTime;
; 6099 :     do
; 6100 :     {
; 6101 :         hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );

  00043	8d 55 c8	 lea	 edx, DWORD PTR _Tempo$[ebp]
  00046	52		 push	 edx
  00047	8d 45 f8	 lea	 eax, DWORD PTR _mtNext$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 c0	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00052	52		 push	 edx
  00053	6a ff		 push	 -1
  00055	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PrivateTempoParam
  0005a	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00062	52		 push	 edx
  00063	ff 51 6c	 call	 DWORD PTR [ecx+108]
  00066	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 6102 :         Tempo.mtTime = mtTime;

  00069	8b 45 f4	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0006c	89 45 d0	 mov	 DWORD PTR _Tempo$[ebp+8], eax

; 6103 :         if (hr == S_OK && Tempo.mtDelta > 0)

  0006f	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00073	75 3b		 jne	 SHORT $L71860
  00075	83 7d d4 00	 cmp	 DWORD PTR _Tempo$[ebp+12], 0
  00079	7e 35		 jle	 SHORT $L71860

; 6104 :         {
; 6105 :             mtTime += Tempo.mtDelta;

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0007e	03 4d d4	 add	 ecx, DWORD PTR _Tempo$[ebp+12]
  00081	89 4d f4	 mov	 DWORD PTR _mtTime$[ebp], ecx

; 6106 :             hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );

  00084	8d 55 c8	 lea	 edx, DWORD PTR _Tempo$[ebp]
  00087	52		 push	 edx
  00088	8d 45 f8	 lea	 eax, DWORD PTR _mtNext$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0008f	51		 push	 ecx
  00090	8b 55 c0	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00093	52		 push	 edx
  00094	6a ff		 push	 -1
  00096	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PrivateTempoParam
  0009b	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	52		 push	 edx
  000a4	ff 51 6c	 call	 DWORD PTR [ecx+108]
  000a7	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 6107 :             Tempo.mtTime = mtTime;

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _mtTime$[ebp]
  000ad	89 45 d0	 mov	 DWORD PTR _Tempo$[ebp+8], eax
$L71860:

; 6108 :         }
; 6109 :         if (hr == S_FALSE && fFirst && !pSegState)

  000b0	83 7d bc 01	 cmp	 DWORD PTR _hr$[ebp], 1
  000b4	75 5a		 jne	 SHORT $L71863
  000b6	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _fFirst$[ebp]
  000ba	85 c9		 test	 ecx, ecx
  000bc	74 52		 je	 SHORT $L71863
  000be	83 7d 10 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  000c2	75 4c		 jne	 SHORT $L71863

; 6110 :         {
; 6111 :             // If this was the very first try, there might not be any tempo track, and
; 6112 :             // so global tempo is called. If so, S_FALSE is returned. This is okay
; 6113 :             // for the NULL segstate case where we are recomputing the tempo map in response 
; 6114 :             // to a change in global tempo, or stop of all segments.
; 6115 :             if (fAllDeltas) // Never do this in response to adding a new event to the tempo map

  000c4	0f b6 55 14	 movzx	 edx, BYTE PTR _fAllDeltas$[ebp]
  000c8	85 d2		 test	 edx, edx
  000ca	74 3f		 je	 SHORT $L71864

; 6116 :             {
; 6117 :                 MusicToReferenceTime(mtTime,&rtTime);

  000cc	8d 45 e8	 lea	 eax, DWORD PTR _rtTime$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d f4	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000d3	51		 push	 ecx
  000d4	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000d7	8b 02		 mov	 eax, DWORD PTR [edx]
  000d9	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	51		 push	 ecx
  000dd	ff 50 14	 call	 DWORD PTR [eax+20]

; 6118 :                 // the rtTime in the tempo map needs to be the non-adjusted value (305694)
; 6119 :                 AddToTempoMap( Tempo.dblTempo, mtTime, rtTime + m_rtAdjust );

  000e0	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 45 e8	 mov	 eax, DWORD PTR _rtTime$[ebp]
  000e6	03 82 a0 02 00
	00		 add	 eax, DWORD PTR [edx+672]
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  000ef	13 8a a4 02 00
	00		 adc	 ecx, DWORD PTR [edx+676]
  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	8b 55 f4	 mov	 edx, DWORD PTR _mtTime$[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 cc	 mov	 eax, DWORD PTR _Tempo$[ebp+4]
  000fe	50		 push	 eax
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR _Tempo$[ebp]
  00102	51		 push	 ecx
  00103	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?AddToTempoMap@CPerformance@@AAEXNJ_J@Z ; CPerformance::AddToTempoMap
$L71864:

; 6120 :             }
; 6121 :             break;

  0010b	e9 a2 01 00 00	 jmp	 $L71857
$L71863:

; 6122 :         }
; 6123 :         if (hr == S_OK)

  00110	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00114	0f 85 72 01 00
	00		 jne	 $L71866

; 6124 :         {
; 6125 :             TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>(Tempo);

  0011a	6a 20		 push	 32			; 00000020H
  0011c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00121	83 c4 04	 add	 esp, 4
  00124	89 45 a4	 mov	 DWORD PTR $T75517[ebp], eax
  00127	83 7d a4 00	 cmp	 DWORD PTR $T75517[ebp], 0
  0012b	74 11		 je	 SHORT $L75518
  0012d	8d 55 c8	 lea	 edx, DWORD PTR _Tempo$[ebp]
  00130	52		 push	 edx
  00131	8b 4d a4	 mov	 ecx, DWORD PTR $T75517[ebp]
  00134	e8 00 00 00 00	 call	 ??0?$TListItem@UPrivateTempo@@@@QAE@ABUPrivateTempo@@@Z ; TListItem<PrivateTempo>::TListItem<PrivateTempo>
  00139	89 45 90	 mov	 DWORD PTR tv147[ebp], eax
  0013c	eb 07		 jmp	 SHORT $L75519
$L75518:
  0013e	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
$L75519:
  00145	8b 45 90	 mov	 eax, DWORD PTR tv147[ebp]
  00148	89 45 b8	 mov	 DWORD PTR _pNew$71867[ebp], eax

; 6126 :             if (pNew)

  0014b	83 7d b8 00	 cmp	 DWORD PTR _pNew$71867[ebp], 0
  0014f	0f 84 ed 00 00
	00		 je	 $L71914

; 6127 :             {
; 6128 :                 // add to TempoList, replacing duplicate times with the most recent mtDelta
; 6129 :                 TListItem<PrivateTempo>* pNext = TempoList.GetHead();

  00155	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  00158	e8 00 00 00 00	 call	 ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
  0015d	89 45 b4	 mov	 DWORD PTR _pNext$71915[ebp], eax

; 6130 :                 if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)

  00160	83 7d b4 00	 cmp	 DWORD PTR _pNext$71915[ebp], 0
  00164	74 10		 je	 SHORT $L71917
  00166	8b 4d b4	 mov	 ecx, DWORD PTR _pNext$71915[ebp]
  00169	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  0016e	8b 4d d0	 mov	 ecx, DWORD PTR _Tempo$[ebp+8]
  00171	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00174	7d 11		 jge	 SHORT $L71916
$L71917:

; 6131 :                 {
; 6132 :                     TempoList.AddHead(pNew);

  00176	8b 55 b8	 mov	 edx, DWORD PTR _pNew$71867[ebp]
  00179	52		 push	 edx
  0017a	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  0017d	e8 00 00 00 00	 call	 ?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z ; TList<PrivateTempo>::AddHead

; 6133 :                 }
; 6134 :                 else for (pScan = TempoList.GetHead(); pScan; pScan = pNext)

  00182	e9 bb 00 00 00	 jmp	 $L71914
$L71916:
  00187	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  0018a	e8 00 00 00 00	 call	 ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
  0018f	89 45 c4	 mov	 DWORD PTR _pScan$[ebp], eax
  00192	eb 06		 jmp	 SHORT $L71919
$L71920:
  00194	8b 45 b4	 mov	 eax, DWORD PTR _pNext$71915[ebp]
  00197	89 45 c4	 mov	 DWORD PTR _pScan$[ebp], eax
$L71919:
  0019a	83 7d c4 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  0019e	0f 84 9e 00 00
	00		 je	 $L71914

; 6135 :                 {
; 6136 :                     pNext = pScan->GetNext();

  001a4	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  001a7	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ ; TListItem<PrivateTempo>::GetNext
  001ac	89 45 b4	 mov	 DWORD PTR _pNext$71915[ebp], eax

; 6137 :                     if (Tempo.mtTime == pScan->GetItemValue().mtTime)

  001af	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  001b2	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  001b7	8b 4d d0	 mov	 ecx, DWORD PTR _Tempo$[ebp+8]
  001ba	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  001bd	75 4e		 jne	 SHORT $L71922

; 6138 :                     {
; 6139 :                         if (Tempo.mtDelta > pScan->GetItemValue().mtDelta)

  001bf	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  001c2	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  001c7	8b 55 d4	 mov	 edx, DWORD PTR _Tempo$[ebp+12]
  001ca	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  001cd	7e 14		 jle	 SHORT $L71923

; 6140 :                         {
; 6141 :                             pScan->GetItemValue() = Tempo;

  001cf	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  001d2	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  001d7	b9 06 00 00 00	 mov	 ecx, 6
  001dc	8d 75 c8	 lea	 esi, DWORD PTR _Tempo$[ebp]
  001df	8b f8		 mov	 edi, eax
  001e1	f3 a5		 rep movsd
$L71923:

; 6142 :                         }
; 6143 :                         delete pNew;

  001e3	8b 45 b8	 mov	 eax, DWORD PTR _pNew$71867[ebp]
  001e6	89 45 9c	 mov	 DWORD PTR $T75521[ebp], eax
  001e9	8b 4d 9c	 mov	 ecx, DWORD PTR $T75521[ebp]
  001ec	89 4d a0	 mov	 DWORD PTR $T75520[ebp], ecx
  001ef	83 7d a0 00	 cmp	 DWORD PTR $T75520[ebp], 0
  001f3	74 0f		 je	 SHORT $L75522
  001f5	6a 01		 push	 1
  001f7	8b 4d a0	 mov	 ecx, DWORD PTR $T75520[ebp]
  001fa	e8 00 00 00 00	 call	 ??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z
  001ff	89 45 8c	 mov	 DWORD PTR tv177[ebp], eax
  00202	eb 07		 jmp	 SHORT $L75523
$L75522:
  00204	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv177[ebp], 0
$L75523:

; 6144 :                         break;

  0020b	eb 35		 jmp	 SHORT $L71914
$L71922:

; 6145 :                     }
; 6146 :                     else if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)

  0020d	83 7d b4 00	 cmp	 DWORD PTR _pNext$71915[ebp], 0
  00211	74 10		 je	 SHORT $L71928
  00213	8b 4d b4	 mov	 ecx, DWORD PTR _pNext$71915[ebp]
  00216	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  0021b	8b 55 d0	 mov	 edx, DWORD PTR _Tempo$[ebp+8]
  0021e	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00221	7d 1a		 jge	 SHORT $L71926
$L71928:

; 6147 :                     {
; 6148 :                         pScan->SetNext(pNew);

  00223	8b 45 b8	 mov	 eax, DWORD PTR _pNew$71867[ebp]
  00226	50		 push	 eax
  00227	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0022a	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z ; TListItem<PrivateTempo>::SetNext

; 6149 :                         pNew->SetNext(pNext);

  0022f	8b 4d b4	 mov	 ecx, DWORD PTR _pNext$71915[ebp]
  00232	51		 push	 ecx
  00233	8b 4d b8	 mov	 ecx, DWORD PTR _pNew$71867[ebp]
  00236	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z ; TListItem<PrivateTempo>::SetNext

; 6150 :                         break;

  0023b	eb 05		 jmp	 SHORT $L71914
$L71926:

; 6151 :                     }
; 6152 :                 }

  0023d	e9 52 ff ff ff	 jmp	 $L71920
$L71914:

; 6153 :             }
; 6154 :             mtTime += mtNext;

  00242	8b 55 f4	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00245	03 55 f8	 add	 edx, DWORD PTR _mtNext$[ebp]
  00248	89 55 f4	 mov	 DWORD PTR _mtTime$[ebp], edx

; 6155 :             fFirst = false;

  0024b	c6 45 0c 00	 mov	 BYTE PTR _fFirst$[ebp], 0

; 6156 :             // If this was the last tempo in the track (that we care about),
; 6157 :             // reset the time and bump the track index
; 6158 :             if (Tempo.fLast || mtTime > (m_mtTransported + TEMPO_AHEAD))

  0024f	0f b6 45 d8	 movzx	 eax, BYTE PTR _Tempo$[ebp+16]
  00253	85 c0		 test	 eax, eax
  00255	75 14		 jne	 SHORT $L71930
  00257	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	8b 91 d0 02 00
	00		 mov	 edx, DWORD PTR [ecx+720]
  00260	81 c2 00 78 00
	00		 add	 edx, 30720		; 00007800H
  00266	39 55 f4	 cmp	 DWORD PTR _mtTime$[ebp], edx
  00269	7e 17		 jle	 SHORT $L71929
$L71930:

; 6159 :             {
; 6160 :                 dwIndex++;

  0026b	8b 45 c0	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0026e	83 c0 01	 add	 eax, 1
  00271	89 45 c0	 mov	 DWORD PTR _dwIndex$[ebp], eax

; 6161 :                 mtCursor = mtTime;

  00274	8b 4d f4	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00277	89 4d fc	 mov	 DWORD PTR _mtCursor$[ebp], ecx

; 6162 :                 mtTime = mtStart;

  0027a	8b 55 08	 mov	 edx, DWORD PTR _mtStart$[ebp]
  0027d	89 55 f4	 mov	 DWORD PTR _mtTime$[ebp], edx

; 6163 :             }
; 6164 :             else if (!mtNext) break; // should never happen but if it does, infinite loop

  00280	eb 08		 jmp	 SHORT $L71931
$L71929:
  00282	83 7d f8 00	 cmp	 DWORD PTR _mtNext$[ebp], 0
  00286	75 02		 jne	 SHORT $L71931
  00288	eb 28		 jmp	 SHORT $L71857
$L71931:

; 6165 :         }
; 6166 :         else if (Tempo.fLast) // There was an empty tempo track

  0028a	eb 18		 jmp	 SHORT $L71933
$L71866:
  0028c	0f b6 45 d8	 movzx	 eax, BYTE PTR _Tempo$[ebp+16]
  00290	85 c0		 test	 eax, eax
  00292	74 10		 je	 SHORT $L71933

; 6167 :         {
; 6168 :             dwIndex++;

  00294	8b 4d c0	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00297	83 c1 01	 add	 ecx, 1
  0029a	89 4d c0	 mov	 DWORD PTR _dwIndex$[ebp], ecx

; 6169 :             hr = S_OK;

  0029d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L71933:

; 6170 :         }
; 6171 :         Tempo.fLast = false;

  002a4	c6 45 d8 00	 mov	 BYTE PTR _Tempo$[ebp+16], 0

; 6172 :     } while (hr == S_OK);

  002a8	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002ac	0f 84 91 fd ff
	ff		 je	 $L71855
$L71857:

; 6173 :     if (TempoList.GetHead() && TempoList.GetHead()->GetItemValue().mtTime > mtStart)

  002b2	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  002b5	e8 00 00 00 00	 call	 ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
  002ba	85 c0		 test	 eax, eax
  002bc	0f 84 a4 00 00
	00		 je	 $L71937
  002c2	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  002c5	e8 00 00 00 00	 call	 ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
  002ca	8b c8		 mov	 ecx, eax
  002cc	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  002d1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002d4	3b 55 08	 cmp	 edx, DWORD PTR _mtStart$[ebp]
  002d7	0f 8e 89 00 00
	00		 jle	 $L71937

; 6174 :     {
; 6175 :         // add a tempo of 120 at time mtStart
; 6176 :         TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>();

  002dd	6a 20		 push	 32			; 00000020H
  002df	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002e4	83 c4 04	 add	 esp, 4
  002e7	89 45 98	 mov	 DWORD PTR $T75524[ebp], eax
  002ea	83 7d 98 00	 cmp	 DWORD PTR $T75524[ebp], 0
  002ee	74 0d		 je	 SHORT $L75525
  002f0	8b 4d 98	 mov	 ecx, DWORD PTR $T75524[ebp]
  002f3	e8 00 00 00 00	 call	 ??0?$TListItem@UPrivateTempo@@@@QAE@XZ ; TListItem<PrivateTempo>::TListItem<PrivateTempo>
  002f8	89 45 88	 mov	 DWORD PTR tv213[ebp], eax
  002fb	eb 07		 jmp	 SHORT $L75526
$L75525:
  002fd	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv213[ebp], 0
$L75526:
  00304	8b 45 88	 mov	 eax, DWORD PTR tv213[ebp]
  00307	89 45 b0	 mov	 DWORD PTR _pNew$71938[ebp], eax

; 6177 :         if (pNew)

  0030a	83 7d b0 00	 cmp	 DWORD PTR _pNew$71938[ebp], 0
  0030e	74 32		 je	 SHORT $L71941

; 6178 :         {
; 6179 :             PrivateTempo& rNew = pNew->GetItemValue();

  00310	8b 4d b0	 mov	 ecx, DWORD PTR _pNew$71938[ebp]
  00313	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  00318	89 45 ac	 mov	 DWORD PTR _rNew$71942[ebp], eax

; 6180 :             rNew.dblTempo = 120.0;

  0031b	8b 4d ac	 mov	 ecx, DWORD PTR _rNew$71942[ebp]
  0031e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00324	c7 41 04 00 00
	5e 40		 mov	 DWORD PTR [ecx+4], 1079902208 ; 405e0000H

; 6181 :             rNew.mtTime = mtStart;

  0032b	8b 55 ac	 mov	 edx, DWORD PTR _rNew$71942[ebp]
  0032e	8b 45 08	 mov	 eax, DWORD PTR _mtStart$[ebp]
  00331	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 6182 :             TempoList.AddHead(pNew);

  00334	8b 4d b0	 mov	 ecx, DWORD PTR _pNew$71938[ebp]
  00337	51		 push	 ecx
  00338	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  0033b	e8 00 00 00 00	 call	 ?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z ; TList<PrivateTempo>::AddHead

; 6183 :         }
; 6184 :         else

  00340	eb 24		 jmp	 SHORT $L71937
$L71941:

; 6185 :         {
; 6186 : #ifdef DBG
; 6187 :             Trace(1, "Error: Out of memory; Tempo map is incomplete.\n");

  00342	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DA@MHNFOPIF@Error?3?5Out?5of?5memory?$DL?5Tempo?5map?5@
  00347	6a 01		 push	 1
  00349	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0034e	83 c4 08	 add	 esp, 8

; 6188 : #endif
; 6189 :             TempoList.GetHead()->GetItemValue().mtTime = mtStart;

  00351	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  00354	e8 00 00 00 00	 call	 ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
  00359	8b c8		 mov	 ecx, eax
  0035b	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  00360	8b 55 08	 mov	 edx, DWORD PTR _mtStart$[ebp]
  00363	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L71937:

; 6190 :         }
; 6191 :     }
; 6192 :     for (pScan = TempoList.GetHead(); pScan; pScan = pScan->GetNext())

  00366	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  00369	e8 00 00 00 00	 call	 ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ; TList<PrivateTempo>::GetHead
  0036e	89 45 c4	 mov	 DWORD PTR _pScan$[ebp], eax
  00371	eb 0b		 jmp	 SHORT $L71945
$L71946:
  00373	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00376	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ ; TListItem<PrivateTempo>::GetNext
  0037b	89 45 c4	 mov	 DWORD PTR _pScan$[ebp], eax
$L71945:
  0037e	83 7d c4 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00382	74 6d		 je	 SHORT $L71947

; 6193 :     {
; 6194 :         PrivateTempo& rTempo = pScan->GetItemValue();

  00384	8b 4d c4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00387	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ; TListItem<PrivateTempo>::GetItemValue
  0038c	89 45 a8	 mov	 DWORD PTR _rTempo$71948[ebp], eax

; 6195 :         if (fAllDeltas || rTempo.mtTime + rTempo.mtDelta >= mtStart)

  0038f	0f b6 45 14	 movzx	 eax, BYTE PTR _fAllDeltas$[ebp]
  00393	85 c0		 test	 eax, eax
  00395	75 11		 jne	 SHORT $L71950
  00397	8b 4d a8	 mov	 ecx, DWORD PTR _rTempo$71948[ebp]
  0039a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0039d	8b 45 a8	 mov	 eax, DWORD PTR _rTempo$71948[ebp]
  003a0	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  003a3	3b 55 08	 cmp	 edx, DWORD PTR _mtStart$[ebp]
  003a6	7c 47		 jl	 SHORT $L71949
$L71950:

; 6196 :         {
; 6197 :             MusicToReferenceTime(rTempo.mtTime,&rtTime);

  003a8	8d 4d e8	 lea	 ecx, DWORD PTR _rtTime$[ebp]
  003ab	51		 push	 ecx
  003ac	8b 55 a8	 mov	 edx, DWORD PTR _rTempo$71948[ebp]
  003af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003b2	50		 push	 eax
  003b3	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  003b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b8	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  003bb	50		 push	 eax
  003bc	ff 52 14	 call	 DWORD PTR [edx+20]

; 6198 :             // the rtTime in the tempo map needs to be the non-adjusted value (305694)
; 6199 :             AddToTempoMap( rTempo.dblTempo, rTempo.mtTime, rtTime + m_rtAdjust );

  003bf	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  003c2	8b 55 e8	 mov	 edx, DWORD PTR _rtTime$[ebp]
  003c5	03 91 a0 02 00
	00		 add	 edx, DWORD PTR [ecx+672]
  003cb	8b 45 ec	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  003ce	13 81 a4 02 00
	00		 adc	 eax, DWORD PTR [ecx+676]
  003d4	50		 push	 eax
  003d5	52		 push	 edx
  003d6	8b 4d a8	 mov	 ecx, DWORD PTR _rTempo$71948[ebp]
  003d9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003dc	52		 push	 edx
  003dd	8b 45 a8	 mov	 eax, DWORD PTR _rTempo$71948[ebp]
  003e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003e3	51		 push	 ecx
  003e4	8b 10		 mov	 edx, DWORD PTR [eax]
  003e6	52		 push	 edx
  003e7	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  003ea	e8 00 00 00 00	 call	 ?AddToTempoMap@CPerformance@@AAEXNJ_J@Z ; CPerformance::AddToTempoMap
$L71949:

; 6200 :         }
; 6201 :     }

  003ef	eb 82		 jmp	 SHORT $L71946
$L71947:

; 6202 :     m_mtTempoCursor = mtCursor;

  003f1	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  003f4	8b 4d fc	 mov	 ecx, DWORD PTR _mtCursor$[ebp]
  003f7	89 88 d8 02 00
	00		 mov	 DWORD PTR [eax+728], ecx

; 6203 : }

  003fd	8d 4d e4	 lea	 ecx, DWORD PTR _TempoList$[ebp]
  00400	e8 00 00 00 00	 call	 ??1?$TList@UPrivateTempo@@@@QAE@XZ ; TList<PrivateTempo>::~TList<PrivateTempo>
  00405	5f		 pop	 edi
  00406	5e		 pop	 esi
  00407	8b e5		 mov	 esp, ebp
  00409	5d		 pop	 ebp
  0040a	c2 10 00	 ret	 16			; 00000010H
?UpdateTempoMap@CPerformance@@AAEXJ_NPAVCSegState@@0@Z ENDP ; CPerformance::UpdateTempoMap
_TEXT	ENDS
PUBLIC	??1?$TListItem@UPrivateTempo@@@@QAE@XZ		; TListItem<PrivateTempo>::~TListItem<PrivateTempo>
; Function compile flags: /Odt
;	COMDAT ??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z PROC NEAR	; TListItem<PrivateTempo>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$TListItem@UPrivateTempo@@@@QAE@XZ ; TListItem<PrivateTempo>::~TListItem<PrivateTempo>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L71954
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L71954:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z ENDP		; TListItem<PrivateTempo>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@ ; `string'
PUBLIC	??_C@_0GE@BACJCOHH@Error?3?5Unable?5to?5convert?5music?5t@ ; `string'
EXTRN	__ftol2:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::MusicToReferenceTime', 00H ; `CPerformance::MusicToReferenceTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@
CONST	SEGMENT
??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@ DB '%s: Inva'
	DB	'lid pointer prtTime', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@BACJCOHH@Error?3?5Unable?5to?5convert?5music?5t@
CONST	SEGMENT
??_C@_0GE@BACJCOHH@Error?3?5Unable?5to?5convert?5music?5t@ DB 'Error: Una'
	DB	'ble to convert music to reference time because the performanc'
	DB	'e has not been initialized.', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z
_TEXT	SEGMENT
_pTempo$71988 = -40
_pTempo$71979 = -36
_dbl$ = -32
_rtTemp$ = -24
_pEvent$ = -16
_mtTempo$ = -12
_rtTempo$ = -8
_this$ = 8
_mtTime$ = 12
_prtTime$ = 16
?MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z PROC NEAR ; CPerformance::MusicToReferenceTime, COMDAT

; 6208 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 6209 :     V_INAME(IDirectMusicPerformance::MusicToReferenceTime);
; 6210 :     V_PTR_WRITE(prtTime,REFERENCE_TIME);

  00006	6a 08		 push	 8
  00008	8b 45 10	 mov	 eax, DWORD PTR _prtTime$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L71963
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L71963:

; 6211 : 
; 6212 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6213 :     if( m_pClock == NULL )

  0003e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00045	75 28		 jne	 SHORT $L71965

; 6214 :     {
; 6215 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6216 :         Trace(0,"Error: Unable to convert music to reference time because the performance has not been initialized.\n");

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GE@BACJCOHH@Error?3?5Unable?5to?5convert?5music?5t@
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00062	83 c4 08	 add	 esp, 8

; 6217 :         return DMUS_E_NO_MASTER_CLOCK;

  00065	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0006a	e9 d8 01 00 00	 jmp	 $L71959
$L71965:

; 6218 :     }
; 6219 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00078	51		 push	 ecx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6220 : 
; 6221 :     PRIV_PMSG*  pEvent;
; 6222 :     double dbl = 120;

  0007f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dbl$[ebp], 0
  00086	c7 45 e4 00 00
	5e 40		 mov	 DWORD PTR _dbl$[ebp+4], 1079902208 ; 405e0000H

; 6223 :     MUSIC_TIME mtTempo = 0;

  0008d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mtTempo$[ebp], 0

; 6224 :     REFERENCE_TIME rtTempo = m_rtStart;

  00094	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00097	8b 82 98 02 00
	00		 mov	 eax, DWORD PTR [edx+664]
  0009d	89 45 f8	 mov	 DWORD PTR _rtTempo$[ebp], eax
  000a0	8b 8a 9c 02 00
	00		 mov	 ecx, DWORD PTR [edx+668]
  000a6	89 4d fc	 mov	 DWORD PTR _rtTempo$[ebp+4], ecx

; 6225 :     REFERENCE_TIME rtTemp;
; 6226 : 
; 6227 :     ENTER_CRITICAL_SECTION( &m_PipelineCrSec );

  000a9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000b2	52		 push	 edx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6228 :     ENTER_API_CRITICAL_SECTION;
; 6229 :     pEvent = m_TempoMap.GetHead();

  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  000c2	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  000c7	89 45 f0	 mov	 DWORD PTR _pEvent$[ebp], eax

; 6230 :     if( pEvent )

  000ca	83 7d f0 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  000ce	0f 84 cb 00 00
	00		 je	 $L71973

; 6231 :     {
; 6232 :         if( mtTime >= pEvent->mtTime )

  000d4	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  000d7	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000da	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  000dd	7c 50		 jl	 SHORT $L71974
$L71976:

; 6233 :         {
; 6234 :             while( pEvent->pNext )

  000df	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000e2	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000e5	74 19		 je	 SHORT $L71977

; 6235 :             {
; 6236 :                 if( pEvent->pNext->mtTime > mtTime )

  000e7	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  000ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ec	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000ef	3b 55 0c	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  000f2	7e 02		 jle	 SHORT $L71978

; 6237 :                 {
; 6238 :                     break;

  000f4	eb 0a		 jmp	 SHORT $L71977
$L71978:

; 6239 :                 }
; 6240 :                 pEvent = pEvent->pNext;

  000f6	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	89 4d f0	 mov	 DWORD PTR _pEvent$[ebp], ecx

; 6241 :             }

  000fe	eb df		 jmp	 SHORT $L71976
$L71977:

; 6242 :             DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;

  00100	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00103	89 55 dc	 mov	 DWORD PTR _pTempo$71979[ebp], edx

; 6243 :             dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;

  00106	8b 45 dc	 mov	 eax, DWORD PTR _pTempo$71979[ebp]
  00109	d9 40 58	 fld	 DWORD PTR [eax+88]
  0010c	8b 4d dc	 mov	 ecx, DWORD PTR _pTempo$71979[ebp]
  0010f	dc 49 50	 fmul	 QWORD PTR [ecx+80]
  00112	dd 5d e0	 fstp	 QWORD PTR _dbl$[ebp]

; 6244 :             mtTempo = pTempo->tempoPMsg.mtTime;

  00115	8b 55 dc	 mov	 edx, DWORD PTR _pTempo$71979[ebp]
  00118	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0011b	89 45 f4	 mov	 DWORD PTR _mtTempo$[ebp], eax

; 6245 :             rtTempo = pTempo->tempoPMsg.rtTime;

  0011e	8b 4d dc	 mov	 ecx, DWORD PTR _pTempo$71979[ebp]
  00121	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00124	89 55 f8	 mov	 DWORD PTR _rtTempo$[ebp], edx
  00127	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0012a	89 45 fc	 mov	 DWORD PTR _rtTempo$[ebp+4], eax

; 6246 :         }
; 6247 :         else

  0012d	eb 70		 jmp	 SHORT $L71973
$L71974:

; 6248 :         {
; 6249 :             // If mtTime is less than everything in the tempo map, look in the old tempo map 
; 6250 :             // (which goes one minute into the past).  This keeps the regular tempo map
; 6251 :             // small, but allows us to get a valid tempo in the cases where the regular tempo
; 6252 :             // map no longer contains the tempo we need.
; 6253 :             pEvent = m_OldTempoMap.GetHead();

  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00138	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  0013d	89 45 f0	 mov	 DWORD PTR _pEvent$[ebp], eax

; 6254 :             if( pEvent )

  00140	83 7d f0 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  00144	74 59		 je	 SHORT $L71973

; 6255 :             {
; 6256 :                 if( mtTime >= pEvent->mtTime )

  00146	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00149	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0014c	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  0014f	7c 4e		 jl	 SHORT $L71973
$L71985:

; 6257 :                 {
; 6258 :                     while( pEvent->pNext )

  00151	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00154	83 38 00	 cmp	 DWORD PTR [eax], 0
  00157	74 19		 je	 SHORT $L71986

; 6259 :                     {
; 6260 :                         if( pEvent->pNext->mtTime > mtTime )

  00159	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0015c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015e	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00161	3b 45 0c	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00164	7e 02		 jle	 SHORT $L71987

; 6261 :                         {
; 6262 :                             break;

  00166	eb 0a		 jmp	 SHORT $L71986
$L71987:

; 6263 :                         }
; 6264 :                         pEvent = pEvent->pNext;

  00168	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0016b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016d	89 55 f0	 mov	 DWORD PTR _pEvent$[ebp], edx

; 6265 :                     }

  00170	eb df		 jmp	 SHORT $L71985
$L71986:

; 6266 :                     DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;

  00172	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00175	89 45 d8	 mov	 DWORD PTR _pTempo$71988[ebp], eax

; 6267 :                     dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;

  00178	8b 4d d8	 mov	 ecx, DWORD PTR _pTempo$71988[ebp]
  0017b	d9 41 58	 fld	 DWORD PTR [ecx+88]
  0017e	8b 55 d8	 mov	 edx, DWORD PTR _pTempo$71988[ebp]
  00181	dc 4a 50	 fmul	 QWORD PTR [edx+80]
  00184	dd 5d e0	 fstp	 QWORD PTR _dbl$[ebp]

; 6268 :                     mtTempo = pTempo->tempoPMsg.mtTime;

  00187	8b 45 d8	 mov	 eax, DWORD PTR _pTempo$71988[ebp]
  0018a	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0018d	89 4d f4	 mov	 DWORD PTR _mtTempo$[ebp], ecx

; 6269 :                     rtTempo = pTempo->tempoPMsg.rtTime;

  00190	8b 55 d8	 mov	 edx, DWORD PTR _pTempo$71988[ebp]
  00193	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00196	89 45 f8	 mov	 DWORD PTR _rtTempo$[ebp], eax
  00199	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0019c	89 4d fc	 mov	 DWORD PTR _rtTempo$[ebp+4], ecx
$L71973:

; 6270 :                 }
; 6271 :             }
; 6272 :         }
; 6273 :     }
; 6274 :     LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );

  0019f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001a2	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  001a8	52		 push	 edx
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6275 :     LEAVE_API_CRITICAL_SECTION;
; 6276 :     rtTempo -= m_rtAdjust;

  001af	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	8b 4d f8	 mov	 ecx, DWORD PTR _rtTempo$[ebp]
  001b5	2b 88 a0 02 00
	00		 sub	 ecx, DWORD PTR [eax+672]
  001bb	8b 55 fc	 mov	 edx, DWORD PTR _rtTempo$[ebp+4]
  001be	1b 90 a4 02 00
	00		 sbb	 edx, DWORD PTR [eax+676]
  001c4	89 4d f8	 mov	 DWORD PTR _rtTempo$[ebp], ecx
  001c7	89 55 fc	 mov	 DWORD PTR _rtTempo$[ebp+4], edx

; 6277 :     rtTemp = ( mtTime - mtTempo );

  001ca	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  001cd	2b 45 f4	 sub	 eax, DWORD PTR _mtTempo$[ebp]
  001d0	99		 cdq
  001d1	89 45 e8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  001d4	89 55 ec	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 6278 :     rtTemp *= 600000000;

  001d7	6a 00		 push	 0
  001d9	68 00 46 c3 23	 push	 600000000		; 23c34600H
  001de	8b 45 ec	 mov	 eax, DWORD PTR _rtTemp$[ebp+4]
  001e1	50		 push	 eax
  001e2	8b 4d e8	 mov	 ecx, DWORD PTR _rtTemp$[ebp]
  001e5	51		 push	 ecx
  001e6	e8 00 00 00 00	 call	 __allmul
  001eb	89 45 e8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  001ee	89 55 ec	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 6279 :     rtTemp += (DMUS_PPQ / 2);

  001f1	8b 55 e8	 mov	 edx, DWORD PTR _rtTemp$[ebp]
  001f4	81 c2 80 01 00
	00		 add	 edx, 384		; 00000180H
  001fa	8b 45 ec	 mov	 eax, DWORD PTR _rtTemp$[ebp+4]
  001fd	83 d0 00	 adc	 eax, 0
  00200	89 55 e8	 mov	 DWORD PTR _rtTemp$[ebp], edx
  00203	89 45 ec	 mov	 DWORD PTR _rtTemp$[ebp+4], eax

; 6280 :     rtTemp /= DMUS_PPQ;

  00206	6a 00		 push	 0
  00208	68 00 03 00 00	 push	 768			; 00000300H
  0020d	8b 4d ec	 mov	 ecx, DWORD PTR _rtTemp$[ebp+4]
  00210	51		 push	 ecx
  00211	8b 55 e8	 mov	 edx, DWORD PTR _rtTemp$[ebp]
  00214	52		 push	 edx
  00215	e8 00 00 00 00	 call	 __alldiv
  0021a	89 45 e8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  0021d	89 55 ec	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 6281 :     rtTemp = (REFERENCE_TIME)(rtTemp / dbl);

  00220	df 6d e8	 fild	 QWORD PTR _rtTemp$[ebp]
  00223	dc 75 e0	 fdiv	 QWORD PTR _dbl$[ebp]
  00226	e8 00 00 00 00	 call	 __ftol2
  0022b	89 45 e8	 mov	 DWORD PTR _rtTemp$[ebp], eax
  0022e	89 55 ec	 mov	 DWORD PTR _rtTemp$[ebp+4], edx

; 6282 :     *prtTime = rtTempo + rtTemp;

  00231	8b 45 f8	 mov	 eax, DWORD PTR _rtTempo$[ebp]
  00234	03 45 e8	 add	 eax, DWORD PTR _rtTemp$[ebp]
  00237	8b 4d fc	 mov	 ecx, DWORD PTR _rtTempo$[ebp+4]
  0023a	13 4d ec	 adc	 ecx, DWORD PTR _rtTemp$[ebp+4]
  0023d	8b 55 10	 mov	 edx, DWORD PTR _prtTime$[ebp]
  00240	89 02		 mov	 DWORD PTR [edx], eax
  00242	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 6283 :     return S_OK;

  00245	33 c0		 xor	 eax, eax
$L71959:

; 6284 : }

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 0c 00	 ret	 12			; 0000000cH
?MusicToReferenceTime@CPerformance@@UAGJJPA_J@Z ENDP	; CPerformance::MusicToReferenceTime
_TEXT	ENDS
PUBLIC	??_C@_0BN@BCCCMJCI@?$CFs?3?5Invalid?5pointer?5pmtTime?6?$AA@ ; `string'
PUBLIC	??_C@_0GE@OLABMEDD@Error?3?5Unable?5to?5convert?5referen@ ; `string'
PUBLIC	??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::ReferenceToMusicTime', 00H ; `CPerformance::ReferenceToMusicTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@BCCCMJCI@?$CFs?3?5Invalid?5pointer?5pmtTime?6?$AA@
CONST	SEGMENT
??_C@_0BN@BCCCMJCI@?$CFs?3?5Invalid?5pointer?5pmtTime?6?$AA@ DB '%s: Inva'
	DB	'lid pointer pmtTime', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@OLABMEDD@Error?3?5Unable?5to?5convert?5referen@
CONST	SEGMENT
??_C@_0GE@OLABMEDD@Error?3?5Unable?5to?5convert?5referen@ DB 'Error: Unab'
	DB	'le to convert reference to music time because the performance'
	DB	' has not been initialized.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@
CONST	SEGMENT
??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@ DB 'Warning: Re'
	DB	'ference to Music time conversion with very large ref time res'
	DB	'ulted in max music time.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z
_TEXT	SEGMENT
tv307 = -56
tv229 = -48
tv220 = -44
tv199 = -40
tv190 = -36
_pTempo$72024 = -32
_pTempo$72015 = -28
_dbl$ = -24
_pEvent$ = -16
_mtTempo$ = -12
_rtTempo$ = -8
_this$ = 8
_rtTime$ = 12
_pmtTime$ = 20
?ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z PROC NEAR ; CPerformance::ReferenceToMusicTime, COMDAT

; 6290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 6291 :     V_INAME(IDirectMusicPerformance::ReferenceToMusicTime);
; 6292 :     V_PTR_WRITE(pmtTime,MUSIC_TIME);

  00006	6a 04		 push	 4
  00008	8b 45 14	 mov	 eax, DWORD PTR _pmtTime$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72000
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BCCCMJCI@?$CFs?3?5Invalid?5pointer?5pmtTime?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72000:

; 6293 : 
; 6294 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6295 :     if( m_pClock == NULL )

  0003e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00045	75 28		 jne	 SHORT $L72002

; 6296 :     {
; 6297 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6298 :         Trace(0,"Error: Unable to convert reference to music time because the performance has not been initialized.\n");

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GE@OLABMEDD@Error?3?5Unable?5to?5convert?5referen@
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00062	83 c4 08	 add	 esp, 8

; 6299 :         return DMUS_E_NO_MASTER_CLOCK;

  00065	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0006a	e9 87 02 00 00	 jmp	 $L71996
$L72002:

; 6300 :     }
; 6301 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00078	51		 push	 ecx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6302 : 
; 6303 :     PRIV_PMSG*  pEvent;
; 6304 :     double dbl = 120;

  0007f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dbl$[ebp], 0
  00086	c7 45 ec 00 00
	5e 40		 mov	 DWORD PTR _dbl$[ebp+4], 1079902208 ; 405e0000H

; 6305 :     MUSIC_TIME mtTempo = 0;

  0008d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mtTempo$[ebp], 0

; 6306 :     REFERENCE_TIME rtTempo = m_rtStart;

  00094	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00097	8b 82 98 02 00
	00		 mov	 eax, DWORD PTR [edx+664]
  0009d	89 45 f8	 mov	 DWORD PTR _rtTempo$[ebp], eax
  000a0	8b 8a 9c 02 00
	00		 mov	 ecx, DWORD PTR [edx+668]
  000a6	89 4d fc	 mov	 DWORD PTR _rtTempo$[ebp+4], ecx

; 6307 : 
; 6308 :     ENTER_CRITICAL_SECTION( &m_PipelineCrSec );

  000a9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000b2	52		 push	 edx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6309 :     ENTER_API_CRITICAL_SECTION;
; 6310 :     pEvent = m_TempoMap.GetHead();

  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  000c2	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  000c7	89 45 f0	 mov	 DWORD PTR _pEvent$[ebp], eax

; 6311 :     if( pEvent )

  000ca	83 7d f0 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  000ce	0f 84 1a 01 00
	00		 je	 $L72009

; 6312 :     {
; 6313 :         if( rtTime >= pEvent->rtTime )

  000d4	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  000d7	89 45 dc	 mov	 DWORD PTR tv190[ebp], eax
  000da	8b 4d dc	 mov	 ecx, DWORD PTR tv190[ebp]
  000dd	8b 55 10	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  000e0	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  000e3	7c 73		 jl	 SHORT $L72010
  000e5	7f 0b		 jg	 SHORT $L72012
  000e7	8b 45 dc	 mov	 eax, DWORD PTR tv190[ebp]
  000ea	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  000ed	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  000f0	72 66		 jb	 SHORT $L72010
$L72012:

; 6314 :         {
; 6315 :             while( pEvent->pNext )

  000f2	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$[ebp]
  000f5	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000f8	74 2c		 je	 SHORT $L72013

; 6316 :             {
; 6317 :                 if( pEvent->pNext->rtTime > rtTime )

  000fa	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  000fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ff	89 4d d8	 mov	 DWORD PTR tv199[ebp], ecx
  00102	8b 55 d8	 mov	 edx, DWORD PTR tv199[ebp]
  00105	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00108	3b 45 10	 cmp	 eax, DWORD PTR _rtTime$[ebp+4]
  0010b	7c 0f		 jl	 SHORT $L72014
  0010d	7f 0b		 jg	 SHORT $L75538
  0010f	8b 4d d8	 mov	 ecx, DWORD PTR tv199[ebp]
  00112	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00115	3b 55 0c	 cmp	 edx, DWORD PTR _rtTime$[ebp]
  00118	76 02		 jbe	 SHORT $L72014
$L75538:

; 6318 :                 {
; 6319 :                     break;

  0011a	eb 0a		 jmp	 SHORT $L72013
$L72014:

; 6320 :                 }
; 6321 :                 pEvent = pEvent->pNext;

  0011c	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	89 4d f0	 mov	 DWORD PTR _pEvent$[ebp], ecx

; 6322 :             }

  00124	eb cc		 jmp	 SHORT $L72012
$L72013:

; 6323 :             DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;

  00126	8b 55 f0	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00129	89 55 e4	 mov	 DWORD PTR _pTempo$72015[ebp], edx

; 6324 :             dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;

  0012c	8b 45 e4	 mov	 eax, DWORD PTR _pTempo$72015[ebp]
  0012f	d9 40 58	 fld	 DWORD PTR [eax+88]
  00132	8b 4d e4	 mov	 ecx, DWORD PTR _pTempo$72015[ebp]
  00135	dc 49 50	 fmul	 QWORD PTR [ecx+80]
  00138	dd 5d e8	 fstp	 QWORD PTR _dbl$[ebp]

; 6325 :             mtTempo = pTempo->tempoPMsg.mtTime;

  0013b	8b 55 e4	 mov	 edx, DWORD PTR _pTempo$72015[ebp]
  0013e	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00141	89 45 f4	 mov	 DWORD PTR _mtTempo$[ebp], eax

; 6326 :             rtTempo = pTempo->tempoPMsg.rtTime;

  00144	8b 4d e4	 mov	 ecx, DWORD PTR _pTempo$72015[ebp]
  00147	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0014a	89 55 f8	 mov	 DWORD PTR _rtTempo$[ebp], edx
  0014d	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00150	89 45 fc	 mov	 DWORD PTR _rtTempo$[ebp+4], eax

; 6327 :         }
; 6328 :         else

  00153	e9 96 00 00 00	 jmp	 $L72009
$L72010:

; 6329 :         {
; 6330 :             // If mtTime is less than everything in the tempo map, look in the old tempo map 
; 6331 :             // (which goes one minute into the past).  This keeps the regular tempo map
; 6332 :             // small, but allows us to get a valid tempo in the cases where the regular tempo
; 6333 :             // map no longer contains the tempo we need.
; 6334 :             pEvent = m_OldTempoMap.GetHead();

  00158	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00161	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00166	89 45 f0	 mov	 DWORD PTR _pEvent$[ebp], eax

; 6335 :             if( pEvent )

  00169	83 7d f0 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0016d	74 7f		 je	 SHORT $L72009

; 6336 :             {
; 6337 :                 if( rtTime >= pEvent->rtTime )

  0016f	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00172	89 4d d4	 mov	 DWORD PTR tv220[ebp], ecx
  00175	8b 55 d4	 mov	 edx, DWORD PTR tv220[ebp]
  00178	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  0017b	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  0017e	7c 6e		 jl	 SHORT $L72009
  00180	7f 0b		 jg	 SHORT $L72021
  00182	8b 4d d4	 mov	 ecx, DWORD PTR tv220[ebp]
  00185	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp]
  00188	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  0018b	72 61		 jb	 SHORT $L72009
$L72021:

; 6338 :                 {
; 6339 :                     while( pEvent->pNext )

  0018d	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00190	83 38 00	 cmp	 DWORD PTR [eax], 0
  00193	74 2c		 je	 SHORT $L72022

; 6340 :                     {
; 6341 :                         if( pEvent->pNext->rtTime > rtTime )

  00195	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00198	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019a	89 55 d0	 mov	 DWORD PTR tv229[ebp], edx
  0019d	8b 45 d0	 mov	 eax, DWORD PTR tv229[ebp]
  001a0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001a3	3b 4d 10	 cmp	 ecx, DWORD PTR _rtTime$[ebp+4]
  001a6	7c 0f		 jl	 SHORT $L72023
  001a8	7f 0b		 jg	 SHORT $L75540
  001aa	8b 55 d0	 mov	 edx, DWORD PTR tv229[ebp]
  001ad	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001b0	3b 45 0c	 cmp	 eax, DWORD PTR _rtTime$[ebp]
  001b3	76 02		 jbe	 SHORT $L72023
$L75540:

; 6342 :                         {
; 6343 :                             break;

  001b5	eb 0a		 jmp	 SHORT $L72022
$L72023:

; 6344 :                         }
; 6345 :                         pEvent = pEvent->pNext;

  001b7	8b 4d f0	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  001ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bc	89 55 f0	 mov	 DWORD PTR _pEvent$[ebp], edx

; 6346 :                     }

  001bf	eb cc		 jmp	 SHORT $L72021
$L72022:

; 6347 :                     DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;

  001c1	8b 45 f0	 mov	 eax, DWORD PTR _pEvent$[ebp]
  001c4	89 45 e0	 mov	 DWORD PTR _pTempo$72024[ebp], eax

; 6348 :                     dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;

  001c7	8b 4d e0	 mov	 ecx, DWORD PTR _pTempo$72024[ebp]
  001ca	d9 41 58	 fld	 DWORD PTR [ecx+88]
  001cd	8b 55 e0	 mov	 edx, DWORD PTR _pTempo$72024[ebp]
  001d0	dc 4a 50	 fmul	 QWORD PTR [edx+80]
  001d3	dd 5d e8	 fstp	 QWORD PTR _dbl$[ebp]

; 6349 :                     mtTempo = pTempo->tempoPMsg.mtTime;

  001d6	8b 45 e0	 mov	 eax, DWORD PTR _pTempo$72024[ebp]
  001d9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001dc	89 4d f4	 mov	 DWORD PTR _mtTempo$[ebp], ecx

; 6350 :                     rtTempo = pTempo->tempoPMsg.rtTime;

  001df	8b 55 e0	 mov	 edx, DWORD PTR _pTempo$72024[ebp]
  001e2	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001e5	89 45 f8	 mov	 DWORD PTR _rtTempo$[ebp], eax
  001e8	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  001eb	89 4d fc	 mov	 DWORD PTR _rtTempo$[ebp+4], ecx
$L72009:

; 6351 :                 }
; 6352 :             }
; 6353 :         }
; 6354 :     }
; 6355 :     LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );

  001ee	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f1	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  001f7	52		 push	 edx
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6356 :     LEAVE_API_CRITICAL_SECTION;
; 6357 :     rtTempo -= m_rtAdjust;

  001fe	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00201	8b 4d f8	 mov	 ecx, DWORD PTR _rtTempo$[ebp]
  00204	2b 88 a0 02 00
	00		 sub	 ecx, DWORD PTR [eax+672]
  0020a	8b 55 fc	 mov	 edx, DWORD PTR _rtTempo$[ebp+4]
  0020d	1b 90 a4 02 00
	00		 sbb	 edx, DWORD PTR [eax+676]
  00213	89 4d f8	 mov	 DWORD PTR _rtTempo$[ebp], ecx
  00216	89 55 fc	 mov	 DWORD PTR _rtTempo$[ebp+4], edx

; 6358 :     if( rtTime < rtTempo )

  00219	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  0021c	3b 45 fc	 cmp	 eax, DWORD PTR _rtTempo$[ebp+4]
  0021f	7f 16		 jg	 SHORT $L72026
  00221	7c 08		 jl	 SHORT $L75541
  00223	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  00226	3b 4d f8	 cmp	 ecx, DWORD PTR _rtTempo$[ebp]
  00229	73 0c		 jae	 SHORT $L72026
$L75541:

; 6359 :     {
; 6360 :         rtTime = rtTempo;

  0022b	8b 55 f8	 mov	 edx, DWORD PTR _rtTempo$[ebp]
  0022e	89 55 0c	 mov	 DWORD PTR _rtTime$[ebp], edx
  00231	8b 45 fc	 mov	 eax, DWORD PTR _rtTempo$[ebp+4]
  00234	89 45 10	 mov	 DWORD PTR _rtTime$[ebp+4], eax
$L72026:

; 6361 :     }
; 6362 :     rtTime -= rtTempo;

  00237	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  0023a	2b 4d f8	 sub	 ecx, DWORD PTR _rtTempo$[ebp]
  0023d	8b 55 10	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  00240	1b 55 fc	 sbb	 edx, DWORD PTR _rtTempo$[ebp+4]
  00243	89 4d 0c	 mov	 DWORD PTR _rtTime$[ebp], ecx
  00246	89 55 10	 mov	 DWORD PTR _rtTime$[ebp+4], edx

; 6363 :     rtTime *= DMUS_PPQ;

  00249	6a 00		 push	 0
  0024b	68 00 03 00 00	 push	 768			; 00000300H
  00250	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  00253	50		 push	 eax
  00254	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  00257	51		 push	 ecx
  00258	e8 00 00 00 00	 call	 __allmul
  0025d	89 45 0c	 mov	 DWORD PTR _rtTime$[ebp], eax
  00260	89 55 10	 mov	 DWORD PTR _rtTime$[ebp+4], edx

; 6364 :     rtTime = (REFERENCE_TIME)(rtTime * dbl);

  00263	df 6d 0c	 fild	 QWORD PTR _rtTime$[ebp]
  00266	dc 4d e8	 fmul	 QWORD PTR _dbl$[ebp]
  00269	e8 00 00 00 00	 call	 __ftol2
  0026e	89 45 0c	 mov	 DWORD PTR _rtTime$[ebp], eax
  00271	89 55 10	 mov	 DWORD PTR _rtTime$[ebp+4], edx

; 6365 :     rtTime += 300000000;

  00274	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp]
  00277	81 c2 00 a3 e1
	11		 add	 edx, 300000000		; 11e1a300H
  0027d	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  00280	83 d0 00	 adc	 eax, 0
  00283	89 55 0c	 mov	 DWORD PTR _rtTime$[ebp], edx
  00286	89 45 10	 mov	 DWORD PTR _rtTime$[ebp+4], eax

; 6366 :     rtTime /= 600000000;

  00289	6a 00		 push	 0
  0028b	68 00 46 c3 23	 push	 600000000		; 23c34600H
  00290	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  00293	51		 push	 ecx
  00294	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp]
  00297	52		 push	 edx
  00298	e8 00 00 00 00	 call	 __alldiv
  0029d	89 45 0c	 mov	 DWORD PTR _rtTime$[ebp], eax
  002a0	89 55 10	 mov	 DWORD PTR _rtTime$[ebp+4], edx

; 6367 :     if ( rtTime & 0xFFFFFFFF00000000 )

  002a3	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  002a6	83 e0 00	 and	 eax, 0
  002a9	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  002ac	89 45 c8	 mov	 DWORD PTR tv307[ebp], eax
  002af	89 4d cc	 mov	 DWORD PTR tv307[ebp+4], ecx
  002b2	8b 55 c8	 mov	 edx, DWORD PTR tv307[ebp]
  002b5	0b 55 cc	 or	 edx, DWORD PTR tv307[ebp+4]
  002b8	85 d2		 test	 edx, edx
  002ba	74 1d		 je	 SHORT $L72028

; 6368 :     {
; 6369 :         Trace(3,"Warning: Reference to Music time conversion with very large ref time resulted in max music time.\n");

  002bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GC@DMFADPEP@Warning?3?5Reference?5to?5Music?5time@
  002c1	6a 03		 push	 3
  002c3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002c8	83 c4 08	 add	 esp, 8

; 6370 :         rtTime = 0x7FFFFFFF; // Set to max.

  002cb	c7 45 0c ff ff
	ff 7f		 mov	 DWORD PTR _rtTime$[ebp], 2147483647 ; 7fffffffH
  002d2	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _rtTime$[ebp+4], 0
$L72028:

; 6371 :     }
; 6372 :     *pmtTime = (long) (rtTime & 0xFFFFFFFF);

  002d9	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  002dc	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  002df	83 e1 00	 and	 ecx, 0
  002e2	8b 55 14	 mov	 edx, DWORD PTR _pmtTime$[ebp]
  002e5	89 02		 mov	 DWORD PTR [edx], eax

; 6373 :     *pmtTime += mtTempo;

  002e7	8b 45 14	 mov	 eax, DWORD PTR _pmtTime$[ebp]
  002ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ec	03 4d f4	 add	 ecx, DWORD PTR _mtTempo$[ebp]
  002ef	8b 55 14	 mov	 edx, DWORD PTR _pmtTime$[ebp]
  002f2	89 0a		 mov	 DWORD PTR [edx], ecx

; 6374 :     return S_OK;

  002f4	33 c0		 xor	 eax, eax
$L71996:

; 6375 : }

  002f6	8b e5		 mov	 esp, ebp
  002f8	5d		 pop	 ebp
  002f9	c2 10 00	 ret	 16			; 00000010H
?ReferenceToMusicTime@CPerformance@@UAGJ_JPAJ@Z ENDP	; CPerformance::ReferenceToMusicTime
_TEXT	ENDS
PUBLIC	??_C@_0DP@NOBNKMFL@Error?3?5Time?5parameter?5passed?5to?5@ ; `string'
PUBLIC	?AdjustTime@CPerformance@@QAGJ_J@Z		; CPerformance::AdjustTime
;	COMDAT ??_C@_0DP@NOBNKMFL@Error?3?5Time?5parameter?5passed?5to?5@
CONST	SEGMENT
??_C@_0DP@NOBNKMFL@Error?3?5Time?5parameter?5passed?5to?5@ DB 'Error: Tim'
	DB	'e parameter passed to AdjustTime() is out of range.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AdjustTime@CPerformance@@QAGJ_J@Z
_TEXT	SEGMENT
_this$ = 8
_rtAmount$ = 12
?AdjustTime@CPerformance@@QAGJ_J@Z PROC NEAR		; CPerformance::AdjustTime, COMDAT

; 6388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6389 :     if( ( rtAmount < -10000000 ) || ( rtAmount > 10000000 ) )

  00003	83 7d 10 ff	 cmp	 DWORD PTR _rtAmount$[ebp+4], -1
  00007	7c 1c		 jl	 SHORT $L72037
  00009	7f 09		 jg	 SHORT $L75545
  0000b	81 7d 0c 80 69
	67 ff		 cmp	 DWORD PTR _rtAmount$[ebp], -10000000 ; ff676980H
  00012	72 11		 jb	 SHORT $L72037
$L75545:
  00014	83 7d 10 00	 cmp	 DWORD PTR _rtAmount$[ebp+4], 0
  00018	7c 21		 jl	 SHORT $L72036
  0001a	7f 09		 jg	 SHORT $L72037
  0001c	81 7d 0c 80 96
	98 00		 cmp	 DWORD PTR _rtAmount$[ebp], 10000000 ; 00989680H
  00023	76 16		 jbe	 SHORT $L72036
$L72037:

; 6390 :     {
; 6391 :         Trace(1,"Error: Time parameter passed to AdjustTime() is out of range.\n"); 

  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@NOBNKMFL@Error?3?5Time?5parameter?5passed?5to?5@
  0002a	6a 01		 push	 1
  0002c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00031	83 c4 08	 add	 esp, 8

; 6392 :         return E_INVALIDARG;

  00034	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00039	eb 26		 jmp	 SHORT $L72035
$L72036:

; 6393 :     }
; 6394 :     m_rtAdjust += rtAmount;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 88 a0 02 00
	00		 mov	 ecx, DWORD PTR [eax+672]
  00044	03 4d 0c	 add	 ecx, DWORD PTR _rtAmount$[ebp]
  00047	8b 90 a4 02 00
	00		 mov	 edx, DWORD PTR [eax+676]
  0004d	13 55 10	 adc	 edx, DWORD PTR _rtAmount$[ebp+4]
  00050	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00053	89 88 a0 02 00
	00		 mov	 DWORD PTR [eax+672], ecx
  00059	89 90 a4 02 00
	00		 mov	 DWORD PTR [eax+676], edx

; 6395 :     return S_OK;

  0005f	33 c0		 xor	 eax, eax
$L72035:

; 6396 : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
?AdjustTime@CPerformance@@QAGJ_J@Z ENDP			; CPerformance::AdjustTime
_TEXT	ENDS
PUBLIC	??_C@_0CB@OGOCOFJA@?$CFs?3?5Invalid?5pointer?5prtResolved?6@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetResolvedTime', 00H ; `CPerformance::GetResolvedTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CB@OGOCOFJA@?$CFs?3?5Invalid?5pointer?5prtResolved?6@
CONST	SEGMENT
??_C@_0CB@OGOCOFJA@?$CFs?3?5Invalid?5pointer?5prtResolved?6@ DB '%s: Inva'
	DB	'lid pointer prtResolved', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z
_TEXT	SEGMENT
_mtTime$72065 = -28
_rtStart$72062 = -24
_rtStart$72058 = -16
_rtTrans$72054 = -8
_this$ = 8
_rtTime$ = 12
_prtResolved$ = 20
_dwResolvedTimeFlags$ = 24
?GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z PROC NEAR	; CPerformance::GetResolvedTime, COMDAT

; 6410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 6411 :     V_INAME(IDirectMusicPerformance::GetResolvedTime);
; 6412 :     V_PTR_WRITE(prtResolved,REFERENCE_TIME);

  00006	6a 08		 push	 8
  00008	8b 45 14	 mov	 eax, DWORD PTR _prtResolved$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72050
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@OGOCOFJA@?$CFs?3?5Invalid?5pointer?5prtResolved?6@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72050:

; 6413 : 
; 6414 :     if (rtTime == 0)

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  00031	0b 4d 10	 or	 ecx, DWORD PTR _rtTime$[ebp+4]
  00034	85 c9		 test	 ecx, ecx
  00036	75 0c		 jne	 SHORT $L72052

; 6415 :     {
; 6416 :         dwResolvedTimeFlags |= DMUS_TIME_RESOLVE_AFTERQUEUETIME ;

  00038	8b 55 18	 mov	 edx, DWORD PTR _dwResolvedTimeFlags$[ebp]
  0003b	81 ca 00 00 20
	00		 or	 edx, 2097152		; 00200000H
  00041	89 55 18	 mov	 DWORD PTR _dwResolvedTimeFlags$[ebp], edx
$L72052:

; 6417 :     }
; 6418 :     if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERPREPARETIME )

  00044	8b 45 18	 mov	 eax, DWORD PTR _dwResolvedTimeFlags$[ebp]
  00047	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0004c	85 c0		 test	 eax, eax
  0004e	74 3a		 je	 SHORT $L72053

; 6419 :     {
; 6420 :         REFERENCE_TIME rtTrans;
; 6421 :         MusicToReferenceTime( m_mtTransported, &rtTrans );

  00050	8d 4d f8	 lea	 ecx, DWORD PTR _rtTrans$72054[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 82 d0 02 00
	00		 mov	 eax, DWORD PTR [edx+720]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00066	50		 push	 eax
  00067	ff 52 14	 call	 DWORD PTR [edx+20]

; 6422 :         if( rtTime < rtTrans ) rtTime = rtTrans;

  0006a	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  0006d	3b 4d fc	 cmp	 ecx, DWORD PTR _rtTrans$72054[ebp+4]
  00070	7f 16		 jg	 SHORT $L72055
  00072	7c 08		 jl	 SHORT $L75550
  00074	8b 55 0c	 mov	 edx, DWORD PTR _rtTime$[ebp]
  00077	3b 55 f8	 cmp	 edx, DWORD PTR _rtTrans$72054[ebp]
  0007a	73 0c		 jae	 SHORT $L72055
$L75550:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _rtTrans$72054[ebp]
  0007f	89 45 0c	 mov	 DWORD PTR _rtTime$[ebp], eax
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _rtTrans$72054[ebp+4]
  00085	89 4d 10	 mov	 DWORD PTR _rtTime$[ebp+4], ecx
$L72055:

; 6423 :     }
; 6424 :     else if (dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERLATENCYTIME )

  00088	eb 79		 jmp	 SHORT $L72056
$L72053:
  0008a	8b 55 18	 mov	 edx, DWORD PTR _dwResolvedTimeFlags$[ebp]
  0008d	81 e2 00 00 40
	00		 and	 edx, 4194304		; 00400000H
  00093	85 d2		 test	 edx, edx
  00095	74 2e		 je	 SHORT $L72057

; 6425 :     {
; 6426 :         REFERENCE_TIME rtStart;
; 6427 :         rtStart = GetLatency();

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  0009f	89 45 f0	 mov	 DWORD PTR _rtStart$72058[ebp], eax
  000a2	89 55 f4	 mov	 DWORD PTR _rtStart$72058[ebp+4], edx

; 6428 :         if( rtTime < rtStart ) rtTime = rtStart;

  000a5	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  000a8	3b 45 f4	 cmp	 eax, DWORD PTR _rtStart$72058[ebp+4]
  000ab	7f 16		 jg	 SHORT $L72059
  000ad	7c 08		 jl	 SHORT $L75551
  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  000b2	3b 4d f0	 cmp	 ecx, DWORD PTR _rtStart$72058[ebp]
  000b5	73 0c		 jae	 SHORT $L72059
$L75551:
  000b7	8b 55 f0	 mov	 edx, DWORD PTR _rtStart$72058[ebp]
  000ba	89 55 0c	 mov	 DWORD PTR _rtTime$[ebp], edx
  000bd	8b 45 f4	 mov	 eax, DWORD PTR _rtStart$72058[ebp+4]
  000c0	89 45 10	 mov	 DWORD PTR _rtTime$[ebp+4], eax
$L72059:

; 6429 :     }  
; 6430 :     else if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERQUEUETIME )

  000c3	eb 3e		 jmp	 SHORT $L72056
$L72057:
  000c5	8b 4d 18	 mov	 ecx, DWORD PTR _dwResolvedTimeFlags$[ebp]
  000c8	81 e1 00 00 20
	00		 and	 ecx, 2097152		; 00200000H
  000ce	85 c9		 test	 ecx, ecx
  000d0	74 31		 je	 SHORT $L72056

; 6431 :     {
; 6432 :         REFERENCE_TIME rtStart;
; 6433 :         GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations

  000d2	8d 55 e8	 lea	 edx, DWORD PTR _rtStart$72062[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000de	52		 push	 edx
  000df	ff 91 84 00 00
	00		 call	 DWORD PTR [ecx+132]

; 6434 :         if( rtTime < rtStart ) rtTime = rtStart;

  000e5	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  000e8	3b 45 ec	 cmp	 eax, DWORD PTR _rtStart$72062[ebp+4]
  000eb	7f 16		 jg	 SHORT $L72056
  000ed	7c 08		 jl	 SHORT $L75552
  000ef	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  000f2	3b 4d e8	 cmp	 ecx, DWORD PTR _rtStart$72062[ebp]
  000f5	73 0c		 jae	 SHORT $L72056
$L75552:
  000f7	8b 55 e8	 mov	 edx, DWORD PTR _rtStart$72062[ebp]
  000fa	89 55 0c	 mov	 DWORD PTR _rtTime$[ebp], edx
  000fd	8b 45 ec	 mov	 eax, DWORD PTR _rtStart$72062[ebp+4]
  00100	89 45 10	 mov	 DWORD PTR _rtTime$[ebp+4], eax
$L72056:

; 6435 :     }
; 6436 :     
; 6437 : 
; 6438 :     if( dwResolvedTimeFlags & ( DMUS_TIME_RESOLVE_BEAT | DMUS_TIME_RESOLVE_MEASURE |
; 6439 :         DMUS_TIME_RESOLVE_GRID | DMUS_TIME_RESOLVE_MARKER | DMUS_TIME_RESOLVE_SEGMENTEND))

  00103	8b 4d 18	 mov	 ecx, DWORD PTR _dwResolvedTimeFlags$[ebp]
  00106	81 e1 00 38 80
	01		 and	 ecx, 25180160		; 01803800H
  0010c	85 c9		 test	 ecx, ecx
  0010e	74 63		 je	 SHORT $L72064

; 6440 :     {
; 6441 :         MUSIC_TIME mtTime; //, mtResolved;
; 6442 : 
; 6443 :         ReferenceToMusicTime( rtTime, &mtTime );

  00110	8d 55 e4	 lea	 edx, DWORD PTR _mtTime$72065[ebp]
  00113	52		 push	 edx
  00114	8b 45 10	 mov	 eax, DWORD PTR _rtTime$[ebp+4]
  00117	50		 push	 eax
  00118	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0011f	8b 02		 mov	 eax, DWORD PTR [edx]
  00121	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	51		 push	 ecx
  00125	ff 50 18	 call	 DWORD PTR [eax+24]

; 6444 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00128	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00131	52		 push	 edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6445 :         mtTime = ResolveTime( mtTime, dwResolvedTimeFlags, NULL);

  00138	6a 00		 push	 0
  0013a	8b 45 18	 mov	 eax, DWORD PTR _dwResolvedTimeFlags$[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d e4	 mov	 ecx, DWORD PTR _mtTime$72065[ebp]
  00141	51		 push	 ecx
  00142	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  0014a	89 45 e4	 mov	 DWORD PTR _mtTime$72065[ebp], eax

; 6446 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0014d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00150	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00156	52		 push	 edx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6447 :         MusicToReferenceTime( mtTime, prtResolved );

  0015d	8b 45 14	 mov	 eax, DWORD PTR _prtResolved$[ebp]
  00160	50		 push	 eax
  00161	8b 4d e4	 mov	 ecx, DWORD PTR _mtTime$72065[ebp]
  00164	51		 push	 ecx
  00165	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00168	8b 02		 mov	 eax, DWORD PTR [edx]
  0016a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	51		 push	 ecx
  0016e	ff 50 14	 call	 DWORD PTR [eax+20]

; 6448 :     }
; 6449 :     else

  00171	eb 0e		 jmp	 SHORT $L72066
$L72064:

; 6450 :     {
; 6451 :         *prtResolved = rtTime;

  00173	8b 55 14	 mov	 edx, DWORD PTR _prtResolved$[ebp]
  00176	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  00179	89 02		 mov	 DWORD PTR [edx], eax
  0017b	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  0017e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L72066:

; 6452 :     }
; 6453 :     return S_OK;

  00181	33 c0		 xor	 eax, eax

; 6454 : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 14 00	 ret	 20			; 00000014H
?GetResolvedTime@CPerformance@@UAGJ_JPA_JK@Z ENDP	; CPerformance::GetResolvedTime
_TEXT	ENDS
PUBLIC	??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@ ; `string'
PUBLIC	??_C@_0EN@NPHAMOAE@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@ ; `string'
PUBLIC	??_C@_0FF@IJFMBAKP@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::IsPlaying', 00H	; `CPerformance::IsPlaying'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@
CONST	SEGMENT
??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@ DB '%s: In'
	DB	'valid pointer pSegState', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@NPHAMOAE@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@
CONST	SEGMENT
??_C@_0EN@NPHAMOAE@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@ DB 'Error:'
	DB	' IsPlaying() failed because the performance has not been init'
	DB	'ialized.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@IJFMBAKP@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@
CONST	SEGMENT
??_C@_0FF@IJFMBAKP@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@ DB 'Error:'
	DB	' IsPlaying() failed because segment and segment state are bot'
	DB	'h NULL pointers.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z
_TEXT	SEGMENT
_pNode$ = -12
_mtNow$ = -8
_dwCount$ = -4
_this$ = 8
_pSegment$ = 12
_pSegState$ = 16
?IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z PROC NEAR ; CPerformance::IsPlaying, COMDAT

; 6472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 6473 :     CSegState* pNode;
; 6474 :     DWORD dwCount;
; 6475 : 
; 6476 :     V_INAME(IDirectMusicPerformance::IsPlaying);
; 6477 :     V_INTERFACE_OPT(pSegment);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  0000a	74 7c		 je	 SHORT $L72077
  0000c	6a 04		 push	 4
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L72079
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L72079:
  00034	6a 04		 push	 4
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $L72082
  00045	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
  0004f	6a ff		 push	 -1
  00051	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 _DebugBreak@0
$L72082:
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0006b	85 c0		 test	 eax, eax
  0006d	74 19		 je	 SHORT $L72077
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CCKODMAP@?$CFs?3?5Invalid?5pointer?5pSegment?6?$AA@
  00079	6a ff		 push	 -1
  0007b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	e8 00 00 00 00	 call	 _DebugBreak@0
$L72077:

; 6478 :     V_INTERFACE_OPT(pSegState);

  00088	83 7d 10 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  0008c	74 7c		 je	 SHORT $L72085
  0008e	6a 04		 push	 4
  00090	8b 45 10	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00099	85 c0		 test	 eax, eax
  0009b	74 19		 je	 SHORT $L72087
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@
  000a7	6a ff		 push	 -1
  000a9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	e8 00 00 00 00	 call	 _DebugBreak@0
$L72087:
  000b6	6a 04		 push	 4
  000b8	8b 4d 10	 mov	 ecx, DWORD PTR _pSegState$[ebp]
  000bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000c3	85 c0		 test	 eax, eax
  000c5	74 19		 je	 SHORT $L72091
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@
  000d1	6a ff		 push	 -1
  000d3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	e8 00 00 00 00	 call	 _DebugBreak@0
$L72091:
  000e0	8b 45 10	 mov	 eax, DWORD PTR _pSegState$[ebp]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  000ed	85 c0		 test	 eax, eax
  000ef	74 19		 je	 SHORT $L72085
  000f1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z@4QBDB
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@JLHPEPNK@?$CFs?3?5Invalid?5pointer?5pSegState?6?$AA@
  000fb	6a ff		 push	 -1
  000fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	e8 00 00 00 00	 call	 _DebugBreak@0
$L72085:

; 6479 : 
; 6480 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0010a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00112	50		 push	 eax
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6481 :     if( m_pClock == NULL )

  00119	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  00120	75 29		 jne	 SHORT $L72094

; 6482 :     {
; 6483 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00122	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00125	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  0012b	52		 push	 edx
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6484 :         Trace(0,"Error: IsPlaying() failed because the performance has not been initialized.\n");

  00132	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EN@NPHAMOAE@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@
  00137	6a 00		 push	 0
  00139	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0013e	83 c4 08	 add	 esp, 8

; 6485 :         return DMUS_E_NO_MASTER_CLOCK;

  00141	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00146	e9 fd 00 00 00	 jmp	 $L72072
$L72094:

; 6486 :     }
; 6487 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0014b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00153	50		 push	 eax
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6488 : 
; 6489 :     if( !pSegment && !pSegState )

  0015a	83 7d 0c 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  0015e	75 1f		 jne	 SHORT $L72097
  00160	83 7d 10 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  00164	75 19		 jne	 SHORT $L72097

; 6490 :     {
; 6491 :         Trace(0,"Error: IsPlaying() failed because segment and segment state are both NULL pointers.\n");

  00166	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FF@IJFMBAKP@Error?3?5IsPlaying?$CI?$CJ?5failed?5becaus@
  0016b	6a 00		 push	 0
  0016d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00172	83 c4 08	 add	 esp, 8

; 6492 :         return E_POINTER;

  00175	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0017a	e9 c9 00 00 00	 jmp	 $L72072
$L72097:

; 6493 :     }
; 6494 : 
; 6495 :     MUSIC_TIME mtNow;
; 6496 :     GetTime(NULL, &mtNow);

  0017f	8d 4d f8	 lea	 ecx, DWORD PTR _mtNow$[ebp]
  00182	51		 push	 ecx
  00183	6a 00		 push	 0
  00185	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00188	8b 02		 mov	 eax, DWORD PTR [edx]
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	51		 push	 ecx
  0018e	ff 50 20	 call	 DWORD PTR [eax+32]

; 6497 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00191	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00194	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  0019a	52		 push	 edx
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6498 :     ENTER_API_CRITICAL_SECTION;
; 6499 :     for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )

  001a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  001a8	eb 09		 jmp	 SHORT $L72101
$L72102:
  001aa	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  001ad	83 c0 01	 add	 eax, 1
  001b0	89 45 fc	 mov	 DWORD PTR _dwCount$[ebp], eax
$L72101:
  001b3	83 7d fc 09	 cmp	 DWORD PTR _dwCount$[ebp], 9
  001b7	73 7b		 jae	 SHORT $L72103

; 6500 :     {
; 6501 :         for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  001bc	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001bf	8d 4c ca 44	 lea	 ecx, DWORD PTR [edx+ecx*8+68]
  001c3	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001c8	89 45 f4	 mov	 DWORD PTR _pNode$[ebp], eax
  001cb	eb 0b		 jmp	 SHORT $L72104
$L72105:
  001cd	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  001d0	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  001d5	89 45 f4	 mov	 DWORD PTR _pNode$[ebp], eax
$L72104:
  001d8	83 7d f4 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  001dc	74 51		 je	 SHORT $L72106

; 6502 :         {
; 6503 :             if( !pNode->m_fStartedPlay )

  001de	8b 45 f4	 mov	 eax, DWORD PTR _pNode$[ebp]
  001e1	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [eax+260], 0
  001e8	75 02		 jne	 SHORT $L72107

; 6504 :             {
; 6505 :                 continue;

  001ea	eb e1		 jmp	 SHORT $L72105
$L72107:

; 6506 :             }
; 6507 :             if( mtNow >= pNode->m_mtResolvedStart )

  001ec	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$[ebp]
  001ef	8b 55 f8	 mov	 edx, DWORD PTR _mtNow$[ebp]
  001f2	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  001f5	7c 34		 jl	 SHORT $L72108

; 6508 :             {
; 6509 :                 if( mtNow < pNode->m_mtLastPlayed )

  001f7	8b 45 f4	 mov	 eax, DWORD PTR _pNode$[ebp]
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _mtNow$[ebp]
  001fd	3b 48 70	 cmp	 ecx, DWORD PTR [eax+112]
  00200	7d 27		 jge	 SHORT $L72109

; 6510 :                 {
; 6511 :                     if(( pNode == (CSegState*) pSegState ) || 
; 6512 :                         ( pNode->m_pSegment == (CSegment *) pSegment ))

  00202	8b 55 f4	 mov	 edx, DWORD PTR _pNode$[ebp]
  00205	3b 55 10	 cmp	 edx, DWORD PTR _pSegState$[ebp]
  00208	74 0b		 je	 SHORT $L72113
  0020a	8b 45 f4	 mov	 eax, DWORD PTR _pNode$[ebp]
  0020d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00210	3b 4d 0c	 cmp	 ecx, DWORD PTR _pSegment$[ebp]
  00213	75 14		 jne	 SHORT $L72109
$L72113:

; 6513 :                     {
; 6514 :                         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00215	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00218	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  0021e	52		 push	 edx
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6515 :                         LEAVE_API_CRITICAL_SECTION;
; 6516 :                         return S_OK;

  00225	33 c0		 xor	 eax, eax
  00227	eb 1f		 jmp	 SHORT $L72072
$L72109:

; 6517 :                     }
; 6518 :                 }
; 6519 :             }
; 6520 :             else

  00229	eb 02		 jmp	 SHORT $L72115
$L72108:

; 6521 :             {
; 6522 :                 // if mtNow is before this pSegState's resolved start, it is before every
; 6523 :                 // pSegState after this too, so break now.
; 6524 :                 break;

  0022b	eb 02		 jmp	 SHORT $L72106
$L72115:

; 6525 :             }
; 6526 :         }

  0022d	eb 9e		 jmp	 SHORT $L72105
$L72106:

; 6527 :     }

  0022f	e9 76 ff ff ff	 jmp	 $L72102
$L72103:

; 6528 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00234	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00237	05 14 03 00 00	 add	 eax, 788		; 00000314H
  0023c	50		 push	 eax
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6529 :     LEAVE_API_CRITICAL_SECTION;
; 6530 :     return S_FALSE;

  00243	b8 01 00 00 00	 mov	 eax, 1
$L72072:

; 6531 : }

  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c2 0c 00	 ret	 12			; 0000000cH
?IsPlaying@CPerformance@@UAGJPAUIDirectMusicSegment@@PAUIDirectMusicSegmentState@@@Z ENDP ; CPerformance::IsPlaying
_TEXT	ENDS
PUBLIC	??_C@_0BM@BIIMPMFB@?$CFs?3?5Invalid?5pointer?5prtNow?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@IJBKBAHG@?$CFs?3?5Invalid?5pointer?5pmtNow?6?$AA@ ; `string'
PUBLIC	??_C@_0EL@HEOBICH@Error?3?5GetTime?$CI?$CJ?5failed?5because?5@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetTime@CPerformance@@UAGJPA_JPAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetTime@CPerformance@@UAGJPA_JPAJ@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetTime', 00H	; `CPerformance::GetTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@BIIMPMFB@?$CFs?3?5Invalid?5pointer?5prtNow?6?$AA@
CONST	SEGMENT
??_C@_0BM@BIIMPMFB@?$CFs?3?5Invalid?5pointer?5prtNow?6?$AA@ DB '%s: Inval'
	DB	'id pointer prtNow', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IJBKBAHG@?$CFs?3?5Invalid?5pointer?5pmtNow?6?$AA@
CONST	SEGMENT
??_C@_0BM@IJBKBAHG@?$CFs?3?5Invalid?5pointer?5pmtNow?6?$AA@ DB '%s: Inval'
	DB	'id pointer pmtNow', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@HEOBICH@Error?3?5GetTime?$CI?$CJ?5failed?5because?5@
CONST	SEGMENT
??_C@_0EL@HEOBICH@Error?3?5GetTime?$CI?$CJ?5failed?5because?5@ DB 'Error:'
	DB	' GetTime() failed because the performance has not been initia'
	DB	'lized.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetTime@CPerformance@@UAGJPA_JPAJ@Z
_TEXT	SEGMENT
_mtTime$72138 = -12
_rtTime$ = -8
_this$ = 8
_prtNow$ = 12
_pmtNow$ = 16
?GetTime@CPerformance@@UAGJPA_JPAJ@Z PROC NEAR		; CPerformance::GetTime, COMDAT

; 6539 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 6540 :     V_INAME(IDirectMusicPerformance::GetTime);
; 6541 :     V_PTR_WRITE_OPT(prtNow,REFERENCE_TIME);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _prtNow$[ebp], 0
  0000a	74 28		 je	 SHORT $L72124
  0000c	6a 08		 push	 8
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _prtNow$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L72124
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTime@CPerformance@@UAGJPA_JPAJ@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@BIIMPMFB@?$CFs?3?5Invalid?5pointer?5prtNow?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L72124:

; 6542 :     V_PTR_WRITE_OPT(pmtNow,MUSIC_TIME);

  00034	83 7d 10 00	 cmp	 DWORD PTR _pmtNow$[ebp], 0
  00038	74 28		 je	 SHORT $L72128
  0003a	6a 04		 push	 4
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _pmtNow$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00045	85 c0		 test	 eax, eax
  00047	74 19		 je	 SHORT $L72128
  00049	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetTime@CPerformance@@UAGJPA_JPAJ@Z@4QBDB
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@IJBKBAHG@?$CFs?3?5Invalid?5pointer?5pmtNow?6?$AA@
  00053	6a ff		 push	 -1
  00055	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	e8 00 00 00 00	 call	 _DebugBreak@0
$L72128:

; 6543 : 
; 6544 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00062	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00065	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  0006b	52		 push	 edx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6545 :     if( m_pClock == NULL )

  00072	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00075	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00079	75 26		 jne	 SHORT $L72132

; 6546 :     {
; 6547 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00084	51		 push	 ecx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6548 :         Trace(0,"Error: GetTime() failed because the performance has not been initialized.\n");

  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@HEOBICH@Error?3?5GetTime?$CI?$CJ?5failed?5because?5@
  00090	6a 00		 push	 0
  00092	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00097	83 c4 08	 add	 esp, 8

; 6549 :         return DMUS_E_NO_MASTER_CLOCK;

  0009a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0009f	eb 5a		 jmp	 SHORT $L72121
$L72132:

; 6550 :     }
; 6551 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000a1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  000aa	52		 push	 edx
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6552 : 
; 6553 :     REFERENCE_TIME rtTime = GetTime();

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  000b9	89 45 f8	 mov	 DWORD PTR _rtTime$[ebp], eax
  000bc	89 55 fc	 mov	 DWORD PTR _rtTime$[ebp+4], edx

; 6554 :     if( prtNow )

  000bf	83 7d 0c 00	 cmp	 DWORD PTR _prtNow$[ebp], 0
  000c3	74 0e		 je	 SHORT $L72136

; 6555 :     {
; 6556 :         *prtNow = rtTime;

  000c5	8b 45 0c	 mov	 eax, DWORD PTR _prtNow$[ebp]
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  000cb	89 08		 mov	 DWORD PTR [eax], ecx
  000cd	8b 55 fc	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  000d0	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L72136:

; 6557 :     }
; 6558 :     if( pmtNow )

  000d3	83 7d 10 00	 cmp	 DWORD PTR _pmtNow$[ebp], 0
  000d7	74 20		 je	 SHORT $L72137

; 6559 :     {
; 6560 :         MUSIC_TIME mtTime;
; 6561 :         ReferenceToMusicTime( rtTime, &mtTime );

  000d9	8d 45 f4	 lea	 eax, DWORD PTR _mtTime$72138[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  000e0	51		 push	 ecx
  000e1	8b 55 f8	 mov	 edx, DWORD PTR _rtTime$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ed	52		 push	 edx
  000ee	ff 51 18	 call	 DWORD PTR [ecx+24]

; 6562 :         *pmtNow = mtTime;

  000f1	8b 45 10	 mov	 eax, DWORD PTR _pmtNow$[ebp]
  000f4	8b 4d f4	 mov	 ecx, DWORD PTR _mtTime$72138[ebp]
  000f7	89 08		 mov	 DWORD PTR [eax], ecx
$L72137:

; 6563 :     }
; 6564 :     return S_OK;

  000f9	33 c0		 xor	 eax, eax
$L72121:

; 6565 : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
?GetTime@CPerformance@@UAGJPA_JPAJ@Z ENDP		; CPerformance::GetTime
_TEXT	ENDS
PUBLIC	??_C@_0FC@CGECENDB@Error?3?5GetLatencyTime?$CI?$CJ?5failed?5b@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetLatencyTime@CPerformance@@UAGJPA_J@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetLatencyTime@CPerformance@@UAGJPA_J@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetLatencyTime', 00H ; `CPerformance::GetLatencyTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0FC@CGECENDB@Error?3?5GetLatencyTime?$CI?$CJ?5failed?5b@
CONST	SEGMENT
??_C@_0FC@CGECENDB@Error?3?5GetLatencyTime?$CI?$CJ?5failed?5b@ DB 'Error:'
	DB	' GetLatencyTime() failed because the performance has not been'
	DB	' initialized.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetLatencyTime@CPerformance@@UAGJPA_J@Z
_TEXT	SEGMENT
_this$ = 8
_prtTime$ = 12
?GetLatencyTime@CPerformance@@UAGJPA_J@Z PROC NEAR	; CPerformance::GetLatencyTime, COMDAT

; 6570 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6571 :     V_INAME(IDirectMusicPerformance::GetLatencyTime);
; 6572 :     V_PTR_WRITE(prtTime,REFERENCE_TIME);

  00003	6a 08		 push	 8
  00005	8b 45 0c	 mov	 eax, DWORD PTR _prtTime$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L72147
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetLatencyTime@CPerformance@@UAGJPA_J@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L72147:

; 6573 : 
; 6574 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6575 :     if( m_pClock == NULL )

  0003b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00042	75 25		 jne	 SHORT $L72148

; 6576 :     {
; 6577 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00044	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00047	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6578 :         Trace(0,"Error: GetLatencyTime() failed because the performance has not been initialized.\n");

  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FC@CGECENDB@Error?3?5GetLatencyTime?$CI?$CJ?5failed?5b@
  00058	6a 00		 push	 0
  0005a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005f	83 c4 08	 add	 esp, 8

; 6579 :         return DMUS_E_NO_MASTER_CLOCK;

  00062	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00067	eb 22		 jmp	 SHORT $L72143
$L72148:

; 6580 :     }
; 6581 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00072	51		 push	 ecx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6582 : 
; 6583 :     *prtTime = GetLatency();

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _prtTime$[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax
  00086	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 6584 :     return S_OK;

  00089	33 c0		 xor	 eax, eax
$L72143:

; 6585 : }

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
?GetLatencyTime@CPerformance@@UAGJPA_J@Z ENDP		; CPerformance::GetLatencyTime
_TEXT	ENDS
PUBLIC	??_C@_0FA@EKFEBJIF@Error?3?5GetQueueTime?$CI?$CJ?5failed?5bec@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetQueueTime@CPerformance@@UAGJPA_J@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetQueueTime@CPerformance@@UAGJPA_J@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetQueueTime', 00H	; `CPerformance::GetQueueTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0FA@EKFEBJIF@Error?3?5GetQueueTime?$CI?$CJ?5failed?5bec@
CONST	SEGMENT
??_C@_0FA@EKFEBJIF@Error?3?5GetQueueTime?$CI?$CJ?5failed?5bec@ DB 'Error:'
	DB	' GetQueueTime() failed because the performance has not been i'
	DB	'nitialized.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetQueueTime@CPerformance@@UAGJPA_J@Z
_TEXT	SEGMENT
tv153 = -24
tv141 = -20
_rtLatency$ = -16
_this$ = 8
_prtTime$ = 12
?GetQueueTime@CPerformance@@UAGJPA_J@Z PROC NEAR	; CPerformance::GetQueueTime, COMDAT

; 6590 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 6591 :     V_INAME(IDirectMusicPerformance::GetQueueTime);
; 6592 :     V_PTR_WRITE(prtTime,REFERENCE_TIME);

  00006	6a 08		 push	 8
  00008	8b 45 0c	 mov	 eax, DWORD PTR _prtTime$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72159
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetQueueTime@CPerformance@@UAGJPA_J@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@LHLJOKKP@?$CFs?3?5Invalid?5pointer?5prtTime?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72159:

; 6593 : 
; 6594 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6595 :     if( m_pClock == NULL )

  0003e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00045	75 28		 jne	 SHORT $L72160

; 6596 :     {
; 6597 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6598 :         Trace(0,"Error: GetQueueTime() failed because the performance has not been initialized.\n");

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@EKFEBJIF@Error?3?5GetQueueTime?$CI?$CJ?5failed?5bec@
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00062	83 c4 08	 add	 esp, 8

; 6599 :         return DMUS_E_NO_MASTER_CLOCK;

  00065	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0006a	e9 a5 00 00 00	 jmp	 $L72155
$L72160:

; 6600 :     }
; 6601 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00078	51		 push	 ecx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6602 : 
; 6603 :     DWORD dw;
; 6604 :     REFERENCE_TIME rtLatency;
; 6605 : 
; 6606 :     *prtTime = 0;

  0007f	8b 55 0c	 mov	 edx, DWORD PTR _prtTime$[ebp]
  00082	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00088	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 6607 : #ifdef DXAPI
; 6608 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 6609 :     for( dw = 0; dw < m_dwNumPorts; dw++ )
; 6610 :     {
; 6611 :         if( m_pPortTable[dw].rtLast > *prtTime )
; 6612 :             *prtTime = m_pPortTable[dw].rtLast;
; 6613 :     }
; 6614 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 6615 : #else
; 6616 :     *prtTime = m_rtLastSendTime;

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _prtTime$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00098	89 10		 mov	 DWORD PTR [eax], edx
  0009a	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0009d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 6617 : #endif
; 6618 :     rtLatency = GetLatency();

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  000a8	89 45 f0	 mov	 DWORD PTR _rtLatency$[ebp], eax
  000ab	89 55 f4	 mov	 DWORD PTR _rtLatency$[ebp+4], edx

; 6619 :     if( *prtTime < rtLatency )

  000ae	8b 55 0c	 mov	 edx, DWORD PTR _prtTime$[ebp]
  000b1	89 55 ec	 mov	 DWORD PTR tv141[ebp], edx
  000b4	8b 45 ec	 mov	 eax, DWORD PTR tv141[ebp]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	3b 4d f4	 cmp	 ecx, DWORD PTR _rtLatency$[ebp+4]
  000bd	7f 1a		 jg	 SHORT $L72165
  000bf	7c 0a		 jl	 SHORT $L75565
  000c1	8b 55 ec	 mov	 edx, DWORD PTR tv141[ebp]
  000c4	8b 02		 mov	 eax, DWORD PTR [edx]
  000c6	3b 45 f0	 cmp	 eax, DWORD PTR _rtLatency$[ebp]
  000c9	73 0e		 jae	 SHORT $L72165
$L75565:

; 6620 :     {
; 6621 :         *prtTime = rtLatency;

  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _prtTime$[ebp]
  000ce	8b 55 f0	 mov	 edx, DWORD PTR _rtLatency$[ebp]
  000d1	89 11		 mov	 DWORD PTR [ecx], edx
  000d3	8b 45 f4	 mov	 eax, DWORD PTR _rtLatency$[ebp+4]
  000d6	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L72165:

; 6622 :     }
; 6623 :     if (m_rtEarliestStartTime > rtLatency)

  000d9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	89 4d e8	 mov	 DWORD PTR tv153[ebp], ecx
  000df	8b 55 e8	 mov	 edx, DWORD PTR tv153[ebp]
  000e2	8b 82 b4 02 00
	00		 mov	 eax, DWORD PTR [edx+692]
  000e8	3b 45 f4	 cmp	 eax, DWORD PTR _rtLatency$[ebp+4]
  000eb	7c 25		 jl	 SHORT $L72166
  000ed	7f 0e		 jg	 SHORT $L75566
  000ef	8b 4d e8	 mov	 ecx, DWORD PTR tv153[ebp]
  000f2	8b 91 b0 02 00
	00		 mov	 edx, DWORD PTR [ecx+688]
  000f8	3b 55 f0	 cmp	 edx, DWORD PTR _rtLatency$[ebp]
  000fb	76 15		 jbe	 SHORT $L72166
$L75566:

; 6624 :     {
; 6625 :         rtLatency = m_rtEarliestStartTime;

  000fd	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00100	8b 88 b0 02 00
	00		 mov	 ecx, DWORD PTR [eax+688]
  00106	89 4d f0	 mov	 DWORD PTR _rtLatency$[ebp], ecx
  00109	8b 90 b4 02 00
	00		 mov	 edx, DWORD PTR [eax+692]
  0010f	89 55 f4	 mov	 DWORD PTR _rtLatency$[ebp+4], edx
$L72166:

; 6626 :     }
; 6627 :     return S_OK;

  00112	33 c0		 xor	 eax, eax
$L72155:

; 6628 : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 08 00	 ret	 8
?GetQueueTime@CPerformance@@UAGJPA_J@Z ENDP		; CPerformance::GetQueueTime
_TEXT	ENDS
PUBLIC	??_C@_0BI@GPMPOKKI@cb?5?$DO?$DN?5sizeof?$CIPRIV_PMSG?$CJ?$AA@ ; `string'
;	COMDAT ??_C@_0BI@GPMPOKKI@cb?5?$DO?$DN?5sizeof?$CIPRIV_PMSG?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@GPMPOKKI@cb?5?$DO?$DN?5sizeof?$CIPRIV_PMSG?$CJ?$AA@ DB 'cb >= s'
	DB	'izeof(PRIV_PMSG)', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AllocPMsg@CPerformance@@AAEJKPAPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT
_this$ = -12
_pDMUS_PMSG$ = -8
_hr$ = -4
_cb$ = 8
_ppPMSG$ = 12
?AllocPMsg@CPerformance@@AAEJKPAPAUPRIV_PMSG@@@Z PROC NEAR ; CPerformance::AllocPMsg, COMDAT
; _this$ = ecx

; 6634 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 6635 :     ASSERT( cb >= sizeof(PRIV_PMSG) );

  00009	83 7d 08 50	 cmp	 DWORD PTR _cb$[ebp], 80	; 00000050H
  0000d	73 17		 jae	 SHORT $L72174
  0000f	6a 00		 push	 0
  00011	68 eb 19 00 00	 push	 6635			; 000019ebH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@GPMPOKKI@cb?5?$DO?$DN?5sizeof?$CIPRIV_PMSG?$CJ?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L72174:

; 6636 :     DMUS_PMSG* pDMUS_PMSG;
; 6637 :     HRESULT hr;
; 6638 : 
; 6639 :     hr = AllocPMsg( cb - PRIV_PART_SIZE, &pDMUS_PMSG );

  00026	8d 45 f8	 lea	 eax, DWORD PTR _pDMUS_PMSG$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _cb$[ebp]
  0002d	83 e9 18	 sub	 ecx, 24			; 00000018H
  00030	51		 push	 ecx
  00031	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	51		 push	 ecx
  0003a	ff 50 24	 call	 DWORD PTR [eax+36]
  0003d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 6640 :     if( SUCCEEDED(hr) )

  00040	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00044	7c 0b		 jl	 SHORT $L72180

; 6641 :     {
; 6642 :         *ppPMSG = DMUS_TO_PRIV(pDMUS_PMSG);

  00046	8b 55 f8	 mov	 edx, DWORD PTR _pDMUS_PMSG$[ebp]
  00049	83 ea 18	 sub	 edx, 24			; 00000018H
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _ppPMSG$[ebp]
  0004f	89 10		 mov	 DWORD PTR [eax], edx
$L72180:

; 6643 :     }
; 6644 :     return hr;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 6645 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?AllocPMsg@CPerformance@@AAEJKPAPAUPRIV_PMSG@@@Z ENDP	; CPerformance::AllocPMsg
_TEXT	ENDS
PUBLIC	??_C@_0CA@KCKMCHDC@?$CFs?3?5Invalid?5pointer?5ppCopyPMSG?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@BPEIHJHJ@?$CFs?3?5Invalid?5pointer?5pSourcePMSG?6@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU3@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU3@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::ClonePMsg', 00H	; `CPerformance::ClonePMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CA@KCKMCHDC@?$CFs?3?5Invalid?5pointer?5ppCopyPMSG?6?$AA@
CONST	SEGMENT
??_C@_0CA@KCKMCHDC@?$CFs?3?5Invalid?5pointer?5ppCopyPMSG?6?$AA@ DB '%s: I'
	DB	'nvalid pointer ppCopyPMSG', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BPEIHJHJ@?$CFs?3?5Invalid?5pointer?5pSourcePMSG?6@
CONST	SEGMENT
??_C@_0CB@BPEIHJHJ@?$CFs?3?5Invalid?5pointer?5pSourcePMSG?6@ DB '%s: Inva'
	DB	'lid pointer pSourcePMSG', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU2@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_pSourcePMSG$ = 12
_ppCopyPMSG$ = 16
?ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU2@@Z PROC NEAR ; CPerformance::ClonePMsg, COMDAT

; 6648 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6649 :     V_INAME(IDirectMusicPerformance::ClonePMsg);
; 6650 : #ifdef DBG
; 6651 :     V_PTRPTR_WRITE(ppCopyPMSG);

  00004	6a 04		 push	 4
  00006	8b 45 10	 mov	 eax, DWORD PTR _ppCopyPMSG$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L72191
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU3@@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@KCKMCHDC@?$CFs?3?5Invalid?5pointer?5ppCopyPMSG?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L72191:

; 6652 :     V_BUFPTR_READ(pSourcePMSG,sizeof(DMUS_PMSG));

  0002c	6a 38		 push	 56			; 00000038H
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L72194
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU3@@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@BPEIHJHJ@?$CFs?3?5Invalid?5pointer?5pSourcePMSG?6@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L72194:

; 6653 : #else
; 6654 : #ifdef DXAPI
; 6655 :     if (!ppCopyPMSG || !pSourcePMSG)
; 6656 :     { 
; 6657 :         return E_POINTER;
; 6658 :     }
; 6659 : #endif
; 6660 : #endif
; 6661 :     HRESULT hr = AllocPMsg(pSourcePMSG->dwSize,ppCopyPMSG);

  00054	8b 55 10	 mov	 edx, DWORD PTR _ppCopyPMSG$[ebp]
  00057	52		 push	 edx
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pSourcePMSG$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	51		 push	 ecx
  0005e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 02		 mov	 eax, DWORD PTR [edx]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	51		 push	 ecx
  00067	ff 50 24	 call	 DWORD PTR [eax+36]
  0006a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 6662 :     if (SUCCEEDED(hr))

  0006d	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00071	7c 69		 jl	 SHORT $L72198

; 6663 :     {
; 6664 :         memcpy(*ppCopyPMSG,pSourcePMSG,pSourcePMSG->dwSize);

  00073	8b 55 0c	 mov	 edx, DWORD PTR _pSourcePMSG$[ebp]
  00076	8b 02		 mov	 eax, DWORD PTR [edx]
  00078	50		 push	 eax
  00079	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 10	 mov	 edx, DWORD PTR _ppCopyPMSG$[ebp]
  00080	8b 02		 mov	 eax, DWORD PTR [edx]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _memcpy
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6665 :         if (pSourcePMSG->punkUser)

  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  0008e	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00092	74 12		 je	 SHORT $L72199

; 6666 :         {
; 6667 :             pSourcePMSG->punkUser->AddRef();

  00094	8b 55 0c	 mov	 edx, DWORD PTR _pSourcePMSG$[ebp]
  00097	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  0009d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000a0	8b 00		 mov	 eax, DWORD PTR [eax]
  000a2	52		 push	 edx
  000a3	ff 50 04	 call	 DWORD PTR [eax+4]
$L72199:

; 6668 :         }
; 6669 :         if (pSourcePMSG->pTool)

  000a6	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  000a9	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  000ad	74 12		 je	 SHORT $L72200

; 6670 :         {
; 6671 :             pSourcePMSG->pTool->AddRef();

  000af	8b 55 0c	 mov	 edx, DWORD PTR _pSourcePMSG$[ebp]
  000b2	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  000b8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	52		 push	 edx
  000be	ff 50 04	 call	 DWORD PTR [eax+4]
$L72200:

; 6672 :         }
; 6673 :         if (pSourcePMSG->pGraph)

  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  000c4	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  000c8	74 12		 je	 SHORT $L72198

; 6674 :         {
; 6675 :             pSourcePMSG->pGraph->AddRef();

  000ca	8b 55 0c	 mov	 edx, DWORD PTR _pSourcePMSG$[ebp]
  000cd	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR _pSourcePMSG$[ebp]
  000d3	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000d6	8b 00		 mov	 eax, DWORD PTR [eax]
  000d8	52		 push	 edx
  000d9	ff 50 04	 call	 DWORD PTR [eax+4]
$L72198:

; 6676 :         }
; 6677 :     }
; 6678 :     return hr;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 6679 : }

  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c2 0c 00	 ret	 12			; 0000000cH
?ClonePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@PAPAU2@@Z ENDP ; CPerformance::ClonePMsg
_TEXT	ENDS
PUBLIC	??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0BD@EBBFLPLC@DM?5allocated?5PMSGs?$AA@	; `string'
PUBLIC	??_C@_0BA@CNKHGELJ@DM?5active?5PMSGs?$AA@	; `string'
PUBLIC	??_C@_0BA@JACIILDB@DM?5cached?5PMSGs?$AA@	; `string'
PUBLIC	??_C@_0BJ@LDFHGMM@DM?5allocation?5rate?5PMSGs?$AA@ ; `string'
PUBLIC	_DMRegisterPMsgPerformanceCounters@0
_BSS	SEGMENT
_g_llPMsgAllocCount DQ 01H DUP (?)
_g_dwPMsgCount DD 01H DUP (?)
_g_dwPMsgBytes DD 01H DUP (?)
_g_dwPMsgActive DD 01H DUP (?)
_g_dwPMsgCached DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@
CONST	SEGMENT
??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@ DB 'DM allocated PMSG '
	DB	'bytes', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EBBFLPLC@DM?5allocated?5PMSGs?$AA@
CONST	SEGMENT
??_C@_0BD@EBBFLPLC@DM?5allocated?5PMSGs?$AA@ DB 'DM allocated PMSGs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CNKHGELJ@DM?5active?5PMSGs?$AA@
CONST	SEGMENT
??_C@_0BA@CNKHGELJ@DM?5active?5PMSGs?$AA@ DB 'DM active PMSGs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JACIILDB@DM?5cached?5PMSGs?$AA@
CONST	SEGMENT
??_C@_0BA@JACIILDB@DM?5cached?5PMSGs?$AA@ DB 'DM cached PMSGs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LDFHGMM@DM?5allocation?5rate?5PMSGs?$AA@
CONST	SEGMENT
??_C@_0BJ@LDFHGMM@DM?5allocation?5rate?5PMSGs?$AA@ DB 'DM allocation rate'
	DB	' PMSGs', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _DMRegisterPMsgPerformanceCounters@0
_TEXT	SEGMENT
_DMRegisterPMsgPerformanceCounters@0 PROC NEAR		; COMDAT

; 6688 : extern "C" void DMRegisterPMsgPerformanceCounters(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6689 :     DMusicRegisterPerformanceCounter( "DM allocated PMSG bytes",
; 6690 :                               DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 6691 :                               &g_dwPMsgBytes );

  00003	68 00 00 00 00	 push	 OFFSET FLAT:_g_dwPMsgBytes
  00008	68 00 00 02 00	 push	 131072			; 00020000H
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@
  00012	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 6692 :     DMusicRegisterPerformanceCounter( "DM allocated PMSG bytes",
; 6693 :                               DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 6694 :                               &g_dwPMsgBytes );

  00017	68 00 00 00 00	 push	 OFFSET FLAT:_g_dwPMsgBytes
  0001c	68 00 00 02 00	 push	 131072			; 00020000H
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@
  00026	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 6695 :     DMusicRegisterPerformanceCounter( "DM allocated PMSGs",
; 6696 :                               DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 6697 :                               &g_dwPMsgCount );

  0002b	68 00 00 00 00	 push	 OFFSET FLAT:_g_dwPMsgCount
  00030	68 00 00 02 00	 push	 131072			; 00020000H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@EBBFLPLC@DM?5allocated?5PMSGs?$AA@
  0003a	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 6698 :     DMusicRegisterPerformanceCounter( "DM active PMSGs",
; 6699 :                               DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 6700 :                               &g_dwPMsgActive );

  0003f	68 00 00 00 00	 push	 OFFSET FLAT:_g_dwPMsgActive
  00044	68 00 00 02 00	 push	 131072			; 00020000H
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@CNKHGELJ@DM?5active?5PMSGs?$AA@
  0004e	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 6701 :     DMusicRegisterPerformanceCounter( "DM cached PMSGs",
; 6702 :                               DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 6703 :                               &g_dwPMsgCached );

  00053	68 00 00 00 00	 push	 OFFSET FLAT:_g_dwPMsgCached
  00058	68 00 00 02 00	 push	 131072			; 00020000H
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@JACIILDB@DM?5cached?5PMSGs?$AA@
  00062	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 6704 :     DMusicRegisterPerformanceCounter( "DM allocation rate PMSGs",
; 6705 :                               DMCOUNT_FREQ100MS | DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
; 6706 :                               &g_llPMsgAllocCount );

  00067	68 00 00 00 00	 push	 OFFSET FLAT:_g_llPMsgAllocCount
  0006c	68 11 00 04 00	 push	 262161			; 00040011H
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@LDFHGMM@DM?5allocation?5rate?5PMSGs?$AA@
  00076	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 6707 : }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_DMRegisterPMsgPerformanceCounters@0 ENDP
_TEXT	ENDS
PUBLIC	_DMUnregisterPMsgPerformanceCounters@0
; Function compile flags: /Odt
;	COMDAT _DMUnregisterPMsgPerformanceCounters@0
_TEXT	SEGMENT
_DMUnregisterPMsgPerformanceCounters@0 PROC NEAR	; COMDAT

; 6709 : extern "C" void DMUnregisterPMsgPerformanceCounters(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6710 :     DMusicUnregisterPerformanceCounter( "DM allocated PMSG bytes");

  00003	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@
  00008	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 6711 :     DMusicUnregisterPerformanceCounter( "DM allocated PMSG bytes");

  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@NBAJNBJH@DM?5allocated?5PMSG?5bytes?$AA@
  00012	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 6712 :     DMusicUnregisterPerformanceCounter( "DM allocated PMSGs");

  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@EBBFLPLC@DM?5allocated?5PMSGs?$AA@
  0001c	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 6713 :     DMusicUnregisterPerformanceCounter( "DM active PMSGs");

  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@CNKHGELJ@DM?5active?5PMSGs?$AA@
  00026	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 6714 :     DMusicUnregisterPerformanceCounter( "DM cached PMSGs");

  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@JACIILDB@DM?5cached?5PMSGs?$AA@
  00030	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 6715 :     DMusicUnregisterPerformanceCounter( "DM allocation rate PMSGs");

  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@LDFHGMM@DM?5allocation?5rate?5PMSGs?$AA@
  0003a	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 6716 : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_DMUnregisterPMsgPerformanceCounters@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MKBIHCAB@?$CFs?3?5Invalid?5pointer?5ppPMSG?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@LLFAGKFK@cb?5is?5?$CFd?5but?5must?5be?5at?5least?5si@ ; `string'
PUBLIC	??_C@_0DC@PNFDFEEC@Attempt?5to?5allocate?5PMSG?5of?5size@ ; `string'
PUBLIC	??_C@_0DB@KHJHODCD@Error?5?9?5previously?5freed?5PMsg?5ha@ ; `string'
PUBLIC	?Alloc@CPMsgZone@@QAEPAXI@Z			; CPMsgZone::Alloc
;	COMDAT ?__szValidateInterfaceName@?1??AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::AllocPMsg', 00H	; `CPerformance::AllocPMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@MKBIHCAB@?$CFs?3?5Invalid?5pointer?5ppPMSG?6?$AA@
CONST	SEGMENT
??_C@_0BM@MKBIHCAB@?$CFs?3?5Invalid?5pointer?5ppPMSG?6?$AA@ DB '%s: Inval'
	DB	'id pointer ppPMSG', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LLFAGKFK@cb?5is?5?$CFd?5but?5must?5be?5at?5least?5si@
CONST	SEGMENT
??_C@_0CK@LLFAGKFK@cb?5is?5?$CFd?5but?5must?5be?5at?5least?5si@ DB 'cb is'
	DB	' %d but must be at least size of %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PNFDFEEC@Attempt?5to?5allocate?5PMSG?5of?5size@
CONST	SEGMENT
??_C@_0DC@PNFDFEEC@Attempt?5to?5allocate?5PMSG?5of?5size@ DB 'Attempt to '
	DB	'allocate PMSG of size %d is too large', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KHJHODCD@Error?5?9?5previously?5freed?5PMsg?5ha@
CONST	SEGMENT
??_C@_0DB@KHJHODCD@Error?5?9?5previously?5freed?5PMsg?5ha@ DB 'Error - pr'
	DB	'eviously freed PMsg has been mangled.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
$T75582 = -20
_cbIndex$72234 = -16
_cbPriv$ = -12
_hr$ = -8
_pPrivPMsg$ = -4
_this$ = 8
_cb$ = 12
_ppPMSG$ = 16
?AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z PROC NEAR ; CPerformance::AllocPMsg, COMDAT

; 6738 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6739 :     V_INAME(IDirectMusicPerformance::AllocPMsg);
; 6740 : #ifdef DXAPI
; 6741 :     if( m_dwVersion < 8)
; 6742 :     {
; 6743 :         V_PTRPTR_WRITE(ppPMSG);
; 6744 :     }
; 6745 :     else
; 6746 :     {
; 6747 : #ifdef DBG
; 6748 :         V_PTRPTR_WRITE(ppPMSG);
; 6749 : #else
; 6750 :         if (!ppPMSG)
; 6751 :         {
; 6752 :             return E_POINTER;
; 6753 :         }
; 6754 : #endif
; 6755 :     }
; 6756 : #else
; 6757 :     V_PTRPTR_WRITE(ppPMSG);

  00006	6a 04		 push	 4
  00008	8b 45 10	 mov	 eax, DWORD PTR _ppPMSG$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72224
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MKBIHCAB@?$CFs?3?5Invalid?5pointer?5ppPMSG?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72224:

; 6758 : #endif
; 6759 :     PRIV_PMSG* pPrivPMsg;
; 6760 : 
; 6761 : #ifdef DXAPI
; 6762 :     if( cb < sizeof(DMUS_PMSG) )
; 6763 :         return E_INVALIDARG;
; 6764 : #else
; 6765 : #ifdef DBG
; 6766 :     if( cb < sizeof(DMUS_PMSG) )

  0002e	83 7d 0c 38	 cmp	 DWORD PTR _cb$[ebp], 56	; 00000038H
  00032	73 15		 jae	 SHORT $L72228

; 6767 : 	    Trace(0,"cb is %d but must be at least size of %d\n", cb, sizeof(DMUS_PMSG));

  00034	6a 38		 push	 56			; 00000038H
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _cb$[ebp]
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@LLFAGKFK@cb?5is?5?$CFd?5but?5must?5be?5at?5least?5si@
  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00046	83 c4 10	 add	 esp, 16			; 00000010H
$L72228:

; 6768 :     if ( cb > 1000)

  00049	81 7d 0c e8 03
	00 00		 cmp	 DWORD PTR _cb$[ebp], 1000 ; 000003e8H
  00050	76 13		 jbe	 SHORT $L72231

; 6769 :         Trace(0,"Attempt to allocate PMSG of size %d is too large\n",cb);

  00052	8b 55 0c	 mov	 edx, DWORD PTR _cb$[ebp]
  00055	52		 push	 edx
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@PNFDFEEC@Attempt?5to?5allocate?5PMSG?5of?5size@
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72231:

; 6770 : #endif
; 6771 : #endif
; 6772 : 
; 6773 :     ENTER_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00065	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00068	05 f8 02 00 00	 add	 eax, 760		; 000002f8H
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6774 :     ENTER_API_CRITICAL_SECTION;
; 6775 : 
; 6776 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 6777 :     g_llPMsgAllocCount++;

  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_llPMsgAllocCount
  0007a	83 c1 01	 add	 ecx, 1
  0007d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _g_llPMsgAllocCount+4
  00083	83 d2 00	 adc	 edx, 0
  00086	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_llPMsgAllocCount, ecx
  0008c	89 15 04 00 00
	00		 mov	 DWORD PTR _g_llPMsgAllocCount+4, edx

; 6778 : #endif
; 6779 : 
; 6780 :     // cached pmsg's are stored in an array based on their public size.
; 6781 :     // If a cached pmsg exists, return it. Otherwise, make a new one.
; 6782 :     if( (cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX) )

  00092	83 7d 0c 30	 cmp	 DWORD PTR _cb$[ebp], 48	; 00000030H
  00096	0f 82 eb 00 00
	00		 jb	 $L72233
  0009c	83 7d 0c 78	 cmp	 DWORD PTR _cb$[ebp], 120 ; 00000078H
  000a0	0f 83 e1 00 00
	00		 jae	 $L72233

; 6783 :     {
; 6784 :         ULONG cbIndex = cb - PERF_PMSG_CB_MIN;

  000a6	8b 45 0c	 mov	 eax, DWORD PTR _cb$[ebp]
  000a9	83 e8 30	 sub	 eax, 48			; 00000030H
  000ac	89 45 f0	 mov	 DWORD PTR _cbIndex$72234[ebp], eax

; 6785 :         if( m_apPMsgCache[ cbIndex ] )

  000af	8b 4d f0	 mov	 ecx, DWORD PTR _cbIndex$72234[ebp]
  000b2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	83 bc 8a 74 01
	00 00 00	 cmp	 DWORD PTR [edx+ecx*4+372], 0
  000bd	0f 84 c4 00 00
	00		 je	 $L72233

; 6786 :         {
; 6787 :             pPrivPMsg = m_apPMsgCache[ cbIndex ];

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _cbIndex$72234[ebp]
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	8b 94 81 74 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+372]
  000d0	89 55 fc	 mov	 DWORD PTR _pPrivPMsg$[ebp], edx

; 6788 :             m_apPMsgCache[ cbIndex ] = pPrivPMsg->pNext;

  000d3	8b 45 f0	 mov	 eax, DWORD PTR _cbIndex$72234[ebp]
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  000dc	8b 12		 mov	 edx, DWORD PTR [edx]
  000de	89 94 81 74 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+372], edx

; 6789 :             pPrivPMsg->pNext = NULL;

  000e5	8b 45 fc	 mov	 eax, DWORD PTR _pPrivPMsg$[ebp]
  000e8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 6790 :             if (pPrivPMsg->dwPrivFlags != PRIV_FLAG_FREE)

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  000f1	81 79 04 d0 ea
	0d 00		 cmp	 DWORD PTR [ecx+4], 912080 ; 000dead0H
  000f8	74 29		 je	 SHORT $L72236

; 6791 :             {
; 6792 :                 Trace(0,"Error - previously freed PMsg has been mangled.\n");

  000fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@KHJHODCD@Error?5?9?5previously?5freed?5PMsg?5ha@
  000ff	6a 00		 push	 0
  00101	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00106	83 c4 08	 add	 esp, 8

; 6793 :                 LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00109	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0010c	81 c2 f8 02 00
	00		 add	 edx, 760		; 000002f8H
  00112	52		 push	 edx
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6794 :                 return E_FAIL;

  00119	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0011e	e9 54 01 00 00	 jmp	 $L72220
$L72236:

; 6795 :             }
; 6796 :             pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;

  00123	8b 45 fc	 mov	 eax, DWORD PTR _pPrivPMsg$[ebp]
  00126	c7 40 04 e0 af
	0c 00		 mov	 DWORD PTR [eax+4], 831456 ; 000cafe0H

; 6797 :             if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	83 b9 10 01 00
	00 00		 cmp	 DWORD PTR [ecx+272], 0
  00137	74 0f		 je	 SHORT $L72239
  00139	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0013c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0013f	83 c8 04	 or	 eax, 4
  00142	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00145	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L72239:

; 6798 :             *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);

  00148	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0014b	83 c2 18	 add	 edx, 24			; 00000018H
  0014e	8b 45 10	 mov	 eax, DWORD PTR _ppPMSG$[ebp]
  00151	89 10		 mov	 DWORD PTR [eax], edx

; 6799 : 
; 6800 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 6801 :             g_dwPMsgCached--;

  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_dwPMsgCached
  00159	83 e9 01	 sub	 ecx, 1
  0015c	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_dwPMsgCached, ecx

; 6802 :             g_dwPMsgActive++;

  00162	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_dwPMsgActive
  00168	83 c2 01	 add	 edx, 1
  0016b	89 15 00 00 00
	00		 mov	 DWORD PTR _g_dwPMsgActive, edx

; 6803 : #endif
; 6804 : 
; 6805 :             LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00171	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00174	05 f8 02 00 00	 add	 eax, 760		; 000002f8H
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6806 :             LEAVE_API_CRITICAL_SECTION;
; 6807 :             return S_OK;

  00180	33 c0		 xor	 eax, eax
  00182	e9 f0 00 00 00	 jmp	 $L72220
$L72233:

; 6808 :         }
; 6809 :     }
; 6810 : 
; 6811 :     HRESULT hr = S_OK;

  00187	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 6812 :     // no cached pmsg exists. Return a new one.
; 6813 :     ULONG cbPriv = cb + PRIV_PART_SIZE;

  0018e	8b 4d 0c	 mov	 ecx, DWORD PTR _cb$[ebp]
  00191	83 c1 18	 add	 ecx, 24			; 00000018H
  00194	89 4d f4	 mov	 DWORD PTR _cbPriv$[ebp], ecx

; 6814 : 
; 6815 : #ifdef USE_PMSG_ZONE
; 6816 :     // Allocate cachable PMSGs out of a private zone to reduce fragmentation
; 6817 :     // This test has to match the one in CPerformance::FreePMsg
; 6818 :     if((cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX))

  00197	83 7d 0c 30	 cmp	 DWORD PTR _cb$[ebp], 48	; 00000030H
  0019b	72 1d		 jb	 SHORT $L72247
  0019d	83 7d 0c 78	 cmp	 DWORD PTR _cb$[ebp], 120 ; 00000078H
  001a1	73 17		 jae	 SHORT $L72247

; 6819 :     {
; 6820 :         pPrivPMsg = (PRIV_PMSG*) m_pPMsgZone->Alloc(cbPriv);

  001a3	8b 55 f4	 mov	 edx, DWORD PTR _cbPriv$[ebp]
  001a6	52		 push	 edx
  001a7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001aa	8b 88 dc 03 00
	00		 mov	 ecx, DWORD PTR [eax+988]
  001b0	e8 00 00 00 00	 call	 ?Alloc@CPMsgZone@@QAEPAXI@Z ; CPMsgZone::Alloc
  001b5	89 45 fc	 mov	 DWORD PTR _pPrivPMsg$[ebp], eax

; 6821 :     }
; 6822 :     else {

  001b8	eb 15		 jmp	 SHORT $L72249
$L72247:

; 6823 :         pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);

  001ba	8b 4d f4	 mov	 ecx, DWORD PTR _cbPriv$[ebp]
  001bd	51		 push	 ecx
  001be	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  001c3	83 c4 04	 add	 esp, 4
  001c6	89 45 ec	 mov	 DWORD PTR $T75582[ebp], eax
  001c9	8b 55 ec	 mov	 edx, DWORD PTR $T75582[ebp]
  001cc	89 55 fc	 mov	 DWORD PTR _pPrivPMsg$[ebp], edx
$L72249:

; 6824 :     }
; 6825 : 
; 6826 : #else
; 6827 :     pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);
; 6828 : #endif
; 6829 : 
; 6830 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 6831 :     g_dwPMsgCount++;

  001cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_dwPMsgCount
  001d4	83 c0 01	 add	 eax, 1
  001d7	a3 00 00 00 00	 mov	 DWORD PTR _g_dwPMsgCount, eax

; 6832 :     g_dwPMsgBytes += cbPriv;

  001dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_dwPMsgBytes
  001e2	03 4d f4	 add	 ecx, DWORD PTR _cbPriv$[ebp]
  001e5	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_dwPMsgBytes, ecx

; 6833 :     g_dwPMsgActive++;

  001eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_dwPMsgActive
  001f1	83 c2 01	 add	 edx, 1
  001f4	89 15 00 00 00
	00		 mov	 DWORD PTR _g_dwPMsgActive, edx

; 6834 : #endif
; 6835 : 
; 6836 :     if( pPrivPMsg )

  001fa	83 7d fc 00	 cmp	 DWORD PTR _pPrivPMsg$[ebp], 0
  001fe	74 5d		 je	 SHORT $L72253

; 6837 :     {
; 6838 :         memset( pPrivPMsg, 0, cbPriv );

  00200	8b 45 f4	 mov	 eax, DWORD PTR _cbPriv$[ebp]
  00203	50		 push	 eax
  00204	6a 00		 push	 0
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 _memset
  0020f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6839 :         pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cb; // size of public part only

  00212	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  00215	8b 45 0c	 mov	 eax, DWORD PTR _cb$[ebp]
  00218	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  0021e	8b 55 0c	 mov	 edx, DWORD PTR _cb$[ebp]
  00221	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 6840 :         pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;

  00224	8b 45 fc	 mov	 eax, DWORD PTR _pPrivPMsg$[ebp]
  00227	c7 40 04 e0 af
	0c 00		 mov	 DWORD PTR [eax+4], 831456 ; 000cafe0H

; 6841 :         if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;

  0022e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	83 b9 10 01 00
	00 00		 cmp	 DWORD PTR [ecx+272], 0
  00238	74 0f		 je	 SHORT $L72254
  0023a	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0023d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00240	83 c8 04	 or	 eax, 4
  00243	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00246	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L72254:

; 6842 :         *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);

  00249	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0024c	83 c2 18	 add	 edx, 24			; 00000018H
  0024f	8b 45 10	 mov	 eax, DWORD PTR _ppPMSG$[ebp]
  00252	89 10		 mov	 DWORD PTR [eax], edx

; 6843 :         hr = S_OK;

  00254	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 6844 :     }
; 6845 :     else

  0025b	eb 07		 jmp	 SHORT $L72258
$L72253:

; 6846 :     {
; 6847 :         hr = E_OUTOFMEMORY;

  0025d	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L72258:

; 6848 :     }
; 6849 :     LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00264	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00267	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0026d	51		 push	 ecx
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6850 :     LEAVE_API_CRITICAL_SECTION;
; 6851 :     return hr;

  00274	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L72220:

; 6852 : }

  00277	8b e5		 mov	 esp, ebp
  00279	5d		 pop	 ebp
  0027a	c2 0c 00	 ret	 12			; 0000000cH
?AllocPMsg@CPerformance@@UAGJKPAPAU_DMUS_PMSG@@@Z ENDP	; CPerformance::AllocPMsg
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Alloc@CPMsgZone@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8
_result$ = -4
_size$ = 8
?Alloc@CPMsgZone@@QAEPAXI@Z PROC NEAR			; CPMsgZone::Alloc, COMDAT
; _this$ = ecx

; 295  :     void* Alloc(size_t size){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 296  :         AllocZone(size);

  00009	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?AllocZone@CPMsgZone@@AAEXK@Z ; CPMsgZone::AllocZone

; 297  :         if(m_dwSize - m_dwOffset < size){

  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001e	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00021	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00024	73 04		 jae	 SHORT $L69572

; 298  :             return NULL;

  00026	33 c0		 xor	 eax, eax
  00028	eb 20		 jmp	 SHORT $L69571
$L69572:

; 299  :         }
; 300  :         void* result = m_pBlock + m_dwOffset;

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00035	89 55 fc	 mov	 DWORD PTR _result$[ebp], edx

; 301  :         m_dwOffset += size;

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003e	03 55 08	 add	 edx, DWORD PTR _size$[ebp]
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 302  : 
; 303  :         return result;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
$L69571:

; 304  :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?Alloc@CPMsgZone@@QAEPAXI@Z ENDP			; CPMsgZone::Alloc
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT
_this$ = -4
_pPMSG$ = 8
?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z PROC NEAR	; CPerformance::FreePMsg, COMDAT
; _this$ = ecx

; 6857 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 6858 :     return FreePMsg( PRIV_TO_DMUS(pPMSG) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _pPMSG$[ebp]
  0000a	83 c0 18	 add	 eax, 24			; 00000018H
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	50		 push	 eax
  00017	ff 52 28	 call	 DWORD PTR [edx+40]

; 6859 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ENDP	; CPerformance::FreePMsg
_TEXT	ENDS
PUBLIC	??_C@_0BL@DDIHCOKC@?$CFs?3?5Invalid?5pointer?5pPMSG?6?$AA@ ; `string'
PUBLIC	??_C@_0EA@CKCJBHIN@Error?5?9?9?9?5Attempt?5to?5free?5a?5PMsg@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::FreePMsg', 00H	; `CPerformance::FreePMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BL@DDIHCOKC@?$CFs?3?5Invalid?5pointer?5pPMSG?6?$AA@
CONST	SEGMENT
??_C@_0BL@DDIHCOKC@?$CFs?3?5Invalid?5pointer?5pPMSG?6?$AA@ DB '%s: Invali'
	DB	'd pointer pPMSG', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CKCJBHIN@Error?5?9?9?9?5Attempt?5to?5free?5a?5PMsg@
CONST	SEGMENT
??_C@_0EA@CKCJBHIN@Error?5?9?9?9?5Attempt?5to?5free?5a?5PMsg@ DB 'Error -'
	DB	'-- Attempt to free a PMsg that is not allocated memory.', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
$T75592 = -12
_cbSize$ = -8
_pPrivPMsg$ = -4
_this$ = 8
_pPMSG$ = 12
?FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z PROC NEAR	; CPerformance::FreePMsg, COMDAT

; 6866 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 6867 :     V_INAME(IDirectMusicPerformance::FreePMsg);
; 6868 : #ifdef DXAPI
; 6869 :     if( m_dwVersion < 8)
; 6870 :     {
; 6871 :         V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
; 6872 :     }
; 6873 :     else
; 6874 :     {
; 6875 : #ifdef DBG
; 6876 :         V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
; 6877 : #else
; 6878 :         if (!pPMSG)
; 6879 :         {
; 6880 :             return E_POINTER;
; 6881 :         }
; 6882 : #endif
; 6883 :     }
; 6884 : #else
; 6885 :     V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));

  00006	6a 38		 push	 56			; 00000038H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pPMSG$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72273
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@DDIHCOKC@?$CFs?3?5Invalid?5pointer?5pPMSG?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72273:

; 6886 : #endif
; 6887 : 
; 6888 :     PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMSG);

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  00031	83 e9 18	 sub	 ecx, 24			; 00000018H
  00034	89 4d fc	 mov	 DWORD PTR _pPrivPMsg$[ebp], ecx

; 6889 : 
; 6890 :     if( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK) != PRIV_FLAG_ALLOC )

  00037	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	25 f0 ff 0f 00	 and	 eax, 1048560		; 000ffff0H
  00042	3d e0 af 0c 00	 cmp	 eax, 831456		; 000cafe0H
  00047	74 19		 je	 SHORT $L72278

; 6891 :     {
; 6892 :         Trace(0, "Error --- Attempt to free a PMsg that is not allocated memory.\n");

  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@CKCJBHIN@Error?5?9?9?9?5Attempt?5to?5free?5a?5PMsg@
  0004e	6a 00		 push	 0
  00050	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00055	83 c4 08	 add	 esp, 8

; 6893 :         // this isn't a msg allocated by AllocPMsg.
; 6894 :         return DMUS_E_CANNOT_FREE;

  00058	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0005d	e9 42 01 00 00	 jmp	 $L72269
$L72278:

; 6895 :     }
; 6896 :     if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED )

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00065	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00068	83 e2 01	 and	 edx, 1
  0006b	85 d2		 test	 edx, edx
  0006d	74 0a		 je	 SHORT $L72281

; 6897 :     {
; 6898 :         TraceI(1, "Attempt to free a PMsg that is currently in the Performance queue.\n");
; 6899 :         return DMUS_E_CANNOT_FREE;

  0006f	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00074	e9 2b 01 00 00	 jmp	 $L72269
$L72281:

; 6900 :     }
; 6901 : 
; 6902 :     ENTER_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00079	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	05 f8 02 00 00	 add	 eax, 760		; 000002f8H
  00081	50		 push	 eax
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6903 :     ENTER_API_CRITICAL_SECTION;
; 6904 :     if( pPMSG->pTool )

  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  0008b	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0008f	74 12		 je	 SHORT $L72284

; 6905 :     {
; 6906 :         pPMSG->pTool->Release();

  00091	8b 55 0c	 mov	 edx, DWORD PTR _pPMSG$[ebp]
  00094	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  0009a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	52		 push	 edx
  000a0	ff 50 08	 call	 DWORD PTR [eax+8]
$L72284:

; 6907 :     }
; 6908 :     if( pPMSG->pGraph )

  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  000a6	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  000aa	74 12		 je	 SHORT $L72285

; 6909 :     {
; 6910 :         pPMSG->pGraph->Release();

  000ac	8b 55 0c	 mov	 edx, DWORD PTR _pPMSG$[ebp]
  000af	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  000b5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	52		 push	 edx
  000bb	ff 50 08	 call	 DWORD PTR [eax+8]
$L72285:

; 6911 :     }
; 6912 :     if( pPMSG->punkUser )

  000be	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  000c1	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  000c5	74 12		 je	 SHORT $L72286

; 6913 :     {
; 6914 :         pPMSG->punkUser->Release();

  000c7	8b 55 0c	 mov	 edx, DWORD PTR _pPMSG$[ebp]
  000ca	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMSG$[ebp]
  000d0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000d3	8b 00		 mov	 eax, DWORD PTR [eax]
  000d5	52		 push	 edx
  000d6	ff 50 08	 call	 DWORD PTR [eax+8]
$L72286:

; 6915 :     }
; 6916 : 
; 6917 :     ULONG cbSize = pPrivPMsg->dwPrivPubSize;

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  000dc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000df	89 55 f8	 mov	 DWORD PTR _cbSize$[ebp], edx

; 6918 :     if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) )

  000e2	83 7d f8 30	 cmp	 DWORD PTR _cbSize$[ebp], 48 ; 00000030H
  000e6	72 68		 jb	 SHORT $L72288
  000e8	83 7d f8 78	 cmp	 DWORD PTR _cbSize$[ebp], 120 ; 00000078H
  000ec	73 62		 jae	 SHORT $L72288

; 6919 :     {
; 6920 :         memset( pPrivPMsg, 0, cbSize + PRIV_PART_SIZE );

  000ee	8b 45 f8	 mov	 eax, DWORD PTR _cbSize$[ebp]
  000f1	83 c0 18	 add	 eax, 24			; 00000018H
  000f4	50		 push	 eax
  000f5	6a 00		 push	 0
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _memset
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6921 :         pPrivPMsg->dwPrivFlags = PRIV_FLAG_FREE; // Mark this as in the free queue.

  00103	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  00106	c7 42 04 d0 ea
	0d 00		 mov	 DWORD PTR [edx+4], 912080 ; 000dead0H

; 6922 :         pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cbSize;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _pPrivPMsg$[ebp]
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _cbSize$[ebp]
  00113	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00116	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  00119	8b 45 f8	 mov	 eax, DWORD PTR _cbSize$[ebp]
  0011c	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 6923 :         pPrivPMsg->pNext = m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ];

  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00122	8b 55 f8	 mov	 edx, DWORD PTR _cbSize$[ebp]
  00125	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00128	8b 94 90 b4 00
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+180]
  0012f	89 11		 mov	 DWORD PTR [ecx], edx

; 6924 :         m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ] = pPrivPMsg;

  00131	8b 45 f8	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	8b 55 fc	 mov	 edx, DWORD PTR _pPrivPMsg$[ebp]
  0013a	89 94 81 b4 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+180], edx

; 6925 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 6926 :         g_dwPMsgCached++;

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_dwPMsgCached
  00146	83 c0 01	 add	 eax, 1
  00149	a3 00 00 00 00	 mov	 DWORD PTR _g_dwPMsgCached, eax

; 6927 : #endif
; 6928 :     }
; 6929 :     else

  0014e	eb 35		 jmp	 SHORT $L72290
$L72288:

; 6930 :     {
; 6931 :         delete [] pPrivPMsg;

  00150	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivPMsg$[ebp]
  00153	89 4d f4	 mov	 DWORD PTR $T75592[ebp], ecx
  00156	8b 55 f4	 mov	 edx, DWORD PTR $T75592[ebp]
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0015f	83 c4 04	 add	 esp, 4

; 6932 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 6933 :         g_dwPMsgBytes -= (cbSize + PRIV_PART_SIZE);

  00162	8b 45 f8	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00165	83 c0 18	 add	 eax, 24			; 00000018H
  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_dwPMsgBytes
  0016e	2b c8		 sub	 ecx, eax
  00170	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_dwPMsgBytes, ecx

; 6934 :         g_dwPMsgCount--;

  00176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_dwPMsgCount
  0017c	83 ea 01	 sub	 edx, 1
  0017f	89 15 00 00 00
	00		 mov	 DWORD PTR _g_dwPMsgCount, edx
$L72290:

; 6935 : #endif
; 6936 :     }
; 6937 : 
; 6938 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 6939 :         g_dwPMsgActive--;

  00185	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_dwPMsgActive
  0018a	83 e8 01	 sub	 eax, 1
  0018d	a3 00 00 00 00	 mov	 DWORD PTR _g_dwPMsgActive, eax

; 6940 : #endif
; 6941 : 
; 6942 :     LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);

  00192	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0019b	51		 push	 ecx
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6943 :     LEAVE_API_CRITICAL_SECTION;
; 6944 :     return S_OK;

  001a2	33 c0		 xor	 eax, eax
$L72269:

; 6945 : }

  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c2 08 00	 ret	 8
?FreePMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z ENDP	; CPerformance::FreePMsg
_TEXT	ENDS
PUBLIC	?FlushVirtualTrack@CPerformance@@QAEJKJK@Z	; CPerformance::FlushVirtualTrack
; Function compile flags: /Odt
;	COMDAT ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z
_TEXT	SEGMENT
_this$ = -4
_dwId$ = 8
_mtTime$ = 12
_dwFlushFlags$ = 16
?FlushVirtualTrack@CPerformance@@QAEJKJK@Z PROC NEAR	; CPerformance::FlushVirtualTrack, COMDAT
; _this$ = ecx

; 6951 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 6952 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 30 03 00 00	 add	 eax, 816		; 00000330H
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6953 :     FlushMainEventQueues( dwId, mtTime, mtTime, dwFlushFlags );

  00016	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlushFlags$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _dwId$[ebp]
  00025	51		 push	 ecx
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z ; CPerformance::FlushMainEventQueues

; 6954 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  00037	52		 push	 edx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6955 :     return S_OK;

  0003e	33 c0		 xor	 eax, eax

; 6956 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ENDP		; CPerformance::FlushVirtualTrack
_TEXT	ENDS
PUBLIC	?GetControlSegTime@CPerformance@@QAEJJPAJ@Z	; CPerformance::GetControlSegTime
; Function compile flags: /Odt
;	COMDAT ?GetControlSegTime@CPerformance@@QAEJJPAJ@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_pTemp$ = -4
_mtTime$ = 8
_pmtNextSeg$ = 12
?GetControlSegTime@CPerformance@@QAEJJPAJ@Z PROC NEAR	; CPerformance::GetControlSegTime, COMDAT
; _this$ = ecx

; 6966 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 6967 :     HRESULT hr = S_FALSE;

  00009	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1

; 6968 :     *pmtNextSeg = 0;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _pmtNextSeg$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 6969 :     ENTER_CRITICAL_SECTION( &m_SegmentCrSec );

  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00022	51		 push	 ecx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 6970 :     // search the secondary lists for a control segment
; 6971 :     CSegState* pTemp;
; 6972 :     for( pTemp = m_SegStateQueues[SQ_CON_DONE].GetHead(); pTemp; pTemp = pTemp->GetNext() )

  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0002f	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00034	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  00037	eb 0b		 jmp	 SHORT $L72309
$L72310:
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00041	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
$L72309:
  00044	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  00048	74 21		 je	 SHORT $L72311

; 6973 :     {
; 6974 :         if( pTemp->m_mtResolvedStart >= mtTime )

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  0004d	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00050	3b 45 08	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00053	7c 14		 jl	 SHORT $L72312

; 6975 :         {
; 6976 :             *pmtNextSeg = pTemp->m_mtResolvedStart;

  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtNextSeg$[ebp]
  00058	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  0005b	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 6977 :             hr = S_OK;

  00060	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 6978 :             break;

  00067	eb 02		 jmp	 SHORT $L72311
$L72312:

; 6979 :         }
; 6980 :     }

  00069	eb ce		 jmp	 SHORT $L72310
$L72311:

; 6981 :     if( S_FALSE == hr ) // if this is still zero, check the current queue

  0006b	83 7d f8 01	 cmp	 DWORD PTR _hr$[ebp], 1
  0006f	75 42		 jne	 SHORT $L72315

; 6982 :     {
; 6983 :         for( pTemp = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )

  00071	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 64	 add	 ecx, 100		; 00000064H
  00077	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0007c	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  0007f	eb 0b		 jmp	 SHORT $L72316
$L72317:
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00084	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00089	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
$L72316:
  0008c	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  00090	74 21		 je	 SHORT $L72315

; 6984 :         {
; 6985 :             if( pTemp->m_mtResolvedStart >= mtTime )

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  00095	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00098	3b 55 08	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  0009b	7c 14		 jl	 SHORT $L72319

; 6986 :             {
; 6987 :                 *pmtNextSeg = pTemp->m_mtResolvedStart;

  0009d	8b 45 0c	 mov	 eax, DWORD PTR _pmtNextSeg$[ebp]
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  000a3	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000a6	89 10		 mov	 DWORD PTR [eax], edx

; 6988 :                 hr = S_OK;

  000a8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 6989 :                 break;

  000af	eb 02		 jmp	 SHORT $L72315
$L72319:

; 6990 :             }
; 6991 :         }

  000b1	eb ce		 jmp	 SHORT $L72317
$L72315:

; 6992 :     }
; 6993 :     LEAVE_CRITICAL_SECTION( &m_SegmentCrSec );

  000b3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	05 14 03 00 00	 add	 eax, 788		; 00000314H
  000bb	50		 push	 eax
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 6994 :     return hr;

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 6995 : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
?GetControlSegTime@CPerformance@@QAEJJPAJ@Z ENDP	; CPerformance::GetControlSegTime
_TEXT	ENDS
PUBLIC	?GetPriSegTime@CPerformance@@QAEJJPAJ@Z		; CPerformance::GetPriSegTime
; Function compile flags: /Odt
;	COMDAT ?GetPriSegTime@CPerformance@@QAEJJPAJ@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_pTemp$ = -4
_mtTime$ = 8
_pmtNextSeg$ = 12
?GetPriSegTime@CPerformance@@QAEJJPAJ@Z PROC NEAR	; CPerformance::GetPriSegTime, COMDAT
; _this$ = ecx

; 7004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 7005 :     HRESULT hr = S_FALSE;

  00009	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1

; 7006 :     *pmtNextSeg = 0;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _pmtNextSeg$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 7007 :     ENTER_CRITICAL_SECTION( &m_SegmentCrSec );

  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00022	51		 push	 ecx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7008 :     CSegState* pTemp;
; 7009 :     for( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )

  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0002f	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00034	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
  00037	eb 0b		 jmp	 SHORT $L72329
$L72330:
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _pTemp$[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00041	89 45 fc	 mov	 DWORD PTR _pTemp$[ebp], eax
$L72329:
  00044	83 7d fc 00	 cmp	 DWORD PTR _pTemp$[ebp], 0
  00048	74 21		 je	 SHORT $L72331

; 7010 :     {
; 7011 :         if( pTemp->m_mtResolvedStart > mtTime )

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  0004d	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00050	3b 45 08	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00053	7e 14		 jle	 SHORT $L72332

; 7012 :         {
; 7013 :             *pmtNextSeg = pTemp->m_mtResolvedStart;

  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtNextSeg$[ebp]
  00058	8b 55 fc	 mov	 edx, DWORD PTR _pTemp$[ebp]
  0005b	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 7014 :             hr = S_OK;

  00060	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7015 :             break;

  00067	eb 02		 jmp	 SHORT $L72331
$L72332:

; 7016 :         }
; 7017 :     }

  00069	eb ce		 jmp	 SHORT $L72330
$L72331:

; 7018 :     LEAVE_CRITICAL_SECTION( &m_SegmentCrSec );

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00074	51		 push	 ecx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7019 :     return hr;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 7020 : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?GetPriSegTime@CPerformance@@QAEJJPAJ@Z ENDP		; CPerformance::GetPriSegTime
_TEXT	ENDS
PUBLIC	?GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraph
PUBLIC	??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@ ; `string'
PUBLIC	??_C@_0EE@BFAEEGCJ@Error?3?5Performance?5does?5not?5curr@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetGraph', 00H	; `CPerformance::GetGraph'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@
CONST	SEGMENT
??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@ DB '%s: Inva'
	DB	'lid pointer ppGraph', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@BFAEEGCJ@Error?3?5Performance?5does?5not?5curr@
CONST	SEGMENT
??_C@_0EE@BFAEEGCJ@Error?3?5Performance?5does?5not?5curr@ DB 'Error: Perf'
	DB	'ormance does not currently have a tool graph installed.', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_ppGraph$ = 12
?GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z PROC NEAR ; CPerformance::GetGraph, COMDAT

; 7034 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7035 :     V_INAME(IDirectMusicPerformance::GetGraph);
; 7036 :     V_PTRPTR_WRITE(ppGraph);

  00004	6a 04		 push	 4
  00006	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L72341
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@CHDJODOG@?$CFs?3?5Invalid?5pointer?5ppGraph?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L72341:

; 7037 : 
; 7038 :     HRESULT hr;
; 7039 : #ifdef DXAPI
; 7040 :     if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
; 7041 :     {
; 7042 :         Trace(0,"Error: Performance not initialized.\n");
; 7043 :         return DMUS_E_NOT_INIT;
; 7044 :     }
; 7045 : #endif
; 7046 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7047 :     if( m_pGraph )

  0003c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00043	74 26		 je	 SHORT $L72344

; 7048 :     {
; 7049 :         *ppGraph = m_pGraph;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _ppGraph$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0004e	89 10		 mov	 DWORD PTR [eax], edx

; 7050 :         m_pGraph->AddRef();

  00050	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00056	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00059	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0005c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005e	50		 push	 eax
  0005f	ff 51 04	 call	 DWORD PTR [ecx+4]

; 7051 :         hr = S_OK;

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7052 :     }
; 7053 :     else

  00069	eb 16		 jmp	 SHORT $L72346
$L72344:

; 7054 :     {
; 7055 :         Trace(1,"Error: Performance does not currently have a tool graph installed.\n");

  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EE@BFAEEGCJ@Error?3?5Performance?5does?5not?5curr@
  00070	6a 01		 push	 1
  00072	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00077	83 c4 08	 add	 esp, 8

; 7056 :         hr = DMUS_E_NOT_FOUND;

  0007a	c7 45 fc 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
$L72346:

; 7057 :     }
; 7058 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00081	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00084	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  0008a	52		 push	 edx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7059 :     return hr;

  00091	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7060 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
?GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z ENDP ; CPerformance::GetGraph
_TEXT	ENDS
PUBLIC	?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraphInternal
EXTRN	??0CGraph@@QAE@XZ:NEAR				; CGraph::CGraph
; Function compile flags: /Odt
;	COMDAT ?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
tv74 = -12
_this$ = -8
$T75608 = -4
_ppGraph$ = 8
?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z PROC NEAR ; CPerformance::GetGraphInternal, COMDAT
; _this$ = ecx

; 7065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 7066 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7067 :     if( !m_pGraph )

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0001f	75 33		 jne	 SHORT $L72356

; 7068 :     {
; 7069 :         m_pGraph = new CGraph;

  00021	68 70 03 00 00	 push	 880			; 00000370H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 fc	 mov	 DWORD PTR $T75608[ebp], eax
  00031	83 7d fc 00	 cmp	 DWORD PTR $T75608[ebp], 0
  00035	74 0d		 je	 SHORT $L75609
  00037	8b 4d fc	 mov	 ecx, DWORD PTR $T75608[ebp]
  0003a	e8 00 00 00 00	 call	 ??0CGraph@@QAE@XZ	; CGraph::CGraph
  0003f	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00042	eb 07		 jmp	 SHORT $L75610
$L75609:
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L75610:
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv74[ebp]
  00051	89 42 34	 mov	 DWORD PTR [edx+52], eax
$L72356:

; 7070 :     }
; 7071 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  0005d	51		 push	 ecx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7072 :     return GetGraph(ppGraph);

  00064	8b 55 08	 mov	 edx, DWORD PTR _ppGraph$[ebp]
  00067	52		 push	 edx
  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?GetGraph@CPerformance@@QAGJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraph

; 7073 : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z ENDP ; CPerformance::GetGraphInternal
_TEXT	ENDS
PUBLIC	??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::SetGraph', 00H	; `CPerformance::SetGraph'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
CONST	SEGMENT
??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@ DB '%s: Inval'
	DB	'id pointer pGraph', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
_this$ = 8
_pGraph$ = 12
?SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z PROC NEAR ; CPerformance::SetGraph, COMDAT

; 7087 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7088 :     V_INAME(IDirectMusicPerformance::SetGraph);
; 7089 :     V_INTERFACE_OPT(pGraph);

  00003	83 7d 0c 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  00007	74 7c		 je	 SHORT $L72365
  00009	6a 04		 push	 4
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $L72367
  00018	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z@4QBDB
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
  00022	6a ff		 push	 -1
  00024	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	e8 00 00 00 00	 call	 _DebugBreak@0
$L72367:
  00031	6a 04		 push	 4
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003e	85 c0		 test	 eax, eax
  00040	74 19		 je	 SHORT $L72371
  00042	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z@4QBDB
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
  0004c	6a ff		 push	 -1
  0004e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	e8 00 00 00 00	 call	 _DebugBreak@0
$L72371:
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00068	85 c0		 test	 eax, eax
  0006a	74 19		 je	 SHORT $L72365
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z@4QBDB
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIBPIOOI@?$CFs?3?5Invalid?5pointer?5pGraph?6?$AA@
  00076	6a ff		 push	 -1
  00078	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	e8 00 00 00 00	 call	 _DebugBreak@0
$L72365:

; 7090 : 
; 7091 : #ifdef DXAPI
; 7092 :     if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
; 7093 :     {
; 7094 :         Trace(0,"Error: Performance not initialized.\n");
; 7095 :         return DMUS_E_NOT_INIT;
; 7096 :     }
; 7097 : #endif
; 7098 : 
; 7099 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00085	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00088	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7100 :     if( m_pGraph )

  00094	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0009b	74 12		 je	 SHORT $L72374

; 7101 :     {
; 7102 :         m_pGraph->Release();

  0009d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000a9	8b 00		 mov	 eax, DWORD PTR [eax]
  000ab	52		 push	 edx
  000ac	ff 50 08	 call	 DWORD PTR [eax+8]
$L72374:

; 7103 :     }
; 7104 :     m_pGraph = pGraph;

  000af	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	8b 55 0c	 mov	 edx, DWORD PTR _pGraph$[ebp]
  000b5	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 7105 :     if( pGraph )

  000b8	83 7d 0c 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  000bc	74 0c		 je	 SHORT $L72375

; 7106 :     {
; 7107 :         pGraph->AddRef();

  000be	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 55 0c	 mov	 edx, DWORD PTR _pGraph$[ebp]
  000c6	52		 push	 edx
  000c7	ff 51 04	 call	 DWORD PTR [ecx+4]
$L72375:

; 7108 :     }
; 7109 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000ca	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7110 :     return S_OK;

  000d9	33 c0		 xor	 eax, eax

; 7111 : }

  000db	5d		 pop	 ebp
  000dc	c2 08 00	 ret	 8
?SetGraph@CPerformance@@QAGJPAUIDirectMusicGraph@@@Z ENDP ; CPerformance::SetGraph
_TEXT	ENDS
PUBLIC	?SetNotificationHandle@CPerformance@@QAGJPAX_J@Z ; CPerformance::SetNotificationHandle
; Function compile flags: /Odt
;	COMDAT ?SetNotificationHandle@CPerformance@@QAGJPAX_J@Z
_TEXT	SEGMENT
_this$ = 8
_hNotification$ = 12
_rtMinimum$ = 16
?SetNotificationHandle@CPerformance@@QAGJPAX_J@Z PROC NEAR ; CPerformance::SetNotificationHandle, COMDAT

; 7123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7124 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7125 :     m_hNotification = hNotification;

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 55 0c	 mov	 edx, DWORD PTR _hNotification$[ebp]
  00018	89 91 f0 00 00
	00		 mov	 DWORD PTR [ecx+240], edx

; 7126 :     if( rtMinimum )

  0001e	8b 45 10	 mov	 eax, DWORD PTR _rtMinimum$[ebp]
  00021	0b 45 14	 or	 eax, DWORD PTR _rtMinimum$[ebp+4]
  00024	85 c0		 test	 eax, eax
  00026	74 15		 je	 SHORT $L72382

; 7127 :     {
; 7128 :         m_rtNotificationDiscard = rtMinimum;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 55 10	 mov	 edx, DWORD PTR _rtMinimum$[ebp]
  0002e	89 91 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], edx
  00034	8b 45 14	 mov	 eax, DWORD PTR _rtMinimum$[ebp+4]
  00037	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax
$L72382:

; 7129 :     }
; 7130 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7131 :     return S_OK;

  0004d	33 c0		 xor	 eax, eax

; 7132 : }

  0004f	5d		 pop	 ebp
  00050	c2 10 00	 ret	 16			; 00000010H
?SetNotificationHandle@CPerformance@@QAGJPAX_J@Z ENDP	; CPerformance::SetNotificationHandle
_TEXT	ENDS
PUBLIC	??_C@_0CI@DIPCKGIK@?$CFs?3?5Invalid?5pointer?5ppNotificati@ ; `string'
PUBLIC	??_C@_05ICFJNKJO@pPriv?$AA@			; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetNotificationPMsg', 00H ; `CPerformance::GetNotificationPMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CI@DIPCKGIK@?$CFs?3?5Invalid?5pointer?5ppNotificati@
CONST	SEGMENT
??_C@_0CI@DIPCKGIK@?$CFs?3?5Invalid?5pointer?5ppNotificati@ DB '%s: Inval'
	DB	'id pointer ppNotificationPMsg', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ICFJNKJO@pPriv?$AA@
CONST	SEGMENT
??_C@_05ICFJNKJO@pPriv?$AA@ DB 'pPriv', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z
_TEXT	SEGMENT
_pPriv$72395 = -8
_hr$ = -4
_this$ = 8
_ppNotificationPMsg$ = 12
?GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z PROC NEAR ; CPerformance::GetNotificationPMsg, COMDAT

; 7137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7138 :     V_INAME(IDirectMusicPerformance::GetNotificationPMsg);
; 7139 :     V_PTRPTR_WRITE(ppNotificationPMsg);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _ppNotificationPMsg$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72391
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@DIPCKGIK@?$CFs?3?5Invalid?5pointer?5ppNotificati@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72391:

; 7140 : 
; 7141 :     HRESULT hr;
; 7142 :     ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7143 :     ENTER_API_CRITICAL_SECTION;
; 7144 :     if( m_NotificationQueue.GetHead() )

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00047	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  0004c	85 c0		 test	 eax, eax
  0004e	74 42		 je	 SHORT $L72394

; 7145 :     {
; 7146 :         PRIV_PMSG* pPriv = m_NotificationQueue.Dequeue();

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00059	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  0005e	89 45 f8	 mov	 DWORD PTR _pPriv$72395[ebp], eax

; 7147 :         ASSERT(pPriv);

  00061	83 7d f8 00	 cmp	 DWORD PTR _pPriv$72395[ebp], 0
  00065	75 17		 jne	 SHORT $L72396
  00067	6a 00		 push	 0
  00069	68 eb 1b 00 00	 push	 7147			; 00001bebH
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05ICFJNKJO@pPriv?$AA@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L72396:

; 7148 :         *ppNotificationPMsg = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPriv);

  0007e	8b 55 f8	 mov	 edx, DWORD PTR _pPriv$72395[ebp]
  00081	83 c2 18	 add	 edx, 24			; 00000018H
  00084	8b 45 0c	 mov	 eax, DWORD PTR _ppNotificationPMsg$[ebp]
  00087	89 10		 mov	 DWORD PTR [eax], edx

; 7149 :         hr = S_OK;

  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7150 :     }
; 7151 :     else

  00090	eb 10		 jmp	 SHORT $L72402
$L72394:

; 7152 :     {
; 7153 :         *ppNotificationPMsg = NULL;

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _ppNotificationPMsg$[ebp]
  00095	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 7154 :         hr = S_FALSE;

  0009b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L72402:

; 7155 :     }
; 7156 :     LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  000a2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  000ab	52		 push	 edx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7157 :     LEAVE_API_CRITICAL_SECTION;
; 7158 :     return hr;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7159 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
?GetNotificationPMsg@CPerformance@@UAGJPAPAU_DMUS_NOTIFICATION_PMSG@@@Z ENDP ; CPerformance::GetNotificationPMsg
_TEXT	ENDS
PUBLIC	?AddNotificationTypeToAllSegments@CPerformance@@AAEXABU_GUID@@@Z ; CPerformance::AddNotificationTypeToAllSegments
; Function compile flags: /Odt
;	COMDAT ?AddNotificationTypeToAllSegments@CPerformance@@AAEXABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -12
_pSegSt$ = -8
_dwCount$ = -4
_rguidNotification$ = 8
?AddNotificationTypeToAllSegments@CPerformance@@AAEXABU_GUID@@@Z PROC NEAR ; CPerformance::AddNotificationTypeToAllSegments, COMDAT
; _this$ = ecx

; 7162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 7163 :     CSegState* pSegSt;
; 7164 :     DWORD dwCount;
; 7165 :     // Note: might be nice to optimize this so the same segment
; 7166 :     // doesn't get called multiple times
; 7167 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7168 :     for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  0001f	eb 09		 jmp	 SHORT $L72410
$L72411:
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	89 4d fc	 mov	 DWORD PTR _dwCount$[ebp], ecx
$L72410:
  0002a	83 7d fc 09	 cmp	 DWORD PTR _dwCount$[ebp], 9
  0002e	73 3a		 jae	 SHORT $L72412

; 7169 :     {
; 7170 :         for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )

  00030	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00033	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  0003a	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0003f	89 45 f8	 mov	 DWORD PTR _pSegSt$[ebp], eax
  00042	eb 0b		 jmp	 SHORT $L72413
$L72414:
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00047	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0004c	89 45 f8	 mov	 DWORD PTR _pSegSt$[ebp], eax
$L72413:
  0004f	83 7d f8 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  00053	74 13		 je	 SHORT $L72415

; 7171 :         {
; 7172 :             pSegSt->m_pSegment->AddNotificationType( rguidNotification, TRUE );

  00055	6a 01		 push	 1
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  0005e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00061	e8 00 00 00 00	 call	 ?AddNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::AddNotificationType

; 7173 :         }

  00066	eb dc		 jmp	 SHORT $L72414
$L72415:

; 7174 :     }

  00068	eb b7		 jmp	 SHORT $L72411
$L72412:

; 7175 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7176 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
?AddNotificationTypeToAllSegments@CPerformance@@AAEXABU_GUID@@@Z ENDP ; CPerformance::AddNotificationTypeToAllSegments
_TEXT	ENDS
PUBLIC	?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z ; CPerformance::RemoveNotificationTypeFromAllSegments
; Function compile flags: /Odt
;	COMDAT ?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -12
_pSegSt$ = -8
_dwCount$ = -4
_rguidNotification$ = 8
?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z PROC NEAR ; CPerformance::RemoveNotificationTypeFromAllSegments, COMDAT
; _this$ = ecx

; 7179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 7180 :     CSegState* pSegSt;
; 7181 :     DWORD dwCount;
; 7182 :     // Note: might be nice to optimize this so the same segment
; 7183 :     // doesn't get called multiple times
; 7184 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7185 :     for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
  0001f	eb 09		 jmp	 SHORT $L72422
$L72423:
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	89 4d fc	 mov	 DWORD PTR _dwCount$[ebp], ecx
$L72422:
  0002a	83 7d fc 09	 cmp	 DWORD PTR _dwCount$[ebp], 9
  0002e	73 3a		 jae	 SHORT $L72424

; 7186 :     {
; 7187 :         for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )

  00030	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00033	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  0003a	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0003f	89 45 f8	 mov	 DWORD PTR _pSegSt$[ebp], eax
  00042	eb 0b		 jmp	 SHORT $L72425
$L72426:
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00047	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0004c	89 45 f8	 mov	 DWORD PTR _pSegSt$[ebp], eax
$L72425:
  0004f	83 7d f8 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  00053	74 13		 je	 SHORT $L72427

; 7188 :         {
; 7189 :             pSegSt->m_pSegment->RemoveNotificationType( rguidNotification, TRUE );

  00055	6a 01		 push	 1
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  0005e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00061	e8 00 00 00 00	 call	 ?RemoveNotificationType@CSegment@@QAEJABU_GUID@@H@Z ; CSegment::RemoveNotificationType

; 7190 :         }

  00066	eb dc		 jmp	 SHORT $L72426
$L72427:

; 7191 :     }

  00068	eb b7		 jmp	 SHORT $L72423
$L72424:

; 7192 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7193 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z ENDP ; CPerformance::RemoveNotificationTypeFromAllSegments
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -8
_pItem$ = -4
_rguidNotification$ = 8
?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z PROC NEAR ; CPerformance::FindNotification, COMDAT
; _this$ = ecx

; 7199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 7200 :     CNotificationItem* pItem;
; 7201 : 
; 7202 :     pItem = m_NotificationList.GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00012	e8 00 00 00 00	 call	 ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::GetHead
  00017	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
$L72434:

; 7203 :     while(pItem)

  0001a	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0001e	74 23		 je	 SHORT $L72435

; 7204 :     {
; 7205 :         if( rguidNotification == pItem->guidNotificationType )

  00020	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _==@8
  00030	85 c0		 test	 eax, eax
  00032	74 02		 je	 SHORT $L72436

; 7206 :         {
; 7207 :             break;

  00034	eb 0d		 jmp	 SHORT $L72435
$L72436:

; 7208 :         }
; 7209 :         pItem = pItem->GetNext();

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00039	e8 00 00 00 00	 call	 ?GetNext@CNotificationItem@@QAEPAV1@XZ ; CNotificationItem::GetNext
  0003e	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax

; 7210 :     }

  00041	eb d7		 jmp	 SHORT $L72434
$L72435:

; 7211 :     return pItem;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]

; 7212 : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z ENDP ; CPerformance::FindNotification
_TEXT	ENDS
PUBLIC	??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ ; `string'
PUBLIC	??0CNotificationItem@@QAE@XZ			; CNotificationItem::CNotificationItem
PUBLIC	?Cat@AList@@QAEXPAVAListItem@@@Z		; AList::Cat
;	COMDAT ?__szValidateInterfaceName@?1??AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::AddNotificationType', 00H ; `CPerformance::AddNotificationType'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT
??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ DB '%'
	DB	's: Invalid pointer (void*)&rguidNotification', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
tv82 = -16
$T75632 = -12
_hr$ = -8
_pItem$ = -4
_this$ = 8
_rguidNotification$ = 12
?AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z PROC NEAR ; CPerformance::AddNotificationType, COMDAT

; 7231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 7232 :     V_INAME(IDirectMusicPerformance::AddNotificationType);
; 7233 :     V_REFGUID(rguidNotification);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72445
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72445:

; 7234 : 
; 7235 :     CNotificationItem*  pItem;
; 7236 :     HRESULT hr = S_OK;

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7237 : 
; 7238 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  0003e	51		 push	 ecx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7239 :     ENTER_API_CRITICAL_SECTION;
; 7240 :     if( NULL == FindNotification( rguidNotification ) )

  00045	8b 55 0c	 mov	 edx, DWORD PTR _rguidNotification$[ebp]
  00048	52		 push	 edx
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z ; CPerformance::FindNotification
  00051	85 c0		 test	 eax, eax
  00053	75 7b		 jne	 SHORT $L72450

; 7241 :     {
; 7242 :         pItem = new CNotificationItem;

  00055	6a 18		 push	 24			; 00000018H
  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 45 f4	 mov	 DWORD PTR $T75632[ebp], eax
  00062	83 7d f4 00	 cmp	 DWORD PTR $T75632[ebp], 0
  00066	74 0d		 je	 SHORT $L75633
  00068	8b 4d f4	 mov	 ecx, DWORD PTR $T75632[ebp]
  0006b	e8 00 00 00 00	 call	 ??0CNotificationItem@@QAE@XZ
  00070	89 45 f0	 mov	 DWORD PTR tv82[ebp], eax
  00073	eb 07		 jmp	 SHORT $L75634
$L75633:
  00075	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$L75634:
  0007c	8b 45 f0	 mov	 eax, DWORD PTR tv82[ebp]
  0007f	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax

; 7243 :         if( NULL == pItem )

  00082	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00086	75 09		 jne	 SHORT $L72453

; 7244 :         {
; 7245 :             hr = E_OUTOFMEMORY;

  00088	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 7246 :         }
; 7247 :         else

  0008f	eb 3d		 jmp	 SHORT $L72455
$L72453:

; 7248 :         {
; 7249 :             pItem->guidNotificationType = rguidNotification;

  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  00094	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  00097	83 c2 04	 add	 edx, 4
  0009a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009c	89 02		 mov	 DWORD PTR [edx], eax
  0009e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a1	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000a7	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000aa	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000ad	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 7250 :             m_NotificationList.Cat( pItem );

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  000b3	52		 push	 edx
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  000bd	e8 00 00 00 00	 call	 ?Cat@AList@@QAEXPAVAListItem@@@Z ; AList::Cat

; 7251 :             AddNotificationTypeToAllSegments( rguidNotification );

  000c2	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?AddNotificationTypeToAllSegments@CPerformance@@AAEXABU_GUID@@@Z ; CPerformance::AddNotificationTypeToAllSegments
$L72455:

; 7252 :         }
; 7253 :     }
; 7254 :     else

  000ce	eb 07		 jmp	 SHORT $L72456
$L72450:

; 7255 :     {
; 7256 :         hr = S_FALSE;

  000d0	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L72456:

; 7257 :     }
; 7258 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  000e0	51		 push	 ecx
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7259 :     LEAVE_API_CRITICAL_SECTION;
; 7260 :     return hr;

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 7261 : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 08 00	 ret	 8
?AddNotificationType@CPerformance@@UAGJABU_GUID@@@Z ENDP ; CPerformance::AddNotificationType
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CNotificationItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CNotificationItem@@QAE@XZ PROC NEAR			; CNotificationItem::CNotificationItem, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CNotificationItem@@QAE@XZ ENDP			; CNotificationItem::CNotificationItem
_TEXT	ENDS
PUBLIC	??_C@_0FJ@PAEGHHCI@Warning?3?5Unable?5to?5remove?5reques@ ; `string'
PUBLIC	?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::RemoveHead
;	COMDAT ?__szValidateInterfaceName@?1??RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::RemoveNotificationType', 00H ; `CPerformance::RemoveNotificationType'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0FJ@PAEGHHCI@Warning?3?5Unable?5to?5remove?5reques@
CONST	SEGMENT
??_C@_0FJ@PAEGHHCI@Warning?3?5Unable?5to?5remove?5reques@ DB 'Warning: Un'
	DB	'able to remove requested notification because it is not curre'
	DB	'ntly installed.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
$T75642 = -16
$T75641 = -12
_hr$ = -8
_pItem$ = -4
_this$ = 8
_rguidNotification$ = 12
?RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z PROC NEAR ; CPerformance::RemoveNotificationType, COMDAT

; 7277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 7278 :     V_INAME(IDirectMusicPerformance::RemoveNotificationType);
; 7279 :     V_REFGUID(rguidNotification);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidNotification$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L72468
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@NOENDGNM@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L72468:

; 7280 : 
; 7281 :     HRESULT hr = S_OK;

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7282 :     CNotificationItem* pItem;
; 7283 :     ENTER_API_CRITICAL_SECTION;
; 7284 :     if( GUID_NULL == rguidNotification )

  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidNotification$[ebp]
  00038	51		 push	 ecx
  00039	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  0003e	e8 00 00 00 00	 call	 _==@8
  00043	85 c0		 test	 eax, eax
  00045	74 3c		 je	 SHORT $L72472
$L72474:

; 7285 :     {
; 7286 :         while (pItem = m_NotificationList.RemoveHead())

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00050	e8 00 00 00 00	 call	 ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ; CNotificationList::RemoveHead
  00055	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
  00058	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0005c	74 23		 je	 SHORT $L72475

; 7287 :         {
; 7288 :             RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  00061	83 c2 04	 add	 edx, 4
  00064	52		 push	 edx
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z ; CPerformance::RemoveNotificationTypeFromAllSegments

; 7289 :             delete pItem;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00070	89 45 f4	 mov	 DWORD PTR $T75641[ebp], eax
  00073	8b 4d f4	 mov	 ecx, DWORD PTR $T75641[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007c	83 c4 04	 add	 esp, 4

; 7290 :         }

  0007f	eb c6		 jmp	 SHORT $L72474
$L72475:

; 7291 :     }
; 7292 :     else

  00081	eb 60		 jmp	 SHORT $L72477
$L72472:

; 7293 :     {
; 7294 :         if( pItem = FindNotification( rguidNotification ))

  00083	8b 55 0c	 mov	 edx, DWORD PTR _rguidNotification$[ebp]
  00086	52		 push	 edx
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?FindNotification@CPerformance@@AAEPAVCNotificationItem@@ABU_GUID@@@Z ; CPerformance::FindNotification
  0008f	89 45 fc	 mov	 DWORD PTR _pItem$[ebp], eax
  00092	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00096	74 35		 je	 SHORT $L72478

; 7295 :         {
; 7296 :             RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );

  00098	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	50		 push	 eax
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?RemoveNotificationTypeFromAllSegments@CPerformance@@AAEXABU_GUID@@@Z ; CPerformance::RemoveNotificationTypeFromAllSegments

; 7297 :             m_NotificationList.Remove( pItem );

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  000b4	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove

; 7298 :             delete pItem;

  000b9	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  000bc	89 55 f0	 mov	 DWORD PTR $T75642[ebp], edx
  000bf	8b 45 f0	 mov	 eax, DWORD PTR $T75642[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c8	83 c4 04	 add	 esp, 4

; 7299 :         }
; 7300 :         else

  000cb	eb 16		 jmp	 SHORT $L72477
$L72478:

; 7301 :         {
; 7302 :             Trace(2,"Warning: Unable to remove requested notification because it is not currently installed.\n");

  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FJ@PAEGHHCI@Warning?3?5Unable?5to?5remove?5reques@
  000d2	6a 02		 push	 2
  000d4	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000d9	83 c4 08	 add	 esp, 8

; 7303 :             hr = S_FALSE;

  000dc	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L72477:

; 7304 :         }
; 7305 :     }
; 7306 :     LEAVE_API_CRITICAL_SECTION;
; 7307 :     return hr;

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 7308 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
?RemoveNotificationType@CPerformance@@UAGJABU_GUID@@@Z ENDP ; CPerformance::RemoveNotificationType
_TEXT	ENDS
PUBLIC	?RemoveUnusedPorts@CPerformance@@QAEXXZ		; CPerformance::RemoveUnusedPorts
; Function compile flags: /Odt
;	COMDAT ?RemoveUnusedPorts@CPerformance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RemoveUnusedPorts@CPerformance@@QAEXXZ PROC NEAR	; CPerformance::RemoveUnusedPorts, COMDAT
; _this$ = ecx

; 7313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7314 : #ifdef DXAPI
; 7315 :     DWORD dwIndex;
; 7316 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7317 :     for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 7318 :     {
; 7319 :         if( m_pPortTable[dwIndex].pPort && !m_AudioPathList.UsesPort(m_pPortTable[dwIndex].pPort))
; 7320 :         {
; 7321 :             // release the port and buffer. NULL them in the table. PChannels
; 7322 :             // that map will return an error code.
; 7323 :             ASSERT( m_pPortTable[dwIndex].pBuffer );
; 7324 :             m_pPortTable[dwIndex].pPort->Release();
; 7325 :             m_pPortTable[dwIndex].pBuffer->Release();
; 7326 :             if( m_pPortTable[dwIndex].pLatencyClock )
; 7327 :             {
; 7328 :                 m_pPortTable[dwIndex].pLatencyClock->Release();
; 7329 :             }
; 7330 :             memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
; 7331 :             CChannelBlock *pBlock = m_ChannelBlockList.GetHead();
; 7332 :             CChannelBlock *pNext;
; 7333 :             for(;pBlock;pBlock = pNext)
; 7334 :             {
; 7335 :                 pNext = pBlock->GetNext();
; 7336 :                 if (pBlock->m_dwPortIndex == dwIndex)
; 7337 :                 {
; 7338 :                     m_ChannelBlockList.Remove(pBlock);
; 7339 :                     delete pBlock;
; 7340 :                 }
; 7341 :             }
; 7342 :         }
; 7343 :     }
; 7344 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7345 : #endif
; 7346 : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?RemoveUnusedPorts@CPerformance@@QAEXXZ ENDP		; CPerformance::RemoveUnusedPorts
_TEXT	ENDS
PUBLIC	?AddPort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z ; CPerformance::AddPort
; Function compile flags: /Odt
;	COMDAT ?AddPort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT
_this$ = 8
_pPort$ = 12
?AddPort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z PROC NEAR ; CPerformance::AddPort, COMDAT

; 7454 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7455 : #ifdef XBOX
; 7456 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 7457 : #else
; 7458 :     V_INAME(IDirectMusicPerformance::AddPort);
; 7459 :     V_INTERFACE_OPT(pPort);
; 7460 :    if (m_dwAudioPathMode == 2)
; 7461 :     {
; 7462 :         Trace(0,"Error: Can not call AddPort() when using AudioPaths.\n");
; 7463 :         return DMUS_E_AUDIOPATHS_IN_USE;
; 7464 :     }
; 7465 :     m_dwAudioPathMode = 1;
; 7466 :     return AddPort(pPort,NULL,NULL,NULL);
; 7467 : #endif // !XBOX
; 7468 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?AddPort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z ENDP	; CPerformance::AddPort
_TEXT	ENDS
PUBLIC	?AddPort@CPerformance@@QAEJPAUIDirectMusicPort@@PAU_GUID@@PAU_DMUS_PORTPARAMS8@@PAK@Z ; CPerformance::AddPort
; Function compile flags: /Odt
;	COMDAT ?AddPort@CPerformance@@QAEJPAUIDirectMusicPort@@PAU_GUID@@PAU_DMUS_PORTPARAMS8@@PAK@Z
_TEXT	SEGMENT
_this$ = -8
_hr$ = -4
_pPort$ = 8
_pguidPortID$ = 12
_pParams$ = 16
_pdwPortID$ = 20
?AddPort@CPerformance@@QAEJPAUIDirectMusicPort@@PAU_GUID@@PAU_DMUS_PORTPARAMS8@@PAK@Z PROC NEAR ; CPerformance::AddPort, COMDAT
; _this$ = ecx

; 7475 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 7476 :     HRESULT hr = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7477 : #ifdef DXAPI
; 7478 :     PortTable* pPortTable;
; 7479 :     IDirectMusicBuffer* pBuffer;
; 7480 :     BOOL    fSetUpBlock = FALSE;
; 7481 :     BOOL    fBuiltNewTable = FALSE;
; 7482 :     GUID guidPortID;             // Class ID of port.
; 7483 :     DWORD dwChannelGroups;       // Number of channel groups at initialization.
; 7484 :     DWORD dwNewPortIndex = 0;    // Index into port array for new port.
; 7485 : 
; 7486 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);
; 7487 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7488 : 
; 7489 :     if( NULL == m_pDirectMusic )
; 7490 :     {
; 7491 :         Trace(0,"Error: Performance is not initialized, ports can not be added.\n");
; 7492 :         hr = DMUS_E_NOT_INIT;
; 7493 :         goto END;
; 7494 :     }
; 7495 : 
; 7496 :     for (;dwNewPortIndex < m_dwNumPorts; dwNewPortIndex++)
; 7497 :     {
; 7498 :         if (!m_pPortTable[dwNewPortIndex].pPort)
; 7499 :         {
; 7500 :             break;
; 7501 :         }
; 7502 :     }
; 7503 :     if (dwNewPortIndex == m_dwNumPorts)
; 7504 :     {
; 7505 :         pPortTable = new PortTable[m_dwNumPorts + 1];
; 7506 :         if( !pPortTable )
; 7507 :         {
; 7508 :             hr = E_OUTOFMEMORY;
; 7509 :             goto END;
; 7510 :         }
; 7511 :         fBuiltNewTable = TRUE;
; 7512 :     }
; 7513 : 
; 7514 :     // if pPort is NULL, create a software synth port
; 7515 :     DMUS_PORTPARAMS dmpp;
; 7516 :     if( NULL == pPort )
; 7517 :     {
; 7518 :         pParams = &dmpp;
; 7519 :         memset(&dmpp, 0, sizeof(DMUS_PORTPARAMS) );
; 7520 :         dmpp.dwSize = sizeof(DMUS_PORTPARAMS);
; 7521 :         dmpp.dwChannelGroups = dwChannelGroups = 1;
; 7522 :         dmpp.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS |
; 7523 :             DMUS_PORTPARAMS_AUDIOCHANNELS;
; 7524 :         dmpp.dwAudioChannels = 2;
; 7525 :         guidPortID = GUID_NULL;
; 7526 :         hr = m_pDirectMusic->CreatePort(GUID_NULL, &dmpp, &pPort, NULL);
; 7527 :         
; 7528 :         if ( SUCCEEDED( hr ) ) 
; 7529 :         {
; 7530 :             hr = pPort->Activate(TRUE);
; 7531 :         }
; 7532 : 
; 7533 : 
; 7534 :         fSetUpBlock = TRUE;
; 7535 :     }
; 7536 :     else
; 7537 :     {
; 7538 :         if (pguidPortID)
; 7539 :         {
; 7540 :             guidPortID = *pguidPortID;
; 7541 :         }
; 7542 :         else
; 7543 :         {
; 7544 :             DMUS_PORTCAPS PortCaps;
; 7545 :             PortCaps.dwSize = sizeof (PortCaps);
; 7546 :             pPort->GetCaps(&PortCaps);
; 7547 :             guidPortID = PortCaps.guidPort;
; 7548 :         }
; 7549 :         pPort->GetNumChannelGroups(&dwChannelGroups);
; 7550 :         pPort->AddRef();
; 7551 :     }
; 7552 :     if( FAILED(hr) || ( pPort == NULL ) )
; 7553 :     {
; 7554 :         if (fBuiltNewTable) delete [] pPortTable;
; 7555 :         Trace(0,"Error: Unable to open requested port.\n");
; 7556 :         hr = DMUS_E_CANNOT_OPEN_PORT;
; 7557 :         goto END;
; 7558 :     }
; 7559 : 
; 7560 :     // Create a buffer
; 7561 :     DMUS_BUFFERDESC dmbd;
; 7562 :     memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
; 7563 :     dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
; 7564 :     dmbd.cbBuffer = DEFAULT_BUFFER_SIZE;
; 7565 :     if( FAILED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
; 7566 :     {
; 7567 :         if (fBuiltNewTable) delete [] pPortTable;
; 7568 :         pPort->Release();
; 7569 :         Trace(1,"Error: Unable to create MIDI buffer for port.\n");
; 7570 :         hr = DMUS_E_CANNOT_OPEN_PORT;
; 7571 :         goto END;
; 7572 :     }
; 7573 : 
; 7574 :     if (fBuiltNewTable) 
; 7575 :     {
; 7576 :         // if there is an existing port table, copy its contents to the new, bigger, port table
; 7577 :         if( m_pPortTable )
; 7578 :         {
; 7579 :             if( m_dwNumPorts > 0 )
; 7580 :             {
; 7581 :                 memcpy( pPortTable, m_pPortTable, sizeof(PortTable) * ( m_dwNumPorts ) );
; 7582 :             }
; 7583 :             delete [] m_pPortTable;
; 7584 :         }
; 7585 :         m_pPortTable = pPortTable;
; 7586 :     }
; 7587 :     if (pdwPortID)
; 7588 :     {
; 7589 :         *pdwPortID = dwNewPortIndex;
; 7590 :     }
; 7591 :     pPortTable = &m_pPortTable[dwNewPortIndex];
; 7592 :     pPortTable->pPort = pPort;
; 7593 :     // If we have a passed params structure, copy it. This will be used for identifying the
; 7594 :     // params as initialized by the synth.
; 7595 :     if (pParams)
; 7596 :     {
; 7597 :         pPortTable->PortParams = *pParams;
; 7598 :     }
; 7599 :     pPortTable->dwGMFlags = 0;
; 7600 :     //set master volume
; 7601 :     IKsControl *pControl;
; 7602 :     if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
; 7603 :     {
; 7604 :         KSPROPERTY ksp;
; 7605 :         ULONG cb;
; 7606 : 
; 7607 :         memset(&ksp, 0, sizeof(ksp));
; 7608 :         ksp.Set   = GUID_DMUS_PROP_Volume;
; 7609 :         ksp.Id    = 0;
; 7610 :         ksp.Flags = KSPROPERTY_TYPE_SET;
; 7611 : 
; 7612 :         pControl->KsProperty(&ksp,
; 7613 :                             sizeof(ksp),
; 7614 :                             (LPVOID)&m_lMasterVolume,
; 7615 :                             sizeof(m_lMasterVolume),
; 7616 :                             &cb);
; 7617 :         // Now, find out if it has a gm, gs, or xg sets in rom...
; 7618 :         BOOL bIsSupported = FALSE;
; 7619 :         ksp.Set     = GUID_DMUS_PROP_GM_Hardware;
; 7620 :         ksp.Flags   = KSPROPERTY_TYPE_GET;
; 7621 : 
; 7622 :         hr = pControl->KsProperty(&ksp,
; 7623 :                             sizeof(ksp),
; 7624 :                             (LPVOID)&bIsSupported,
; 7625 :                             sizeof(bIsSupported),
; 7626 :                             &cb);
; 7627 :         if (SUCCEEDED(hr) && (bIsSupported))
; 7628 :         {
; 7629 :             pPortTable->dwGMFlags |= DM_PORTFLAGS_GM;
; 7630 :         }
; 7631 :         bIsSupported = FALSE;
; 7632 :         ksp.Set     = GUID_DMUS_PROP_GS_Hardware;
; 7633 :         ksp.Flags   = KSPROPERTY_TYPE_GET;
; 7634 : 
; 7635 :         hr = pControl->KsProperty(&ksp,
; 7636 :                             sizeof(ksp),
; 7637 :                             (LPVOID)&bIsSupported,
; 7638 :                             sizeof(bIsSupported),
; 7639 :                             &cb);
; 7640 :         if (SUCCEEDED(hr) && (bIsSupported))
; 7641 :         {
; 7642 :             pPortTable->dwGMFlags |= DM_PORTFLAGS_GS;
; 7643 :         }
; 7644 :         bIsSupported = FALSE;
; 7645 :         ksp.Set     = GUID_DMUS_PROP_XG_Hardware;
; 7646 :         ksp.Flags   = KSPROPERTY_TYPE_GET;
; 7647 : 
; 7648 :         hr = pControl->KsProperty(&ksp,
; 7649 :                             sizeof(ksp),
; 7650 :                             (LPVOID)&bIsSupported,
; 7651 :                             sizeof(bIsSupported),
; 7652 :                             &cb);
; 7653 :         if (SUCCEEDED(hr) && (bIsSupported))
; 7654 :         {
; 7655 :             pPortTable->dwGMFlags |= DM_PORTFLAGS_XG;
; 7656 :         }
; 7657 :         pControl->Release();
; 7658 :     }
; 7659 : 
; 7660 :     if( FAILED( pPort->GetLatencyClock( &pPortTable->pLatencyClock )))
; 7661 :     {
; 7662 :         pPortTable->pLatencyClock = NULL;
; 7663 :     }
; 7664 :     pPortTable->dwChannelGroups = dwChannelGroups;
; 7665 :     pPortTable->guidPortID = guidPortID;
; 7666 :     pPortTable->pBuffer = pBuffer;
; 7667 :     pPortTable->fBufferFilled = FALSE;
; 7668 :     pPortTable->rtLast = 0;
; 7669 :     if (fBuiltNewTable) m_dwNumPorts++; // must do this before calling AssignPChannelBlock
; 7670 :     if( fSetUpBlock && m_ChannelBlockList.IsEmpty() ) // set up default PChannel map if none already set
; 7671 :     {
; 7672 :         AssignPChannelBlock( 0, pPort, 1);
; 7673 :     }
; 7674 :     hr = S_OK;
; 7675 : END:
; 7676 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7677 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 7678 : #endif
; 7679 :     return hr;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7680 : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 10 00	 ret	 16			; 00000010H
?AddPort@CPerformance@@QAEJPAUIDirectMusicPort@@PAU_GUID@@PAU_DMUS_PORTPARAMS8@@PAK@Z ENDP ; CPerformance::AddPort
_TEXT	ENDS
PUBLIC	?RemovePort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z ; CPerformance::RemovePort
; Function compile flags: /Odt
;	COMDAT ?RemovePort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_pPort$ = 12
?RemovePort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z PROC NEAR ; CPerformance::RemovePort, COMDAT

; 7685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7686 :     HRESULT hr = E_INVALIDARG;

  00004	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 7687 : #ifdef DXAPI
; 7688 :     V_INAME(IDirectMusicPerformance::RemovePort);
; 7689 :     V_INTERFACE(pPort);
; 7690 : 
; 7691 :     DWORD dwIndex;
; 7692 : 
; 7693 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7694 :     for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 7695 :     {
; 7696 :         if( m_pPortTable[dwIndex].pPort == pPort )
; 7697 :         {
; 7698 :             // release the port and buffer. NULL them in the table. PChannels
; 7699 :             // that map will return an error code.
; 7700 :             ASSERT( m_pPortTable[dwIndex].pBuffer );
; 7701 :             m_pPortTable[dwIndex].pPort->Release();
; 7702 :             m_pPortTable[dwIndex].pBuffer->Release();
; 7703 :             if( m_pPortTable[dwIndex].pLatencyClock )
; 7704 :             {
; 7705 :                 m_pPortTable[dwIndex].pLatencyClock->Release();
; 7706 :             }
; 7707 :             memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
; 7708 :             hr = S_OK;
; 7709 :             break;
; 7710 :         }
; 7711 :     }
; 7712 : #ifdef DBG
; 7713 :     if (hr == E_INVALIDARG)
; 7714 :     {
; 7715 :         Trace(0,"Error: Invalid port passed to RemovePort().\n");
; 7716 :     }
; 7717 : #endif
; 7718 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7719 : #endif
; 7720 :     return hr;

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7721 : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?RemovePort@CPerformance@@QAGJPAUIDirectMusicPort@@@Z ENDP ; CPerformance::RemovePort
_TEXT	ENDS
PUBLIC	??0CChannelBlock@@QAE@XZ			; CChannelBlock::CChannelBlock
PUBLIC	?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ; CChannelBlockList::AddHead
PUBLIC	?AssignPChannelBlock@CPerformance@@AAEJKKKG@Z	; CPerformance::AssignPChannelBlock
; Function compile flags: /Odt
;	COMDAT ?AssignPChannelBlock@CPerformance@@AAEJKKKG@Z
_TEXT	SEGMENT
tv84 = -20
_this$ = -16
$T75658 = -12
_pChannelBlock$ = -8
_dwPChannel$ = -4
_dwBlockNum$ = 8
_dwPortIndex$ = 12
_dwGroup$ = 16
_wFlags$ = 20
?AssignPChannelBlock@CPerformance@@AAEJKKKG@Z PROC NEAR	; CPerformance::AssignPChannelBlock, COMDAT
; _this$ = ecx

; 7729 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 7730 :     // see if we've already allocated this block before
; 7731 :     // blocknum is PChannel / 16, so search on that.
; 7732 :     DWORD dwPChannel = dwBlockNum * 16;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwBlockNum$[ebp]
  0000c	c1 e0 04	 shl	 eax, 4
  0000f	89 45 fc	 mov	 DWORD PTR _dwPChannel$[ebp], eax

; 7733 :     CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

  00012	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00018	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  0001d	89 45 f8	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 7734 : 
; 7735 :     for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  00020	eb 0b		 jmp	 SHORT $L72515
$L72516:
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00025	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  0002a	89 45 f8	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72515:
  0002d	83 7d f8 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00031	74 28		 je	 SHORT $L72517

; 7736 :     {
; 7737 :         if( pChannelBlock->m_dwPChannelStart == dwPChannel )

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	3b 55 fc	 cmp	 edx, DWORD PTR _dwPChannel$[ebp]
  0003c	75 1b		 jne	 SHORT $L72518

; 7738 :         {
; 7739 :             pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);

  0003e	66 8b 45 14	 mov	 ax, WORD PTR _wFlags$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _dwGroup$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 0c	 mov	 edx, DWORD PTR _dwPortIndex$[ebp]
  0004a	52		 push	 edx
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _dwPChannel$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00052	e8 00 00 00 00	 call	 ?Init@CChannelBlock@@QAEXKKKG@Z ; CChannelBlock::Init

; 7740 :             break;

  00057	eb 02		 jmp	 SHORT $L72517
$L72518:

; 7741 :         }
; 7742 :     }

  00059	eb c7		 jmp	 SHORT $L72516
$L72517:

; 7743 :     if( !pChannelBlock )

  0005b	83 7d f8 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  0005f	75 6e		 jne	 SHORT $L72519

; 7744 :     {
; 7745 :         pChannelBlock = new CChannelBlock;

  00061	68 10 08 00 00	 push	 2064			; 00000810H
  00066	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 f4	 mov	 DWORD PTR $T75658[ebp], eax
  00071	83 7d f4 00	 cmp	 DWORD PTR $T75658[ebp], 0
  00075	74 0d		 je	 SHORT $L75659
  00077	8b 4d f4	 mov	 ecx, DWORD PTR $T75658[ebp]
  0007a	e8 00 00 00 00	 call	 ??0CChannelBlock@@QAE@XZ
  0007f	89 45 ec	 mov	 DWORD PTR tv84[ebp], eax
  00082	eb 07		 jmp	 SHORT $L75660
$L75659:
  00084	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$L75660:
  0008b	8b 4d ec	 mov	 ecx, DWORD PTR tv84[ebp]
  0008e	89 4d f8	 mov	 DWORD PTR _pChannelBlock$[ebp], ecx

; 7746 :         if( !pChannelBlock )

  00091	83 7d f8 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00095	75 07		 jne	 SHORT $L72522

; 7747 :         {
; 7748 :             return E_OUTOFMEMORY;

  00097	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0009c	eb 33		 jmp	 SHORT $L72512
$L72522:

; 7749 :         }
; 7750 :         pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);

  0009e	66 8b 55 14	 mov	 dx, WORD PTR _wFlags$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 10	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPortIndex$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  000ae	52		 push	 edx
  000af	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000b2	e8 00 00 00 00	 call	 ?Init@CChannelBlock@@QAEXKKKG@Z ; CChannelBlock::Init

; 7751 :         m_ChannelBlockList.AddHead(pChannelBlock);

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	83 c1 3c	 add	 ecx, 60			; 0000003cH
  000c1	e8 00 00 00 00	 call	 ?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ; CChannelBlockList::AddHead

; 7752 :         pChannelBlock->m_dwPChannelStart = dwPChannel;

  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  000cc	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L72519:

; 7753 :     }
; 7754 :     return S_OK;

  000cf	33 c0		 xor	 eax, eax
$L72512:

; 7755 : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 10 00	 ret	 16			; 00000010H
?AssignPChannelBlock@CPerformance@@AAEJKKKG@Z ENDP	; CPerformance::AssignPChannelBlock
_TEXT	ENDS
PUBLIC	??0CChannelMap@@QAE@XZ				; CChannelMap::CChannelMap
; Function compile flags: /Odt
;	COMDAT ??0CChannelBlock@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CChannelBlock@@QAE@XZ PROC NEAR			; CChannelBlock::CChannelBlock, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  0000f	68 00 00 00 00	 push	 OFFSET FLAT:??0CChannelMap@@QAE@XZ
  00014	6a 10		 push	 16			; 00000010H
  00016	68 80 00 00 00	 push	 128			; 00000080H
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 08	 add	 eax, 8
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??0CChannelBlock@@QAE@XZ ENDP				; CChannelBlock::CChannelBlock
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CChannelMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CChannelMap@@QAE@XZ PROC NEAR			; CChannelMap::CChannelMap, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00015	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 18	 add	 ecx, 24			; 00000018H
  00020	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 24	 add	 ecx, 36			; 00000024H
  0002b	e8 00 00 00 00	 call	 ??0CPitchMerger@@QAE@XZ	; CPitchMerger::CPitchMerger
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 34	 add	 ecx, 52			; 00000034H
  00036	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 40	 add	 ecx, 64			; 00000040H
  00041	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0004c	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 58	 add	 ecx, 88			; 00000058H
  00057	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 64	 add	 ecx, 100		; 00000064H
  00062	e8 00 00 00 00	 call	 ??0CParamMerger@@QAE@XZ	; CParamMerger::CParamMerger
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??0CChannelMap@@QAE@XZ ENDP				; CChannelMap::CChannelMap
_TEXT	ENDS
PUBLIC	?AssignPChannel@CPerformance@@AAEJKKKKG@Z	; CPerformance::AssignPChannel
PUBLIC	??_C@_0BN@GOEGCFB@dwIndex?5?$DM?5PCHANNEL_BLOCKSIZE?$AA@ ; `string'
;	COMDAT ??_C@_0BN@GOEGCFB@dwIndex?5?$DM?5PCHANNEL_BLOCKSIZE?$AA@
CONST	SEGMENT
??_C@_0BN@GOEGCFB@dwIndex?5?$DM?5PCHANNEL_BLOCKSIZE?$AA@ DB 'dwIndex < PC'
	DB	'HANNEL_BLOCKSIZE', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AssignPChannel@CPerformance@@AAEJKKKKG@Z
_TEXT	SEGMENT
tv81 = -24
_this$ = -20
$T75670 = -16
_dwIndex$ = -12
_pMap$ = -8
_pChannelBlock$ = -4
_dwPChannel$ = 8
_dwPortIndex$ = 12
_dwGroup$ = 16
_dwMChannel$ = 20
_wFlags$ = 24
?AssignPChannel@CPerformance@@AAEJKKKKG@Z PROC NEAR	; CPerformance::AssignPChannel, COMDAT
; _this$ = ecx

; 7764 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 7765 :     DWORD dwIndex;
; 7766 :     CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0000f	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 7767 : 
; 7768 :     for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  00017	eb 0b		 jmp	 SHORT $L72540
$L72541:
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0001c	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00021	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72540:
  00024	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00028	74 1d		 je	 SHORT $L72542

; 7769 :     {
; 7770 :         if( pChannelBlock->m_dwPChannelStart <= dwPChannel )

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _dwPChannel$[ebp]
  00033	77 10		 ja	 SHORT $L72543

; 7771 :         {
; 7772 :             if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )

  00035	8b 55 fc	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  00038	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003b	83 c0 10	 add	 eax, 16			; 00000010H
  0003e	3b 45 08	 cmp	 eax, DWORD PTR _dwPChannel$[ebp]
  00041	76 02		 jbe	 SHORT $L72543

; 7773 :             {
; 7774 :                 break;

  00043	eb 02		 jmp	 SHORT $L72542
$L72543:

; 7775 :             }
; 7776 :         }
; 7777 :     }

  00045	eb d2		 jmp	 SHORT $L72541
$L72542:

; 7778 :     if( !pChannelBlock )

  00047	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  0004b	75 61		 jne	 SHORT $L72545

; 7779 :     {
; 7780 :         // there is no currently existing block that encompases dwPChannel.
; 7781 :         // Create one.
; 7782 :         pChannelBlock = new CChannelBlock;

  0004d	68 10 08 00 00	 push	 2064			; 00000810H
  00052	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00057	83 c4 04	 add	 esp, 4
  0005a	89 45 f0	 mov	 DWORD PTR $T75670[ebp], eax
  0005d	83 7d f0 00	 cmp	 DWORD PTR $T75670[ebp], 0
  00061	74 0d		 je	 SHORT $L75671
  00063	8b 4d f0	 mov	 ecx, DWORD PTR $T75670[ebp]
  00066	e8 00 00 00 00	 call	 ??0CChannelBlock@@QAE@XZ
  0006b	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  0006e	eb 07		 jmp	 SHORT $L75672
$L75671:
  00070	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L75672:
  00077	8b 4d e8	 mov	 ecx, DWORD PTR tv81[ebp]
  0007a	89 4d fc	 mov	 DWORD PTR _pChannelBlock$[ebp], ecx

; 7783 : 
; 7784 :         if( !pChannelBlock )

  0007d	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00081	75 0a		 jne	 SHORT $L72548

; 7785 :         {
; 7786 :             return E_OUTOFMEMORY;

  00083	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00088	e9 e9 00 00 00	 jmp	 $L72537
$L72548:

; 7787 :         }
; 7788 :         pChannelBlock->Init(dwPChannel,0,0,CMAP_FREE);

  0008d	6a 01		 push	 1
  0008f	6a 00		 push	 0
  00091	6a 00		 push	 0
  00093	8b 55 08	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  00096	52		 push	 edx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0009a	e8 00 00 00 00	 call	 ?Init@CChannelBlock@@QAEXKKKG@Z ; CChannelBlock::Init

; 7789 :         m_ChannelBlockList.AddHead(pChannelBlock);

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	83 c1 3c	 add	 ecx, 60			; 0000003cH
  000a9	e8 00 00 00 00	 call	 ?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ; CChannelBlockList::AddHead
$L72545:

; 7790 :     }
; 7791 : 
; 7792 :     dwIndex = dwPChannel - pChannelBlock->m_dwPChannelStart;

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  000b4	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  000b7	89 55 f4	 mov	 DWORD PTR _dwIndex$[ebp], edx

; 7793 : 
; 7794 :     ASSERT( dwIndex < PCHANNEL_BLOCKSIZE );

  000ba	83 7d f4 10	 cmp	 DWORD PTR _dwIndex$[ebp], 16 ; 00000010H
  000be	72 17		 jb	 SHORT $L72551
  000c0	6a 00		 push	 0
  000c2	68 72 1e 00 00	 push	 7794			; 00001e72H
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@GOEGCFB@dwIndex?5?$DM?5PCHANNEL_BLOCKSIZE?$AA@
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L72551:

; 7795 :     CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  000da	c1 e0 07	 shl	 eax, 7
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000e0	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000e4	89 55 f8	 mov	 DWORD PTR _pMap$[ebp], edx

; 7796 :     pMap->dwPortIndex = dwPortIndex;

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _pMap$[ebp]
  000ea	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPortIndex$[ebp]
  000ed	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 7797 :     pMap->dwGroup = dwGroup;

  000f0	8b 55 f8	 mov	 edx, DWORD PTR _pMap$[ebp]
  000f3	8b 45 10	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  000f6	89 42 74	 mov	 DWORD PTR [edx+116], eax

; 7798 :     pMap->dwMChannel = dwMChannel;

  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _pMap$[ebp]
  000fc	8b 55 14	 mov	 edx, DWORD PTR _dwMChannel$[ebp]
  000ff	89 51 78	 mov	 DWORD PTR [ecx+120], edx

; 7799 :     pMap->nTranspose = 0;

  00102	8b 45 f8	 mov	 eax, DWORD PTR _pMap$[ebp]
  00105	66 c7 40 7c 00
	00		 mov	 WORD PTR [eax+124], 0

; 7800 :     if ((pMap->wFlags & CMAP_FREE) && !(wFlags & CMAP_FREE)) 

  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _pMap$[ebp]
  0010e	0f b7 51 7e	 movzx	 edx, WORD PTR [ecx+126]
  00112	83 e2 01	 and	 edx, 1
  00115	85 d2		 test	 edx, edx
  00117	74 22		 je	 SHORT $L72556
  00119	0f b7 45 18	 movzx	 eax, WORD PTR _wFlags$[ebp]
  0011d	83 e0 01	 and	 eax, 1
  00120	85 c0		 test	 eax, eax
  00122	75 17		 jne	 SHORT $L72556

; 7801 :         pChannelBlock->m_dwFreeChannels--;

  00124	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00127	8b 91 08 08 00
	00		 mov	 edx, DWORD PTR [ecx+2056]
  0012d	83 ea 01	 sub	 edx, 1
  00130	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  00133	89 90 08 08 00
	00		 mov	 DWORD PTR [eax+2056], edx

; 7802 :     else if (!(pMap->wFlags & CMAP_FREE) && (wFlags & CMAP_FREE)) 

  00139	eb 2e		 jmp	 SHORT $L72557
$L72556:
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _pMap$[ebp]
  0013e	0f b7 51 7e	 movzx	 edx, WORD PTR [ecx+126]
  00142	83 e2 01	 and	 edx, 1
  00145	85 d2		 test	 edx, edx
  00147	75 20		 jne	 SHORT $L72557
  00149	0f b7 45 18	 movzx	 eax, WORD PTR _wFlags$[ebp]
  0014d	83 e0 01	 and	 eax, 1
  00150	85 c0		 test	 eax, eax
  00152	74 15		 je	 SHORT $L72557

; 7803 :         pChannelBlock->m_dwFreeChannels++;

  00154	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00157	8b 91 08 08 00
	00		 mov	 edx, DWORD PTR [ecx+2056]
  0015d	83 c2 01	 add	 edx, 1
  00160	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  00163	89 90 08 08 00
	00		 mov	 DWORD PTR [eax+2056], edx
$L72557:

; 7804 :     pMap->wFlags = wFlags;

  00169	8b 4d f8	 mov	 ecx, DWORD PTR _pMap$[ebp]
  0016c	66 8b 55 18	 mov	 dx, WORD PTR _wFlags$[ebp]
  00170	66 89 51 7e	 mov	 WORD PTR [ecx+126], dx

; 7805 :     return S_OK;

  00174	33 c0		 xor	 eax, eax
$L72537:

; 7806 : }

  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c2 14 00	 ret	 20			; 00000014H
?AssignPChannel@CPerformance@@AAEJKKKKG@Z ENDP		; CPerformance::AssignPChannel
_TEXT	ENDS
PUBLIC	?AssignPChannelBlock@CPerformance@@QAGJKPAUIDirectMusicPort@@K@Z ; CPerformance::AssignPChannelBlock
; Function compile flags: /Odt
;	COMDAT ?AssignPChannelBlock@CPerformance@@QAGJKPAUIDirectMusicPort@@K@Z
_TEXT	SEGMENT
_this$ = 8
_dwBlockNum$ = 12
_pPort$ = 16
_dwGroup$ = 20
?AssignPChannelBlock@CPerformance@@QAGJKPAUIDirectMusicPort@@K@Z PROC NEAR ; CPerformance::AssignPChannelBlock, COMDAT

; 7813 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7814 : #ifdef XBOX
; 7815 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 7816 : #else
; 7817 :     V_INAME(IDirectMusicPerformance::AssignPChannelBlock);
; 7818 :     V_INTERFACE(pPort);
; 7819 : 
; 7820 : 
; 7821 :     if (m_dwAudioPathMode == 2)
; 7822 :     {
; 7823 :         Trace(0,"Error: Can not call AssignPChannelBlock() when using AudioPaths.\n");
; 7824 :         return DMUS_E_AUDIOPATHS_IN_USE;
; 7825 :     }
; 7826 :     m_dwAudioPathMode = 1;
; 7827 :     DWORD dwIndex;
; 7828 :     HRESULT hr = E_INVALIDARG;
; 7829 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7830 :     for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 7831 :     {
; 7832 :         if( m_pPortTable[dwIndex].pPort == pPort )
; 7833 :         {
; 7834 :             if( SUCCEEDED( hr = AssignPChannelBlock( dwBlockNum, dwIndex, dwGroup, CMAP_STATIC )))
; 7835 :             {
; 7836 :                 if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
; 7837 :                 {
; 7838 :                     hr = S_FALSE;
; 7839 :                 }
; 7840 :             }
; 7841 :             break;
; 7842 :         }
; 7843 :     }
; 7844 : #ifdef DBG
; 7845 :     if (hr == E_INVALIDARG)
; 7846 :     {
; 7847 :         Trace(0,"Error: AssignPChannelBlock() called with invalid port.\n");
; 7848 :     }
; 7849 : #endif
; 7850 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7851 :     return hr;
; 7852 : #endif // !XBOX
; 7853 : }

  00008	5d		 pop	 ebp
  00009	c2 10 00	 ret	 16			; 00000010H
?AssignPChannelBlock@CPerformance@@QAGJKPAUIDirectMusicPort@@K@Z ENDP ; CPerformance::AssignPChannelBlock
_TEXT	ENDS
PUBLIC	?AssignPChannel@CPerformance@@QAGJKPAUIDirectMusicPort@@KK@Z ; CPerformance::AssignPChannel
; Function compile flags: /Odt
;	COMDAT ?AssignPChannel@CPerformance@@QAGJKPAUIDirectMusicPort@@KK@Z
_TEXT	SEGMENT
_this$ = 8
_dwPChannel$ = 12
_pPort$ = 16
_dwGroup$ = 20
_dwMChannel$ = 24
?AssignPChannel@CPerformance@@QAGJKPAUIDirectMusicPort@@KK@Z PROC NEAR ; CPerformance::AssignPChannel, COMDAT

; 7861 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7862 : #ifdef XBOX
; 7863 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 7864 : #else
; 7865 :     V_INAME(IDirectMusicPerformance::AssignPChannel);
; 7866 :     V_INTERFACE(pPort);
; 7867 : 
; 7868 : 
; 7869 :     if (m_dwAudioPathMode == 2)
; 7870 :     {
; 7871 :         Trace(0,"Error: Can not call AssignPChannel() when using AudioPaths.\n");
; 7872 :         return DMUS_E_AUDIOPATHS_IN_USE;
; 7873 :     }
; 7874 :     m_dwAudioPathMode = 1;
; 7875 :     DWORD dwIndex;
; 7876 :     HRESULT hr = E_INVALIDARG;
; 7877 :     if( (dwMChannel < 0) || (dwMChannel > 15))
; 7878 :     {
; 7879 :         Trace(0,"Error: AssignPChannel() called with invalid MIDI Channel %ld.\n",dwMChannel);
; 7880 :         return E_INVALIDARG;
; 7881 :     }
; 7882 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7883 :     for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
; 7884 :     {
; 7885 :         if( m_pPortTable[dwIndex].pPort == pPort )
; 7886 :         {
; 7887 :             if( SUCCEEDED( hr = AssignPChannel( dwPChannel, dwIndex, dwGroup, dwMChannel, CMAP_STATIC )))
; 7888 :             {
; 7889 :                 if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
; 7890 :                 {
; 7891 :                     hr = S_FALSE;
; 7892 :                 }
; 7893 :             }
; 7894 :             break;
; 7895 :         }
; 7896 :     }
; 7897 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7898 :     return hr;
; 7899 : #endif // !XBOX
; 7900 : }

  00008	5d		 pop	 ebp
  00009	c2 14 00	 ret	 20			; 00000014H
?AssignPChannel@CPerformance@@QAGJKPAUIDirectMusicPort@@KK@Z ENDP ; CPerformance::AssignPChannel
_TEXT	ENDS
PUBLIC	?ReleasePChannel@CPerformance@@AAEJK@Z		; CPerformance::ReleasePChannel
PUBLIC	?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z	; CPerformance::PChannelIndex
; Function compile flags: /Odt
;	COMDAT ?ReleasePChannel@CPerformance@@AAEJK@Z
_TEXT	SEGMENT
_this$ = -32
_dwIndex$72593 = -28
_hr$72596 = -24
_dwGroup$72594 = -20
_dwMChannel$72595 = -16
_pMap$72590 = -12
_hr$ = -8
_pChannelBlock$ = -4
_dwPChannel$ = 8
?ReleasePChannel@CPerformance@@AAEJK@Z PROC NEAR	; CPerformance::ReleasePChannel, COMDAT
; _this$ = ecx

; 7909 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 7910 :     HRESULT hr = E_INVALIDARG;

  00009	c7 45 f8 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 7911 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00010	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00013	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7912 :     CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

  0001f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00025	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  0002a	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 7913 :     for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  0002d	eb 0b		 jmp	 SHORT $L72584
$L72585:
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00032	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00037	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72584:
  0003a	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  0003e	74 1d		 je	 SHORT $L72586

; 7914 :     {
; 7915 :         if( pChannelBlock->m_dwPChannelStart <= dwPChannel )

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00043	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00046	3b 55 08	 cmp	 edx, DWORD PTR _dwPChannel$[ebp]
  00049	77 10		 ja	 SHORT $L72587

; 7916 :         {
; 7917 :             if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0004e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00051	83 c1 10	 add	 ecx, 16			; 00000010H
  00054	3b 4d 08	 cmp	 ecx, DWORD PTR _dwPChannel$[ebp]
  00057	76 02		 jbe	 SHORT $L72587

; 7918 :             {
; 7919 :                 break;

  00059	eb 02		 jmp	 SHORT $L72586
$L72587:

; 7920 :             }
; 7921 :         }
; 7922 :     }

  0005b	eb d2		 jmp	 SHORT $L72585
$L72586:

; 7923 :     if( pChannelBlock )

  0005d	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00061	0f 84 a6 00 00
	00		 je	 $L72589

; 7924 :     {
; 7925 :         // Only release if this is genuinely a virtual pchannel. Otherwise, leave alone.
; 7926 :         CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];

  00067	8b 55 fc	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  0006a	8b 45 08	 mov	 eax, DWORD PTR _dwPChannel$[ebp]
  0006d	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00070	c1 e0 07	 shl	 eax, 7
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00076	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0007a	89 55 f4	 mov	 DWORD PTR _pMap$72590[ebp], edx

; 7927 :         if (pMap->wFlags & CMAP_VIRTUAL)

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _pMap$72590[ebp]
  00080	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  00084	83 e1 04	 and	 ecx, 4
  00087	85 c9		 test	 ecx, ecx
  00089	74 7b		 je	 SHORT $L72592

; 7928 :         {
; 7929 :             pChannelBlock->m_dwFreeChannels++;

  0008b	8b 55 fc	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  0008e	8b 82 08 08 00
	00		 mov	 eax, DWORD PTR [edx+2056]
  00094	83 c0 01	 add	 eax, 1
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0009a	89 81 08 08 00
	00		 mov	 DWORD PTR [ecx+2056], eax

; 7930 :             // Clear out all the merge lists, etc.
; 7931 :             pMap->Clear();

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _pMap$72590[ebp]
  000a3	e8 00 00 00 00	 call	 ?Clear@CChannelMap@@QAEXXZ ; CChannelMap::Clear

; 7932 :             // Reset controllers, but don't send a GM reset.
; 7933 :             ResetAllControllers(pMap,0, false);

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	8b 55 f4	 mov	 edx, DWORD PTR _pMap$72590[ebp]
  000b1	52		 push	 edx
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?ResetAllControllers@CPerformance@@AAEXPAVCChannelMap@@_J_N@Z ; CPerformance::ResetAllControllers

; 7934 : #ifdef XBOX
; 7935 :             // For XBox, we may have passed a buffer down to the port, so make sure it is released.
; 7936 :             DWORD dwIndex;
; 7937 :             DWORD dwGroup;
; 7938 :             DWORD dwMChannel;
; 7939 :             HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );

  000ba	6a 00		 push	 0
  000bc	8d 45 f0	 lea	 eax, DWORD PTR _dwMChannel$72595[ebp]
  000bf	50		 push	 eax
  000c0	8d 4d ec	 lea	 ecx, DWORD PTR _dwGroup$72594[ebp]
  000c3	51		 push	 ecx
  000c4	8d 55 e4	 lea	 edx, DWORD PTR _dwIndex$72593[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 08	 mov	 eax, DWORD PTR _dwPChannel$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  000d4	89 45 e8	 mov	 DWORD PTR _hr$72596[ebp], eax

; 7940 :             if (SUCCEEDED(hr) && m_pSynth)

  000d7	83 7d e8 00	 cmp	 DWORD PTR _hr$72596[ebp], 0
  000db	7c 29		 jl	 SHORT $L72592
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000e4	74 20		 je	 SHORT $L72592

; 7941 :             {
; 7942 :                 m_pSynth->AssignChannelToOutput(dwGroup,dwMChannel,NULL,0,NULL);

  000e6	6a 00		 push	 0
  000e8	6a 00		 push	 0
  000ea	6a 00		 push	 0
  000ec	8b 55 f0	 mov	 edx, DWORD PTR _dwMChannel$72595[ebp]
  000ef	52		 push	 edx
  000f0	8b 45 ec	 mov	 eax, DWORD PTR _dwGroup$72594[ebp]
  000f3	50		 push	 eax
  000f4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000fa	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00100	8b 12		 mov	 edx, DWORD PTR [edx]
  00102	51		 push	 ecx
  00103	ff 52 3c	 call	 DWORD PTR [edx+60]
$L72592:

; 7943 :             }
; 7944 : #endif
; 7945 :         }
; 7946 :         hr = S_OK;

  00106	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L72589:

; 7947 :     }
; 7948 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0010d	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00110	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00115	50		 push	 eax
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7949 :     return hr;

  0011c	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 7950 : }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 04 00	 ret	 4
?ReleasePChannel@CPerformance@@AAEJK@Z ENDP		; CPerformance::ReleasePChannel
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSynth@CPerformance@@UAGJPAPAUIDirectMusicSynthX@@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_ppSynth$ = 12
?GetSynth@CPerformance@@UAGJPAPAUIDirectMusicSynthX@@@Z PROC NEAR ; CPerformance::GetSynth, COMDAT

; 7955 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7956 :     HRESULT hr = E_FAIL;

  00004	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 7957 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 7958 :     *ppSynth = m_pSynth;

  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _ppSynth$[ebp]
  0001d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00020	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00023	89 01		 mov	 DWORD PTR [ecx], eax

; 7959 :     if (m_pSynth)

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0002c	74 19		 je	 SHORT $L72606

; 7960 :     {
; 7961 :         hr = S_OK;

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7962 :         m_pSynth->AddRef();

  00035	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00038	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	52		 push	 edx
  00044	ff 50 04	 call	 DWORD PTR [eax+4]
$L72606:

; 7963 :     }
; 7964 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  00050	51		 push	 ecx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 7965 :     return hr;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7966 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?GetSynth@CPerformance@@UAGJPAPAUIDirectMusicSynthX@@@Z ENDP ; CPerformance::GetSynth
_TEXT	ENDS
PUBLIC	?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z ; CPerformance::GetPort
; Function compile flags: /Odt
;	COMDAT ?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT
_this$ = -4
_dwPortID$ = 8
_ppPort$ = 12
?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z PROC NEAR ; CPerformance::GetPort, COMDAT
; _this$ = ecx

; 7972 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7973 : #ifdef DXAPI
; 7974 :     HRESULT hr;
; 7975 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7976 :     if (dwPortID < m_dwNumPorts)
; 7977 :     {
; 7978 :         *ppPort = m_pPortTable[dwPortID].pPort;
; 7979 :         (*ppPort)->AddRef();
; 7980 :         hr = S_OK;
; 7981 :     }
; 7982 :     else 
; 7983 :     {
; 7984 :         Trace(1,"Error: Unable to find requested port.\n");
; 7985 :         hr = E_FAIL;
; 7986 :     }
; 7987 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 7988 :     return hr;
; 7989 : #else
; 7990 :     return E_FAIL;

  00007	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 7991 : #endif
; 7992 : }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z ENDP ; CPerformance::GetPort
_TEXT	ENDS
PUBLIC	?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ; CChannelBlockList::AddTail
PUBLIC	?AllocVChannel@CPerformance@@AAEJKKPAK00@Z	; CPerformance::AllocVChannel
PUBLIC	??_C@_0CO@MLOBAHAL@Error?3?5Unable?5to?5allocated?5dynam@ ; `string'
;	COMDAT ?sdwSearchForAll@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA
_DATA	SEGMENT
?sdwSearchForAll@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA DD 00H ; `CPerformance::AllocVChannel'::`2'::sdwSearchForAll
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
_DATA	ENDS
;	COMDAT ?sdwSearchForDrums@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA
_DATA	SEGMENT
?sdwSearchForDrums@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA DD 09H ; `CPerformance::AllocVChannel'::`2'::sdwSearchForDrums
_DATA	ENDS
;	COMDAT ?sdwSearchForMelodic@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA
_DATA	SEGMENT
?sdwSearchForMelodic@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA DD 00H ; `CPerformance::AllocVChannel'::`2'::sdwSearchForMelodic
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
_DATA	ENDS
;	COMDAT ??_C@_0CO@MLOBAHAL@Error?3?5Unable?5to?5allocated?5dynam@
CONST	SEGMENT
??_C@_0CO@MLOBAHAL@Error?3?5Unable?5to?5allocated?5dynam@ DB 'Error: Unab'
	DB	'le to allocated dynamic PChannel.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AllocVChannel@CPerformance@@AAEJKKPAK00@Z
_TEXT	SEGMENT
tv164 = -56
_this$ = -52
$T75691 = -48
_pMap$72662 = -44
_dwChannelGroupCount$72653 = -40
_pPort$72654 = -36
_dwIndex$72644 = -32
_dwSearchSize$ = -28
_dwHighestPChannel$ = -24
_dwChannel$ = -20
_hr$ = -16
_pSearchArray$ = -12
_pChannelBlock$ = -8
_fNotFound$ = -4
_dwPortID$ = 8
_dwDrumFlags$ = 12
_pdwPChannel$ = 16
_pdwGroup$ = 20
_pdwMChannel$ = 24
?AllocVChannel@CPerformance@@AAEJKKPAK00@Z PROC NEAR	; CPerformance::AllocVChannel, COMDAT
; _this$ = ecx

; 7996 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 7997 :     // dwDrumsFlags:
; 7998 :     // bit 0 determines whether this port separates out drums on channel 10.
; 7999 :     // bit 1 determines whether this request is for a drum.
; 8000 :     // First, figure out if we are scanning for drums on channel 10, melodic instruments
; 8001 :     // on the other channels, or any on all channels.
; 8002 :     static DWORD sdwSearchForDrums[1] = { 9 };
; 8003 :     static DWORD sdwSearchForAll[16] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };
; 8004 :     static DWORD sdwSearchForMelodic[15] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 };
; 8005 :     DWORD *pSearchArray = sdwSearchForAll;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pSearchArray$[ebp], OFFSET FLAT:?sdwSearchForAll@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA

; 8006 :     DWORD dwSearchSize = 16;

  00010	c7 45 e4 10 00
	00 00		 mov	 DWORD PTR _dwSearchSize$[ebp], 16 ; 00000010H

; 8007 :     if (dwDrumFlags & 1) // Do we handle drums as a special case for channel 10?

  00017	8b 45 0c	 mov	 eax, DWORD PTR _dwDrumFlags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 28		 je	 SHORT $L72630

; 8008 :     {
; 8009 :         if (dwDrumFlags & 2) // And are we looking for drums on channel 10?

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _dwDrumFlags$[ebp]
  00024	83 e1 02	 and	 ecx, 2
  00027	85 c9		 test	 ecx, ecx
  00029	74 10		 je	 SHORT $L72631

; 8010 :         {
; 8011 :             pSearchArray = sdwSearchForDrums;

  0002b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pSearchArray$[ebp], OFFSET FLAT:?sdwSearchForDrums@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA

; 8012 :             dwSearchSize = 1;

  00032	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _dwSearchSize$[ebp], 1

; 8013 :         }
; 8014 :         else

  00039	eb 0e		 jmp	 SHORT $L72630
$L72631:

; 8015 :         {
; 8016 :             pSearchArray = sdwSearchForMelodic;

  0003b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pSearchArray$[ebp], OFFSET FLAT:?sdwSearchForMelodic@?1??AllocVChannel@CPerformance@@AAEJKKPAK00@Z@4PAKA

; 8017 :             dwSearchSize = 15;

  00042	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _dwSearchSize$[ebp], 15 ; 0000000fH
$L72630:

; 8018 :         }
; 8019 :     }
; 8020 :     HRESULT hr = E_INVALIDARG; // Return this if the vChannel is out of range.

  00049	c7 45 f0 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 8021 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00050	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  00059	52		 push	 edx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8022 : 
; 8023 :     CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

  00060	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00066	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  0006b	89 45 f8	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 8024 :     BOOL fNotFound = TRUE;              // Use to indicate when we finally find a match.

  0006e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fNotFound$[ebp], 1

; 8025 :     DWORD dwHighestPChannel = 0;        // Keep track of the highest PCHannel in use, this will be 

  00075	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dwHighestPChannel$[ebp], 0

; 8026 :                                         // used to create a new PChannel block, if needed.
; 8027 :     DWORD dwChannel;
; 8028 :     for (;fNotFound && pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )

  0007c	eb 0b		 jmp	 SHORT $L72639
$L72640:
  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00081	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00086	89 45 f8	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72639:
  00089	83 7d fc 00	 cmp	 DWORD PTR _fNotFound$[ebp], 0
  0008d	0f 84 f9 00 00
	00		 je	 $L72641
  00093	83 7d f8 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00097	0f 84 ef 00 00
	00		 je	 $L72641

; 8029 :     {
; 8030 :         if (dwHighestPChannel < pChannelBlock->m_dwPChannelStart)

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  000a0	8b 4d e8	 mov	 ecx, DWORD PTR _dwHighestPChannel$[ebp]
  000a3	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000a6	73 09		 jae	 SHORT $L72642

; 8031 :         {
; 8032 :             dwHighestPChannel = pChannelBlock->m_dwPChannelStart;

  000a8	8b 55 f8	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  000ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ae	89 45 e8	 mov	 DWORD PTR _dwHighestPChannel$[ebp], eax
$L72642:

; 8033 :         }
; 8034 :         if ((pChannelBlock->m_dwPortIndex == dwPortID) && (pChannelBlock->m_dwFreeChannels))

  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000b4	8b 91 0c 08 00
	00		 mov	 edx, DWORD PTR [ecx+2060]
  000ba	3b 55 08	 cmp	 edx, DWORD PTR _dwPortID$[ebp]
  000bd	0f 85 c4 00 00
	00		 jne	 $L72643
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  000c6	83 b8 08 08 00
	00 00		 cmp	 DWORD PTR [eax+2056], 0
  000cd	0f 84 b4 00 00
	00		 je	 $L72643

; 8035 :         {
; 8036 :             DWORD dwIndex;
; 8037 :             for (dwIndex = 0; dwIndex < dwSearchSize; dwIndex++)

  000d3	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwIndex$72644[ebp], 0
  000da	eb 09		 jmp	 SHORT $L72645
$L72646:
  000dc	8b 4d e0	 mov	 ecx, DWORD PTR _dwIndex$72644[ebp]
  000df	83 c1 01	 add	 ecx, 1
  000e2	89 4d e0	 mov	 DWORD PTR _dwIndex$72644[ebp], ecx
$L72645:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR _dwIndex$72644[ebp]
  000e8	3b 55 e4	 cmp	 edx, DWORD PTR _dwSearchSize$[ebp]
  000eb	0f 83 96 00 00
	00		 jae	 $L72643

; 8038 :             {
; 8039 :                 dwChannel = pSearchArray[dwIndex];

  000f1	8b 45 e0	 mov	 eax, DWORD PTR _dwIndex$72644[ebp]
  000f4	8b 4d f4	 mov	 ecx, DWORD PTR _pSearchArray$[ebp]
  000f7	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000fa	89 55 ec	 mov	 DWORD PTR _dwChannel$[ebp], edx

; 8040 :                 if (pChannelBlock->m_aChannelMap[dwChannel].wFlags & CMAP_FREE) 

  000fd	8b 45 ec	 mov	 eax, DWORD PTR _dwChannel$[ebp]
  00100	c1 e0 07	 shl	 eax, 7
  00103	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00106	0f b7 94 01 86
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+134]
  0010e	83 e2 01	 and	 edx, 1
  00111	85 d2		 test	 edx, edx
  00113	74 6d		 je	 SHORT $L72649

; 8041 :                 {
; 8042 :                     *pdwPChannel = pChannelBlock->m_dwPChannelStart + dwChannel;

  00115	8b 45 f8	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  00118	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011b	03 4d ec	 add	 ecx, DWORD PTR _dwChannel$[ebp]
  0011e	8b 55 10	 mov	 edx, DWORD PTR _pdwPChannel$[ebp]
  00121	89 0a		 mov	 DWORD PTR [edx], ecx

; 8043 :                     pChannelBlock->m_dwFreeChannels--;

  00123	8b 45 f8	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  00126	8b 88 08 08 00
	00		 mov	 ecx, DWORD PTR [eax+2056]
  0012c	83 e9 01	 sub	 ecx, 1
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  00132	89 8a 08 08 00
	00		 mov	 DWORD PTR [edx+2056], ecx

; 8044 :                     pChannelBlock->m_aChannelMap[dwChannel].wFlags = CMAP_VIRTUAL;

  00138	8b 45 ec	 mov	 eax, DWORD PTR _dwChannel$[ebp]
  0013b	c1 e0 07	 shl	 eax, 7
  0013e	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00141	66 c7 84 01 86
	00 00 00 04 00	 mov	 WORD PTR [ecx+eax+134], 4

; 8045 :                     *pdwGroup = pChannelBlock->m_aChannelMap[dwChannel].dwGroup;

  0014b	8b 55 ec	 mov	 edx, DWORD PTR _dwChannel$[ebp]
  0014e	c1 e2 07	 shl	 edx, 7
  00151	8b 45 14	 mov	 eax, DWORD PTR _pdwGroup$[ebp]
  00154	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00157	8b 54 11 7c	 mov	 edx, DWORD PTR [ecx+edx+124]
  0015b	89 10		 mov	 DWORD PTR [eax], edx

; 8046 :                     *pdwMChannel = pChannelBlock->m_aChannelMap[dwChannel].dwMChannel;

  0015d	8b 45 ec	 mov	 eax, DWORD PTR _dwChannel$[ebp]
  00160	c1 e0 07	 shl	 eax, 7
  00163	8b 4d 18	 mov	 ecx, DWORD PTR _pdwMChannel$[ebp]
  00166	8b 55 f8	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  00169	8b 84 02 80 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+128]
  00170	89 01		 mov	 DWORD PTR [ecx], eax

; 8047 :                     fNotFound = FALSE;

  00172	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fNotFound$[ebp], 0

; 8048 :                     hr = S_OK;

  00179	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8049 :                     break;

  00180	eb 05		 jmp	 SHORT $L72643
$L72649:

; 8050 :                 }
; 8051 :             }

  00182	e9 55 ff ff ff	 jmp	 $L72646
$L72643:

; 8052 :         }
; 8053 :     }

  00187	e9 f2 fe ff ff	 jmp	 $L72640
$L72641:

; 8054 :     if( fNotFound )

  0018c	83 7d fc 00	 cmp	 DWORD PTR _fNotFound$[ebp], 0
  00190	0f 84 11 01 00
	00		 je	 $L72652

; 8055 :     {
; 8056 :         // there is no currently existing block that has a free channel.
; 8057 :         // Create one.
; 8058 :         DWORD dwChannelGroupCount;
; 8059 : #ifdef DXAPI
; 8060 :         IDirectMusicPort *pPort = m_pPortTable[dwPortID].pPort;
; 8061 :         pPort->GetNumChannelGroups(&dwChannelGroupCount);
; 8062 :         dwChannelGroupCount++;
; 8063 : #else
; 8064 :         IDirectMusicSynthX *pPort = m_pSynth;

  00196	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0019c	89 55 dc	 mov	 DWORD PTR _pPort$72654[ebp], edx

; 8065 :         m_dwNumChannelGroups++;

  0019f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001a5	83 c1 01	 add	 ecx, 1
  001a8	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  001ab	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 8066 :         dwChannelGroupCount = m_dwNumChannelGroups;

  001ae	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  001b1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001b4	89 4d d8	 mov	 DWORD PTR _dwChannelGroupCount$72653[ebp], ecx

; 8067 : #endif
; 8068 :         hr = pPort->SetNumChannelGroups(dwChannelGroupCount);

  001b7	8b 55 d8	 mov	 edx, DWORD PTR _dwChannelGroupCount$72653[ebp]
  001ba	52		 push	 edx
  001bb	8b 45 dc	 mov	 eax, DWORD PTR _pPort$72654[ebp]
  001be	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c0	8b 55 dc	 mov	 edx, DWORD PTR _pPort$72654[ebp]
  001c3	52		 push	 edx
  001c4	ff 51 10	 call	 DWORD PTR [ecx+16]
  001c7	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 8069 :         if (SUCCEEDED(hr))

  001ca	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ce	0f 8c d3 00 00
	00		 jl	 $L72652

; 8070 :         {
; 8071 : #ifdef DXAPI
; 8072 :             m_pPortTable[dwPortID].dwChannelGroups = dwChannelGroupCount;
; 8073 : #endif
; 8074 :             hr = E_OUTOFMEMORY;

  001d4	c7 45 f0 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 8075 :             dwHighestPChannel += PCHANNEL_BLOCKSIZE;

  001db	8b 45 e8	 mov	 eax, DWORD PTR _dwHighestPChannel$[ebp]
  001de	83 c0 10	 add	 eax, 16			; 00000010H
  001e1	89 45 e8	 mov	 DWORD PTR _dwHighestPChannel$[ebp], eax

; 8076 :             pChannelBlock = new CChannelBlock;

  001e4	68 10 08 00 00	 push	 2064			; 00000810H
  001e9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001ee	83 c4 04	 add	 esp, 4
  001f1	89 45 d0	 mov	 DWORD PTR $T75691[ebp], eax
  001f4	83 7d d0 00	 cmp	 DWORD PTR $T75691[ebp], 0
  001f8	74 0d		 je	 SHORT $L75692
  001fa	8b 4d d0	 mov	 ecx, DWORD PTR $T75691[ebp]
  001fd	e8 00 00 00 00	 call	 ??0CChannelBlock@@QAE@XZ
  00202	89 45 c8	 mov	 DWORD PTR tv164[ebp], eax
  00205	eb 07		 jmp	 SHORT $L75693
$L75692:
  00207	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv164[ebp], 0
$L75693:
  0020e	8b 4d c8	 mov	 ecx, DWORD PTR tv164[ebp]
  00211	89 4d f8	 mov	 DWORD PTR _pChannelBlock$[ebp], ecx

; 8077 :             if (pChannelBlock)

  00214	83 7d f8 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00218	0f 84 89 00 00
	00		 je	 $L72652

; 8078 :             {
; 8079 :                 pChannelBlock->Init(dwHighestPChannel,dwPortID,dwChannelGroupCount,CMAP_FREE);

  0021e	6a 01		 push	 1
  00220	8b 55 d8	 mov	 edx, DWORD PTR _dwChannelGroupCount$72653[ebp]
  00223	52		 push	 edx
  00224	8b 45 08	 mov	 eax, DWORD PTR _dwPortID$[ebp]
  00227	50		 push	 eax
  00228	8b 4d e8	 mov	 ecx, DWORD PTR _dwHighestPChannel$[ebp]
  0022b	51		 push	 ecx
  0022c	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0022f	e8 00 00 00 00	 call	 ?Init@CChannelBlock@@QAEXKKKG@Z ; CChannelBlock::Init

; 8080 :                 m_ChannelBlockList.AddTail(pChannelBlock);

  00234	8b 55 f8	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  00237	52		 push	 edx
  00238	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0023e	e8 00 00 00 00	 call	 ?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ; CChannelBlockList::AddTail

; 8081 :                 dwChannel = pSearchArray[0];  // Which channel should we use?

  00243	8b 45 f4	 mov	 eax, DWORD PTR _pSearchArray$[ebp]
  00246	8b 08		 mov	 ecx, DWORD PTR [eax]
  00248	89 4d ec	 mov	 DWORD PTR _dwChannel$[ebp], ecx

; 8082 :                 CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwChannel];

  0024b	8b 55 ec	 mov	 edx, DWORD PTR _dwChannel$[ebp]
  0024e	c1 e2 07	 shl	 edx, 7
  00251	8b 45 f8	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  00254	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00258	89 4d d4	 mov	 DWORD PTR _pMap$72662[ebp], ecx

; 8083 :                 pMap->dwMChannel = dwChannel;

  0025b	8b 55 d4	 mov	 edx, DWORD PTR _pMap$72662[ebp]
  0025e	8b 45 ec	 mov	 eax, DWORD PTR _dwChannel$[ebp]
  00261	89 42 78	 mov	 DWORD PTR [edx+120], eax

; 8084 :                 pMap->wFlags = CMAP_VIRTUAL;

  00264	8b 4d d4	 mov	 ecx, DWORD PTR _pMap$72662[ebp]
  00267	66 c7 41 7e 04
	00		 mov	 WORD PTR [ecx+126], 4

; 8085 :                 pChannelBlock->m_dwFreeChannels--;

  0026d	8b 55 f8	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  00270	8b 82 08 08 00
	00		 mov	 eax, DWORD PTR [edx+2056]
  00276	83 e8 01	 sub	 eax, 1
  00279	8b 4d f8	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0027c	89 81 08 08 00
	00		 mov	 DWORD PTR [ecx+2056], eax

; 8086 :                 *pdwPChannel = dwChannel + dwHighestPChannel;

  00282	8b 55 ec	 mov	 edx, DWORD PTR _dwChannel$[ebp]
  00285	03 55 e8	 add	 edx, DWORD PTR _dwHighestPChannel$[ebp]
  00288	8b 45 10	 mov	 eax, DWORD PTR _pdwPChannel$[ebp]
  0028b	89 10		 mov	 DWORD PTR [eax], edx

; 8087 :                 *pdwGroup = pMap->dwGroup;

  0028d	8b 4d 14	 mov	 ecx, DWORD PTR _pdwGroup$[ebp]
  00290	8b 55 d4	 mov	 edx, DWORD PTR _pMap$72662[ebp]
  00293	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00296	89 01		 mov	 DWORD PTR [ecx], eax

; 8088 :                 *pdwMChannel = dwChannel;

  00298	8b 4d 18	 mov	 ecx, DWORD PTR _pdwMChannel$[ebp]
  0029b	8b 55 ec	 mov	 edx, DWORD PTR _dwChannel$[ebp]
  0029e	89 11		 mov	 DWORD PTR [ecx], edx

; 8089 :                 hr = S_OK;

  002a0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L72652:

; 8090 :             }
; 8091 :         }
; 8092 :     }
; 8093 : #ifdef DBG
; 8094 :     if (hr == E_INVALIDARG)

  002a7	81 7d f0 57 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
  002ae	75 0f		 jne	 SHORT $L72666

; 8095 :     {
; 8096 :         Trace(1,"Error: Unable to allocated dynamic PChannel.\n");

  002b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@MLOBAHAL@Error?3?5Unable?5to?5allocated?5dynam@
  002b5	6a 01		 push	 1
  002b7	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002bc	83 c4 08	 add	 esp, 8
$L72666:

; 8097 :     }
; 8098 : #endif
; 8099 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  002bf	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  002c2	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  002c7	50		 push	 eax
  002c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8100 :     return hr;

  002ce	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 8101 : }

  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c2 14 00	 ret	 20			; 00000014H
?AllocVChannel@CPerformance@@AAEJKKPAK00@Z ENDP		; CPerformance::AllocVChannel
_TEXT	ENDS
EXTRN	_IDirectSound_Release@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\dsound.h
;	COMDAT ?Release@IDirectSound@@QAGKXZ
_TEXT	SEGMENT
_this$ = 8
?Release@IDirectSound@@QAGKXZ PROC NEAR			; IDirectSound::Release, COMDAT

; 1451 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1452 :         return IDirectSound_Release(this);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSound_Release@4

; 1453 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?Release@IDirectSound@@QAGKXZ ENDP			; IDirectSound::Release
_TEXT	ENDS
PUBLIC	?AllocVChannelBlock@CPerformance@@AAEJKK@Z	; CPerformance::AllocVChannelBlock
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
;	COMDAT ?AllocVChannelBlock@CPerformance@@AAEJKK@Z
_TEXT	SEGMENT
tv81 = -24
_this$ = -20
$T75700 = -16
_lHighestPChannel$ = -12
_hr$ = -8
_pChannelBlock$ = -4
_dwPortID$ = 8
_dwGroup$ = 12
?AllocVChannelBlock@CPerformance@@AAEJKK@Z PROC NEAR	; CPerformance::AllocVChannelBlock, COMDAT
; _this$ = ecx

; 8104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 8105 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8106 : 
; 8107 :     CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0001e	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  00023	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 8108 :     long lHighestPChannel = -PCHANNEL_BLOCKSIZE;

  00026	c7 45 f4 f0 ff
	ff ff		 mov	 DWORD PTR _lHighestPChannel$[ebp], -16 ; fffffff0H

; 8109 :     for (;pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )

  0002d	eb 0b		 jmp	 SHORT $L72675
$L72676:
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00032	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00037	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72675:
  0003a	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  0003e	74 16		 je	 SHORT $L72677

; 8110 :     {
; 8111 :         if (lHighestPChannel < (long) pChannelBlock->m_dwPChannelStart)

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00043	8b 55 f4	 mov	 edx, DWORD PTR _lHighestPChannel$[ebp]
  00046	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00049	7d 09		 jge	 SHORT $L72679

; 8112 :         {
; 8113 :             lHighestPChannel = pChannelBlock->m_dwPChannelStart;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0004e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00051	89 4d f4	 mov	 DWORD PTR _lHighestPChannel$[ebp], ecx
$L72679:

; 8114 :         }
; 8115 :     }

  00054	eb d9		 jmp	 SHORT $L72676
$L72677:

; 8116 :     HRESULT hr = E_OUTOFMEMORY;

  00056	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 8117 :     lHighestPChannel += PCHANNEL_BLOCKSIZE;

  0005d	8b 55 f4	 mov	 edx, DWORD PTR _lHighestPChannel$[ebp]
  00060	83 c2 10	 add	 edx, 16			; 00000010H
  00063	89 55 f4	 mov	 DWORD PTR _lHighestPChannel$[ebp], edx

; 8118 :     pChannelBlock = new CChannelBlock;

  00066	68 10 08 00 00	 push	 2064			; 00000810H
  0006b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00070	83 c4 04	 add	 esp, 4
  00073	89 45 f0	 mov	 DWORD PTR $T75700[ebp], eax
  00076	83 7d f0 00	 cmp	 DWORD PTR $T75700[ebp], 0
  0007a	74 0d		 je	 SHORT $L75701
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR $T75700[ebp]
  0007f	e8 00 00 00 00	 call	 ??0CChannelBlock@@QAE@XZ
  00084	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  00087	eb 07		 jmp	 SHORT $L75702
$L75701:
  00089	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L75702:
  00090	8b 45 e8	 mov	 eax, DWORD PTR tv81[ebp]
  00093	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 8119 :     if (pChannelBlock)

  00096	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  0009a	74 2c		 je	 SHORT $L72684

; 8120 :     {
; 8121 :         pChannelBlock->Init((DWORD) lHighestPChannel,dwPortID,dwGroup,CMAP_FREE);

  0009c	6a 01		 push	 1
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _dwGroup$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 08	 mov	 edx, DWORD PTR _dwPortID$[ebp]
  000a5	52		 push	 edx
  000a6	8b 45 f4	 mov	 eax, DWORD PTR _lHighestPChannel$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000ad	e8 00 00 00 00	 call	 ?Init@CChannelBlock@@QAEXKKKG@Z ; CChannelBlock::Init

; 8122 :         m_ChannelBlockList.AddTail(pChannelBlock);

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  000b5	51		 push	 ecx
  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 3c	 add	 ecx, 60			; 0000003cH
  000bc	e8 00 00 00 00	 call	 ?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ; CChannelBlockList::AddTail

; 8123 :         hr = S_OK;

  000c1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L72684:

; 8124 :     }
; 8125 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  000c8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  000d1	52		 push	 edx
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8126 :     return hr;

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 8127 : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 08 00	 ret	 8
?AllocVChannelBlock@CPerformance@@AAEJKK@Z ENDP		; CPerformance::AllocVChannelBlock
_TEXT	ENDS
PUBLIC	?TraceAllChannelMaps@CPerformance@@AAEXXZ	; CPerformance::TraceAllChannelMaps
; Function compile flags: /Odt
;	COMDAT ?TraceAllChannelMaps@CPerformance@@AAEXXZ
_TEXT	SEGMENT
_this$ = -16
_pMap$72700 = -12
_dwIndex$72696 = -8
_pChannelBlock$ = -4
?TraceAllChannelMaps@CPerformance@@AAEXXZ PROC NEAR	; CPerformance::TraceAllChannelMaps, COMDAT
; _this$ = ecx

; 8133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 8134 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8135 :     CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0001e	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  00023	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 8136 :     for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  00026	eb 0b		 jmp	 SHORT $L72692
$L72693:
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0002b	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00030	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72692:
  00033	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00037	74 2c		 je	 SHORT $L72694

; 8137 :     {
; 8138 :         TraceI(0,"ChannelBlock %lx, Free %ld\n",pChannelBlock->m_dwPChannelStart,pChannelBlock->m_dwFreeChannels);
; 8139 :         DWORD dwIndex;
; 8140 :         for (dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++)

  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwIndex$72696[ebp], 0
  00040	eb 09		 jmp	 SHORT $L72697
$L72698:
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _dwIndex$72696[ebp]
  00045	83 c1 01	 add	 ecx, 1
  00048	89 4d f8	 mov	 DWORD PTR _dwIndex$72696[ebp], ecx
$L72697:
  0004b	83 7d f8 10	 cmp	 DWORD PTR _dwIndex$72696[ebp], 16 ; 00000010H
  0004f	73 12		 jae	 SHORT $L72699

; 8141 :         {
; 8142 :             CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];

  00051	8b 55 f8	 mov	 edx, DWORD PTR _dwIndex$72696[ebp]
  00054	c1 e2 07	 shl	 edx, 7
  00057	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0005a	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  0005e	89 4d f4	 mov	 DWORD PTR _pMap$72700[ebp], ecx

; 8143 :             TraceI(0,"\tPort %ld, Group: %ld, MIDI: %ld, Transpose: %ld, Flags: %ld\n",
; 8144 :                 pMap->dwPortIndex, pMap->dwGroup, pMap->dwMChannel, (long) pMap->nTranspose, (long) pMap->wFlags);
; 8145 :         }

  00061	eb df		 jmp	 SHORT $L72698
$L72699:

; 8146 :     }

  00063	eb c3		 jmp	 SHORT $L72693
$L72694:

; 8147 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00065	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00068	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  0006e	52		 push	 edx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8148 : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?TraceAllChannelMaps@CPerformance@@AAEXXZ ENDP		; CPerformance::TraceAllChannelMaps
_TEXT	ENDS
PUBLIC	?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z ; CPerformance::GetPChannelMap
; Function compile flags: /Odt
;	COMDAT ?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z
_TEXT	SEGMENT
_this$ = -12
_pChannelMap$72713 = -8
_pChannelBlock$ = -4
_dwPChannel$ = 8
?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z PROC NEAR ; CPerformance::GetPChannelMap, COMDAT
; _this$ = ecx

; 8160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 8161 :     CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0000f	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax

; 8162 : 
; 8163 :     for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  00017	eb 0b		 jmp	 SHORT $L72709
$L72710:
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  0001c	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  00021	89 45 fc	 mov	 DWORD PTR _pChannelBlock$[ebp], eax
$L72709:
  00024	83 7d fc 00	 cmp	 DWORD PTR _pChannelBlock$[ebp], 0
  00028	74 36		 je	 SHORT $L72711

; 8164 :     {
; 8165 :         if( ( dwPChannel >= pChannelBlock->m_dwPChannelStart ) &&
; 8166 :             ( dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE ) )

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _dwPChannel$[ebp]
  00030	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00033	72 29		 jb	 SHORT $L72712
  00035	8b 55 fc	 mov	 edx, DWORD PTR _pChannelBlock$[ebp]
  00038	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003b	83 c0 10	 add	 eax, 16			; 00000010H
  0003e	39 45 08	 cmp	 DWORD PTR _dwPChannel$[ebp], eax
  00041	73 1b		 jae	 SHORT $L72712

; 8167 :         {
; 8168 :             CChannelMap* pChannelMap;
; 8169 : 
; 8170 :             pChannelMap = &pChannelBlock->m_aChannelMap[ dwPChannel - pChannelBlock->m_dwPChannelStart ];

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelBlock$[ebp]
  00046	8b 55 08	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  00049	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0004c	c1 e2 07	 shl	 edx, 7
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  00052	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00056	89 4d f8	 mov	 DWORD PTR _pChannelMap$72713[ebp], ecx

; 8171 :             if( pChannelMap->dwGroup == 0 )
; 8172 :             {
; 8173 :                 // this PChannel isn't on a valid group, therefore it hasn't
; 8174 :                 // been set.
; 8175 : //              return NULL;
; 8176 :             }
; 8177 :             return pChannelMap;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _pChannelMap$72713[ebp]
  0005c	eb 04		 jmp	 SHORT $L72707
$L72712:

; 8178 :         }
; 8179 :     }

  0005e	eb b9		 jmp	 SHORT $L72710
$L72711:

; 8180 :     return NULL;

  00060	33 c0		 xor	 eax, eax
$L72707:

; 8181 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z ENDP ; CPerformance::GetPChannelMap
_TEXT	ENDS
PUBLIC	??_C@_0CE@MIOFNNJP@pdwIndex?5?$CG?$CG?5pdwGroup?5?$CG?$CG?5pdwMChan@ ; `string'
PUBLIC	??_C@_0DG@HEDCPHMP@Error?3?5PChannel?5?$CFld?5has?5not?5been@ ; `string'
;	COMDAT ??_C@_0CE@MIOFNNJP@pdwIndex?5?$CG?$CG?5pdwGroup?5?$CG?$CG?5pdwMChan@
CONST	SEGMENT
??_C@_0CE@MIOFNNJP@pdwIndex?5?$CG?$CG?5pdwGroup?5?$CG?$CG?5pdwMChan@ DB 'p'
	DB	'dwIndex && pdwGroup && pdwMChannel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HEDCPHMP@Error?3?5PChannel?5?$CFld?5has?5not?5been@
CONST	SEGMENT
??_C@_0DG@HEDCPHMP@Error?3?5PChannel?5?$CFld?5has?5not?5been@ DB 'Error: '
	DB	'PChannel %ld has not been assigned to a port.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_pChannelMap$ = -4
_dwPChannel$ = 8
_pdwIndex$ = 12
_pdwGroup$ = 16
_pdwMChannel$ = 20
_pnTranspose$ = 24
?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z PROC NEAR	; CPerformance::PChannelIndex, COMDAT
; _this$ = ecx

; 8189 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 8190 :     if (m_dwAudioPathMode == 0)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00013	75 19		 jne	 SHORT $L72723

; 8191 :     {
; 8192 :         Trace(0,"Error: Performance not initialized.\n");

  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  0001a	6a 00		 push	 0
  0001c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00021	83 c4 08	 add	 esp, 8

; 8193 :         return DMUS_E_NOT_INIT;

  00024	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  00029	e9 b8 00 00 00	 jmp	 $L72722
$L72723:

; 8194 :     }
; 8195 :     HRESULT hr;
; 8196 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8197 :     CChannelMap *pChannelMap = GetPChannelMap(dwPChannel);

  0003e	8b 55 08	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  00041	52		 push	 edx
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z ; CPerformance::GetPChannelMap
  0004a	89 45 fc	 mov	 DWORD PTR _pChannelMap$[ebp], eax

; 8198 :     if (pChannelMap)

  0004d	83 7d fc 00	 cmp	 DWORD PTR _pChannelMap$[ebp], 0
  00051	74 66		 je	 SHORT $L72730

; 8199 :     {
; 8200 :         ASSERT( pdwIndex && pdwGroup && pdwMChannel );

  00053	83 7d 0c 00	 cmp	 DWORD PTR _pdwIndex$[ebp], 0
  00057	74 0c		 je	 SHORT $L72732
  00059	83 7d 10 00	 cmp	 DWORD PTR _pdwGroup$[ebp], 0
  0005d	74 06		 je	 SHORT $L72732
  0005f	83 7d 14 00	 cmp	 DWORD PTR _pdwMChannel$[ebp], 0
  00063	75 17		 jne	 SHORT $L72731
$L72732:
  00065	6a 00		 push	 0
  00067	68 08 20 00 00	 push	 8200			; 00002008H
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@MIOFNNJP@pdwIndex?5?$CG?$CG?5pdwGroup?5?$CG?$CG?5pdwMChan@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L72731:

; 8201 : 
; 8202 :         *pdwIndex = pChannelMap->dwPortIndex;

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _pdwIndex$[ebp]
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00082	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00085	89 10		 mov	 DWORD PTR [eax], edx

; 8203 :         *pdwGroup = pChannelMap->dwGroup;

  00087	8b 45 10	 mov	 eax, DWORD PTR _pdwGroup$[ebp]
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0008d	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00090	89 10		 mov	 DWORD PTR [eax], edx

; 8204 :         *pdwMChannel = pChannelMap->dwMChannel;

  00092	8b 45 14	 mov	 eax, DWORD PTR _pdwMChannel$[ebp]
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00098	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0009b	89 10		 mov	 DWORD PTR [eax], edx

; 8205 :         if( pnTranspose )

  0009d	83 7d 18 00	 cmp	 DWORD PTR _pnTranspose$[ebp], 0
  000a1	74 0d		 je	 SHORT $L72734

; 8206 :         {
; 8207 :             *pnTranspose = pChannelMap->nTranspose;

  000a3	8b 45 18	 mov	 eax, DWORD PTR _pnTranspose$[ebp]
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  000a9	66 8b 51 7c	 mov	 dx, WORD PTR [ecx+124]
  000ad	66 89 10	 mov	 WORD PTR [eax], dx
$L72734:

; 8208 :         }
; 8209 :         hr = S_OK;

  000b0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8210 :     }
; 8211 :     else

  000b7	eb 1a		 jmp	 SHORT $L72736
$L72730:

; 8212 :     {
; 8213 :         Trace(1,"Error: PChannel %ld has not been assigned to a port.\n",dwPChannel);

  000b9	8b 45 08	 mov	 eax, DWORD PTR _dwPChannel$[ebp]
  000bc	50		 push	 eax
  000bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@HEDCPHMP@Error?3?5PChannel?5?$CFld?5has?5not?5been@
  000c2	6a 01		 push	 1
  000c4	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8214 : #ifdef DXAPI
; 8215 :         if (m_dwVersion < 8)
; 8216 :         {
; 8217 :             hr = E_INVALIDARG;
; 8218 :         }
; 8219 :         else
; 8220 : #endif
; 8221 :         {
; 8222 :             hr = DMUS_E_AUDIOPATH_NOPORT;

  000cc	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L72736:

; 8223 :         }
; 8224 :     }
; 8225 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  000dc	51		 push	 ecx
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8226 :     return hr;

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L72722:

; 8227 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 14 00	 ret	 20			; 00000014H
?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ENDP	; CPerformance::PChannelIndex
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetPortAndFlags@CPerformance@@UAGJKPAPAUIDirectMusicPort@@PAK@Z
_TEXT	SEGMENT
_this$ = 8
_dwPChannel$ = 12
_ppPort$ = 16
_pdwFlags$ = 20
?GetPortAndFlags@CPerformance@@UAGJKPAPAUIDirectMusicPort@@PAK@Z PROC NEAR ; CPerformance::GetPortAndFlags, COMDAT

; 8249 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8250 : #ifdef DXAPI
; 8251 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 8252 :     DWORD dwIndex;
; 8253 :     DWORD dwGroup;
; 8254 :     DWORD dwMChannel;
; 8255 :     HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );
; 8256 :     if (SUCCEEDED(hr))
; 8257 :     {
; 8258 :         *ppPort = m_pPortTable[dwIndex].pPort;
; 8259 :         if( *ppPort )
; 8260 :         {
; 8261 :             m_pPortTable[dwIndex].pPort->AddRef();
; 8262 :         }
; 8263 :         else
; 8264 :         {
; 8265 :             Trace(1,"Error: Performance does not have a port assigned to PChannel %ld.\n",dwPChannel);
; 8266 :             hr = DMUS_E_NOT_INIT;
; 8267 :         }
; 8268 :         *pdwFlags = m_pPortTable[dwIndex].dwGMFlags;
; 8269 :     }
; 8270 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 8271 :     return hr;
; 8272 : #else
; 8273 :     return E_FAIL;

  00003	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 8274 : #endif
; 8275 : }

  00008	5d		 pop	 ebp
  00009	c2 10 00	 ret	 16			; 00000010H
?GetPortAndFlags@CPerformance@@UAGJKPAPAUIDirectMusicPort@@PAK@Z ENDP ; CPerformance::GetPortAndFlags
_TEXT	ENDS
PUBLIC	??_C@_0BM@EPLKJNPH@?$CFs?3?5Invalid?5pointer?5ppPort?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@KBPMEOHD@?$CFs?3?5Invalid?5pointer?5pdwGroup?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NJMOJABB@?$CFs?3?5Invalid?5pointer?5pdwMChannel?6@ ; `string'
PUBLIC	?PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z ; CPerformance::PChannelInfo
;	COMDAT ?__szValidateInterfaceName@?1??PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::PChannelInfo', 00H	; `CPerformance::PChannelInfo'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@EPLKJNPH@?$CFs?3?5Invalid?5pointer?5ppPort?6?$AA@
CONST	SEGMENT
??_C@_0BM@EPLKJNPH@?$CFs?3?5Invalid?5pointer?5ppPort?6?$AA@ DB '%s: Inval'
	DB	'id pointer ppPort', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KBPMEOHD@?$CFs?3?5Invalid?5pointer?5pdwGroup?6?$AA@
CONST	SEGMENT
??_C@_0BO@KBPMEOHD@?$CFs?3?5Invalid?5pointer?5pdwGroup?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pdwGroup', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NJMOJABB@?$CFs?3?5Invalid?5pointer?5pdwMChannel?6@
CONST	SEGMENT
??_C@_0CB@NJMOJABB@?$CFs?3?5Invalid?5pointer?5pdwMChannel?6@ DB '%s: Inva'
	DB	'lid pointer pdwMChannel', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z
_TEXT	SEGMENT
_dwIndex$ = -16
_hr$ = -12
_dwGroup$ = -8
_dwMChannel$ = -4
_this$ = 8
_dwPChannel$ = 12
_ppPort$ = 16
_pdwGroup$ = 20
_pdwMChannel$ = 24
?PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z PROC NEAR ; CPerformance::PChannelInfo, COMDAT

; 8283 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8284 :     V_INAME(IDirectMusicPerformance::PChannelInfo);
; 8285 :     V_PTRPTR_WRITE_OPT(ppPort);

  00006	83 7d 10 00	 cmp	 DWORD PTR _ppPort$[ebp], 0
  0000a	74 28		 je	 SHORT $L72755
  0000c	6a 04		 push	 4
  0000e	8b 45 10	 mov	 eax, DWORD PTR _ppPort$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L72755
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@EPLKJNPH@?$CFs?3?5Invalid?5pointer?5ppPort?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L72755:

; 8286 :     V_PTR_WRITE_OPT(pdwGroup,DWORD);

  00034	83 7d 14 00	 cmp	 DWORD PTR _pdwGroup$[ebp], 0
  00038	74 28		 je	 SHORT $L72759
  0003a	6a 04		 push	 4
  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _pdwGroup$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00045	85 c0		 test	 eax, eax
  00047	74 19		 je	 SHORT $L72759
  00049	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z@4QBDB
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@KBPMEOHD@?$CFs?3?5Invalid?5pointer?5pdwGroup?6?$AA@
  00053	6a ff		 push	 -1
  00055	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	e8 00 00 00 00	 call	 _DebugBreak@0
$L72759:

; 8287 :     V_PTR_WRITE_OPT(pdwMChannel,DWORD);

  00062	83 7d 18 00	 cmp	 DWORD PTR _pdwMChannel$[ebp], 0
  00066	74 28		 je	 SHORT $L72763
  00068	6a 04		 push	 4
  0006a	8b 55 18	 mov	 edx, DWORD PTR _pdwMChannel$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00073	85 c0		 test	 eax, eax
  00075	74 19		 je	 SHORT $L72763
  00077	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z@4QBDB
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NJMOJABB@?$CFs?3?5Invalid?5pointer?5pdwMChannel?6@
  00081	6a ff		 push	 -1
  00083	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	e8 00 00 00 00	 call	 _DebugBreak@0
$L72763:

; 8288 : 
; 8289 :     DWORD dwIndex, dwGroup, dwMChannel;
; 8290 :     HRESULT hr;
; 8291 : 
; 8292 :     if (m_dwAudioPathMode == 0)

  00090	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00093	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  0009a	75 16		 jne	 SHORT $L72771

; 8293 :     {
; 8294 :         Trace(0,"Error: Performance not initialized.\n");

  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@EPKHKOHF@Error?3?5Performance?5not?5initializ@
  000a1	6a 00		 push	 0
  000a3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a8	83 c4 08	 add	 esp, 8

; 8295 :         return DMUS_E_NOT_INIT;

  000ab	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  000b0	eb 6d		 jmp	 SHORT $L72752
$L72771:

; 8296 :     }
; 8297 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  000bb	51		 push	 ecx
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8298 :     if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))

  000c2	6a 00		 push	 0
  000c4	8d 55 fc	 lea	 edx, DWORD PTR _dwMChannel$[ebp]
  000c7	52		 push	 edx
  000c8	8d 45 f8	 lea	 eax, DWORD PTR _dwGroup$[ebp]
  000cb	50		 push	 eax
  000cc	8d 4d f0	 lea	 ecx, DWORD PTR _dwIndex$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  000d3	52		 push	 edx
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  000dc	85 c0		 test	 eax, eax
  000de	7c 25		 jl	 SHORT $L72777

; 8299 :     {
; 8300 : #ifdef DXAPI
; 8301 :         if( ppPort )
; 8302 :         {
; 8303 :             *ppPort = m_pPortTable[dwIndex].pPort;
; 8304 :             if( *ppPort )
; 8305 :             {
; 8306 :                 m_pPortTable[dwIndex].pPort->AddRef();
; 8307 :             }
; 8308 :         }
; 8309 : #endif
; 8310 :         if( pdwGroup )

  000e0	83 7d 14 00	 cmp	 DWORD PTR _pdwGroup$[ebp], 0
  000e4	74 08		 je	 SHORT $L72778

; 8311 :         {
; 8312 :             *pdwGroup = dwGroup;

  000e6	8b 45 14	 mov	 eax, DWORD PTR _pdwGroup$[ebp]
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _dwGroup$[ebp]
  000ec	89 08		 mov	 DWORD PTR [eax], ecx
$L72778:

; 8313 :         }
; 8314 :         if( pdwMChannel )

  000ee	83 7d 18 00	 cmp	 DWORD PTR _pdwMChannel$[ebp], 0
  000f2	74 08		 je	 SHORT $L72779

; 8315 :         {
; 8316 :             *pdwMChannel = dwMChannel;

  000f4	8b 55 18	 mov	 edx, DWORD PTR _pdwMChannel$[ebp]
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _dwMChannel$[ebp]
  000fa	89 02		 mov	 DWORD PTR [edx], eax
$L72779:

; 8317 :         }
; 8318 :         hr = S_OK;

  000fc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8319 :     }
; 8320 :     else

  00103	eb 07		 jmp	 SHORT $L72781
$L72777:

; 8321 :     {
; 8322 :         // No need to print an error message because PChannelIndex() does it.
; 8323 :         hr = E_INVALIDARG;

  00105	c7 45 f4 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L72781:

; 8324 :     }
; 8325 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  00115	51		 push	 ecx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8326 :     return hr;

  0011c	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]
$L72752:

; 8327 : }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 14 00	 ret	 20			; 00000014H
?PChannelInfo@CPerformance@@QAGJKPAPAUIDirectMusicPort@@PAK1@Z ENDP ; CPerformance::PChannelInfo
_TEXT	ENDS
PUBLIC	??_C@_0EO@NCOGNNDB@Error?3?5Invalidate?$CI?$CJ?5failed?5becau@ ; `string'
EXTRN	?SetInvalidate@CSegState@@QAEJJ@Z:NEAR		; CSegState::SetInvalidate
EXTRN	?GenerateNotification@CSegState@@AAEXKJ@Z:NEAR	; CSegState::GenerateNotification
EXTRN	?SendDirtyPMsg@CSegState@@AAEXJ@Z:NEAR		; CSegState::SendDirtyPMsg
;	COMDAT ??_C@_0EO@NCOGNNDB@Error?3?5Invalidate?$CI?$CJ?5failed?5becau@
CONST	SEGMENT
??_C@_0EO@NCOGNNDB@Error?3?5Invalidate?$CI?$CJ?5failed?5becau@ DB 'Error:'
	DB	' Invalidate() failed because the performance has not been ini'
	DB	'tialized.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Invalidate@CPerformance@@UAGJJK@Z
_TEXT	SEGMENT
_rtQueue$ = -32
_pSegSt$ = -20
_dwCount$ = -16
_mtBumperLength$ = -12
_mtQueue$ = -8
_pNext$ = -4
_this$ = 8
_mtTime$ = 12
_dwFlags$ = 16
?Invalidate@CPerformance@@UAGJJK@Z PROC NEAR		; CPerformance::Invalidate, COMDAT

; 8414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 8415 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8416 :     if( m_pClock == NULL )

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0001c	75 29		 jne	 SHORT $L72788

; 8417 :     {
; 8418 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0001e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00021	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  00027	52		 push	 edx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8419 :          Trace(0,"Error: Invalidate() failed because the performance has not been initialized.\n");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EO@NCOGNNDB@Error?3?5Invalidate?$CI?$CJ?5failed?5becau@
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0003a	83 c4 08	 add	 esp, 8

; 8420 :         return DMUS_E_NO_MASTER_CLOCK;

  0003d	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00042	e9 d9 02 00 00	 jmp	 $L72787
$L72788:

; 8421 :     }
; 8422 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8423 : 
; 8424 :     ENTER_CRITICAL_SECTION( &m_SegmentCrSec );

  00056	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  0005f	51		 push	 ecx
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8425 :     ENTER_CRITICAL_SECTION( &m_PipelineCrSec );

  00066	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00069	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  0006f	52		 push	 edx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8426 :     
; 8427 :     SendBuffers();
; 8428 : 
; 8429 :     // make sure mtTime is greater than the current queue time
; 8430 :     REFERENCE_TIME rtQueue;
; 8431 :     MUSIC_TIME mtQueue;
; 8432 :     MUSIC_TIME mtBumperLength;
; 8433 : 
; 8434 :     GetQueueTime( &rtQueue );

  00076	8d 45 e0	 lea	 eax, DWORD PTR _rtQueue$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00082	50		 push	 eax
  00083	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 8435 :     ReferenceToMusicTime( rtQueue, &mtQueue );

  00089	8d 4d f8	 lea	 ecx, DWORD PTR _mtQueue$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 e4	 mov	 edx, DWORD PTR _rtQueue$[ebp+4]
  00090	52		 push	 edx
  00091	8b 45 e0	 mov	 eax, DWORD PTR _rtQueue$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	50		 push	 eax
  0009e	ff 52 18	 call	 DWORD PTR [edx+24]

; 8436 :     ReferenceToMusicTime( m_rtBumperLength, &mtBumperLength );

  000a1	8d 4d f4	 lea	 ecx, DWORD PTR _mtBumperLength$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	8b 82 cc 02 00
	00		 mov	 eax, DWORD PTR [edx+716]
  000ae	50		 push	 eax
  000af	8b 8a c8 02 00
	00		 mov	 ecx, DWORD PTR [edx+712]
  000b5	51		 push	 ecx
  000b6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000b9	8b 02		 mov	 eax, DWORD PTR [edx]
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	51		 push	 ecx
  000bf	ff 50 18	 call	 DWORD PTR [eax+24]

; 8437 :     if( mtTime < mtQueue + mtBumperLength )

  000c2	8b 55 f8	 mov	 edx, DWORD PTR _mtQueue$[ebp]
  000c5	03 55 f4	 add	 edx, DWORD PTR _mtBumperLength$[ebp]
  000c8	39 55 0c	 cmp	 DWORD PTR _mtTime$[ebp], edx
  000cb	7d 09		 jge	 SHORT $L72794

; 8438 :     {
; 8439 :         mtTime = mtQueue + mtBumperLength;

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _mtQueue$[ebp]
  000d0	03 45 f4	 add	 eax, DWORD PTR _mtBumperLength$[ebp]
  000d3	89 45 0c	 mov	 DWORD PTR _mtTime$[ebp], eax
$L72794:

; 8440 :     }
; 8441 :     // resolve mtTime to the boundary of dwFlags
; 8442 :     mtTime = ResolveTime( mtTime, dwFlags, NULL );

  000d6	6a 00		 push	 0
  000d8	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  000db	51		 push	 ecx
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  000df	52		 push	 edx
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?ResolveTime@CPerformance@@AAEJJKPAJ@Z ; CPerformance::ResolveTime
  000e8	89 45 0c	 mov	 DWORD PTR _mtTime$[ebp], eax

; 8443 :     // flush messages
; 8444 :     FlushMainEventQueues( 0, mtTime, mtQueue, 0 );

  000eb	6a 00		 push	 0
  000ed	8b 45 f8	 mov	 eax, DWORD PTR _mtQueue$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000f4	51		 push	 ecx
  000f5	6a 00		 push	 0
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ?FlushMainEventQueues@CPerformance@@AAEXKJJK@Z ; CPerformance::FlushMainEventQueues

; 8445 :     // move any segments in the past list that are affected into the current list
; 8446 :     CSegState *pSegSt;
; 8447 :     CSegState *pNext;
; 8448 :     for (pSegSt = m_SegStateQueues[SQ_SEC_DONE].GetHead();pSegSt;pSegSt = pNext)

  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00108	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0010d	89 45 ec	 mov	 DWORD PTR _pSegSt$[ebp], eax
  00110	eb 06		 jmp	 SHORT $L72797
$L72798:
  00112	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  00115	89 55 ec	 mov	 DWORD PTR _pSegSt$[ebp], edx
$L72797:
  00118	83 7d ec 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  0011c	74 39		 je	 SHORT $L72799

; 8449 :     {
; 8450 :         pNext = pSegSt->GetNext();

  0011e	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00121	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00126	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 8451 :         if( pSegSt->m_mtLastPlayed > mtTime )

  00129	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  0012c	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0012f	3b 4d 0c	 cmp	 ecx, DWORD PTR _mtTime$[ebp]
  00132	7e 21		 jle	 SHORT $L72800

; 8452 :         {
; 8453 :             m_SegStateQueues[SQ_SEC_DONE].Remove(pSegSt);

  00134	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  00137	52		 push	 edx
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00141	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 8454 :             m_SegStateQueues[SQ_SEC_PLAY].Insert( pSegSt );

  00146	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00150	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L72800:

; 8455 :         }
; 8456 :     }

  00155	eb bb		 jmp	 SHORT $L72798
$L72799:

; 8457 :     for (pSegSt = m_SegStateQueues[SQ_CON_DONE].GetHead();pSegSt;pSegSt = pNext)

  00157	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0015d	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00162	89 45 ec	 mov	 DWORD PTR _pSegSt$[ebp], eax
  00165	eb 06		 jmp	 SHORT $L72801
$L72802:
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0016a	89 4d ec	 mov	 DWORD PTR _pSegSt$[ebp], ecx
$L72801:
  0016d	83 7d ec 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  00171	74 36		 je	 SHORT $L72803

; 8458 :     {
; 8459 :         pNext = pSegSt->GetNext();

  00173	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00176	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0017b	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 8460 :         if( pSegSt->m_mtLastPlayed > mtTime )

  0017e	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  00181	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00184	3b 45 0c	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00187	7e 1e		 jle	 SHORT $L72804

; 8461 :         {
; 8462 :             m_SegStateQueues[SQ_CON_DONE].Remove(pSegSt);

  00189	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0018c	51		 push	 ecx
  0018d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00193	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 8463 :             m_SegStateQueues[SQ_CON_PLAY].Insert( pSegSt );

  00198	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  0019b	52		 push	 edx
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	83 c1 64	 add	 ecx, 100		; 00000064H
  001a2	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L72804:

; 8464 :         }
; 8465 :     }

  001a7	eb be		 jmp	 SHORT $L72802
$L72803:

; 8466 :     pSegSt = m_SegStateQueues[SQ_PRI_DONE].GetTail();

  001a9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	83 c1 74	 add	 ecx, 116		; 00000074H
  001af	e8 00 00 00 00	 call	 ?GetTail@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetTail
  001b4	89 45 ec	 mov	 DWORD PTR _pSegSt$[ebp], eax

; 8467 :     if(pSegSt)

  001b7	83 7d ec 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  001bb	74 29		 je	 SHORT $L72805

; 8468 :     {
; 8469 :         // only check the last one in this list
; 8470 :         if( pSegSt->m_mtLastPlayed > mtTime )

  001bd	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  001c0	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  001c3	3b 4d 0c	 cmp	 ecx, DWORD PTR _mtTime$[ebp]
  001c6	7e 1e		 jle	 SHORT $L72805

; 8471 :         {
; 8472 :             m_SegStateQueues[SQ_PRI_DONE].Remove(pSegSt);

  001c8	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  001cb	52		 push	 edx
  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	83 c1 74	 add	 ecx, 116		; 00000074H
  001d2	e8 00 00 00 00	 call	 ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Remove

; 8473 :             m_SegStateQueues[SQ_PRI_PLAY].Insert( pSegSt );

  001d7	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  001da	50		 push	 eax
  001db	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	83 c1 5c	 add	 ecx, 92			; 0000005cH
  001e1	e8 00 00 00 00	 call	 ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::Insert
$L72805:

; 8474 :         }
; 8475 :     }
; 8476 :     // seek back any affected segmentstates that were playing
; 8477 :     DWORD dwCount;
; 8478 :     for( dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++ )

  001e6	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 3
  001ed	eb 09		 jmp	 SHORT $L72808
$L72809:
  001ef	8b 4d f0	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  001f2	83 c1 01	 add	 ecx, 1
  001f5	89 4d f0	 mov	 DWORD PTR _dwCount$[ebp], ecx
$L72808:
  001f8	83 7d f0 05	 cmp	 DWORD PTR _dwCount$[ebp], 5
  001fc	0f 87 e2 00 00
	00		 ja	 $L72810

; 8479 :     {
; 8480 :         for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )

  00202	8b 55 f0	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00205	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00208	8d 4c d0 44	 lea	 ecx, DWORD PTR [eax+edx*8+68]
  0020c	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00211	89 45 ec	 mov	 DWORD PTR _pSegSt$[ebp], eax
  00214	eb 0b		 jmp	 SHORT $L72811
$L72812:
  00216	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00219	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0021e	89 45 ec	 mov	 DWORD PTR _pSegSt$[ebp], eax
$L72811:
  00221	83 7d ec 00	 cmp	 DWORD PTR _pSegSt$[ebp], 0
  00225	0f 84 b4 00 00
	00		 je	 $L72813

; 8481 :         {
; 8482 :             if( pSegSt->m_fStartedPlay )

  0022b	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0022e	83 b9 04 01 00
	00 00		 cmp	 DWORD PTR [ecx+260], 0
  00235	0f 84 9f 00 00
	00		 je	 $L72814

; 8483 :             {
; 8484 :                 if (SQ_PRI_PLAY == dwCount && pSegSt->m_mtResolvedStart >= mtTime)

  0023b	83 7d f0 03	 cmp	 DWORD PTR _dwCount$[ebp], 3
  0023f	75 50		 jne	 SHORT $L72815
  00241	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  00244	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00247	3b 45 0c	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  0024a	7c 45		 jl	 SHORT $L72815

; 8485 :                 {
; 8486 :                     // resend the segment start notification 
; 8487 :                     pSegSt->GenerateNotification( DMUS_NOTIFICATION_SEGSTART, pSegSt->m_mtResolvedStart );

  0024c	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0024f	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00252	52		 push	 edx
  00253	6a 00		 push	 0
  00255	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00258	e8 00 00 00 00	 call	 ?GenerateNotification@CSegState@@AAEXKJ@Z ; CSegState::GenerateNotification

; 8488 :                     // if this is a primary or controlling segment, resend a DMUS_PMSGT_DIRTY message
; 8489 :                     if( !(pSegSt->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (pSegSt->m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )

  0025d	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  00260	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00263	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00269	85 c9		 test	 ecx, ecx
  0026b	74 0f		 je	 SHORT $L72817
  0026d	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  00270	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00273	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00278	85 c0		 test	 eax, eax
  0027a	74 15		 je	 SHORT $L72815
$L72817:

; 8490 :                     {
; 8491 :                         TraceI(4, "ReSend Dirty PMsg [3] %d (%d)\n", pSegSt->m_mtSeek, pSegSt->m_mtOffset + pSegSt->m_mtSeek);
; 8492 :                         pSegSt->SendDirtyPMsg( pSegSt->m_mtOffset + pSegSt->m_mtSeek );

  0027c	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0027f	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00282	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  00285	03 50 78	 add	 edx, DWORD PTR [eax+120]
  00288	52		 push	 edx
  00289	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0028c	e8 00 00 00 00	 call	 ?SendDirtyPMsg@CSegState@@AAEXJ@Z ; CSegState::SendDirtyPMsg
$L72815:

; 8493 :                     }
; 8494 :                 }
; 8495 :                 if( pSegSt->m_mtLastPlayed > mtTime )

  00291	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00294	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00297	3b 55 0c	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  0029a	7e 3e		 jle	 SHORT $L72814

; 8496 :                 {
; 8497 :                     // if mtTime is after the actual start time of the segment,
; 8498 :                     // set it so the segment has never been played before and
; 8499 :                     // seek the segment to the beginning
; 8500 :                     if( pSegSt->m_mtResolvedStart > mtTime )

  0029c	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  0029f	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  002a2	3b 4d 0c	 cmp	 ecx, DWORD PTR _mtTime$[ebp]
  002a5	7e 1b		 jle	 SHORT $L72820

; 8501 :                     {
; 8502 :                         pSegSt->m_mtLastPlayed = pSegSt->m_mtResolvedStart;

  002a7	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  002aa	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  002ad	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  002b0	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 8503 :                         pSegSt->m_fStartedPlay = FALSE;

  002b3	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  002b6	c7 82 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+260], 0

; 8504 :                     }
; 8505 :                     else

  002c0	eb 09		 jmp	 SHORT $L72821
$L72820:

; 8506 :                     {
; 8507 :                         pSegSt->m_mtLastPlayed = mtTime;

  002c2	8b 45 ec	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  002c5	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  002c8	89 48 70	 mov	 DWORD PTR [eax+112], ecx
$L72821:

; 8508 :                     }
; 8509 :                     pSegSt->SetInvalidate( pSegSt->m_mtLastPlayed );

  002cb	8b 55 ec	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  002ce	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  002d1	50		 push	 eax
  002d2	8b 4d ec	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  002d5	e8 00 00 00 00	 call	 ?SetInvalidate@CSegState@@QAEJJ@Z ; CSegState::SetInvalidate
$L72814:

; 8510 :                 }
; 8511 :             }
; 8512 :         }

  002da	e9 37 ff ff ff	 jmp	 $L72812
$L72813:

; 8513 :     }

  002df	e9 0b ff ff ff	 jmp	 $L72809
$L72810:

; 8514 : 
; 8515 :     LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );

  002e4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  002ed	51		 push	 ecx
  002ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8516 :     LEAVE_CRITICAL_SECTION( &m_SegmentCrSec );

  002f4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002f7	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  002fd	52		 push	 edx
  002fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8517 :     // signal the transport thread so we don't have to wait for it to wake up on its own
; 8518 : #ifdef DXAPI
; 8519 :     if( m_hTransport ) SetEvent( m_hTransport );
; 8520 : #else
; 8521 :     if (m_pTransportWorker) m_pTransportWorker->WakeUp();

  00304	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00307	83 b8 bc 03 00
	00 00		 cmp	 DWORD PTR [eax+956], 0
  0030e	74 0e		 je	 SHORT $L72822
  00310	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	8b 89 bc 03 00
	00		 mov	 ecx, DWORD PTR [ecx+956]
  00319	e8 00 00 00 00	 call	 ?WakeUp@CWorker@@QAEXXZ	; CWorker::WakeUp
$L72822:

; 8522 : #endif
; 8523 :     return S_OK;

  0031e	33 c0		 xor	 eax, eax
$L72787:

; 8524 : }

  00320	8b e5		 mov	 esp, ebp
  00322	5d		 pop	 ebp
  00323	c2 0c 00	 ret	 12			; 0000000cH
?Invalidate@CPerformance@@UAGJJK@Z ENDP			; CPerformance::Invalidate
_TEXT	ENDS
PUBLIC	??_C@_0BN@PLMGLDO@?$CFs?3?5Invalid?5pointer?5pmtNext?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetParamEx', 00H	; `CPerformance::GetParamEx'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@PLMGLDO@?$CFs?3?5Invalid?5pointer?5pmtNext?6?$AA@
CONST	SEGMENT
??_C@_0BN@PLMGLDO@?$CFs?3?5Invalid?5pointer?5pmtNext?6?$AA@ DB '%s: Inval'
	DB	'id pointer pmtNext', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
CONST	SEGMENT
??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@ DB '%s: Invali'
	DB	'd pointer pData', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT
??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ DB '%'
	DB	's: Invalid pointer (void*)&rguidType', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?dwSearchOrder@?BC@??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4PAKA
_DATA	SEGMENT
?dwSearchOrder@?BC@??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4PAKA DD 03H ; `CPerformance::GetParamEx'::`18'::dwSearchOrder
	DD	05H
	DD	06H
	DD	08H
	DD	00H
	DD	02H
	DD	04H
	DD	07H
	DD	01H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z
_TEXT	SEGMENT
_pCTrack$72860 = -16
_hr$ = -12
_pSegNode$ = -8
_dwIX$ = -4
_this$ = 8
_rguidType$ = 12
_dwTrackID$ = 16
_dwGroupBits$ = 20
_dwIndex$ = 24
_mtTime$ = 28
_pmtNext$ = 32
_pData$ = 36
?GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z PROC NEAR ; CPerformance::GetParamEx, COMDAT

; 8556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8557 :     V_INAME(IDirectMusicPerformance::GetParamEx);
; 8558 :     V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);

  00006	83 7d 20 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  0000a	74 28		 je	 SHORT $L72836
  0000c	6a 04		 push	 4
  0000e	8b 45 20	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L72836
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@PLMGLDO@?$CFs?3?5Invalid?5pointer?5pmtNext?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L72836:

; 8559 :     V_PTR_WRITE_OPT(pData,1);

  00034	83 7d 24 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00038	74 28		 je	 SHORT $L72840
  0003a	6a 04		 push	 4
  0003c	8b 4d 24	 mov	 ecx, DWORD PTR _pData$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00045	85 c0		 test	 eax, eax
  00047	74 19		 je	 SHORT $L72840
  00049	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4QBDB
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
  00053	6a ff		 push	 -1
  00055	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	e8 00 00 00 00	 call	 _DebugBreak@0
$L72840:

; 8560 :     V_REFGUID(rguidType);

  00062	6a 10		 push	 16			; 00000010H
  00064	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0006d	85 c0		 test	 eax, eax
  0006f	74 19		 je	 SHORT $L72845
  00071	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4QBDB
  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0007b	6a ff		 push	 -1
  0007d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	e8 00 00 00 00	 call	 _DebugBreak@0
$L72845:

; 8561 : 
; 8562 :     static DWORD dwSearchOrder[SQ_COUNT] = { SQ_PRI_PLAY, SQ_SEC_PLAY, 
; 8563 :                                       SQ_PRI_DONE, SQ_SEC_DONE, 
; 8564 :                                       SQ_PRI_WAIT, SQ_SEC_WAIT,
; 8565 :                                       SQ_CON_PLAY, SQ_CON_DONE,
; 8566 :                                       SQ_CON_WAIT };
; 8567 : 
; 8568 :     DWORD dwIX;
; 8569 :     HRESULT hr;
; 8570 :     CSegState *pSegNode;
; 8571 :     ENTER_API_CRITICAL_SECTION;
; 8572 :     if (dwTrackID)

  0008a	83 7d 10 00	 cmp	 DWORD PTR _dwTrackID$[ebp], 0
  0008e	0f 84 d9 00 00
	00		 je	 $L72852

; 8573 :     {
; 8574 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00094	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00097	05 14 03 00 00	 add	 eax, 788		; 00000314H
  0009c	50		 push	 eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8575 :         for (dwIX = 0; dwIX < SQ_COUNT; dwIX++)

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwIX$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $L72853
$L72854:
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _dwIX$[ebp]
  000af	83 c1 01	 add	 ecx, 1
  000b2	89 4d fc	 mov	 DWORD PTR _dwIX$[ebp], ecx
$L72853:
  000b5	83 7d fc 09	 cmp	 DWORD PTR _dwIX$[ebp], 9
  000b9	0f 83 9c 00 00
	00		 jae	 $L72855

; 8576 :         {
; 8577 :             pSegNode = m_SegStateQueues[dwSearchOrder[dwIX]].GetHead();

  000bf	8b 55 fc	 mov	 edx, DWORD PTR _dwIX$[ebp]
  000c2	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?dwSearchOrder@?BC@??GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z@4PAKA[edx*4]
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	8d 4c c1 44	 lea	 ecx, DWORD PTR [ecx+eax*8+68]
  000d0	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  000d5	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8578 :             for (;pSegNode;pSegNode = pSegNode->GetNext())

  000d8	eb 0b		 jmp	 SHORT $L72856
$L72857:
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  000dd	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  000e2	89 45 f8	 mov	 DWORD PTR _pSegNode$[ebp], eax
$L72856:
  000e5	83 7d f8 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  000e9	74 6b		 je	 SHORT $L72858

; 8579 :             {
; 8580 :                 if ((pSegNode->m_dwFirstTrackID <= dwTrackID) && 
; 8581 :                     (pSegNode->m_dwLastTrackID >= dwTrackID))

  000eb	8b 55 f8	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  000ee	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  000f4	3b 45 10	 cmp	 eax, DWORD PTR _dwTrackID$[ebp]
  000f7	77 5b		 ja	 SHORT $L72859
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  000fc	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [ecx+272]
  00102	3b 55 10	 cmp	 edx, DWORD PTR _dwTrackID$[ebp]
  00105	72 4d		 jb	 SHORT $L72859

; 8582 :                 {
; 8583 :                     CTrack* pCTrack;
; 8584 :                     for (pCTrack = pSegNode->m_TrackList.GetHead();pCTrack;pCTrack = pCTrack->GetNext())

  00107	8b 4d f8	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0010a	83 c1 44	 add	 ecx, 68			; 00000044H
  0010d	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00112	89 45 f0	 mov	 DWORD PTR _pCTrack$72860[ebp], eax
  00115	eb 0b		 jmp	 SHORT $L72861
$L72862:
  00117	8b 4d f0	 mov	 ecx, DWORD PTR _pCTrack$72860[ebp]
  0011a	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  0011f	89 45 f0	 mov	 DWORD PTR _pCTrack$72860[ebp], eax
$L72861:
  00122	83 7d f0 00	 cmp	 DWORD PTR _pCTrack$72860[ebp], 0
  00126	74 2a		 je	 SHORT $L72863

; 8585 :                     {
; 8586 :                         if (pCTrack->m_dwVirtualID == dwTrackID)

  00128	8b 45 f0	 mov	 eax, DWORD PTR _pCTrack$72860[ebp]
  0012b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0012e	3b 4d 10	 cmp	 ecx, DWORD PTR _dwTrackID$[ebp]
  00131	75 1d		 jne	 SHORT $L72864

; 8587 :                         {
; 8588 :                             m_dwGetParamFlags = pCTrack->m_dwFlags;

  00133	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00136	8b 45 f0	 mov	 eax, DWORD PTR _pCTrack$72860[ebp]
  00139	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0013c	89 8a d8 03 00
	00		 mov	 DWORD PTR [edx+984], ecx

; 8589 :                             m_pGetParamSegmentState = pSegNode;

  00142	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00145	8b 45 f8	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  00148	89 82 d4 03 00
	00		 mov	 DWORD PTR [edx+980], eax

; 8590 :                             break;

  0014e	eb 02		 jmp	 SHORT $L72863
$L72864:

; 8591 :                         }
; 8592 :                     }

  00150	eb c5		 jmp	 SHORT $L72862
$L72863:

; 8593 :                     break;

  00152	eb 02		 jmp	 SHORT $L72858
$L72859:

; 8594 :                 } 
; 8595 :             }

  00154	eb 84		 jmp	 SHORT $L72857
$L72858:

; 8596 :         }

  00156	e9 51 ff ff ff	 jmp	 $L72854
$L72855:

; 8597 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00164	51		 push	 ecx
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8598 :     }
; 8599 :     else

  0016b	eb 1a		 jmp	 SHORT $L72865
$L72852:

; 8600 :     {
; 8601 :         m_pGetParamSegmentState = NULL;

  0016d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00170	c7 82 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+980], 0

; 8602 :         m_dwGetParamFlags = 0;

  0017a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0017d	c7 80 d8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+984], 0
$L72865:

; 8603 :     }
; 8604 :     hr = GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData);

  00187	8b 4d 24	 mov	 ecx, DWORD PTR _pData$[ebp]
  0018a	51		 push	 ecx
  0018b	8b 55 20	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  0018e	52		 push	 edx
  0018f	8b 45 1c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00192	50		 push	 eax
  00193	8b 4d 18	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00196	51		 push	 ecx
  00197	8b 55 14	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  0019a	52		 push	 edx
  0019b	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a4	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	50		 push	 eax
  001a8	ff 52 6c	 call	 DWORD PTR [edx+108]
  001ab	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 8605 :     m_pGetParamSegmentState = NULL;

  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	c7 81 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+980], 0

; 8606 :     m_dwGetParamFlags = 0;

  001bb	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001be	c7 82 d8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+984], 0

; 8607 :     LEAVE_API_CRITICAL_SECTION;
; 8608 :     return hr;

  001c8	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 8609 : }

  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c2 20 00	 ret	 32			; 00000020H
?GetParamEx@CPerformance@@UAGJABU_GUID@@KKKJPAJPAX@Z ENDP ; CPerformance::GetParamEx
_TEXT	ENDS
PUBLIC	??_C@_0EM@IFKLLGJK@Error?3?5GetParam?$CI?$CJ?5failed?5because@ ; `string'
PUBLIC	??_C@_0CK@BIEEPMLC@Couldn?8t?5find?5SegState?5in?5GetPar@ ; `string'
PUBLIC	??_C@_0DO@PMAJEBNC@Error?3?5Null?5pointer?5for?5time?5sig@ ; `string'
PUBLIC	??_C@_0DF@IBANBBLM@Error?3?5Null?5pointer?5for?5tempo?5pa@ ; `string'
EXTRN	_GUID_TempoParam:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetParam', 00H	; `CPerformance::GetParam'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0EM@IFKLLGJK@Error?3?5GetParam?$CI?$CJ?5failed?5because@
CONST	SEGMENT
??_C@_0EM@IFKLLGJK@Error?3?5GetParam?$CI?$CJ?5failed?5because@ DB 'Error:'
	DB	' GetParam() failed because the performance has not been initi'
	DB	'alized.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BIEEPMLC@Couldn?8t?5find?5SegState?5in?5GetPar@
CONST	SEGMENT
??_C@_0CK@BIEEPMLC@Couldn?8t?5find?5SegState?5in?5GetPar@ DB 'Couldn''t f'
	DB	'ind SegState in GetParam call.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PMAJEBNC@Error?3?5Null?5pointer?5for?5time?5sig@
CONST	SEGMENT
??_C@_0DO@PMAJEBNC@Error?3?5Null?5pointer?5for?5time?5sig@ DB 'Error: Nul'
	DB	'l pointer for time signature passed to GetParam().', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IBANBBLM@Error?3?5Null?5pointer?5for?5tempo?5pa@
CONST	SEGMENT
??_C@_0DF@IBANBBLM@Error?3?5Null?5pointer?5for?5tempo?5pa@ DB 'Error: Nul'
	DB	'l pointer for tempo passed to GetParam().', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z
_TEXT	SEGMENT
_pTempoData$72976 = -132
_pTempoData$72973 = -128
_pNextTempo$72966 = -124
_pInternalTempo$72964 = -120
_pTSigData$72953 = -116
_timeSig$72955 = -112
_pSegment$72932 = -48
_dwRepeat$ = -44
_mtSegTime$ = -40
_hr$ = -36
_mtLoopEnd$ = -32
_dwRepeatsLeft$ = -28
_pSegSource$ = -24
_fCheckedPast$ = -20
_pSegNode$ = -16
_dwOverrideFlags$ = -12
_mtSegEnd$ = -8
_mtOffset$ = -4
_this$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_mtTime$ = 24
_pmtNext$ = 28
_pData$ = 32
?GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z PROC NEAR ; CPerformance::GetParam, COMDAT

; 8619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H

; 8620 :     V_INAME(IDirectMusicPerformance::GetParam);
; 8621 :     V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);

  00009	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  0000d	74 28		 je	 SHORT $L72877
  0000f	6a 04		 push	 4
  00011	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0001a	85 c0		 test	 eax, eax
  0001c	74 19		 je	 SHORT $L72877
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@PLMGLDO@?$CFs?3?5Invalid?5pointer?5pmtNext?6?$AA@
  00028	6a ff		 push	 -1
  0002a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	e8 00 00 00 00	 call	 _DebugBreak@0
$L72877:

; 8622 :     V_PTR_WRITE_OPT(pData,1);

  00037	83 7d 20 00	 cmp	 DWORD PTR _pData$[ebp], 0
  0003b	74 28		 je	 SHORT $L72880
  0003d	6a 04		 push	 4
  0003f	8b 4d 20	 mov	 ecx, DWORD PTR _pData$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00048	85 c0		 test	 eax, eax
  0004a	74 19		 je	 SHORT $L72880
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
  00056	6a ff		 push	 -1
  00058	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	e8 00 00 00 00	 call	 _DebugBreak@0
$L72880:

; 8623 :     V_REFGUID(rguidType);

  00065	6a 10		 push	 16			; 00000010H
  00067	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00070	85 c0		 test	 eax, eax
  00072	74 19		 je	 SHORT $L72884
  00074	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z@4QBDB
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0007e	6a ff		 push	 -1
  00080	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	e8 00 00 00 00	 call	 _DebugBreak@0
$L72884:

; 8624 : 
; 8625 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00090	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00095	50		 push	 eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8626 :     if( m_pClock == NULL )

  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  000a3	75 29		 jne	 SHORT $L72885

; 8627 :     {
; 8628 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000a5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  000ae	52		 push	 edx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8629 :         Trace(0,"Error: GetParam() failed because the performance has not been initialized.\n");

  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@IFKLLGJK@Error?3?5GetParam?$CI?$CJ?5failed?5because@
  000ba	6a 00		 push	 0
  000bc	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c1	83 c4 08	 add	 esp, 8

; 8630 :         return DMUS_E_NO_MASTER_CLOCK;

  000c4	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000c9	e9 f1 05 00 00	 jmp	 $L72874
$L72885:

; 8631 :     }
; 8632 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000ce	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  000d6	50		 push	 eax
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8633 : 
; 8634 :     if( pmtNext )

  000dd	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  000e1	74 09		 je	 SHORT $L72888

; 8635 :     {
; 8636 :         *pmtNext = 0; // this will be replaced by calls to IDMSegment::GetParam

  000e3	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  000e6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L72888:

; 8637 :     }
; 8638 :     CSegState* pSegNode;
; 8639 :     CSegState* pSegSource = (CSegState *) m_pGetParamSegmentState;

  000ec	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ef	8b 82 d4 03 00
	00		 mov	 eax, DWORD PTR [edx+980]
  000f5	89 45 e8	 mov	 DWORD PTR _pSegSource$[ebp], eax

; 8640 :     DWORD dwOverrideFlags;
; 8641 :     HRESULT hr = DMUS_E_NOT_FOUND;

  000f8	c7 45 dc 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H

; 8642 :     BOOL fCheckedPast = FALSE;

  000ff	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fCheckedPast$[ebp], 0

; 8643 :     MUSIC_TIME mtOffset;
; 8644 :     DWORD dwRepeat = 0;

  00106	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _dwRepeat$[ebp], 0

; 8645 :     MUSIC_TIME mtSegTime = 0;

  0010d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _mtSegTime$[ebp], 0

; 8646 :     MUSIC_TIME mtSegEnd = 0;

  00114	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mtSegEnd$[ebp], 0

; 8647 :     MUSIC_TIME mtLoopEnd = 0;

  0011b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _mtLoopEnd$[ebp], 0

; 8648 :     DWORD dwRepeatsLeft = 0;

  00122	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwRepeatsLeft$[ebp], 0

; 8649 :     if (pSegSource) 

  00129	83 7d e8 00	 cmp	 DWORD PTR _pSegSource$[ebp], 0
  0012d	74 11		 je	 SHORT $L72905

; 8650 :     {
; 8651 :         dwOverrideFlags = m_dwGetParamFlags & (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK);

  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	8b 91 d8 03 00
	00		 mov	 edx, DWORD PTR [ecx+984]
  00138	83 e2 07	 and	 edx, 7
  0013b	89 55 f4	 mov	 DWORD PTR _dwOverrideFlags$[ebp], edx

; 8652 :     }
; 8653 :     else

  0013e	eb 07		 jmp	 SHORT $L72906
$L72905:

; 8654 :     {
; 8655 :         dwOverrideFlags = 0;

  00140	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwOverrideFlags$[ebp], 0
$L72906:

; 8656 :     }
; 8657 : 
; 8658 :     if (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_ALL)

  00147	8b 45 f4	 mov	 eax, DWORD PTR _dwOverrideFlags$[ebp]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 6f		 je	 SHORT $L72907

; 8659 :     {
; 8660 :         // The calling track wants the controlling param to come from the segment itself 
; 8661 :         mtSegTime = mtTime;

  00151	8b 4d 18	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00154	89 4d d8	 mov	 DWORD PTR _mtSegTime$[ebp], ecx

; 8662 :         if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )

  00157	8d 55 d4	 lea	 edx, DWORD PTR _dwRepeat$[ebp]
  0015a	52		 push	 edx
  0015b	8d 45 fc	 lea	 eax, DWORD PTR _mtOffset$[ebp]
  0015e	50		 push	 eax
  0015f	8d 4d d8	 lea	 ecx, DWORD PTR _mtSegTime$[ebp]
  00162	51		 push	 ecx
  00163	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  00166	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  0016b	85 c0		 test	 eax, eax
  0016d	75 51		 jne	 SHORT $L72907

; 8663 :         {
; 8664 :             hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex, 
; 8665 :                     mtSegTime, pmtNext, pData );

  0016f	8b 55 20	 mov	 edx, DWORD PTR _pData$[ebp]
  00172	52		 push	 edx
  00173	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00176	50		 push	 eax
  00177	8b 4d d8	 mov	 ecx, DWORD PTR _mtSegTime$[ebp]
  0017a	51		 push	 ecx
  0017b	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0017e	52		 push	 edx
  0017f	8b 45 10	 mov	 eax, DWORD PTR _dwGroupBits$[ebp]
  00182	50		 push	 eax
  00183	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  00186	51		 push	 ecx
  00187	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0018a	52		 push	 edx
  0018b	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  0018e	e8 00 00 00 00	 call	 ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
  00193	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 8666 :             if( SUCCEEDED(hr) )

  00196	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0019a	7c 24		 jl	 SHORT $L72907

; 8667 :             {
; 8668 :                 dwRepeatsLeft = pSegSource->m_dwRepeats;

  0019c	8b 45 e8	 mov	 eax, DWORD PTR _pSegSource$[ebp]
  0019f	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  001a2	89 4d e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], ecx

; 8669 :                 mtLoopEnd = pSegSource->m_mtLoopEnd;

  001a5	8b 55 e8	 mov	 edx, DWORD PTR _pSegSource$[ebp]
  001a8	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  001ab	89 45 e0	 mov	 DWORD PTR _mtLoopEnd$[ebp], eax

; 8670 :                 mtSegEnd = pSegSource->m_mtLength;

  001ae	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  001b1	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  001b4	89 55 f8	 mov	 DWORD PTR _mtSegEnd$[ebp], edx

; 8671 :                 dwRepeatsLeft -= dwRepeat;

  001b7	8b 45 e4	 mov	 eax, DWORD PTR _dwRepeatsLeft$[ebp]
  001ba	2b 45 d4	 sub	 eax, DWORD PTR _dwRepeat$[ebp]
  001bd	89 45 e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], eax
$L72907:

; 8672 :             }
; 8673 :         }       
; 8674 :     }
; 8675 :     if (FAILED(hr))

  001c0	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001c4	0f 8d 00 01 00
	00		 jge	 $L72913

; 8676 :     {
; 8677 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  001ca	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  001d3	51		 push	 ecx
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8678 :         // we only care about control segments
; 8679 :         if( m_SegStateQueues[SQ_CON_DONE].GetHead() )

  001da	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	83 c1 7c	 add	 ecx, 124		; 0000007cH
  001e0	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001e5	85 c0		 test	 eax, eax
  001e7	74 10		 je	 SHORT $L72914

; 8680 :         {
; 8681 :             pSegNode = m_SegStateQueues[SQ_CON_DONE].GetHead();

  001e9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001ec	83 c1 7c	 add	 ecx, 124		; 0000007cH
  001ef	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  001f4	89 45 f0	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8682 :         }
; 8683 :         else

  001f7	eb 15		 jmp	 SHORT $L72917
$L72914:

; 8684 :         {
; 8685 :             pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();

  001f9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	83 c1 64	 add	 ecx, 100		; 00000064H
  001ff	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00204	89 45 f0	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8686 :             fCheckedPast = TRUE;

  00207	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _fCheckedPast$[ebp], 1
$L72917:

; 8687 :         }
; 8688 :         while( pSegNode )

  0020e	83 7d f0 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00212	0f 84 a2 00 00
	00		 je	 $L72918

; 8689 :         {
; 8690 :             mtSegTime = mtTime;

  00218	8b 55 18	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0021b	89 55 d8	 mov	 DWORD PTR _mtSegTime$[ebp], edx

; 8691 :             if( S_OK == pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )

  0021e	8d 45 d4	 lea	 eax, DWORD PTR _dwRepeat$[ebp]
  00221	50		 push	 eax
  00222	8d 4d fc	 lea	 ecx, DWORD PTR _mtOffset$[ebp]
  00225	51		 push	 ecx
  00226	8d 55 d8	 lea	 edx, DWORD PTR _mtSegTime$[ebp]
  00229	52		 push	 edx
  0022a	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0022d	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  00232	85 c0		 test	 eax, eax
  00234	75 53		 jne	 SHORT $L72920

; 8692 :             {
; 8693 :                 hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex, 
; 8694 :                         mtSegTime, pmtNext, pData );

  00236	8b 45 20	 mov	 eax, DWORD PTR _pData$[ebp]
  00239	50		 push	 eax
  0023a	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  0023d	51		 push	 ecx
  0023e	8b 55 d8	 mov	 edx, DWORD PTR _mtSegTime$[ebp]
  00241	52		 push	 edx
  00242	8b 45 14	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00245	50		 push	 eax
  00246	8b 4d 10	 mov	 ecx, DWORD PTR _dwGroupBits$[ebp]
  00249	51		 push	 ecx
  0024a	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  0024d	52		 push	 edx
  0024e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00251	50		 push	 eax
  00252	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00255	e8 00 00 00 00	 call	 ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
  0025a	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 8695 :                 if( SUCCEEDED(hr) )

  0025d	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00261	7c 26		 jl	 SHORT $L72920

; 8696 :                 {
; 8697 :                     dwRepeatsLeft = pSegNode->m_dwRepeats;

  00263	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00266	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00269	89 55 e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], edx

; 8698 :                     mtLoopEnd = pSegNode->m_mtLoopEnd;

  0026c	8b 45 f0	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  0026f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00272	89 4d e0	 mov	 DWORD PTR _mtLoopEnd$[ebp], ecx

; 8699 :                     mtSegEnd = pSegNode->m_mtLength;

  00275	8b 55 f0	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  00278	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0027b	89 45 f8	 mov	 DWORD PTR _mtSegEnd$[ebp], eax

; 8700 :                     dwRepeatsLeft -= dwRepeat;

  0027e	8b 4d e4	 mov	 ecx, DWORD PTR _dwRepeatsLeft$[ebp]
  00281	2b 4d d4	 sub	 ecx, DWORD PTR _dwRepeat$[ebp]
  00284	89 4d e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], ecx

; 8701 :                 
; 8702 :                     break; // got the param we want. We're outta this loop with a success.

  00287	eb 31		 jmp	 SHORT $L72918
$L72920:

; 8703 :                 }
; 8704 :             }
; 8705 :             // we didn't find the param, so try the next segment.
; 8706 :             pSegNode = pSegNode->GetNext();

  00289	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  0028c	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  00291	89 45 f0	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8707 : 
; 8708 :             // if we're the last segnode in the done queue, we need to 
; 8709 :             // check against the time of the first segnode in the control play queue
; 8710 :             if (!pSegNode && !fCheckedPast )

  00294	83 7d f0 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00298	75 1b		 jne	 SHORT $L72923
  0029a	83 7d ec 00	 cmp	 DWORD PTR _fCheckedPast$[ebp], 0
  0029e	75 15		 jne	 SHORT $L72923

; 8711 :             {
; 8712 :                 pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();

  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	83 c1 64	 add	 ecx, 100		; 00000064H
  002a6	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  002ab	89 45 f0	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8713 :                 fCheckedPast = TRUE;

  002ae	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _fCheckedPast$[ebp], 1
$L72923:

; 8714 :             }
; 8715 :         }

  002b5	e9 54 ff ff ff	 jmp	 $L72917
$L72918:

; 8716 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  002ba	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002bd	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  002c3	52		 push	 edx
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L72913:

; 8717 :     }
; 8718 : 
; 8719 :     if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY))

  002ca	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002ce	7d 79		 jge	 SHORT $L72925
  002d0	8b 45 f4	 mov	 eax, DWORD PTR _dwOverrideFlags$[ebp]
  002d3	83 e0 02	 and	 eax, 2
  002d6	85 c0		 test	 eax, eax
  002d8	74 6f		 je	 SHORT $L72925

; 8720 :     {
; 8721 :         // The calling track wants the controlling param to come from the segment 
; 8722 :         // itself if there was no controlling segment.
; 8723 :         mtSegTime = mtTime;

  002da	8b 4d 18	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  002dd	89 4d d8	 mov	 DWORD PTR _mtSegTime$[ebp], ecx

; 8724 :         if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )

  002e0	8d 55 d4	 lea	 edx, DWORD PTR _dwRepeat$[ebp]
  002e3	52		 push	 edx
  002e4	8d 45 fc	 lea	 eax, DWORD PTR _mtOffset$[ebp]
  002e7	50		 push	 eax
  002e8	8d 4d d8	 lea	 ecx, DWORD PTR _mtSegTime$[ebp]
  002eb	51		 push	 ecx
  002ec	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  002ef	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  002f4	85 c0		 test	 eax, eax
  002f6	75 51		 jne	 SHORT $L72925

; 8725 :         {
; 8726 :             hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex, 
; 8727 :                     mtSegTime, pmtNext, pData );

  002f8	8b 55 20	 mov	 edx, DWORD PTR _pData$[ebp]
  002fb	52		 push	 edx
  002fc	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  002ff	50		 push	 eax
  00300	8b 4d d8	 mov	 ecx, DWORD PTR _mtSegTime$[ebp]
  00303	51		 push	 ecx
  00304	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00307	52		 push	 edx
  00308	8b 45 10	 mov	 eax, DWORD PTR _dwGroupBits$[ebp]
  0030b	50		 push	 eax
  0030c	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  0030f	51		 push	 ecx
  00310	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00313	52		 push	 edx
  00314	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  00317	e8 00 00 00 00	 call	 ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
  0031c	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 8728 :             if( SUCCEEDED(hr) )

  0031f	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00323	7c 24		 jl	 SHORT $L72925

; 8729 :             {
; 8730 :                 dwRepeatsLeft = pSegSource->m_dwRepeats;

  00325	8b 45 e8	 mov	 eax, DWORD PTR _pSegSource$[ebp]
  00328	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0032b	89 4d e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], ecx

; 8731 :                 mtLoopEnd = pSegSource->m_mtLoopEnd;

  0032e	8b 55 e8	 mov	 edx, DWORD PTR _pSegSource$[ebp]
  00331	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00334	89 45 e0	 mov	 DWORD PTR _mtLoopEnd$[ebp], eax

; 8732 :                 mtSegEnd = pSegSource->m_mtLength;

  00337	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  0033a	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0033d	89 55 f8	 mov	 DWORD PTR _mtSegEnd$[ebp], edx

; 8733 :                 dwRepeatsLeft -= dwRepeat;

  00340	8b 45 e4	 mov	 eax, DWORD PTR _dwRepeatsLeft$[ebp]
  00343	2b 45 d4	 sub	 eax, DWORD PTR _dwRepeat$[ebp]
  00346	89 45 e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], eax
$L72925:

; 8734 :             }
; 8735 :         }       
; 8736 :     }
; 8737 : 
; 8738 :     if( FAILED(hr) ) // didn't find one in the previous, so check for a primary segment

  00349	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0034d	0f 8d d9 00 00
	00		 jge	 $L72931

; 8739 :     {
; 8740 :         IDirectMusicSegment* pSegment = NULL;

  00353	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pSegment$72932[ebp], 0

; 8741 :         mtSegTime = mtTime;

  0035a	8b 4d 18	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0035d	89 4d d8	 mov	 DWORD PTR _mtSegTime$[ebp], ecx

; 8742 :         ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00360	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00363	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00369	52		 push	 edx
  0036a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8743 :         pSegNode = GetPrimarySegmentAtTime( mtTime );

  00370	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00373	50		 push	 eax
  00374	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00377	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  0037c	89 45 f0	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8744 :         if( pSegNode )

  0037f	83 7d f0 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  00383	74 4f		 je	 SHORT $L72933

; 8745 :         {
; 8746 :             pSegment = pSegNode->m_pSegment;

  00385	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00388	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0038b	89 55 d0	 mov	 DWORD PTR _pSegment$72932[ebp], edx

; 8747 :             pSegment->AddRef();

  0038e	8b 45 d0	 mov	 eax, DWORD PTR _pSegment$72932[ebp]
  00391	8b 08		 mov	 ecx, DWORD PTR [eax]
  00393	8b 55 d0	 mov	 edx, DWORD PTR _pSegment$72932[ebp]
  00396	52		 push	 edx
  00397	ff 51 04	 call	 DWORD PTR [ecx+4]

; 8748 :             pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat );

  0039a	8d 45 d4	 lea	 eax, DWORD PTR _dwRepeat$[ebp]
  0039d	50		 push	 eax
  0039e	8d 4d fc	 lea	 ecx, DWORD PTR _mtOffset$[ebp]
  003a1	51		 push	 ecx
  003a2	8d 55 d8	 lea	 edx, DWORD PTR _mtSegTime$[ebp]
  003a5	52		 push	 edx
  003a6	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  003a9	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime

; 8749 :             dwRepeatsLeft = pSegNode->m_dwRepeats;

  003ae	8b 45 f0	 mov	 eax, DWORD PTR _pSegNode$[ebp]
  003b1	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  003b4	89 4d e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], ecx

; 8750 :             mtLoopEnd = pSegNode->m_mtLoopEnd;

  003b7	8b 55 f0	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  003ba	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  003bd	89 45 e0	 mov	 DWORD PTR _mtLoopEnd$[ebp], eax

; 8751 :             mtSegEnd = pSegNode->m_mtLength;

  003c0	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  003c3	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  003c6	89 55 f8	 mov	 DWORD PTR _mtSegEnd$[ebp], edx

; 8752 :             dwRepeatsLeft -= dwRepeat;

  003c9	8b 45 e4	 mov	 eax, DWORD PTR _dwRepeatsLeft$[ebp]
  003cc	2b 45 d4	 sub	 eax, DWORD PTR _dwRepeat$[ebp]
  003cf	89 45 e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], eax

; 8753 :         }
; 8754 :         else

  003d2	eb 0f		 jmp	 SHORT $L72934
$L72933:

; 8755 :         {
; 8756 :             Trace(4, "Couldn't find SegState in GetParam call.\n");

  003d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@BIEEPMLC@Couldn?8t?5find?5SegState?5in?5GetPar@
  003d9	6a 04		 push	 4
  003db	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  003e0	83 c4 08	 add	 esp, 8
$L72934:

; 8757 :         }
; 8758 :         LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  003e3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003e6	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  003ec	51		 push	 ecx
  003ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8759 :         if( pSegment )

  003f3	83 7d d0 00	 cmp	 DWORD PTR _pSegment$72932[ebp], 0
  003f7	74 33		 je	 SHORT $L72931

; 8760 :         {
; 8761 :             hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex, 
; 8762 :                     mtSegTime, pmtNext, pData );

  003f9	8b 55 20	 mov	 edx, DWORD PTR _pData$[ebp]
  003fc	52		 push	 edx
  003fd	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00400	50		 push	 eax
  00401	8b 4d d8	 mov	 ecx, DWORD PTR _mtSegTime$[ebp]
  00404	51		 push	 ecx
  00405	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00408	52		 push	 edx
  00409	8b 45 10	 mov	 eax, DWORD PTR _dwGroupBits$[ebp]
  0040c	50		 push	 eax
  0040d	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  00410	51		 push	 ecx
  00411	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00414	52		 push	 edx
  00415	8b 4d f0	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  00418	e8 00 00 00 00	 call	 ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
  0041d	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 8763 :             pSegment->Release();

  00420	8b 45 d0	 mov	 eax, DWORD PTR _pSegment$72932[ebp]
  00423	8b 08		 mov	 ecx, DWORD PTR [eax]
  00425	8b 55 d0	 mov	 edx, DWORD PTR _pSegment$72932[ebp]
  00428	52		 push	 edx
  00429	ff 51 08	 call	 DWORD PTR [ecx+8]
$L72931:

; 8764 :         }
; 8765 :     }
; 8766 :     
; 8767 :     if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_FALLBACK))

  0042c	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00430	7d 79		 jge	 SHORT $L72938
  00432	8b 45 f4	 mov	 eax, DWORD PTR _dwOverrideFlags$[ebp]
  00435	83 e0 04	 and	 eax, 4
  00438	85 c0		 test	 eax, eax
  0043a	74 6f		 je	 SHORT $L72938

; 8768 :     {
; 8769 :         // The calling track wants the controlling param to come from the segment itself 
; 8770 :         mtSegTime = mtTime;

  0043c	8b 4d 18	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0043f	89 4d d8	 mov	 DWORD PTR _mtSegTime$[ebp], ecx

; 8771 :         if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )

  00442	8d 55 d4	 lea	 edx, DWORD PTR _dwRepeat$[ebp]
  00445	52		 push	 edx
  00446	8d 45 fc	 lea	 eax, DWORD PTR _mtOffset$[ebp]
  00449	50		 push	 eax
  0044a	8d 4d d8	 lea	 ecx, DWORD PTR _mtSegTime$[ebp]
  0044d	51		 push	 ecx
  0044e	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  00451	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  00456	85 c0		 test	 eax, eax
  00458	75 51		 jne	 SHORT $L72938

; 8772 :         {
; 8773 :             hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex, 
; 8774 :                     mtSegTime, pmtNext, pData );

  0045a	8b 55 20	 mov	 edx, DWORD PTR _pData$[ebp]
  0045d	52		 push	 edx
  0045e	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00461	50		 push	 eax
  00462	8b 4d d8	 mov	 ecx, DWORD PTR _mtSegTime$[ebp]
  00465	51		 push	 ecx
  00466	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00469	52		 push	 edx
  0046a	8b 45 10	 mov	 eax, DWORD PTR _dwGroupBits$[ebp]
  0046d	50		 push	 eax
  0046e	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  00471	51		 push	 ecx
  00472	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00475	52		 push	 edx
  00476	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  00479	e8 00 00 00 00	 call	 ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
  0047e	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 8775 :             if( SUCCEEDED(hr) )

  00481	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00485	7c 24		 jl	 SHORT $L72938

; 8776 :             {
; 8777 :                 dwRepeatsLeft = pSegSource->m_dwRepeats;

  00487	8b 45 e8	 mov	 eax, DWORD PTR _pSegSource$[ebp]
  0048a	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0048d	89 4d e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], ecx

; 8778 :                 mtLoopEnd = pSegSource->m_mtLoopEnd;

  00490	8b 55 e8	 mov	 edx, DWORD PTR _pSegSource$[ebp]
  00493	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00496	89 45 e0	 mov	 DWORD PTR _mtLoopEnd$[ebp], eax

; 8779 :                 mtSegEnd = pSegSource->m_mtLength;

  00499	8b 4d e8	 mov	 ecx, DWORD PTR _pSegSource$[ebp]
  0049c	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0049f	89 55 f8	 mov	 DWORD PTR _mtSegEnd$[ebp], edx

; 8780 :                 dwRepeatsLeft -= dwRepeat;

  004a2	8b 45 e4	 mov	 eax, DWORD PTR _dwRepeatsLeft$[ebp]
  004a5	2b 45 d4	 sub	 eax, DWORD PTR _dwRepeat$[ebp]
  004a8	89 45 e4	 mov	 DWORD PTR _dwRepeatsLeft$[ebp], eax
$L72938:

; 8781 :             }
; 8782 :         }       
; 8783 :     }
; 8784 : 
; 8785 :     if( FAILED(hr) )

  004ab	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  004af	0f 8d db 01 00
	00		 jge	 $L72944

; 8786 :     {   // If we failed, fill in the end time of loop or segment anyway. 
; 8787 :         if (pmtNext) 

  004b5	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  004b9	74 26		 je	 SHORT $L72945

; 8788 :         {   // Check to see if the loop end is earlier than end of segment.
; 8789 :             if (dwRepeatsLeft && (mtLoopEnd > mtSegTime))

  004bb	83 7d e4 00	 cmp	 DWORD PTR _dwRepeatsLeft$[ebp], 0
  004bf	74 15		 je	 SHORT $L72946
  004c1	8b 4d e0	 mov	 ecx, DWORD PTR _mtLoopEnd$[ebp]
  004c4	3b 4d d8	 cmp	 ecx, DWORD PTR _mtSegTime$[ebp]
  004c7	7e 0d		 jle	 SHORT $L72946

; 8790 :             {
; 8791 :                 *pmtNext = mtLoopEnd - mtSegTime;                

  004c9	8b 55 e0	 mov	 edx, DWORD PTR _mtLoopEnd$[ebp]
  004cc	2b 55 d8	 sub	 edx, DWORD PTR _mtSegTime$[ebp]
  004cf	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  004d2	89 10		 mov	 DWORD PTR [eax], edx

; 8792 :             }
; 8793 :             else // Or, mark end of segment.

  004d4	eb 0b		 jmp	 SHORT $L72945
$L72946:

; 8794 :             {
; 8795 :                 *pmtNext = mtSegEnd - mtSegTime; 

  004d6	8b 4d f8	 mov	 ecx, DWORD PTR _mtSegEnd$[ebp]
  004d9	2b 4d d8	 sub	 ecx, DWORD PTR _mtSegTime$[ebp]
  004dc	8b 55 1c	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  004df	89 0a		 mov	 DWORD PTR [edx], ecx
$L72945:

; 8796 :             }
; 8797 :         }
; 8798 :         // if we're looking for timesig, and didn't find it anywhere,
; 8799 :         // return the Performance timesig
; 8800 :         if( rguidType == GUID_TimeSignature )

  004e1	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TimeSignature
  004e6	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  004e9	50		 push	 eax
  004ea	e8 00 00 00 00	 call	 _==@8
  004ef	85 c0		 test	 eax, eax
  004f1	74 68		 je	 SHORT $L72948

; 8801 :         {
; 8802 :             if( NULL == pData )

  004f3	83 7d 20 00	 cmp	 DWORD PTR _pData$[ebp], 0
  004f7	75 18		 jne	 SHORT $L72949

; 8803 :             {
; 8804 :                 Trace(0,"Error: Null pointer for time signature passed to GetParam().\n");

  004f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@PMAJEBNC@Error?3?5Null?5pointer?5for?5time?5sig@
  004fe	6a 00		 push	 0
  00500	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00505	83 c4 08	 add	 esp, 8

; 8805 :                 hr = E_POINTER;

  00508	c7 45 dc 03 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467261 ; 80004003H

; 8806 :             }
; 8807 :             else

  0050f	eb 45		 jmp	 SHORT $L72952
$L72949:

; 8808 :             {
; 8809 :                 DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;

  00511	8b 4d 20	 mov	 ecx, DWORD PTR _pData$[ebp]
  00514	89 4d 8c	 mov	 DWORD PTR _pTSigData$72953[ebp], ecx

; 8810 :                 DMUS_TIMESIG_PMSG timeSig;
; 8811 : 
; 8812 :                 GetTimeSig( mtTime, &timeSig );

  00517	8d 55 90	 lea	 edx, DWORD PTR _timeSig$72955[ebp]
  0051a	52		 push	 edx
  0051b	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0051e	50		 push	 eax
  0051f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00522	e8 00 00 00 00	 call	 ?GetTimeSig@CPerformance@@AAEXJPAU_DMUS_TIMESIG_PMSG@@@Z ; CPerformance::GetTimeSig

; 8813 :                 pTSigData->bBeatsPerMeasure = timeSig.bBeatsPerMeasure;

  00527	8b 4d 8c	 mov	 ecx, DWORD PTR _pTSigData$72953[ebp]
  0052a	8a 55 c8	 mov	 dl, BYTE PTR _timeSig$72955[ebp+56]
  0052d	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 8814 :                 pTSigData->bBeat = timeSig.bBeat;

  00530	8b 45 8c	 mov	 eax, DWORD PTR _pTSigData$72953[ebp]
  00533	8a 4d c9	 mov	 cl, BYTE PTR _timeSig$72955[ebp+57]
  00536	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 8815 :                 pTSigData->wGridsPerBeat = timeSig.wGridsPerBeat;

  00539	8b 55 8c	 mov	 edx, DWORD PTR _pTSigData$72953[ebp]
  0053c	66 8b 45 ca	 mov	 ax, WORD PTR _timeSig$72955[ebp+58]
  00540	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 8816 :                 pTSigData->mtTime = timeSig.mtTime - mtTime;

  00544	8b 4d a0	 mov	 ecx, DWORD PTR _timeSig$72955[ebp+16]
  00547	2b 4d 18	 sub	 ecx, DWORD PTR _mtTime$[ebp]
  0054a	8b 55 8c	 mov	 edx, DWORD PTR _pTSigData$72953[ebp]
  0054d	89 0a		 mov	 DWORD PTR [edx], ecx

; 8817 :                 hr = S_OK;

  0054f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L72952:

; 8818 :             }
; 8819 :         }
; 8820 :         // Likewise, if there was no tempo in a segment, we need to read directly from the tempo list.
; 8821 :         else if  ( rguidType == GUID_TempoParam || rguidType == GUID_PrivateTempoParam)

  00556	e9 33 01 00 00	 jmp	 $L72957
$L72948:
  0055b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TempoParam
  00560	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00563	50		 push	 eax
  00564	e8 00 00 00 00	 call	 _==@8
  00569	85 c0		 test	 eax, eax
  0056b	75 16		 jne	 SHORT $L72959
  0056d	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PrivateTempoParam
  00572	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  00575	51		 push	 ecx
  00576	e8 00 00 00 00	 call	 _==@8
  0057b	85 c0		 test	 eax, eax
  0057d	0f 84 0b 01 00
	00		 je	 $L72957
$L72959:

; 8822 :         {
; 8823 :             if( NULL == pData )

  00583	83 7d 20 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00587	75 1b		 jne	 SHORT $L72960

; 8824 :             {
; 8825 :                 Trace(0,"Error: Null pointer for tempo passed to GetParam().\n");

  00589	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@IBANBBLM@Error?3?5Null?5pointer?5for?5tempo?5pa@
  0058e	6a 00		 push	 0
  00590	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00595	83 c4 08	 add	 esp, 8

; 8826 :                 hr = E_POINTER;

  00598	c7 45 dc 03 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467261 ; 80004003H

; 8827 :             }
; 8828 :             else 

  0059f	e9 ea 00 00 00	 jmp	 $L72957
$L72960:

; 8829 :             {
; 8830 :                 DMInternalTempo* pInternalTempo;
; 8831 :                 ENTER_CRITICAL_SECTION( &m_PipelineCrSec );

  005a4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  005a7	81 c2 30 03 00
	00		 add	 edx, 816		; 00000330H
  005ad	52		 push	 edx
  005ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8832 :                 pInternalTempo = (DMInternalTempo*)m_TempoMap.GetHead();

  005b4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  005b7	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  005bd	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  005c2	89 45 88	 mov	 DWORD PTR _pInternalTempo$72964[ebp], eax

; 8833 :                 DMInternalTempo* pNextTempo = NULL;

  005c5	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _pNextTempo$72966[ebp], 0

; 8834 :                 for ( ;pInternalTempo;pInternalTempo = pNextTempo )

  005cc	eb 06		 jmp	 SHORT $L72967
$L72968:
  005ce	8b 45 84	 mov	 eax, DWORD PTR _pNextTempo$72966[ebp]
  005d1	89 45 88	 mov	 DWORD PTR _pInternalTempo$72964[ebp], eax
$L72967:
  005d4	83 7d 88 00	 cmp	 DWORD PTR _pInternalTempo$72964[ebp], 0
  005d8	0f 84 93 00 00
	00		 je	 $L72969

; 8835 :                 {
; 8836 :                     pNextTempo = (DMInternalTempo *) pInternalTempo->pNext;

  005de	8b 4d 88	 mov	 ecx, DWORD PTR _pInternalTempo$72964[ebp]
  005e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  005e3	89 55 84	 mov	 DWORD PTR _pNextTempo$72966[ebp], edx

; 8837 :                     if (pNextTempo && (pNextTempo->tempoPMsg.mtTime <= mtTime))

  005e6	83 7d 84 00	 cmp	 DWORD PTR _pNextTempo$72966[ebp], 0
  005ea	74 0d		 je	 SHORT $L72971
  005ec	8b 45 84	 mov	 eax, DWORD PTR _pNextTempo$72966[ebp]
  005ef	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  005f2	3b 4d 18	 cmp	 ecx, DWORD PTR _mtTime$[ebp]
  005f5	7f 02		 jg	 SHORT $L72971

; 8838 :                     {
; 8839 :                         continue;

  005f7	eb d5		 jmp	 SHORT $L72968
$L72971:

; 8840 :                     }
; 8841 :                     if (rguidType == GUID_TempoParam)

  005f9	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TempoParam
  005fe	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  00601	52		 push	 edx
  00602	e8 00 00 00 00	 call	 _==@8
  00607	85 c0		 test	 eax, eax
  00609	74 28		 je	 SHORT $L72972

; 8842 :                     {
; 8843 :                         DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;

  0060b	8b 45 20	 mov	 eax, DWORD PTR _pData$[ebp]
  0060e	89 45 80	 mov	 DWORD PTR _pTempoData$72973[ebp], eax

; 8844 :                         pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;

  00611	8b 4d 88	 mov	 ecx, DWORD PTR _pInternalTempo$72964[ebp]
  00614	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00617	2b 55 18	 sub	 edx, DWORD PTR _mtTime$[ebp]
  0061a	8b 45 80	 mov	 eax, DWORD PTR _pTempoData$72973[ebp]
  0061d	89 10		 mov	 DWORD PTR [eax], edx

; 8845 :                         pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;

  0061f	8b 4d 80	 mov	 ecx, DWORD PTR _pTempoData$72973[ebp]
  00622	8b 55 88	 mov	 edx, DWORD PTR _pInternalTempo$72964[ebp]
  00625	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00628	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0062b	8b 52 54	 mov	 edx, DWORD PTR [edx+84]
  0062e	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 8846 :                     }
; 8847 :                     else // rguidType == GUID_PrivateTempoParam

  00631	eb 2f		 jmp	 SHORT $L72975
$L72972:

; 8848 :                     {
; 8849 :                         PrivateTempo* pTempoData = (PrivateTempo*)pData;

  00633	8b 45 20	 mov	 eax, DWORD PTR _pData$[ebp]
  00636	89 85 7c ff ff
	ff		 mov	 DWORD PTR _pTempoData$72976[ebp], eax

; 8850 :                         pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;

  0063c	8b 4d 88	 mov	 ecx, DWORD PTR _pInternalTempo$72964[ebp]
  0063f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00642	2b 55 18	 sub	 edx, DWORD PTR _mtTime$[ebp]
  00645	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _pTempoData$72976[ebp]
  0064b	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 8851 :                         pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;

  0064e	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _pTempoData$72976[ebp]
  00654	8b 55 88	 mov	 edx, DWORD PTR _pInternalTempo$72964[ebp]
  00657	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0065a	89 01		 mov	 DWORD PTR [ecx], eax
  0065c	8b 52 54	 mov	 edx, DWORD PTR [edx+84]
  0065f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L72975:

; 8852 :                     }
; 8853 :                     if( pmtNext )

  00662	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  00666	74 09		 je	 SHORT $L72969

; 8854 :                     {
; 8855 :                         *pmtNext = 0;

  00668	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  0066b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L72969:

; 8856 :                     }
; 8857 :                     break;
; 8858 :                 }
; 8859 :                 LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );

  00671	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00674	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  0067a	51		 push	 ecx
  0067b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8860 :                 if (pInternalTempo)

  00681	83 7d 88 00	 cmp	 DWORD PTR _pInternalTempo$72964[ebp], 0
  00685	74 07		 je	 SHORT $L72957

; 8861 :                 {
; 8862 :                     hr = S_FALSE;

  00687	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1
$L72957:

; 8863 :                 }
; 8864 :             }
; 8865 :         }
; 8866 :     }
; 8867 :     else // GetParam from a segment succeeded, so we need to clean up the next time parameter to account

  0068e	eb 2c		 jmp	 SHORT $L72981
$L72944:

; 8868 :          // for loops and end of segment.
; 8869 :     {
; 8870 :         if (pmtNext) // Check to see if the loop end is earlier than *pmtNext.

  00690	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  00694	74 26		 je	 SHORT $L72981

; 8871 :         {
; 8872 :             if (dwRepeatsLeft && (*pmtNext > (mtLoopEnd - mtSegTime)))

  00696	83 7d e4 00	 cmp	 DWORD PTR _dwRepeatsLeft$[ebp], 0
  0069a	74 20		 je	 SHORT $L72981
  0069c	8b 55 e0	 mov	 edx, DWORD PTR _mtLoopEnd$[ebp]
  0069f	2b 55 d8	 sub	 edx, DWORD PTR _mtSegTime$[ebp]
  006a2	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  006a5	39 10		 cmp	 DWORD PTR [eax], edx
  006a7	7e 13		 jle	 SHORT $L72981

; 8873 :             {
; 8874 :                 if (mtLoopEnd >= mtSegTime) // This should always be true, but test anyway.

  006a9	8b 4d e0	 mov	 ecx, DWORD PTR _mtLoopEnd$[ebp]
  006ac	3b 4d d8	 cmp	 ecx, DWORD PTR _mtSegTime$[ebp]
  006af	7c 0b		 jl	 SHORT $L72981

; 8875 :                 {
; 8876 :                     *pmtNext = mtLoopEnd - mtSegTime;                

  006b1	8b 55 e0	 mov	 edx, DWORD PTR _mtLoopEnd$[ebp]
  006b4	2b 55 d8	 sub	 edx, DWORD PTR _mtSegTime$[ebp]
  006b7	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  006ba	89 10		 mov	 DWORD PTR [eax], edx
$L72981:

; 8877 :                 }
; 8878 :             }
; 8879 :         }
; 8880 :     }
; 8881 : #ifdef DXAPI
; 8882 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);
; 8883 :     if (m_pParamHook && SUCCEEDED(hr))
; 8884 :     {
; 8885 :         hr = m_pParamHook->GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData,
; 8886 :             pSegSource,m_dwGetParamFlags,hr);
; 8887 :         
; 8888 :     }
; 8889 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 8890 : #endif
; 8891 :     return hr;

  006bc	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]
$L72874:

; 8892 : }

  006bf	8b e5		 mov	 esp, ebp
  006c1	5d		 pop	 ebp
  006c2	c2 1c 00	 ret	 28			; 0000001cH
?GetParam@CPerformance@@UAGJABU_GUID@@KKJPAJPAX@Z ENDP	; CPerformance::GetParam
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AListItem@@QAE@XZ PROC NEAR				; AListItem::AListItem, COMDAT
; _this$ = ecx

; 17   :     AListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AListItem@@QAE@XZ ENDP				; AListItem::AListItem
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@AListItem@@QAEXPAV1@@Z PROC NEAR		; AListItem::SetNext, COMDAT
; _this$ = ecx

; 19   :     void SetNext(AListItem *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNext@AListItem@@QAEXPAV1@@Z ENDP			; AListItem::SetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AList@@QAE@XZ PROC NEAR				; AList::AList, COMDAT
; _this$ = ecx

; 34   :     AList() {m_pHead=NULL;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AList@@QAE@XZ ENDP					; AList::AList
_TEXT	ENDS
EXTRN	?GetCount@AListItem@@QBEJXZ:NEAR		; AListItem::GetCount
; Function compile flags: /Odt
;	COMDAT ?GetCount@AList@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?GetCount@AList@@QBEJXZ PROC NEAR			; AList::GetCount, COMDAT
; _this$ = ecx

; 38   :     LONG GetCount() const {return m_pHead->GetCount();}; 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	e8 00 00 00 00	 call	 ?GetCount@AListItem@@QBEJXZ ; AListItem::GetCount
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetCount@AList@@QBEJXZ ENDP				; AList::GetCount
_TEXT	ENDS
PUBLIC	??_C@_0EM@FKGBLCKC@Error?3?5SetParam?$CI?$CJ?5failed?5because@ ; `string'
PUBLIC	??_C@_0EH@NMKGDHBB@Error?3?5SetParam?5failed?5because?5t@ ; `string'
PUBLIC	?SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z	; CPerformance::SetParam
;	COMDAT ?__szValidateInterfaceName@?1??SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z@4QBDB
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::SetParam', 00H	; `CPerformance::SetParam'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0EM@FKGBLCKC@Error?3?5SetParam?$CI?$CJ?5failed?5because@
CONST	SEGMENT
??_C@_0EM@FKGBLCKC@Error?3?5SetParam?$CI?$CJ?5failed?5because@ DB 'Error:'
	DB	' SetParam() failed because the performance has not been initi'
	DB	'alized.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NMKGDHBB@Error?3?5SetParam?5failed?5because?5t@
CONST	SEGMENT
??_C@_0EH@NMKGDHBB@Error?3?5SetParam?5failed?5because?5t@ DB 'Error: SetP'
	DB	'aram failed because there is no segment at requested time.', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z
_TEXT	SEGMENT
_dwRepeat$ = -20
_hr$ = -16
_pSegNode$ = -12
_pSegment$ = -8
_mtOffset$ = -4
_this$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_mtTime$ = 24
_pData$ = 28
?SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z PROC NEAR ; CPerformance::SetParam, COMDAT

; 8920 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 8921 :     V_INAME(IDirectMusicPerformance::SetParam);
; 8922 :     V_PTR_WRITE_OPT(pData,1);

  00006	83 7d 1c 00	 cmp	 DWORD PTR _pData$[ebp], 0
  0000a	74 28		 je	 SHORT $L72995
  0000c	6a 04		 push	 4
  0000e	8b 45 1c	 mov	 eax, DWORD PTR _pData$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00017	85 c0		 test	 eax, eax
  00019	74 19		 je	 SHORT $L72995
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z@4QBDB
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
  00025	6a ff		 push	 -1
  00027	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _DebugBreak@0
$L72995:

; 8923 :     V_REFGUID(rguidType);

  00034	6a 10		 push	 16			; 00000010H
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003f	85 c0		 test	 eax, eax
  00041	74 19		 je	 SHORT $L72999
  00043	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z@4QBDB
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0004d	6a ff		 push	 -1
  0004f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	e8 00 00 00 00	 call	 _DebugBreak@0
$L72999:

; 8924 : 
; 8925 :     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0005c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8926 :     if( m_pClock == NULL )

  0006c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00073	75 29		 jne	 SHORT $L73000

; 8927 :     {
; 8928 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  00075	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	81 c1 a0 03 00
	00		 add	 ecx, 928		; 000003a0H
  0007e	51		 push	 ecx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8929 :         Trace(0,"Error: SetParam() failed because the performance has not been initialized.\n");

  00085	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@FKGBLCKC@Error?3?5SetParam?$CI?$CJ?5failed?5because@
  0008a	6a 00		 push	 0
  0008c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00091	83 c4 08	 add	 esp, 8

; 8930 :         return DMUS_E_NO_MASTER_CLOCK;

  00094	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00099	e9 c4 00 00 00	 jmp	 $L72992
$L73000:

; 8931 :     }
; 8932 :     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0009e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	81 c2 a0 03 00
	00		 add	 edx, 928		; 000003a0H
  000a7	52		 push	 edx
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8933 : 
; 8934 :     CSegState* pSegNode;
; 8935 :     IDirectMusicSegment* pSegment = NULL;

  000ae	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pSegment$[ebp], 0

; 8936 :     HRESULT hr;
; 8937 : 
; 8938 :     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  000b5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	05 14 03 00 00	 add	 eax, 788		; 00000314H
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8939 :     pSegNode = GetPrimarySegmentAtTime( mtTime );

  000c4	8b 4d 18	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  000d0	89 45 f4	 mov	 DWORD PTR _pSegNode$[ebp], eax

; 8940 : 
; 8941 :     MUSIC_TIME mtOffset;
; 8942 :     DWORD dwRepeat;
; 8943 :     if( pSegNode )

  000d3	83 7d f4 00	 cmp	 DWORD PTR _pSegNode$[ebp], 0
  000d7	74 29		 je	 SHORT $L73008

; 8944 :     {
; 8945 :         pSegment = pSegNode->m_pSegment;

  000d9	8b 55 f4	 mov	 edx, DWORD PTR _pSegNode$[ebp]
  000dc	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000df	89 45 f8	 mov	 DWORD PTR _pSegment$[ebp], eax

; 8946 :         pSegment->AddRef();

  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	8b 45 f8	 mov	 eax, DWORD PTR _pSegment$[ebp]
  000ea	50		 push	 eax
  000eb	ff 52 04	 call	 DWORD PTR [edx+4]

; 8947 :         pSegNode->ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );

  000ee	8d 4d ec	 lea	 ecx, DWORD PTR _dwRepeat$[ebp]
  000f1	51		 push	 ecx
  000f2	8d 55 fc	 lea	 edx, DWORD PTR _mtOffset$[ebp]
  000f5	52		 push	 edx
  000f6	8d 45 18	 lea	 eax, DWORD PTR _mtTime$[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d f4	 mov	 ecx, DWORD PTR _pSegNode$[ebp]
  000fd	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
$L73008:

; 8948 :     }
; 8949 :     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  00102	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  0010b	51		 push	 ecx
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 8950 :     if( pSegment )

  00112	83 7d f8 00	 cmp	 DWORD PTR _pSegment$[ebp], 0
  00116	74 31		 je	 SHORT $L73009

; 8951 :     {
; 8952 :         hr = pSegment->SetParam( rguidType, dwGroupBits, dwIndex, 
; 8953 :                 mtTime, pData );

  00118	8b 55 1c	 mov	 edx, DWORD PTR _pData$[ebp]
  0011b	52		 push	 edx
  0011c	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0011f	50		 push	 eax
  00120	8b 4d 14	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00123	51		 push	 ecx
  00124	8b 55 10	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  00127	52		 push	 edx
  00128	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0012b	50		 push	 eax
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  0012f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00131	8b 45 f8	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00134	50		 push	 eax
  00135	ff 52 70	 call	 DWORD PTR [edx+112]
  00138	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 8954 :         pSegment->Release();

  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  0013e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00140	8b 45 f8	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00143	50		 push	 eax
  00144	ff 52 08	 call	 DWORD PTR [edx+8]

; 8955 :     }
; 8956 :     else

  00147	eb 16		 jmp	 SHORT $L73010
$L73009:

; 8957 :     {
; 8958 :         Trace(2,"Error: SetParam failed because there is no segment at requested time.\n");

  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@NMKGDHBB@Error?3?5SetParam?5failed?5because?5t@
  0014e	6a 02		 push	 2
  00150	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00155	83 c4 08	 add	 esp, 8

; 8959 :         hr = DMUS_E_NOT_FOUND;

  00158	c7 45 f0 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
$L73010:

; 8960 :     }
; 8961 :     return hr;

  0015f	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
$L72992:

; 8962 : }

  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c2 18 00	 ret	 24			; 00000018H
?SetParam@CPerformance@@QAGJABU_GUID@@KKJPAX@Z ENDP	; CPerformance::SetParam
_TEXT	ENDS
EXTRN	?Cat@AListItem@@QAEPAV1@PAV1@@Z:NEAR		; AListItem::Cat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
;	COMDAT ?Cat@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Cat@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::Cat, COMDAT
; _this$ = ecx

; 41   :     void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	e8 00 00 00 00	 call	 ?Cat@AListItem@@QAEPAV1@PAV1@@Z ; AListItem::Cat
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Cat@AList@@QAEXPAVAListItem@@@Z ENDP			; AList::Cat
_TEXT	ENDS
EXTRN	?Remove@AListItem@@QAEPAV1@PAV1@@Z:NEAR		; AListItem::Remove
; Function compile flags: /Odt
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Remove@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::Remove, COMDAT
; _this$ = ecx

; 60   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   :             if (pItem != NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 13		 je	 SHORT $L32733

; 62   :             {
; 63   :                 m_pHead=m_pHead->Remove(pItem);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	e8 00 00 00 00	 call	 ?Remove@AListItem@@QAEPAV1@PAV1@@Z ; AListItem::Remove
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	89 02		 mov	 DWORD PTR [edx], eax
$L32733:

; 64   :             }
; 65   :         };

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?Remove@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::Remove
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsEmpty@AList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsEmpty@AList@@QBEHXZ PROC NEAR			; AList::IsEmpty, COMDAT
; _this$ = ecx

; 68   :     BOOL IsEmpty(void) const {return (m_pHead==NULL);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	0f 94 c1	 sete	 cl
  00012	8b c1		 mov	 eax, ecx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?IsEmpty@AList@@QBEHXZ ENDP				; AList::IsEmpty
_TEXT	ENDS
PUBLIC	??_C@_0GM@BGEGCLPI@Error?3?5GetGlobalParam?$CI?$CJ?5failed?5b@ ; `string'
PUBLIC	??_C@_0EM@OCDJIEKL@Warning?3?5GetGlobalParam?$CI?$CJ?5failed@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::GetGlobalParam', 00H ; `CPerformance::GetGlobalParam'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0GM@BGEGCLPI@Error?3?5GetGlobalParam?$CI?$CJ?5failed?5b@
CONST	SEGMENT
??_C@_0GM@BGEGCLPI@Error?3?5GetGlobalParam?$CI?$CJ?5failed?5b@ DB 'Error:'
	DB	' GetGlobalParam() failed because the passed data size %ld was'
	DB	' inconsistent with %ld, set previously.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OCDJIEKL@Warning?3?5GetGlobalParam?$CI?$CJ?5failed@
CONST	SEGMENT
??_C@_0EM@OCDJIEKL@Warning?3?5GetGlobalParam?$CI?$CJ?5failed@ DB 'Warning'
	DB	': GetGlobalParam() failed because the parameter had never bee'
	DB	'n set.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z
_TEXT	SEGMENT
_hr$ = -8
_pGD$ = -4
_this$ = 8
_rguidType$ = 12
_pData$ = 16
_dwSize$ = 20
?GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z PROC NEAR ; CPerformance::GetGlobalParam, COMDAT

; 8986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8987 :     V_INAME(IDirectMusicPerformance::GetGlobalParam);
; 8988 :     V_REFGUID(rguidType);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L73026
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L73026:

; 8989 : 
; 8990 :     if( dwSize )

  0002e	83 7d 14 00	 cmp	 DWORD PTR _dwSize$[ebp], 0
  00032	74 2a		 je	 SHORT $L73027

; 8991 :     {
; 8992 :         V_BUFPTR_WRITE( pData, dwSize );

  00034	8b 4d 14	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 10	 mov	 edx, DWORD PTR _pData$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $L73027
  00045	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
  0004f	6a ff		 push	 -1
  00051	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 _DebugBreak@0
$L73027:

; 8993 :     }
; 8994 : 
; 8995 :     GlobalData* pGD;
; 8996 :     HRESULT hr = S_OK;

  0005e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8997 :     ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec); 

  00065	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00068	05 68 03 00 00	 add	 eax, 872		; 00000368H
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 8998 :     ENTER_API_CRITICAL_SECTION;
; 8999 :     for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 91 04 01 00
	00		 mov	 edx, DWORD PTR [ecx+260]
  0007d	89 55 fc	 mov	 DWORD PTR _pGD$[ebp], edx
  00080	eb 08		 jmp	 SHORT $L73032
$L73033:
  00082	8b 45 fc	 mov	 eax, DWORD PTR _pGD$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 4d fc	 mov	 DWORD PTR _pGD$[ebp], ecx
$L73032:
  0008a	83 7d fc 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  0008e	74 18		 je	 SHORT $L73034

; 9000 :     {
; 9001 :         if( pGD->guidType == rguidType )

  00090	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  00093	52		 push	 edx
  00094	8b 45 fc	 mov	 eax, DWORD PTR _pGD$[ebp]
  00097	83 c0 04	 add	 eax, 4
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _==@8
  000a0	85 c0		 test	 eax, eax
  000a2	74 02		 je	 SHORT $L73035

; 9002 :         {
; 9003 :             break;

  000a4	eb 02		 jmp	 SHORT $L73034
$L73035:

; 9004 :         }
; 9005 :     }

  000a6	eb da		 jmp	 SHORT $L73033
$L73034:

; 9006 :     if( pGD && ( dwSize == pGD->dwSize ) )

  000a8	83 7d fc 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  000ac	74 27		 je	 SHORT $L73036
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  000b1	8b 55 14	 mov	 edx, DWORD PTR _dwSize$[ebp]
  000b4	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  000b7	75 1c		 jne	 SHORT $L73036

; 9007 :     {
; 9008 :         memcpy( pData, pGD->pData, pGD->dwSize );

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _pGD$[ebp]
  000bc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000bf	51		 push	 ecx
  000c0	8b 55 fc	 mov	 edx, DWORD PTR _pGD$[ebp]
  000c3	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000c6	50		 push	 eax
  000c7	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 _memcpy
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9009 :     }
; 9010 :     else

  000d3	eb 43		 jmp	 SHORT $L73037
$L73036:

; 9011 :     {
; 9012 : #ifdef DBG
; 9013 :         if (pGD && ( dwSize != pGD->dwSize ))

  000d5	83 7d fc 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  000d9	74 27		 je	 SHORT $L73038
  000db	8b 55 fc	 mov	 edx, DWORD PTR _pGD$[ebp]
  000de	8b 45 14	 mov	 eax, DWORD PTR _dwSize$[ebp]
  000e1	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  000e4	74 1c		 je	 SHORT $L73038

; 9014 :         {
; 9015 :             Trace(1,"Error: GetGlobalParam() failed because the passed data size %ld was inconsistent with %ld, set previously.\n",
; 9016 :                 dwSize, pGD->dwSize);

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  000e9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ec	52		 push	 edx
  000ed	8b 45 14	 mov	 eax, DWORD PTR _dwSize$[ebp]
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GM@BGEGCLPI@Error?3?5GetGlobalParam?$CI?$CJ?5failed?5b@
  000f6	6a 01		 push	 1
  000f8	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000fd	83 c4 10	 add	 esp, 16			; 00000010H

; 9017 :         }
; 9018 :         else

  00100	eb 0f		 jmp	 SHORT $L73040
$L73038:

; 9019 :         {
; 9020 :             Trace(4,"Warning: GetGlobalParam() failed because the parameter had never been set.\n");

  00102	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@OCDJIEKL@Warning?3?5GetGlobalParam?$CI?$CJ?5failed@
  00107	6a 04		 push	 4
  00109	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0010e	83 c4 08	 add	 esp, 8
$L73040:

; 9021 :         }
; 9022 : #endif
; 9023 :         hr = E_INVALIDARG;

  00111	c7 45 f8 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L73037:

; 9024 :     }
; 9025 :     LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  00118	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  00121	51		 push	 ecx
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9026 :     LEAVE_API_CRITICAL_SECTION;
; 9027 :     return hr;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 9028 : }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 10 00	 ret	 16			; 00000010H
?GetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z ENDP	; CPerformance::GetGlobalParam
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??_U@YAPAXI@Z PROC NEAR					; operator new[], COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 24   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_U@YAPAXI@Z ENDP					; operator new[]
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??_V@YAXPAX@Z PROC NEAR					; operator delete[], COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 29   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_V@YAXPAX@Z ENDP					; operator delete[]
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	??_C@_0FA@IPKJGLPP@Error?3?5Attempt?5to?5set?5global?5tem@ ; `string'
PUBLIC	??_C@_0FA@DBNAGDNA@Error?3?5Attempt?5to?5set?5global?5vol@ ; `string'
PUBLIC	??_C@_0HF@LGHJJIB@Error?3?5Attempt?5to?5set?5global?5par@ ; `string'
PUBLIC	__real@3c23d70a
EXTRN	_GUID_PerfMasterTempo:BYTE
EXTRN	_GUID_PerfMasterVolume:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::SetGlobalParam', 00H ; `CPerformance::SetGlobalParam'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_C@_0FA@IPKJGLPP@Error?3?5Attempt?5to?5set?5global?5tem@
CONST	SEGMENT
??_C@_0FA@IPKJGLPP@Error?3?5Attempt?5to?5set?5global?5tem@ DB 'Error: Att'
	DB	'empt to set global tempo failed because dwSize is not size of'
	DB	' float.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@DBNAGDNA@Error?3?5Attempt?5to?5set?5global?5vol@
CONST	SEGMENT
??_C@_0FA@DBNAGDNA@Error?3?5Attempt?5to?5set?5global?5vol@ DB 'Error: Att'
	DB	'empt to set global volume failed because dwSize is not size o'
	DB	'f long.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@LGHJJIB@Error?3?5Attempt?5to?5set?5global?5par@
CONST	SEGMENT
??_C@_0HF@LGHJJIB@Error?3?5Attempt?5to?5set?5global?5par@ DB 'Error: Atte'
	DB	'mpt to set global parameter failed because dwSize is not cons'
	DB	'istent with previous SetGlobalParam() call.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z
_TEXT	SEGMENT
tv197 = -28
$T75772 = -24
$T75771 = -20
$T75770 = -16
$T75769 = -12
_flt$73060 = -8
_pGD$ = -4
_this$ = 8
_rguidType$ = 12
_pData$ = 16
_dwSize$ = 20
?SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z PROC NEAR ; CPerformance::SetGlobalParam, COMDAT

; 9048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 9049 :     V_INAME(IDirectMusicPerformance::SetGlobalParam);
; 9050 :     V_REFGUID(rguidType);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L73053
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@BMJBMIKG@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L73053:

; 9051 : 
; 9052 :     if( dwSize )

  0002e	83 7d 14 00	 cmp	 DWORD PTR _dwSize$[ebp], 0
  00032	74 2a		 je	 SHORT $L73054

; 9053 :     {
; 9054 :         V_BUFPTR_READ( pData, dwSize );

  00034	8b 4d 14	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 10	 mov	 edx, DWORD PTR _pData$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $L73054
  00045	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z@4QBDB
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KONEABPP@?$CFs?3?5Invalid?5pointer?5pData?6?$AA@
  0004f	6a ff		 push	 -1
  00051	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 _DebugBreak@0
$L73054:

; 9055 :     }
; 9056 :     GlobalData* pGD;
; 9057 :     // see if this is one of our special Performance globals
; 9058 :     if( rguidType == GUID_PerfMasterTempo )

  0005e	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PerfMasterTempo
  00063	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _==@8
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 c3 00 00
	00		 je	 $L73057

; 9059 :     {
; 9060 :         if( dwSize == sizeof(float) )

  00074	83 7d 14 04	 cmp	 DWORD PTR _dwSize$[ebp], 4
  00078	0f 85 9e 00 00
	00		 jne	 $L73059

; 9061 :         {
; 9062 :             float flt;
; 9063 :             memcpy( &flt, pData, sizeof(float) );

  0007e	6a 04		 push	 4
  00080	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  00083	51		 push	 ecx
  00084	8d 55 f8	 lea	 edx, DWORD PTR _flt$73060[ebp]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9064 :             if( (flt >= DMUS_MASTERTEMPO_MIN) && (flt <= DMUS_MASTERTEMPO_MAX) )

  00090	d9 45 f8	 fld	 DWORD PTR _flt$73060[ebp]
  00093	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3c23d70a
  00099	df e0		 fnstsw	 ax
  0009b	f6 c4 01	 test	 ah, 1
  0009e	75 7a		 jne	 SHORT $L73062
  000a0	d9 45 f8	 fld	 DWORD PTR _flt$73060[ebp]
  000a3	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42c80000
  000a9	df e0		 fnstsw	 ax
  000ab	f6 c4 41	 test	 ah, 65			; 00000041H
  000ae	7a 6a		 jp	 SHORT $L73062

; 9065 :             {
; 9066 :                 if( m_fltRelTempo != flt )

  000b0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	d9 80 e8 02 00
	00		 fld	 DWORD PTR [eax+744]
  000b9	d8 5d f8	 fcomp	 DWORD PTR _flt$73060[ebp]
  000bc	df e0		 fnstsw	 ax
  000be	f6 c4 44	 test	 ah, 68			; 00000044H
  000c1	7b 57		 jnp	 SHORT $L73062

; 9067 :                 {
; 9068 :                     m_fltRelTempo = flt;

  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _flt$73060[ebp]
  000c9	89 91 e8 02 00
	00		 mov	 DWORD PTR [ecx+744], edx

; 9069 :                     // It's only necessary to recalc the tempo map if something is playing
; 9070 :                     ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  000cf	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	05 14 03 00 00	 add	 eax, 788		; 00000314H
  000d7	50		 push	 eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9071 :                     if (GetPrimarySegmentAtTime(m_mtTransported))

  000de	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	8b 91 d0 02 00
	00		 mov	 edx, DWORD PTR [ecx+720]
  000e7	52		 push	 edx
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?GetPrimarySegmentAtTime@CPerformance@@AAEPAVCSegState@@J@Z ; CPerformance::GetPrimarySegmentAtTime
  000f0	85 c0		 test	 eax, eax
  000f2	74 16		 je	 SHORT $L73064

; 9072 :                     {
; 9073 :                         RecalcTempoMap(NULL,m_mtTransported);

  000f4	6a 01		 push	 1
  000f6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  000ff	51		 push	 ecx
  00100	6a 00		 push	 0
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?RecalcTempoMap@CPerformance@@AAEXPAVCSegState@@J_N@Z ; CPerformance::RecalcTempoMap
$L73064:

; 9074 :                     }
; 9075 :                     LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  0010a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00113	52		 push	 edx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L73062:

; 9076 :                 }
; 9077 :             }
; 9078 :         }
; 9079 :         else

  0011a	eb 19		 jmp	 SHORT $L73065
$L73059:

; 9080 :         {
; 9081 :             Trace(1,"Error: Attempt to set global tempo failed because dwSize is not size of float.\n");

  0011c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@IPKJGLPP@Error?3?5Attempt?5to?5set?5global?5tem@
  00121	6a 01		 push	 1
  00123	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00128	83 c4 08	 add	 esp, 8

; 9082 :             return E_INVALIDARG;

  0012b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00130	e9 10 02 00 00	 jmp	 $L73048
$L73065:

; 9083 :         }
; 9084 :     }
; 9085 :     else if( rguidType == GUID_PerfMasterVolume )

  00135	eb 67		 jmp	 SHORT $L73068
$L73057:
  00137	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_PerfMasterVolume
  0013c	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _==@8
  00145	85 c0		 test	 eax, eax
  00147	74 55		 je	 SHORT $L73068

; 9086 :     {
; 9087 :         // master volume
; 9088 :         if( dwSize == sizeof(long) )

  00149	83 7d 14 04	 cmp	 DWORD PTR _dwSize$[ebp], 4
  0014d	75 1a		 jne	 SHORT $L73071

; 9089 :         {
; 9090 :             memcpy( &m_lMasterVolume, pData, sizeof(long) );

  0014f	6a 04		 push	 4
  00151	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00158	81 c2 e4 02 00
	00		 add	 edx, 740		; 000002e4H
  0015e	52		 push	 edx
  0015f	e8 00 00 00 00	 call	 _memcpy
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9091 :         }
; 9092 :         else

  00167	eb 19		 jmp	 SHORT $L73073
$L73071:

; 9093 :         {
; 9094 :             Trace(1,"Error: Attempt to set global volume failed because dwSize is not size of long.\n");

  00169	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@DBNAGDNA@Error?3?5Attempt?5to?5set?5global?5vol@
  0016e	6a 01		 push	 1
  00170	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00175	83 c4 08	 add	 esp, 8

; 9095 :             return E_INVALIDARG;

  00178	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0017d	e9 c3 01 00 00	 jmp	 $L73048
$L73073:

; 9096 :         }
; 9097 : #ifdef DXAPI
; 9098 :         // Go through all Ports and set the master volume.
; 9099 :         // This is also done upon adding a Port.
; 9100 :         DWORD dw;
; 9101 : 
; 9102 :         ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 9103 :         ENTER_API_CRITICAL_SECTION;
; 9104 :         for( dw = 0; dw < m_dwNumPorts; dw++ )
; 9105 :         {
; 9106 :             IDirectMusicPort* pPort = m_pPortTable[dw].pPort;
; 9107 :             if( pPort )
; 9108 :             {
; 9109 :                 IKsControl *pControl;
; 9110 :                 if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
; 9111 :                 {
; 9112 :                     KSPROPERTY ksp;
; 9113 :                     ULONG cb;
; 9114 : 
; 9115 :                     memset(&ksp, 0, sizeof(ksp));
; 9116 :                     ksp.Set   = GUID_DMUS_PROP_Volume;
; 9117 :                     ksp.Id    = 0;
; 9118 :                     ksp.Flags = KSPROPERTY_TYPE_SET;
; 9119 : 
; 9120 :                     pControl->KsProperty(&ksp,
; 9121 :                                          sizeof(ksp),
; 9122 :                                          (LPVOID)&m_lMasterVolume,
; 9123 :                                          sizeof(m_lMasterVolume),
; 9124 :                                          &cb);
; 9125 :                     pControl->Release();
; 9126 :                 }
; 9127 :             }
; 9128 :         }
; 9129 :         LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 9130 :         LEAVE_API_CRITICAL_SECTION;
; 9131 : #else
; 9132 :         m_pSynth->SetMasterVolume(m_lMasterVolume);

  00182	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 88 e4 02 00
	00		 mov	 ecx, DWORD PTR [eax+740]
  0018b	51		 push	 ecx
  0018c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0018f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00192	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00198	8b 00		 mov	 eax, DWORD PTR [eax]
  0019a	52		 push	 edx
  0019b	ff 50 14	 call	 DWORD PTR [eax+20]
$L73068:

; 9133 : #endif
; 9134 :     }
; 9135 : 
; 9136 :     // see if this type is already there. If so, use it.
; 9137 :     ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec); 

  0019e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  001a7	51		 push	 ecx
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9138 :     ENTER_API_CRITICAL_SECTION;
; 9139 :     for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )

  001ae	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001b1	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  001b7	89 45 fc	 mov	 DWORD PTR _pGD$[ebp], eax
  001ba	eb 08		 jmp	 SHORT $L73076
$L73077:
  001bc	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  001bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c1	89 55 fc	 mov	 DWORD PTR _pGD$[ebp], edx
$L73076:
  001c4	83 7d fc 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  001c8	74 18		 je	 SHORT $L73078

; 9140 :     {
; 9141 :         if( pGD->guidType == rguidType )

  001ca	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  001cd	50		 push	 eax
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  001d1	83 c1 04	 add	 ecx, 4
  001d4	51		 push	 ecx
  001d5	e8 00 00 00 00	 call	 _==@8
  001da	85 c0		 test	 eax, eax
  001dc	74 02		 je	 SHORT $L73079

; 9142 :         {
; 9143 :             break;

  001de	eb 02		 jmp	 SHORT $L73078
$L73079:

; 9144 :         }
; 9145 :     }

  001e0	eb da		 jmp	 SHORT $L73077
$L73078:

; 9146 :     LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  001e2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001e5	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  001eb	52		 push	 edx
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9147 :     LEAVE_API_CRITICAL_SECTION;
; 9148 :     // if it already exists, just copy the new data into the
; 9149 :     // existing memory block and return
; 9150 :     if( pGD )

  001f2	83 7d fc 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  001f6	74 48		 je	 SHORT $L73080

; 9151 :     {
; 9152 :         if( pGD->dwSize != dwSize )

  001f8	8b 45 fc	 mov	 eax, DWORD PTR _pGD$[ebp]
  001fb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001fe	3b 4d 14	 cmp	 ecx, DWORD PTR _dwSize$[ebp]
  00201	74 19		 je	 SHORT $L73081

; 9153 :         {
; 9154 :             Trace(1,"Error: Attempt to set global parameter failed because dwSize is not consistent with previous SetGlobalParam() call.\n");

  00203	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0HF@LGHJJIB@Error?3?5Attempt?5to?5set?5global?5par@
  00208	6a 01		 push	 1
  0020a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0020f	83 c4 08	 add	 esp, 8

; 9155 :             return E_INVALIDARG;

  00212	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00217	e9 29 01 00 00	 jmp	 $L73048
$L73081:

; 9156 :         }
; 9157 :         if( dwSize )

  0021c	83 7d 14 00	 cmp	 DWORD PTR _dwSize$[ebp], 0
  00220	74 17		 je	 SHORT $L73084

; 9158 :         {
; 9159 :             memcpy( pGD->pData, pData, dwSize );

  00222	8b 55 14	 mov	 edx, DWORD PTR _dwSize$[ebp]
  00225	52		 push	 edx
  00226	8b 45 10	 mov	 eax, DWORD PTR _pData$[ebp]
  00229	50		 push	 eax
  0022a	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  0022d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00230	52		 push	 edx
  00231	e8 00 00 00 00	 call	 _memcpy
  00236	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73084:

; 9160 :         }
; 9161 :         return S_OK;

  00239	33 c0		 xor	 eax, eax
  0023b	e9 05 01 00 00	 jmp	 $L73048
$L73080:

; 9162 :     }
; 9163 : 
; 9164 :     // otherwise, create new memory
; 9165 :     pGD = new GlobalData;

  00240	6a 1c		 push	 28			; 0000001cH
  00242	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00247	83 c4 04	 add	 esp, 4
  0024a	89 45 f4	 mov	 DWORD PTR $T75769[ebp], eax
  0024d	8b 45 f4	 mov	 eax, DWORD PTR $T75769[ebp]
  00250	f7 d8		 neg	 eax
  00252	1b c0		 sbb	 eax, eax
  00254	23 45 f4	 and	 eax, DWORD PTR $T75769[ebp]
  00257	89 45 fc	 mov	 DWORD PTR _pGD$[ebp], eax

; 9166 :     if( NULL == pGD )

  0025a	83 7d fc 00	 cmp	 DWORD PTR _pGD$[ebp], 0
  0025e	75 0a		 jne	 SHORT $L73088

; 9167 :     {
; 9168 :         return E_OUTOFMEMORY;

  00260	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00265	e9 db 00 00 00	 jmp	 $L73048
$L73088:

; 9169 :     }
; 9170 :     pGD->dwSize = dwSize;

  0026a	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  0026d	8b 55 14	 mov	 edx, DWORD PTR _dwSize$[ebp]
  00270	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 9171 :     if( dwSize )

  00273	83 7d 14 00	 cmp	 DWORD PTR _dwSize$[ebp], 0
  00277	74 69		 je	 SHORT $L73090

; 9172 :     {
; 9173 :         pGD->pData = (void*)(new char[dwSize]);

  00279	8b 45 14	 mov	 eax, DWORD PTR _dwSize$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00282	83 c4 04	 add	 esp, 4
  00285	89 45 f0	 mov	 DWORD PTR $T75770[ebp], eax
  00288	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  0028b	8b 55 f0	 mov	 edx, DWORD PTR $T75770[ebp]
  0028e	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 9174 :         if( NULL == pGD->pData )

  00291	8b 45 fc	 mov	 eax, DWORD PTR _pGD$[ebp]
  00294	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00298	75 2f		 jne	 SHORT $L73094

; 9175 :         {
; 9176 :             delete pGD;

  0029a	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  0029d	89 4d e8	 mov	 DWORD PTR $T75772[ebp], ecx
  002a0	8b 55 e8	 mov	 edx, DWORD PTR $T75772[ebp]
  002a3	89 55 ec	 mov	 DWORD PTR $T75771[ebp], edx
  002a6	83 7d ec 00	 cmp	 DWORD PTR $T75771[ebp], 0
  002aa	74 0f		 je	 SHORT $L75773
  002ac	6a 01		 push	 1
  002ae	8b 4d ec	 mov	 ecx, DWORD PTR $T75771[ebp]
  002b1	e8 00 00 00 00	 call	 ??_GGlobalData@@QAEPAXI@Z
  002b6	89 45 e4	 mov	 DWORD PTR tv197[ebp], eax
  002b9	eb 07		 jmp	 SHORT $L75774
$L75773:
  002bb	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv197[ebp], 0
$L75774:

; 9177 :             return E_OUTOFMEMORY;

  002c2	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  002c7	eb 7c		 jmp	 SHORT $L73048
$L73094:

; 9178 :         }
; 9179 :         memcpy( pGD->pData, pData, dwSize );

  002c9	8b 45 14	 mov	 eax, DWORD PTR _dwSize$[ebp]
  002cc	50		 push	 eax
  002cd	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  002d0	51		 push	 ecx
  002d1	8b 55 fc	 mov	 edx, DWORD PTR _pGD$[ebp]
  002d4	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  002d7	50		 push	 eax
  002d8	e8 00 00 00 00	 call	 _memcpy
  002dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9180 :     }
; 9181 :     else

  002e0	eb 0a		 jmp	 SHORT $L73098
$L73090:

; 9182 :     {
; 9183 :         pGD->pData = NULL;

  002e2	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  002e5	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L73098:

; 9184 :     }
; 9185 :     pGD->guidType = rguidType;

  002ec	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  002ef	8b 45 fc	 mov	 eax, DWORD PTR _pGD$[ebp]
  002f2	83 c0 04	 add	 eax, 4
  002f5	8b 0a		 mov	 ecx, DWORD PTR [edx]
  002f7	89 08		 mov	 DWORD PTR [eax], ecx
  002f9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002fc	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  002ff	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00302	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00305	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00308	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 9186 :     ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec); // just using this one since it's available and not used much

  0030b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0030e	05 68 03 00 00	 add	 eax, 872		; 00000368H
  00313	50		 push	 eax
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9187 :     pGD->pNext = m_pGlobalData;

  0031a	8b 4d fc	 mov	 ecx, DWORD PTR _pGD$[ebp]
  0031d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00320	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  00326	89 01		 mov	 DWORD PTR [ecx], eax

; 9188 :     m_pGlobalData = pGD;

  00328	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0032b	8b 55 fc	 mov	 edx, DWORD PTR _pGD$[ebp]
  0032e	89 91 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edx

; 9189 :     LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

  00334	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00337	05 68 03 00 00	 add	 eax, 872		; 00000368H
  0033c	50		 push	 eax
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9190 :     return S_OK;

  00343	33 c0		 xor	 eax, eax
$L73048:

; 9191 : }

  00345	8b e5		 mov	 esp, ebp
  00347	5d		 pop	 ebp
  00348	c2 10 00	 ret	 16			; 00000010H
?SetGlobalParam@CPerformance@@UAGJABU_GUID@@PAXK@Z ENDP	; CPerformance::SetGlobalParam
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dowork.h
_TEXT	ENDS
;	COMDAT ?WakeUp@CWorker@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?WakeUp@CWorker@@QAEXXZ PROC NEAR			; CWorker::WakeUp, COMDAT
; _this$ = ecx

; 16   :     void        WakeUp() { m_rtWakeUpTime = 0; };   // Tells the worker to wake up as soon as possible.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00011	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?WakeUp@CWorker@@QAEXXZ ENDP				; CWorker::WakeUp
_TEXT	ENDS
PUBLIC	?GetNext@AListItem@@QBEPAV1@XZ			; AListItem::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?GetNext@CTrack@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CTrack@@QAEPAV1@XZ PROC NEAR			; CTrack::GetNext, COMDAT
; _this$ = ecx

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 		return (CTrack*)AListItem::GetNext();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext

; 25   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CTrack@@QAEPAV1@XZ ENDP			; CTrack::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@AListItem@@QBEPAV1@XZ PROC NEAR		; AListItem::GetNext, COMDAT
; _this$ = ecx

; 18   :     AListItem *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNext@AListItem@@QBEPAV1@XZ ENDP			; AListItem::GetNext
_TEXT	ENDS
PUBLIC	?GetHead@AList@@QBEPAVAListItem@@XZ		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?GetHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CTrackList@@QAEPAVCTrack@@XZ PROC NEAR		; CTrackList::GetHead, COMDAT
; _this$ = ecx

; 58   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		return (CTrack*)AList::GetHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead

; 60   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CTrackList@@QAEPAVCTrack@@XZ ENDP		; CTrackList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetHead, COMDAT
; _this$ = ecx

; 35   :     AListItem *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
_TEXT	ENDS
;	COMDAT ?Init@CPerformance@@UAGJPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
_this$ = 8
_pGraph$ = 12
?Init@CPerformance@@UAGJPAUIDirectMusicGraph@@@Z PROC NEAR ; CPerformance::Init, COMDAT

; 9205 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9206 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 9207 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?Init@CPerformance@@UAGJPAUIDirectMusicGraph@@@Z ENDP	; CPerformance::Init
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z
_TEXT	SEGMENT
_this$ = -4
_pbMsg$ = 8
_dwLength$ = 12
_rt$ = 16
_dwGroup$ = 24
?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z PROC NEAR	; CPerformance::SendLongMsg, COMDAT
; _this$ = ecx

; 9234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 9235 :     if (m_pSynth)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0000e	74 26		 je	 SHORT $L73111

; 9236 :     {
; 9237 :         m_pSynth->SendLongMsg(rt,dwGroup,pbMsg,dwLength);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLength$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _pbMsg$[ebp]
  00017	52		 push	 edx
  00018	8b 45 18	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	50		 push	 eax
  00033	ff 51 24	 call	 DWORD PTR [ecx+36]
$L73111:

; 9238 :     }
; 9239 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 14 00	 ret	 20			; 00000014H
?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z ENDP		; CPerformance::SendLongMsg
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\ntfylist.h
_TEXT	ENDS
;	COMDAT ?GetNext@CNotificationItem@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CNotificationItem@@QAEPAV1@XZ PROC NEAR	; CNotificationItem::GetNext, COMDAT
; _this$ = ecx

; 16   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 17   : 		return (CNotificationItem*)AListItem::GetNext();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext

; 18   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CNotificationItem@@QAEPAV1@XZ ENDP		; CNotificationItem::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ PROC NEAR ; CNotificationList::GetHead, COMDAT
; _this$ = ecx

; 28   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		return (CNotificationItem*)AList::GetHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead

; 30   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ENDP ; CNotificationList::GetHead
_TEXT	ENDS
PUBLIC	??_C@_0CN@KPAIOJCO@Play?5note?5failed?5on?5unassigned?5P@ ; `string'
PUBLIC	?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z	; CPerformance::PackNote
;	COMDAT ??_C@_0CN@KPAIOJCO@Play?5note?5failed?5on?5unassigned?5P@
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
??_C@_0CN@KPAIOJCO@Play?5note?5failed?5on?5unassigned?5P@ DB 'Play note f'
	DB	'ailed on unassigned PChannel %ld', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
tv445 = -112
tv406 = -104
tv405 = -96
tv344 = -92
tv290 = -88
_this$ = -84
_rt$73166 = -80
_mtTemp$73160 = -68
_rtTemp$73161 = -64
_pNote$ = -56
_pPriv$ = -52
_hr$ = -48
_dwGroup$ = -44
_nTranspose$ = -40
_dwPortTableIndex$ = -36
_rtLogical$ = -32
_nValue$ = -20
_dwMsg$ = -16
_dwMChannel$ = -12
_pBuffer$ = -8
_pPort$ = -4
_pEvent$ = 8
_rt$ = 12
?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::PackNote, COMDAT
; _this$ = ecx

; 9265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	56		 push	 esi
  00007	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 9266 :     DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pEvent;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0000d	89 45 c8	 mov	 DWORD PTR _pNote$[ebp], eax

; 9267 :     PRIV_PMSG* pPriv = DMUS_TO_PRIV(pEvent);

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00013	83 e9 18	 sub	 ecx, 24			; 00000018H
  00016	89 4d cc	 mov	 DWORD PTR _pPriv$[ebp], ecx

; 9268 :     REFERENCE_TIME rtLogical; // the time the note occurs in logical music time (subtract offset)
; 9269 :     IDirectMusicBuffer* pBuffer = NULL;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pBuffer$[ebp], 0

; 9270 :     IDirectMusicPort* pPort = NULL;

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pPort$[ebp], 0

; 9271 :     DWORD dwMsg;
; 9272 :     DWORD dwGroup, dwMChannel, dwPortTableIndex;
; 9273 :     short nTranspose = 0;

  00027	66 c7 45 d8 00
	00		 mov	 WORD PTR _nTranspose$[ebp], 0

; 9274 :     short nValue;
; 9275 :     HRESULT hr = DMUS_S_FREE;

  0002d	c7 45 d0 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 9276 : 
; 9277 :     if( NULL == pEvent )

  00034	83 7d 08 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  00038	75 0a		 jne	 SHORT $L73137

; 9278 :         return E_INVALIDARG;

  0003a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0003f	e9 26 04 00 00	 jmp	 $L73117
$L73137:

; 9279 : 
; 9280 :     if( FAILED( PChannelIndex( pNote->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel,
; 9281 :         &nTranspose )))

  00044	8d 55 d8	 lea	 edx, DWORD PTR _nTranspose$[ebp]
  00047	52		 push	 edx
  00048	8d 45 f4	 lea	 eax, DWORD PTR _dwMChannel$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d d4	 lea	 ecx, DWORD PTR _dwGroup$[ebp]
  0004f	51		 push	 ecx
  00050	8d 55 dc	 lea	 edx, DWORD PTR _dwPortTableIndex$[ebp]
  00053	52		 push	 edx
  00054	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  00057	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005a	51		 push	 ecx
  0005b	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  00063	85 c0		 test	 eax, eax
  00065	7d 20		 jge	 SHORT $L73140

; 9282 :     {
; 9283 :         Trace(1,"Play note failed on unassigned PChannel %ld\n",pNote->dwPChannel);

  00067	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  0006a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@KPAIOJCO@Play?5note?5failed?5on?5unassigned?5P@
  00073	6a 01		 push	 1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9284 :         return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.

  0007d	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  00082	e9 e3 03 00 00	 jmp	 $L73117
$L73140:

; 9285 :     }
; 9286 : #ifdef DXAPI
; 9287 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 9288 :     if( dwPortTableIndex > m_dwNumPorts )
; 9289 :     {
; 9290 :         pPort = NULL; // the PChannel map is out of range of the number of ports
; 9291 :                     // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
; 9292 :     }
; 9293 :     else
; 9294 :     {
; 9295 :         pPort = m_pPortTable[dwPortTableIndex].pPort;
; 9296 :         if( pPort ) pPort->AddRef();
; 9297 :         pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
; 9298 :         if( pBuffer ) pBuffer->AddRef();
; 9299 :     }
; 9300 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 9301 :     if(pPort && pBuffer )
; 9302 : #endif
; 9303 :     {
; 9304 :         dwMsg = 0;

  00087	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 0

; 9305 :         if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  0008e	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00091	0f b6 51 45	 movzx	 edx, BYTE PTR [ecx+69]
  00095	83 e2 01	 and	 edx, 1
  00098	85 d2		 test	 edx, edx
  0009a	74 52		 je	 SHORT $L73146

; 9306 :         {
; 9307 :             // transpose the note's bMidiValue, and store it in the note so the note off
; 9308 :             // plays the correct pitch.
; 9309 :             nValue = pNote->bMidiValue + nTranspose;

  0009c	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  0009f	0f b6 48 4b	 movzx	 ecx, BYTE PTR [eax+75]
  000a3	0f bf 55 d8	 movsx	 edx, WORD PTR _nTranspose$[ebp]
  000a7	03 ca		 add	 ecx, edx
  000a9	66 89 4d ec	 mov	 WORD PTR _nValue$[ebp], cx

; 9310 :             if( ( nValue > 127 ) || ( nValue < 0 ) 
; 9311 :                 || pNote->mtDuration <= 0 )

  000ad	0f bf 45 ec	 movsx	 eax, WORD PTR _nValue$[ebp]
  000b1	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  000b4	7f 11		 jg	 SHORT $L73148
  000b6	0f bf 4d ec	 movsx	 ecx, WORD PTR _nValue$[ebp]
  000ba	85 c9		 test	 ecx, ecx
  000bc	7c 09		 jl	 SHORT $L73148
  000be	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  000c1	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  000c5	7f 0a		 jg	 SHORT $L73147
$L73148:

; 9312 :             {
; 9313 :                 // don't play this out-of-range or 0-duration note
; 9314 : #ifdef DXAPI
; 9315 :                 pPort->Release();
; 9316 :                 pBuffer->Release();
; 9317 : #endif
; 9318 :                 return DMUS_S_FREE;

  000c7	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  000cc	e9 99 03 00 00	 jmp	 $L73117
$L73147:

; 9319 :             }
; 9320 :             pNote->bMidiValue = (BYTE)nValue;

  000d1	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  000d4	8a 4d ec	 mov	 cl, BYTE PTR _nValue$[ebp]
  000d7	88 48 4b	 mov	 BYTE PTR [eax+75], cl

; 9321 :             dwMsg |= pNote->bVelocity << 16;

  000da	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  000dd	0f b6 42 44	 movzx	 eax, BYTE PTR [edx+68]
  000e1	c1 e0 10	 shl	 eax, 16			; 00000010H
  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  000e7	0b c8		 or	 ecx, eax
  000e9	89 4d f0	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9322 :         }
; 9323 :         else if( rt < pPriv->rtLast )

  000ec	eb 36		 jmp	 SHORT $L73154
$L73146:
  000ee	8b 55 cc	 mov	 edx, DWORD PTR _pPriv$[ebp]
  000f1	89 55 a8	 mov	 DWORD PTR tv290[ebp], edx
  000f4	8b 45 a8	 mov	 eax, DWORD PTR tv290[ebp]
  000f7	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  000fa	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  000fd	7f 25		 jg	 SHORT $L73154
  000ff	7c 0b		 jl	 SHORT $L75809
  00101	8b 55 a8	 mov	 edx, DWORD PTR tv290[ebp]
  00104	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  00107	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0010a	73 18		 jae	 SHORT $L73154
$L75809:

; 9324 :         {
; 9325 :             // the note off will play before the note on. Bad.
; 9326 :             rt = pPriv->rtLast + REF_PER_MIL;

  0010c	8b 4d cc	 mov	 ecx, DWORD PTR _pPriv$[ebp]
  0010f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00112	81 c2 10 27 00
	00		 add	 edx, 10000		; 00002710H
  00118	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0011b	83 d0 00	 adc	 eax, 0
  0011e	89 55 0c	 mov	 DWORD PTR _rt$[ebp], edx
  00121	89 45 10	 mov	 DWORD PTR _rt$[ebp+4], eax
$L73154:

; 9327 :         }
; 9328 :         dwMsg |= pNote->bMidiValue << 8; // set note value

  00124	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00127	0f b6 51 4b	 movzx	 edx, BYTE PTR [ecx+75]
  0012b	c1 e2 08	 shl	 edx, 8
  0012e	8b 45 f0	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00131	0b c2		 or	 eax, edx
  00133	89 45 f0	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9329 :         dwMsg |= dwMChannel; // MIDI Channel

  00136	8b 4d f0	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00139	0b 4d f4	 or	 ecx, DWORD PTR _dwMChannel$[ebp]
  0013c	89 4d f0	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9330 :         if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  0013f	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00142	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00146	83 e0 01	 and	 eax, 1
  00149	85 c0		 test	 eax, eax
  0014b	74 2b		 je	 SHORT $L73156

; 9331 :         {
; 9332 :             dwMsg |= MIDI_NOTEON;

  0014d	8b 4d f0	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00150	81 c9 90 00 00
	00		 or	 ecx, 144		; 00000090H
  00156	89 4d f0	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9333 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 9334 :             m_dwTempNotesPerSecond++;

  00159	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0015c	8b 82 f8 03 00
	00		 mov	 eax, DWORD PTR [edx+1016]
  00162	83 c0 01	 add	 eax, 1
  00165	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	89 81 f8 03 00
	00		 mov	 DWORD PTR [ecx+1016], eax

; 9335 :             UpdateDebugParams();

  0016e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?UpdateDebugParams@CPerformance@@AAEXXZ ; CPerformance::UpdateDebugParams

; 9336 : #endif
; 9337 :         }
; 9338 :         else

  00176	eb 0c		 jmp	 SHORT $L73157
$L73156:

; 9339 :         {
; 9340 :             dwMsg |= MIDI_NOTEOFF;

  00178	8b 55 f0	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  0017b	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00181	89 55 f0	 mov	 DWORD PTR _dwMsg$[ebp], edx
$L73157:

; 9341 :         }
; 9342 :         if (SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup))

  00184	8b 45 d4	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  00187	50		 push	 eax
  00188	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  0018b	83 e9 02	 sub	 ecx, 2
  0018e	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  00191	83 da 00	 sbb	 edx, 0
  00194	52		 push	 edx
  00195	51		 push	 ecx
  00196	8b 45 f0	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00199	50		 push	 eax
  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  0019d	51		 push	 ecx
  0019e	8b 55 f8	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  001a1	52		 push	 edx
  001a2	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg
  001aa	0f b6 c0	 movzx	 eax, al
  001ad	85 c0		 test	 eax, eax
  001af	0f 84 8e 02 00
	00		 je	 $L73158

; 9343 :         {
; 9344 :             ENTER_CRITICAL_SECTION(&m_PipelineCrSec); // to prevent deadlock in MusicToReferenceTime

  001b5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  001be	51		 push	 ecx
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9345 :             ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  001c5	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  001c8	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  001ce	52		 push	 edx
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9346 : #ifdef DXAPI
; 9347 :             m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
; 9348 : #endif
; 9349 :             rtLogical = rt;

  001d5	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  001d8	89 45 e0	 mov	 DWORD PTR _rtLogical$[ebp], eax
  001db	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  001de	89 4d e4	 mov	 DWORD PTR _rtLogical$[ebp+4], ecx

; 9350 :             // subtract the offset if needed, but only for a note on.
; 9351 :             if( pNote->nOffset && (pNote->bFlags & DMUS_NOTEF_NOTEON))

  001e1	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  001e4	0f bf 42 40	 movsx	 eax, WORD PTR [edx+64]
  001e8	85 c0		 test	 eax, eax
  001ea	74 55		 je	 SHORT $L73159
  001ec	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  001ef	0f b6 51 45	 movzx	 edx, BYTE PTR [ecx+69]
  001f3	83 e2 01	 and	 edx, 1
  001f6	85 d2		 test	 edx, edx
  001f8	74 47		 je	 SHORT $L73159

; 9352 :             {
; 9353 :                 MUSIC_TIME mtTemp = pNote->mtTime - pNote->nOffset + 1;

  001fa	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  001fd	0f bf 48 40	 movsx	 ecx, WORD PTR [eax+64]
  00201	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00204	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00207	2b c1		 sub	 eax, ecx
  00209	83 c0 01	 add	 eax, 1
  0020c	89 45 bc	 mov	 DWORD PTR _mtTemp$73160[ebp], eax

; 9354 :                 REFERENCE_TIME rtTemp;
; 9355 :                 MusicToReferenceTime( mtTemp, &rtTemp );

  0020f	8d 4d c0	 lea	 ecx, DWORD PTR _rtTemp$73161[ebp]
  00212	51		 push	 ecx
  00213	8b 55 bc	 mov	 edx, DWORD PTR _mtTemp$73160[ebp]
  00216	52		 push	 edx
  00217	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021c	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0021f	52		 push	 edx
  00220	ff 51 14	 call	 DWORD PTR [ecx+20]

; 9356 :                 if( rtTemp > rtLogical )

  00223	8b 45 c4	 mov	 eax, DWORD PTR _rtTemp$73161[ebp+4]
  00226	3b 45 e4	 cmp	 eax, DWORD PTR _rtLogical$[ebp+4]
  00229	7c 16		 jl	 SHORT $L73159
  0022b	7f 08		 jg	 SHORT $L75810
  0022d	8b 4d c0	 mov	 ecx, DWORD PTR _rtTemp$73161[ebp]
  00230	3b 4d e0	 cmp	 ecx, DWORD PTR _rtLogical$[ebp]
  00233	76 0c		 jbe	 SHORT $L73159
$L75810:

; 9357 :                 {
; 9358 :                     rtLogical = rtTemp;

  00235	8b 55 c0	 mov	 edx, DWORD PTR _rtTemp$73161[ebp]
  00238	89 55 e0	 mov	 DWORD PTR _rtLogical$[ebp], edx
  0023b	8b 45 c4	 mov	 eax, DWORD PTR _rtTemp$73161[ebp+4]
  0023e	89 45 e4	 mov	 DWORD PTR _rtLogical$[ebp+4], eax
$L73159:

; 9359 :                 }
; 9360 :             }
; 9361 : #ifdef DXAPI
; 9362 :             if( m_pPortTable[dwPortTableIndex].rtLast < rtLogical )
; 9363 :             {
; 9364 :                 m_pPortTable[dwPortTableIndex].rtLast = rtLogical;
; 9365 :             }
; 9366 : #else
; 9367 :             if (m_rtLastSendTime < rtLogical)

  00241	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00244	89 4d a4	 mov	 DWORD PTR tv344[ebp], ecx
  00247	8b 55 a4	 mov	 edx, DWORD PTR tv344[ebp]
  0024a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0024d	3b 45 e4	 cmp	 eax, DWORD PTR _rtLogical$[ebp+4]
  00250	7f 1c		 jg	 SHORT $L73163
  00252	7c 0b		 jl	 SHORT $L75811
  00254	8b 4d a4	 mov	 ecx, DWORD PTR tv344[ebp]
  00257	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0025a	3b 55 e0	 cmp	 edx, DWORD PTR _rtLogical$[ebp]
  0025d	73 0f		 jae	 SHORT $L73163
$L75811:

; 9368 :             {
; 9369 :                 m_rtLastSendTime = rtLogical;

  0025f	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00262	8b 4d e0	 mov	 ecx, DWORD PTR _rtLogical$[ebp]
  00265	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00268	8b 55 e4	 mov	 edx, DWORD PTR _rtLogical$[ebp+4]
  0026b	89 50 2c	 mov	 DWORD PTR [eax+44], edx
$L73163:

; 9370 :             }
; 9371 : #endif
; 9372 :             LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0026e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00271	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00276	50		 push	 eax
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9373 :             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  0027d	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00280	81 c1 30 03 00
	00		 add	 ecx, 816		; 00000330H
  00286	51		 push	 ecx
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9374 : 
; 9375 :             if( pNote->bFlags & DMUS_NOTEF_NOTEON )

  0028d	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00290	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00294	83 e0 01	 and	 eax, 1
  00297	85 c0		 test	 eax, eax
  00299	0f 84 a4 01 00
	00		 je	 $L73158

; 9376 :             {
; 9377 :                 pPriv->rtLast = rt;

  0029f	8b 4d cc	 mov	 ecx, DWORD PTR _pPriv$[ebp]
  002a2	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  002a5	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  002a8	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  002ab	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 9378 :                 m_rtHighestPackedNoteOn = rt;

  002ae	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  002b4	89 91 a8 02 00
	00		 mov	 DWORD PTR [ecx+680], edx
  002ba	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  002bd	89 81 ac 02 00
	00		 mov	 DWORD PTR [ecx+684], eax

; 9379 :                 if (pNote->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)

  002c3	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  002c6	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002c9	83 e2 40	 and	 edx, 64			; 00000040H
  002cc	85 d2		 test	 edx, edx
  002ce	0f 84 c6 00 00
	00		 je	 $L73165

; 9380 :                 {
; 9381 :                     // This is a clock time message. 
; 9382 :                     REFERENCE_TIME rt = pNote->rtTime;

  002d4	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  002d7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002da	89 4d b0	 mov	 DWORD PTR _rt$73166[ebp], ecx
  002dd	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  002e0	89 55 b4	 mov	 DWORD PTR _rt$73166[ebp+4], edx

; 9383 :                     pNote->rtTime += (pNote->mtDuration * REF_PER_MIL);

  002e3	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  002e6	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  002e9	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  002ef	99		 cdq
  002f0	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  002f3	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  002f6	03 f0		 add	 esi, eax
  002f8	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  002fb	13 c2		 adc	 eax, edx
  002fd	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00300	89 71 08	 mov	 DWORD PTR [ecx+8], esi
  00303	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 9384 :                     if (pNote->mtDuration > 1)

  00306	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00309	83 7a 38 01	 cmp	 DWORD PTR [edx+56], 1
  0030d	7e 1b		 jle	 SHORT $L73167

; 9385 :                     {
; 9386 :                         pNote->rtTime -= REF_PER_MIL;

  0030f	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  00312	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00315	81 e9 10 27 00
	00		 sub	 ecx, 10000		; 00002710H
  0031b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0031e	83 da 00	 sbb	 edx, 0
  00321	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  00324	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00327	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L73167:

; 9387 :                     }
; 9388 :                     // subtract 1 to guarantee that a note off at the same time as a note on doesn't
; 9389 :                     // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
; 9390 :                     // was zero, so be sure to check that.
; 9391 :                     if( pNote->rtTime < rt + 1 )

  0032a	8b 4d b0	 mov	 ecx, DWORD PTR _rt$73166[ebp]
  0032d	83 c1 01	 add	 ecx, 1
  00330	8b 55 b4	 mov	 edx, DWORD PTR _rt$73166[ebp+4]
  00333	83 d2 00	 adc	 edx, 0
  00336	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  00339	89 45 a0	 mov	 DWORD PTR tv405[ebp], eax
  0033c	89 4d 98	 mov	 DWORD PTR tv406[ebp], ecx
  0033f	89 55 9c	 mov	 DWORD PTR tv406[ebp+4], edx
  00342	8b 4d a0	 mov	 ecx, DWORD PTR tv405[ebp]
  00345	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00348	3b 55 9c	 cmp	 edx, DWORD PTR tv406[ebp+4]
  0034b	7f 22		 jg	 SHORT $L73168
  0034d	7c 0b		 jl	 SHORT $L75812
  0034f	8b 45 a0	 mov	 eax, DWORD PTR tv405[ebp]
  00352	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00355	3b 4d 98	 cmp	 ecx, DWORD PTR tv406[ebp]
  00358	73 15		 jae	 SHORT $L73168
$L75812:

; 9392 :                     {
; 9393 :                         pNote->rtTime = rt + 1;

  0035a	8b 55 b0	 mov	 edx, DWORD PTR _rt$73166[ebp]
  0035d	83 c2 01	 add	 edx, 1
  00360	8b 45 b4	 mov	 eax, DWORD PTR _rt$73166[ebp+4]
  00363	83 d0 00	 adc	 eax, 0
  00366	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00369	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0036c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L73168:

; 9394 :                     }
; 9395 :                     pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now

  0036f	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00372	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00376	83 e0 fe	 and	 eax, -2			; fffffffeH
  00379	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  0037c	88 41 45	 mov	 BYTE PTR [ecx+69], al

; 9396 :                     pNote->dwFlags &= ~DMUS_PMSGF_MUSICTIME; 

  0037f	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00382	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00385	83 e0 fd	 and	 eax, -3			; fffffffdH
  00388	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  0038b	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 9397 :                     hr = DMUS_S_REQUEUE;

  0038e	c7 45 d0 00 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086656 ; 08781200H

; 9398 :                 }
; 9399 :                 else

  00395	e9 92 00 00 00	 jmp	 $L73173
$L73165:

; 9400 :                 {
; 9401 :                     pNote->mtTime += pNote->mtDuration;

  0039a	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  0039d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  003a0	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003a3	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  003a6	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  003a9	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 9402 :                     if (pNote->mtDuration > 1)

  003ac	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  003af	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  003b3	7e 0f		 jle	 SHORT $L73174

; 9403 :                     {
; 9404 :                         pNote->mtTime--;

  003b5	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003b8	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  003bb	83 ea 01	 sub	 edx, 1
  003be	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  003c1	89 50 10	 mov	 DWORD PTR [eax+16], edx
$L73174:

; 9405 :                     }
; 9406 :                     MusicToReferenceTime( pNote->mtTime, &rt );

  003c4	8d 4d 0c	 lea	 ecx, DWORD PTR _rt$[ebp]
  003c7	51		 push	 ecx
  003c8	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  003cb	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  003ce	50		 push	 eax
  003cf	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  003d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d4	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  003d7	50		 push	 eax
  003d8	ff 52 14	 call	 DWORD PTR [edx+20]

; 9407 :                     // subtract 1 to guarantee that a note off at the same time as a note on doesn't
; 9408 :                     // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
; 9409 :                     // was zero, so be sure to check that.
; 9410 :                     if( rt < pNote->rtTime + 2 )

  003db	8b 4d c8	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003de	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003e1	83 c2 02	 add	 edx, 2
  003e4	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  003e7	83 d0 00	 adc	 eax, 0
  003ea	89 55 90	 mov	 DWORD PTR tv445[ebp], edx
  003ed	89 45 94	 mov	 DWORD PTR tv445[ebp+4], eax
  003f0	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  003f3	3b 4d 94	 cmp	 ecx, DWORD PTR tv445[ebp+4]
  003f6	7f 1f		 jg	 SHORT $L73175
  003f8	7c 08		 jl	 SHORT $L75813
  003fa	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  003fd	3b 55 90	 cmp	 edx, DWORD PTR tv445[ebp]
  00400	73 15		 jae	 SHORT $L73175
$L75813:

; 9411 :                     {
; 9412 :                         rt = pNote->rtTime + 2;

  00402	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  00405	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00408	83 c1 02	 add	 ecx, 2
  0040b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0040e	83 d2 00	 adc	 edx, 0
  00411	89 4d 0c	 mov	 DWORD PTR _rt$[ebp], ecx
  00414	89 55 10	 mov	 DWORD PTR _rt$[ebp+4], edx
$L73175:

; 9413 :                     }
; 9414 :                     pNote->rtTime = rt - 1;

  00417	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  0041a	83 e8 01	 sub	 eax, 1
  0041d	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  00420	83 d9 00	 sbb	 ecx, 0
  00423	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00426	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00429	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$L73173:

; 9415 :                 }
; 9416 :                 pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now

  0042c	8b 45 c8	 mov	 eax, DWORD PTR _pNote$[ebp]
  0042f	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  00433	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00436	8b 55 c8	 mov	 edx, DWORD PTR _pNote$[ebp]
  00439	88 4a 45	 mov	 BYTE PTR [edx+69], cl

; 9417 :                 hr = DMUS_S_REQUEUE;

  0043c	c7 45 d0 00 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086656 ; 08781200H
$L73158:

; 9418 :             }
; 9419 :         }
; 9420 :     }
; 9421 :     if( pPort ) pPort->Release();

  00443	83 7d fc 00	 cmp	 DWORD PTR _pPort$[ebp], 0
  00447	74 0c		 je	 SHORT $L73180
  00449	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  0044c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044e	8b 55 fc	 mov	 edx, DWORD PTR _pPort$[ebp]
  00451	52		 push	 edx
  00452	ff 51 08	 call	 DWORD PTR [ecx+8]
$L73180:

; 9422 :     if( pBuffer ) pBuffer->Release();

  00455	83 7d f8 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00459	74 0c		 je	 SHORT $L73181
  0045b	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0045e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00460	8b 55 f8	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00463	52		 push	 edx
  00464	ff 51 08	 call	 DWORD PTR [ecx+8]
$L73181:

; 9423 :     return hr;

  00467	8b 45 d0	 mov	 eax, DWORD PTR _hr$[ebp]
$L73117:

; 9424 : }

  0046a	5e		 pop	 esi
  0046b	8b e5		 mov	 esp, ebp
  0046d	5d		 pop	 ebp
  0046e	c2 0c 00	 ret	 12			; 0000000cH
?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ENDP	; CPerformance::PackNote
_TEXT	ENDS
PUBLIC	?RemoveHead@AList@@QAEPAVAListItem@@XZ		; AList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\ntfylist.h
;	COMDAT ?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ PROC NEAR ; CNotificationList::RemoveHead, COMDAT
; _this$ = ecx

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		return (CNotificationItem*)AList::RemoveHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead

; 34   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CNotificationList@@QAEPAVCNotificationItem@@XZ ENDP ; CNotificationList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@AList@@QAEPAVAListItem@@XZ PROC NEAR	; AList::RemoveHead, COMDAT
; _this$ = ecx

; 71   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 72   :             AListItem *li;
; 73   :             li = m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 74   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L32744

; 75   :             {
; 76   :                 m_pHead = m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 77   :                 li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L32744:

; 78   :             }
; 79   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 80   :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@AList@@QAEPAVAListItem@@XZ ENDP		; AList::RemoveHead
_TEXT	ENDS
PUBLIC	??_C@_0CO@NENCKBIH@Play?5curve?5failed?5on?5unassigned?5@ ; `string'
PUBLIC	?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackCurve
;	COMDAT ??_C@_0CO@NENCKBIH@Play?5curve?5failed?5on?5unassigned?5@
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
??_C@_0CO@NENCKBIH@Play?5curve?5failed?5on?5unassigned?5@ DB 'Play curve '
	DB	'failed on unassigned PChannel %ld', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
tv928 = -100
tv289 = -96
tv232 = -92
tv667 = -88
_this$ = -84
_dwMsg2$73299 = -80
_lTemp$73252 = -76
_lTemp$73254 = -72
_lRange$73249 = -68
_dwCurve$73240 = -64
_dwMergeIndex$73241 = -60
_mt$73226 = -56
_pPrivPMsg$73222 = -52
_rtLatency$73212 = -48
_mtLatency$73213 = -40
_mtTemp$73209 = -36
_fCalcStartValue$ = -32
_hr$ = -28
_pChannelMap$ = -24
_dwMsg$ = -20
_pCurve$ = -16
_fIsStartOfCurve$ = -12
_pBuffer$ = -8
_pPort$ = -4
_pEvent$ = 8
_rt$ = 12
?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::PackCurve, COMDAT
; _this$ = ecx

; 9433 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	56		 push	 esi
  00007	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 9434 :     DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pEvent;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0000d	89 45 f0	 mov	 DWORD PTR _pCurve$[ebp], eax

; 9435 :     IDirectMusicBuffer* pBuffer = NULL;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pBuffer$[ebp], 0

; 9436 :     IDirectMusicPort* pPort = NULL;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pPort$[ebp], 0

; 9437 :     DWORD dwMsg;
; 9438 :     HRESULT hr = DMUS_S_FREE;

  0001e	c7 45 e4 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 9439 :     BOOL fCalcStartValue = FALSE;

  00025	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fCalcStartValue$[ebp], 0

; 9440 :     BOOL fIsStartOfCurve = FALSE;

  0002c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fIsStartOfCurve$[ebp], 0

; 9441 :     CChannelMap *pChannelMap = NULL;

  00033	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pChannelMap$[ebp], 0

; 9442 : 
; 9443 :     if( NULL == pEvent )

  0003a	83 7d 08 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0003e	75 0a		 jne	 SHORT $L73200

; 9444 :         return E_INVALIDARG;

  00040	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00045	e9 b6 09 00 00	 jmp	 $L73186
$L73200:

; 9445 : 
; 9446 :     if ( !(pCurve->bFlags & DMUS_CURVE_STARTED))

  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0004d	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  00051	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00057	85 d2		 test	 edx, edx
  00059	0f 85 7e 01 00
	00		 jne	 $L73202

; 9447 :     {
; 9448 :         fIsStartOfCurve = TRUE;

  0005f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fIsStartOfCurve$[ebp], 1

; 9449 :         pCurve->bFlags |= DMUS_CURVE_STARTED;

  00066	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00069	0f b6 48 53	 movzx	 ecx, BYTE PTR [eax+83]
  0006d	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  00073	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00076	88 4a 53	 mov	 BYTE PTR [edx+83], cl

; 9450 :         // if we're flushing and have never played this curve at all, just free
; 9451 :         // it.
; 9452 :         if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )

  00079	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0007c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0007f	83 e1 20	 and	 ecx, 32			; 00000020H
  00082	85 c9		 test	 ecx, ecx
  00084	74 0a		 je	 SHORT $L73203

; 9453 :         {
; 9454 :             return DMUS_S_FREE;

  00086	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  0008b	e9 70 09 00 00	 jmp	 $L73186
$L73203:

; 9455 :         }
; 9456 :         if (pCurve->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)

  00090	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00093	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00096	83 e0 40	 and	 eax, 64			; 00000040H
  00099	85 c0		 test	 eax, eax
  0009b	0f 84 91 00 00
	00		 je	 $L73208

; 9457 :         {
; 9458 :             // This is a clock time message. Convert the duration into music time. It will act as 
; 9459 :             // a music time message from now on. This does have the downside that if a dramatic tempo
; 9460 :             // change occurs in the middle of a lengthy curve, the end time can be distorted. 
; 9461 :             // But, given the purpose of curves, this is really an unlikely issue.
; 9462 :             MUSIC_TIME mtTemp;
; 9463 :             ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtDuration * REF_PER_MIL),&mtTemp);

  000a1	8d 4d dc	 lea	 ecx, DWORD PTR _mtTemp$73209[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  000a8	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000ab	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  000b1	99		 cdq
  000b2	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000b5	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  000b8	03 f0		 add	 esi, eax
  000ba	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000bd	13 c2		 adc	 eax, edx
  000bf	50		 push	 eax
  000c0	56		 push	 esi
  000c1	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c6	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	50		 push	 eax
  000ca	ff 52 18	 call	 DWORD PTR [edx+24]

; 9464 :             mtTemp -= pCurve->mtTime;

  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000d0	8b 55 dc	 mov	 edx, DWORD PTR _mtTemp$73209[ebp]
  000d3	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  000d6	89 55 dc	 mov	 DWORD PTR _mtTemp$73209[ebp], edx

; 9465 :             pCurve->mtDuration = mtTemp;

  000d9	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  000dc	8b 4d dc	 mov	 ecx, DWORD PTR _mtTemp$73209[ebp]
  000df	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 9466 :             ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtResetDuration * REF_PER_MIL),&mtTemp);

  000e2	8d 55 dc	 lea	 edx, DWORD PTR _mtTemp$73209[ebp]
  000e5	52		 push	 edx
  000e6	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  000e9	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  000ec	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  000f2	99		 cdq
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000f6	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  000f9	03 f0		 add	 esi, eax
  000fb	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000fe	13 c2		 adc	 eax, edx
  00100	50		 push	 eax
  00101	56		 push	 esi
  00102	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	8b 11		 mov	 edx, DWORD PTR [ecx]
  00107	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	50		 push	 eax
  0010b	ff 52 18	 call	 DWORD PTR [edx+24]

; 9467 :             mtTemp -= pCurve->mtTime;

  0010e	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00111	8b 55 dc	 mov	 edx, DWORD PTR _mtTemp$73209[ebp]
  00114	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00117	89 55 dc	 mov	 DWORD PTR _mtTemp$73209[ebp], edx

; 9468 :             pCurve->mtResetDuration = mtTemp;

  0011a	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0011d	8b 4d dc	 mov	 ecx, DWORD PTR _mtTemp$73209[ebp]
  00120	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 9469 :             pCurve->dwFlags &= ~DMUS_PMSGF_LOCKTOREFTIME;

  00123	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00126	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00129	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0012c	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0012f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L73208:

; 9470 :         }
; 9471 :         // store the original start time so we know how far into the curve we are
; 9472 :         if (!pCurve->mtOriginalStart)

  00132	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00135	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  00139	75 0c		 jne	 SHORT $L73210

; 9473 :         {
; 9474 :             pCurve->mtOriginalStart = pCurve->mtTime;

  0013b	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00141	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00144	89 50 3c	 mov	 DWORD PTR [eax+60], edx
$L73210:

; 9475 :         }
; 9476 :         // check the latency clock. Adjust pCurve->mtTime if needed. This can happen
; 9477 :         // if the curve is time-stamped for the past. We only need do this for non-instant
; 9478 :         // curve types.
; 9479 :         if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )

  00147	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0014a	0f b6 48 51	 movzx	 ecx, BYTE PTR [eax+81]
  0014e	83 f9 01	 cmp	 ecx, 1
  00151	0f 84 86 00 00
	00		 je	 $L73202

; 9480 :         {
; 9481 :             REFERENCE_TIME rtLatency = GetLatency();

  00157	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?GetLatency@CPerformance@@AAE_JXZ ; CPerformance::GetLatency
  0015f	89 45 d0	 mov	 DWORD PTR _rtLatency$73212[ebp], eax
  00162	89 55 d4	 mov	 DWORD PTR _rtLatency$73212[ebp+4], edx

; 9482 :             MUSIC_TIME mtLatency;
; 9483 :             ReferenceToMusicTime( rtLatency, &mtLatency );

  00165	8d 55 d8	 lea	 edx, DWORD PTR _mtLatency$73213[ebp]
  00168	52		 push	 edx
  00169	8b 45 d4	 mov	 eax, DWORD PTR _rtLatency$73212[ebp+4]
  0016c	50		 push	 eax
  0016d	8b 4d d0	 mov	 ecx, DWORD PTR _rtLatency$73212[ebp]
  00170	51		 push	 ecx
  00171	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  00174	8b 02		 mov	 eax, DWORD PTR [edx]
  00176	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	51		 push	 ecx
  0017a	ff 50 18	 call	 DWORD PTR [eax+24]

; 9484 :             if( pCurve->mtTime < mtLatency )

  0017d	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00180	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00183	3b 45 d8	 cmp	 eax, DWORD PTR _mtLatency$73213[ebp]
  00186	7d 2e		 jge	 SHORT $L73214

; 9485 :             {
; 9486 :                 if( pCurve->mtTime + pCurve->mtDuration < mtLatency )

  00188	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0018b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0018e	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00191	03 50 38	 add	 edx, DWORD PTR [eax+56]
  00194	3b 55 d8	 cmp	 edx, DWORD PTR _mtLatency$73213[ebp]
  00197	7d 14		 jge	 SHORT $L73215

; 9487 :                 {
; 9488 :                     // If it is far enough in the past,
; 9489 :                     // we only need to send out the final value.
; 9490 :                     pCurve->mtTime += pCurve->mtDuration;

  00199	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0019c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0019f	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001a2	03 50 38	 add	 edx, DWORD PTR [eax+56]
  001a5	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001a8	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 9491 :                 }
; 9492 :                 else

  001ab	eb 09		 jmp	 SHORT $L73214
$L73215:

; 9493 :                 {
; 9494 :                     pCurve->mtTime = mtLatency;

  001ad	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001b0	8b 45 d8	 mov	 eax, DWORD PTR _mtLatency$73213[ebp]
  001b3	89 42 10	 mov	 DWORD PTR [edx+16], eax
$L73214:

; 9495 :                 }
; 9496 :             }
; 9497 :             // If this is the start of a curve and we are supposed to start with the current playing value...
; 9498 :             if (pCurve->bFlags & DMUS_CURVE_START_FROM_CURRENT)

  001b6	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001b9	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  001bd	83 e2 02	 and	 edx, 2
  001c0	85 d2		 test	 edx, edx
  001c2	74 09		 je	 SHORT $L73217

; 9499 :             {
; 9500 :                 fCalcStartValue = TRUE;

  001c4	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fCalcStartValue$[ebp], 1

; 9501 :             }
; 9502 :             else

  001cb	eb 10		 jmp	 SHORT $L73202
$L73217:

; 9503 :             {
; 9504 :                 pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.

  001cd	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 ?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurveTimeSlice
  001d6	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001d9	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax
$L73202:

; 9505 :             }
; 9506 :         }
; 9507 :     }
; 9508 :     // it is necessary to check reset duration >= 0 because it could have been set
; 9509 :     // to be negative by the flushing, and we don't want to toss it in that case.
; 9510 :     // (should no longer be necessary to check, as a result of fixing 33987)
; 9511 :     if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && (pCurve->mtResetDuration >= 0) && ( pCurve->mtTime == 
; 9512 :         pCurve->mtDuration + pCurve->mtResetDuration + pCurve->mtOriginalStart ))

  001dd	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001e0	0f b6 42 53	 movzx	 eax, BYTE PTR [edx+83]
  001e4	83 e0 01	 and	 eax, 1
  001e7	85 c0		 test	 eax, eax
  001e9	0f 84 e1 00 00
	00		 je	 $L73220
  001ef	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001f2	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  001f6	0f 8c d4 00 00
	00		 jl	 $L73220
  001fc	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001ff	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00202	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00205	03 41 40	 add	 eax, DWORD PTR [ecx+64]
  00208	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0020b	03 42 3c	 add	 eax, DWORD PTR [edx+60]
  0020e	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00211	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00214	0f 85 b6 00 00
	00		 jne	 $L73220

; 9513 :     {
; 9514 :         if( !( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH ) )

  0021a	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0021d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00220	83 e0 20	 and	 eax, 32			; 00000020H
  00223	85 c0		 test	 eax, eax
  00225	0f 85 a5 00 00
	00		 jne	 $L73220

; 9515 :         {
; 9516 :             PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pEvent);

  0022b	8b 4d 08	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0022e	83 e9 18	 sub	 ecx, 24			; 00000018H
  00231	89 4d cc	 mov	 DWORD PTR _pPrivPMsg$73222[ebp], ecx

; 9517 :             if ( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_FLUSH) )

  00234	8b 55 cc	 mov	 edx, DWORD PTR _pPrivPMsg$73222[ebp]
  00237	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0023a	83 e0 08	 and	 eax, 8
  0023d	85 c0		 test	 eax, eax
  0023f	0f 84 81 00 00
	00		 je	 $L73225

; 9518 :             {
; 9519 :                 pPrivPMsg->dwPrivFlags &= ~PRIV_FLAG_FLUSH;

  00245	8b 4d cc	 mov	 ecx, DWORD PTR _pPrivPMsg$73222[ebp]
  00248	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0024b	83 e2 f7	 and	 edx, -9			; fffffff7H
  0024e	8b 45 cc	 mov	 eax, DWORD PTR _pPrivPMsg$73222[ebp]
  00251	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 9520 :                 pCurve->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;

  00254	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00257	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0025a	83 ca 20	 or	 edx, 32			; 00000020H
  0025d	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00260	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 9521 :                 MUSIC_TIME mt = 0;

  00263	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _mt$73226[ebp], 0

; 9522 :                 if( rt <= pPrivPMsg->rtLast )

  0026a	8b 4d cc	 mov	 ecx, DWORD PTR _pPrivPMsg$73222[ebp]
  0026d	89 4d a8	 mov	 DWORD PTR tv667[ebp], ecx
  00270	8b 55 a8	 mov	 edx, DWORD PTR tv667[ebp]
  00273	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  00276	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00279	7f 32		 jg	 SHORT $L73227
  0027b	7c 0b		 jl	 SHORT $L75823
  0027d	8b 4d a8	 mov	 ecx, DWORD PTR tv667[ebp]
  00280	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  00283	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00286	77 25		 ja	 SHORT $L73227
$L75823:

; 9523 :                 {
; 9524 :                     return PackCurve( pEvent, pPrivPMsg->rtLast + REF_PER_MIL );

  00288	8b 45 cc	 mov	 eax, DWORD PTR _pPrivPMsg$73222[ebp]
  0028b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0028e	81 c1 10 27 00
	00		 add	 ecx, 10000		; 00002710H
  00294	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00297	83 d2 00	 adc	 edx, 0
  0029a	52		 push	 edx
  0029b	51		 push	 ecx
  0029c	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0029f	50		 push	 eax
  002a0	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	e8 00 00 00 00	 call	 ?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackCurve
  002a8	e9 53 07 00 00	 jmp	 $L73186
$L73227:

; 9525 :                 }
; 9526 :                 else
; 9527 :                 {
; 9528 :                     return PackCurve( pEvent, rt );

  002ad	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  002b0	51		 push	 ecx
  002b1	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  002b4	52		 push	 edx
  002b5	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  002b8	50		 push	 eax
  002b9	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	e8 00 00 00 00	 call	 ?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackCurve
  002c1	e9 3a 07 00 00	 jmp	 $L73186
$L73225:

; 9529 :                 }
; 9530 :             }
; 9531 :             else
; 9532 :             {
; 9533 :                 // the reset duration has expired, and we're not flushing, so expire the event.
; 9534 :                 return DMUS_S_FREE;

  002c6	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  002cb	e9 30 07 00 00	 jmp	 $L73186
$L73220:

; 9535 :             }
; 9536 :         }
; 9537 :     }
; 9538 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  002d0	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  002d9	51		 push	 ecx
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9539 :     pChannelMap = GetPChannelMap(pCurve->dwPChannel);

  002e0	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  002e3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002e6	50		 push	 eax
  002e7	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  002ea	e8 00 00 00 00	 call	 ?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z ; CPerformance::GetPChannelMap
  002ef	89 45 e8	 mov	 DWORD PTR _pChannelMap$[ebp], eax

; 9540 :     if (!pChannelMap)

  002f2	83 7d e8 00	 cmp	 DWORD PTR _pChannelMap$[ebp], 0
  002f6	75 2f		 jne	 SHORT $L73234

; 9541 :     {
; 9542 :         Trace(1,"Play curve failed on unassigned PChannel %ld\n",pCurve->dwPChannel);

  002f8	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  002fb	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  002fe	52		 push	 edx
  002ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@NENCKBIH@Play?5curve?5failed?5on?5unassigned?5@
  00304	6a 01		 push	 1
  00306	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0030b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9543 :         LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0030e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00311	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00316	50		 push	 eax
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9544 :         return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.

  0031d	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  00322	e9 d9 06 00 00	 jmp	 $L73186
$L73234:

; 9545 :     }
; 9546 : #ifdef DXAPI
; 9547 :     if( pChannelMap->dwPortIndex > m_dwNumPorts )
; 9548 :     {
; 9549 :         pPort = NULL; // the PChannel map is out of range of the number of ports
; 9550 :                     // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
; 9551 :     }
; 9552 :     else
; 9553 :     {
; 9554 :         pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
; 9555 :         if( pPort ) pPort->AddRef();
; 9556 :         pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
; 9557 :         if( pBuffer ) pBuffer->AddRef();
; 9558 :     }
; 9559 :     if( pPort && pBuffer)
; 9560 : #endif
; 9561 :     {
; 9562 :         DWORD dwCurve;
; 9563 :         DWORD dwMergeIndex = 0;

  00327	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _dwMergeIndex$73241[ebp], 0

; 9564 :         dwMsg = 0; 

  0032e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 0

; 9565 :         if (pCurve->dwFlags & DMUS_PMSGF_DX8)

  00335	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00338	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0033b	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00341	85 d2		 test	 edx, edx
  00343	74 0a		 je	 SHORT $L73242

; 9566 :         {
; 9567 :             dwMergeIndex = pCurve->wMergeIndex;

  00345	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00348	0f b7 48 56	 movzx	 ecx, WORD PTR [eax+86]
  0034c	89 4d c4	 mov	 DWORD PTR _dwMergeIndex$73241[ebp], ecx
$L73242:

; 9568 :         }
; 9569 :         switch( pCurve->bType )
; 9570 :         {

  0034f	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00352	0f b6 42 50	 movzx	 eax, BYTE PTR [edx+80]
  00356	89 45 a4	 mov	 DWORD PTR tv232[ebp], eax
  00359	8b 4d a4	 mov	 ecx, DWORD PTR tv232[ebp]
  0035c	83 e9 03	 sub	 ecx, 3
  0035f	89 4d a4	 mov	 DWORD PTR tv232[ebp], ecx
  00362	83 7d a4 05	 cmp	 DWORD PTR tv232[ebp], 5
  00366	0f 87 bf 05 00
	00		 ja	 $L73244
  0036c	8b 55 a4	 mov	 edx, DWORD PTR tv232[ebp]
  0036f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L75825[edx*4]
$L73247:

; 9571 :         case DMUS_CURVET_PBCURVE:
; 9572 :             if (fIsStartOfCurve)

  00376	83 7d f4 00	 cmp	 DWORD PTR _fIsStartOfCurve$[ebp], 0
  0037a	0f 84 b4 00 00
	00		 je	 $L73248

; 9573 :             {
; 9574 :                 // This is the start of the curve, so convert all values to 
; 9575 :                 // pitch cents (100ths of a semitone). The pitch range is set
; 9576 :                 // to this in the synth and we trap all calls to set the range
; 9577 :                 // and store the value in pChannelMap->m_PitchbendMerger.m_lBendRange.
; 9578 :                 long lRange = pCurve->wParamType;   // Store the range here.

  00380	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00383	0f b7 48 54	 movzx	 ecx, WORD PTR [eax+84]
  00387	89 4d bc	 mov	 DWORD PTR _lRange$73249[ebp], ecx

; 9579 :                 pCurve->wParamType = 0;             // Make sure this now reflects full range.

  0038a	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0038d	66 c7 42 54 00
	00		 mov	 WORD PTR [edx+84], 0

; 9580 :                 if (!lRange)

  00393	83 7d bc 00	 cmp	 DWORD PTR _lRange$73249[ebp], 0
  00397	75 09		 jne	 SHORT $L73250

; 9581 :                 {   
; 9582 :                     lRange = pChannelMap->m_PitchbendMerger.m_lBendRange;

  00399	8b 45 e8	 mov	 eax, DWORD PTR _pChannelMap$[ebp]
  0039c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0039f	89 4d bc	 mov	 DWORD PTR _lRange$73249[ebp], ecx
$L73250:

; 9583 :                 }
; 9584 : 
; 9585 :                 if (!fCalcStartValue)

  003a2	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  003a6	75 46		 jne	 SHORT $L73251

; 9586 :                 {
; 9587 :                     long lTemp = pCurve->nStartValue - 0x2000;

  003a8	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  003ab	0f bf 42 44	 movsx	 eax, WORD PTR [edx+68]
  003af	2d 00 20 00 00	 sub	 eax, 8192		; 00002000H
  003b4	89 45 b4	 mov	 DWORD PTR _lTemp$73252[ebp], eax

; 9588 :                     lTemp *= lRange;

  003b7	8b 4d b4	 mov	 ecx, DWORD PTR _lTemp$73252[ebp]
  003ba	0f af 4d bc	 imul	 ecx, DWORD PTR _lRange$73249[ebp]
  003be	89 4d b4	 mov	 DWORD PTR _lTemp$73252[ebp], ecx

; 9589 :                     lTemp += 0x1000;    // handle rounding up.

  003c1	8b 55 b4	 mov	 edx, DWORD PTR _lTemp$73252[ebp]
  003c4	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  003ca	89 55 b4	 mov	 DWORD PTR _lTemp$73252[ebp], edx

; 9590 :                     lTemp /= 0x2000;

  003cd	8b 45 b4	 mov	 eax, DWORD PTR _lTemp$73252[ebp]
  003d0	99		 cdq
  003d1	81 e2 ff 1f 00
	00		 and	 edx, 8191		; 00001fffH
  003d7	03 c2		 add	 eax, edx
  003d9	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  003dc	89 45 b4	 mov	 DWORD PTR _lTemp$73252[ebp], eax

; 9591 :                     pCurve->nStartValue = (short) (lTemp + 0x2000);

  003df	8b 45 b4	 mov	 eax, DWORD PTR _lTemp$73252[ebp]
  003e2	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  003e7	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  003ea	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$L73251:

; 9592 :                 }
; 9593 :                 long lTemp = pCurve->nEndValue - 0x2000;

  003ee	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  003f1	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  003f5	2d 00 20 00 00	 sub	 eax, 8192		; 00002000H
  003fa	89 45 b8	 mov	 DWORD PTR _lTemp$73254[ebp], eax

; 9594 :                 lTemp *= lRange;

  003fd	8b 4d b8	 mov	 ecx, DWORD PTR _lTemp$73254[ebp]
  00400	0f af 4d bc	 imul	 ecx, DWORD PTR _lRange$73249[ebp]
  00404	89 4d b8	 mov	 DWORD PTR _lTemp$73254[ebp], ecx

; 9595 :                 lTemp += 0x1000;        // handle rounding up.

  00407	8b 55 b8	 mov	 edx, DWORD PTR _lTemp$73254[ebp]
  0040a	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  00410	89 55 b8	 mov	 DWORD PTR _lTemp$73254[ebp], edx

; 9596 :                 lTemp /= 0x2000;

  00413	8b 45 b8	 mov	 eax, DWORD PTR _lTemp$73254[ebp]
  00416	99		 cdq
  00417	81 e2 ff 1f 00
	00		 and	 edx, 8191		; 00001fffH
  0041d	03 c2		 add	 eax, edx
  0041f	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  00422	89 45 b8	 mov	 DWORD PTR _lTemp$73254[ebp], eax

; 9597 :                 pCurve->nEndValue = (short) (lTemp + 0x2000);

  00425	8b 45 b8	 mov	 eax, DWORD PTR _lTemp$73254[ebp]
  00428	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  0042d	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00430	66 89 41 46	 mov	 WORD PTR [ecx+70], ax
$L73248:

; 9598 :             }
; 9599 :             if (fCalcStartValue)

  00434	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  00438	74 1e		 je	 SHORT $L73256

; 9600 :             {
; 9601 :                 pCurve->nStartValue = 
; 9602 :                     (short) pChannelMap->m_PitchbendMerger.GetIndexedValue(dwMergeIndex) + 0x2000;

  0043a	8b 55 c4	 mov	 edx, DWORD PTR _dwMergeIndex$73241[ebp]
  0043d	52		 push	 edx
  0043e	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00441	83 c1 24	 add	 ecx, 36			; 00000024H
  00444	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  00449	0f bf c0	 movsx	 eax, ax
  0044c	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00451	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00454	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$L73256:

; 9603 :             }
; 9604 :             dwCurve = ComputeCurve( pCurve );

  00458	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0045b	52		 push	 edx
  0045c	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  00461	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9605 :             dwCurve = pChannelMap->m_PitchbendMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x2000,0x3FFF);

  00464	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00469	68 00 20 00 00	 push	 8192			; 00002000H
  0046e	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  00471	50		 push	 eax
  00472	8b 4d c4	 mov	 ecx, DWORD PTR _dwMergeIndex$73241[ebp]
  00475	51		 push	 ecx
  00476	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00479	83 c1 24	 add	 ecx, 36			; 00000024H
  0047c	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  00481	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9606 :             dwMsg = MIDI_PBEND;

  00484	c7 45 ec e0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 224 ; 000000e0H

; 9607 :             dwMsg |= ( (dwCurve & 0x7F) << 8);

  0048b	8b 55 c0	 mov	 edx, DWORD PTR _dwCurve$73240[ebp]
  0048e	83 e2 7f	 and	 edx, 127		; 0000007fH
  00491	c1 e2 08	 shl	 edx, 8
  00494	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00497	0b c2		 or	 eax, edx
  00499	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9608 :             dwCurve = dwCurve >> 7;

  0049c	8b 4d c0	 mov	 ecx, DWORD PTR _dwCurve$73240[ebp]
  0049f	c1 e9 07	 shr	 ecx, 7
  004a2	89 4d c0	 mov	 DWORD PTR _dwCurve$73240[ebp], ecx

; 9609 :             dwMsg |= ( (dwCurve & 0x7F) << 16);

  004a5	8b 55 c0	 mov	 edx, DWORD PTR _dwCurve$73240[ebp]
  004a8	83 e2 7f	 and	 edx, 127		; 0000007fH
  004ab	c1 e2 10	 shl	 edx, 16			; 00000010H
  004ae	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  004b1	0b c2		 or	 eax, edx
  004b3	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9610 :             break;

  004b6	e9 70 04 00 00	 jmp	 $L73244
$L73259:

; 9611 :         case DMUS_CURVET_CCCURVE:
; 9612 :             switch (pCurve->bCCData)
; 9613 :             {

  004bb	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  004be	0f b6 51 52	 movzx	 edx, BYTE PTR [ecx+82]
  004c2	89 55 a0	 mov	 DWORD PTR tv289[ebp], edx
  004c5	8b 45 a0	 mov	 eax, DWORD PTR tv289[ebp]
  004c8	83 e8 01	 sub	 eax, 1
  004cb	89 45 a0	 mov	 DWORD PTR tv289[ebp], eax
  004ce	83 7d a0 78	 cmp	 DWORD PTR tv289[ebp], 120 ; 00000078H
  004d2	0f 87 38 02 00
	00		 ja	 $L73293
  004d8	8b 4d a0	 mov	 ecx, DWORD PTR tv289[ebp]
  004db	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $L75824[ecx]
  004e2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L75826[edx*4]
$L73264:

; 9614 :             case MIDI_CC_MOD_WHEEL:
; 9615 :                 if (fCalcStartValue)

  004e9	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  004ed	74 1c		 je	 SHORT $L73265

; 9616 :                 {
; 9617 :                     pCurve->nStartValue = 
; 9618 :                         (short) pChannelMap->m_ModWheelMerger.GetIndexedValue(dwMergeIndex) + 0x7F;

  004ef	8b 45 c4	 mov	 eax, DWORD PTR _dwMergeIndex$73241[ebp]
  004f2	50		 push	 eax
  004f3	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  004f6	83 c1 4c	 add	 ecx, 76			; 0000004cH
  004f9	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  004fe	0f bf c8	 movsx	 ecx, ax
  00501	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00504	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00507	66 89 4a 44	 mov	 WORD PTR [edx+68], cx
$L73265:

; 9619 :                 }
; 9620 :                 dwCurve = ComputeCurve( pCurve );

  0050b	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0050e	50		 push	 eax
  0050f	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  00514	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9621 :                 dwCurve = pChannelMap->m_ModWheelMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);

  00517	6a 7f		 push	 127			; 0000007fH
  00519	6a 7f		 push	 127			; 0000007fH
  0051b	8b 4d c0	 mov	 ecx, DWORD PTR _dwCurve$73240[ebp]
  0051e	51		 push	 ecx
  0051f	8b 55 c4	 mov	 edx, DWORD PTR _dwMergeIndex$73241[ebp]
  00522	52		 push	 edx
  00523	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00526	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00529	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  0052e	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9622 :                 break;

  00531	e9 e6 01 00 00	 jmp	 $L73261
$L73268:

; 9623 :             case MIDI_CC_VOLUME:
; 9624 :                 if (fCalcStartValue)

  00536	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  0053a	74 17		 je	 SHORT $L73269

; 9625 :                 {
; 9626 :                     pCurve->nStartValue = 
; 9627 :                         (short) pChannelMap->m_VolumeMerger.GetVolumeStart(dwMergeIndex);

  0053c	8b 45 c4	 mov	 eax, DWORD PTR _dwMergeIndex$73241[ebp]
  0053f	50		 push	 eax
  00540	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00543	e8 00 00 00 00	 call	 ?GetVolumeStart@CParamMerger@@QAEEK@Z ; CParamMerger::GetVolumeStart
  00548	66 0f b6 c8	 movzx	 cx, al
  0054c	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0054f	66 89 4a 44	 mov	 WORD PTR [edx+68], cx
$L73269:

; 9628 : //                    DbgPrint("S%ld,",pCurve->nStartValue); 
; 9629 :                 }
; 9630 :                 dwCurve = ComputeCurve( pCurve );

  00553	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00556	50		 push	 eax
  00557	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  0055c	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9631 : //                DbgPrint("(%ld)%ld->",(long)(rt),dwCurve);
; 9632 :                 dwCurve = pChannelMap->m_VolumeMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);

  0055f	8a 4d c0	 mov	 cl, BYTE PTR _dwCurve$73240[ebp]
  00562	51		 push	 ecx
  00563	8b 55 c4	 mov	 edx, DWORD PTR _dwMergeIndex$73241[ebp]
  00566	52		 push	 edx
  00567	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0056a	e8 00 00 00 00	 call	 ?MergeMidiVolume@CParamMerger@@QAEEKE@Z ; CParamMerger::MergeMidiVolume
  0056f	0f b6 c0	 movzx	 eax, al
  00572	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9633 : //                DbgPrint("%ld, ",dwCurve);
; 9634 :                 break;

  00575	e9 a2 01 00 00	 jmp	 $L73261
$L73272:

; 9635 :             case MIDI_CC_PAN:
; 9636 :                 if (fCalcStartValue)

  0057a	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  0057e	74 1c		 je	 SHORT $L73273

; 9637 :                 {
; 9638 :                     pCurve->nStartValue = 
; 9639 :                         (short) pChannelMap->m_PanMerger.GetIndexedValue(dwMergeIndex) + 0x40;

  00580	8b 4d c4	 mov	 ecx, DWORD PTR _dwMergeIndex$73241[ebp]
  00583	51		 push	 ecx
  00584	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00587	83 c1 34	 add	 ecx, 52			; 00000034H
  0058a	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  0058f	0f bf d0	 movsx	 edx, ax
  00592	83 c2 40	 add	 edx, 64			; 00000040H
  00595	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00598	66 89 50 44	 mov	 WORD PTR [eax+68], dx
$L73273:

; 9640 :                 }
; 9641 :                 dwCurve = ComputeCurve( pCurve );

  0059c	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0059f	51		 push	 ecx
  005a0	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  005a5	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9642 :                 dwCurve = pChannelMap->m_PanMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);

  005a8	6a 7f		 push	 127			; 0000007fH
  005aa	6a 40		 push	 64			; 00000040H
  005ac	8b 55 c0	 mov	 edx, DWORD PTR _dwCurve$73240[ebp]
  005af	52		 push	 edx
  005b0	8b 45 c4	 mov	 eax, DWORD PTR _dwMergeIndex$73241[ebp]
  005b3	50		 push	 eax
  005b4	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  005b7	83 c1 34	 add	 ecx, 52			; 00000034H
  005ba	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  005bf	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9643 :                 break;

  005c2	e9 55 01 00 00	 jmp	 $L73261
$L73276:

; 9644 :             case MIDI_CC_EXPRESSION:
; 9645 :                 if (fCalcStartValue)

  005c7	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  005cb	74 1a		 je	 SHORT $L73277

; 9646 :                 {
; 9647 :                     pCurve->nStartValue = 
; 9648 :                         (short) pChannelMap->m_ExpressionMerger.GetVolumeStart(dwMergeIndex);

  005cd	8b 4d c4	 mov	 ecx, DWORD PTR _dwMergeIndex$73241[ebp]
  005d0	51		 push	 ecx
  005d1	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  005d4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  005d7	e8 00 00 00 00	 call	 ?GetVolumeStart@CParamMerger@@QAEEK@Z ; CParamMerger::GetVolumeStart
  005dc	66 0f b6 d0	 movzx	 dx, al
  005e0	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  005e3	66 89 50 44	 mov	 WORD PTR [eax+68], dx
$L73277:

; 9649 :                 }
; 9650 :                 dwCurve = ComputeCurve( pCurve );

  005e7	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  005ea	51		 push	 ecx
  005eb	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  005f0	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9651 :                 dwCurve = pChannelMap->m_ExpressionMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);

  005f3	8a 55 c0	 mov	 dl, BYTE PTR _dwCurve$73240[ebp]
  005f6	52		 push	 edx
  005f7	8b 45 c4	 mov	 eax, DWORD PTR _dwMergeIndex$73241[ebp]
  005fa	50		 push	 eax
  005fb	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  005fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00601	e8 00 00 00 00	 call	 ?MergeMidiVolume@CParamMerger@@QAEEKE@Z ; CParamMerger::MergeMidiVolume
  00606	0f b6 c8	 movzx	 ecx, al
  00609	89 4d c0	 mov	 DWORD PTR _dwCurve$73240[ebp], ecx

; 9652 :                 break;

  0060c	e9 0b 01 00 00	 jmp	 $L73261
$L73280:

; 9653 :             case MIDI_CC_FILTER:
; 9654 :                 if (fCalcStartValue)

  00611	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  00615	74 1c		 je	 SHORT $L73281

; 9655 :                 {
; 9656 :                     pCurve->nStartValue = 
; 9657 :                         (short) pChannelMap->m_FilterMerger.GetIndexedValue(dwMergeIndex) + 0x40;

  00617	8b 55 c4	 mov	 edx, DWORD PTR _dwMergeIndex$73241[ebp]
  0061a	52		 push	 edx
  0061b	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0061e	83 c1 40	 add	 ecx, 64			; 00000040H
  00621	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  00626	0f bf c0	 movsx	 eax, ax
  00629	83 c0 40	 add	 eax, 64			; 00000040H
  0062c	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0062f	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$L73281:

; 9658 :                 }
; 9659 :                 dwCurve = ComputeCurve( pCurve );

  00633	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00636	52		 push	 edx
  00637	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  0063c	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9660 :                 dwCurve = pChannelMap->m_FilterMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);

  0063f	6a 7f		 push	 127			; 0000007fH
  00641	6a 40		 push	 64			; 00000040H
  00643	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  00646	50		 push	 eax
  00647	8b 4d c4	 mov	 ecx, DWORD PTR _dwMergeIndex$73241[ebp]
  0064a	51		 push	 ecx
  0064b	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0064e	83 c1 40	 add	 ecx, 64			; 00000040H
  00651	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  00656	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9661 :                 break;

  00659	e9 be 00 00 00	 jmp	 $L73261
$L73284:

; 9662 :             case MIDI_CC_REVERB:
; 9663 :                 if (fCalcStartValue)

  0065e	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  00662	74 1c		 je	 SHORT $L73285

; 9664 :                 {
; 9665 :                     pCurve->nStartValue = 
; 9666 :                         (short) pChannelMap->m_ReverbMerger.GetIndexedValue(dwMergeIndex) + 0x7F;

  00664	8b 55 c4	 mov	 edx, DWORD PTR _dwMergeIndex$73241[ebp]
  00667	52		 push	 edx
  00668	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0066b	83 c1 58	 add	 ecx, 88			; 00000058H
  0066e	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  00673	0f bf c0	 movsx	 eax, ax
  00676	83 c0 7f	 add	 eax, 127		; 0000007fH
  00679	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0067c	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$L73285:

; 9667 :                 }
; 9668 :                 dwCurve = ComputeCurve( pCurve );

  00680	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00683	52		 push	 edx
  00684	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  00689	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9669 :                 dwCurve = pChannelMap->m_ReverbMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);

  0068c	6a 7f		 push	 127			; 0000007fH
  0068e	6a 7f		 push	 127			; 0000007fH
  00690	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  00693	50		 push	 eax
  00694	8b 4d c4	 mov	 ecx, DWORD PTR _dwMergeIndex$73241[ebp]
  00697	51		 push	 ecx
  00698	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0069b	83 c1 58	 add	 ecx, 88			; 00000058H
  0069e	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  006a3	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9670 :                 break;

  006a6	eb 74		 jmp	 SHORT $L73261
$L73288:

; 9671 :             case MIDI_CC_CHORUS:
; 9672 :                 if (fCalcStartValue)

  006a8	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  006ac	74 1c		 je	 SHORT $L73289

; 9673 :                 {
; 9674 :                     pCurve->nStartValue = 
; 9675 :                         (short) pChannelMap->m_ChorusMerger.GetIndexedValue(dwMergeIndex) + 0x7F;

  006ae	8b 55 c4	 mov	 edx, DWORD PTR _dwMergeIndex$73241[ebp]
  006b1	52		 push	 edx
  006b2	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  006b5	83 c1 64	 add	 ecx, 100		; 00000064H
  006b8	e8 00 00 00 00	 call	 ?GetIndexedValue@CParamMerger@@QAEJK@Z ; CParamMerger::GetIndexedValue
  006bd	0f bf c0	 movsx	 eax, ax
  006c0	83 c0 7f	 add	 eax, 127		; 0000007fH
  006c3	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  006c6	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$L73289:

; 9676 :                 }
; 9677 :                 dwCurve = ComputeCurve( pCurve );

  006ca	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  006cd	52		 push	 edx
  006ce	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  006d3	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9678 :                 dwCurve = pChannelMap->m_ChorusMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);

  006d6	6a 7f		 push	 127			; 0000007fH
  006d8	6a 7f		 push	 127			; 0000007fH
  006da	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  006dd	50		 push	 eax
  006de	8b 4d c4	 mov	 ecx, DWORD PTR _dwMergeIndex$73241[ebp]
  006e1	51		 push	 ecx
  006e2	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  006e5	83 c1 64	 add	 ecx, 100		; 00000064H
  006e8	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  006ed	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9679 :                 break;

  006f0	eb 2a		 jmp	 SHORT $L73261
$L73292:

; 9680 :             case MIDI_CC_RESETALL:
; 9681 :                 dwCurve = ComputeCurve( pCurve );

  006f2	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  006f5	52		 push	 edx
  006f6	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  006fb	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9682 :                 pChannelMap->Reset(pCurve->nEndValue);

  006fe	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00701	0f bf 48 46	 movsx	 ecx, WORD PTR [eax+70]
  00705	51		 push	 ecx
  00706	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00709	e8 00 00 00 00	 call	 ?Reset@CChannelMap@@QAEXH@Z ; CChannelMap::Reset

; 9683 :                 break;

  0070e	eb 0c		 jmp	 SHORT $L73261
$L73293:

; 9684 :             default:
; 9685 :                 dwCurve = ComputeCurve( pCurve );

  00710	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00713	52		 push	 edx
  00714	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  00719	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax
$L73261:

; 9686 :                 break;
; 9687 :             }
; 9688 :             dwMsg = MIDI_CCHANGE;

  0071c	c7 45 ec b0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 176 ; 000000b0H

; 9689 :             dwMsg |= (pCurve->bCCData << 8);

  00723	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00726	0f b6 48 52	 movzx	 ecx, BYTE PTR [eax+82]
  0072a	c1 e1 08	 shl	 ecx, 8
  0072d	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  00730	0b d1		 or	 edx, ecx
  00732	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 9690 :             dwMsg |= (dwCurve << 16);

  00735	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  00738	c1 e0 10	 shl	 eax, 16			; 00000010H
  0073b	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  0073e	0b c8		 or	 ecx, eax
  00740	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9691 :             break;

  00743	e9 e3 01 00 00	 jmp	 $L73244
$L73294:

; 9692 :         case DMUS_CURVET_MATCURVE:
; 9693 :             dwCurve = ComputeCurve( pCurve );

  00748	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0074b	52		 push	 edx
  0074c	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  00751	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9694 :             dwMsg = MIDI_MTOUCH;

  00754	c7 45 ec d0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 208 ; 000000d0H

; 9695 :             dwMsg |= (dwCurve << 8);

  0075b	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  0075e	c1 e0 08	 shl	 eax, 8
  00761	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00764	0b c8		 or	 ecx, eax
  00766	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9696 :             break;

  00769	e9 bd 01 00 00	 jmp	 $L73244
$L73295:

; 9697 :         case DMUS_CURVET_PATCURVE:
; 9698 :             dwCurve = ComputeCurve( pCurve );

  0076e	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00771	52		 push	 edx
  00772	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  00777	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9699 :             dwMsg = MIDI_PTOUCH;

  0077a	c7 45 ec a0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 160 ; 000000a0H

; 9700 :             dwMsg |= (pCurve->bCCData << 8);

  00781	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00784	0f b6 48 52	 movzx	 ecx, BYTE PTR [eax+82]
  00788	c1 e1 08	 shl	 ecx, 8
  0078b	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  0078e	0b d1		 or	 edx, ecx
  00790	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 9701 :             dwMsg |= (dwCurve << 16);

  00793	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  00796	c1 e0 10	 shl	 eax, 16			; 00000010H
  00799	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  0079c	0b c8		 or	 ecx, eax
  0079e	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9702 :             break;

  007a1	e9 85 01 00 00	 jmp	 $L73244
$L73296:

; 9703 :         case DMUS_CURVET_RPNCURVE:
; 9704 :         case DMUS_CURVET_NRPNCURVE:
; 9705 : #ifdef DXAPI
; 9706 :             if (pCurve->dwFlags & DMUS_PMSGF_DX8)
; 9707 : #endif
; 9708 :             {
; 9709 :                 if ((pCurve->bType == DMUS_CURVET_RPNCURVE) && 
; 9710 :                     (pCurve->wParamType == MIDI_RPN_PITCHBEND))

  007a6	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  007a9	0f b6 42 50	 movzx	 eax, BYTE PTR [edx+80]
  007ad	83 f8 07	 cmp	 eax, 7
  007b0	75 24		 jne	 SHORT $L73297
  007b2	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  007b5	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  007b9	85 d2		 test	 edx, edx
  007bb	75 19		 jne	 SHORT $L73297

; 9711 :                 {
; 9712 :                     pChannelMap->m_PitchbendMerger.m_lBendRange = pCurve->nEndValue;

  007bd	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  007c0	0f bf 48 46	 movsx	 ecx, WORD PTR [eax+70]
  007c4	8b 55 e8	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  007c7	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 9713 :                     dwMsg = 0; // No need to send since we do the math here.

  007ca	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 0

; 9714 :                 }
; 9715 :                 else

  007d1	e9 55 01 00 00	 jmp	 $L73244
$L73297:

; 9716 :                 {
; 9717 :                     dwCurve = ComputeCurve( pCurve );

  007d6	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  007d9	50		 push	 eax
  007da	e8 00 00 00 00	 call	 ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurve
  007df	89 45 c0	 mov	 DWORD PTR _dwCurve$73240[ebp], eax

; 9718 :                     DWORD dwMsg2 = MIDI_CCHANGE;

  007e2	c7 45 b0 b0 00
	00 00		 mov	 DWORD PTR _dwMsg2$73299[ebp], 176 ; 000000b0H

; 9719 :                     dwMsg = MIDI_CCHANGE;

  007e9	c7 45 ec b0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 176 ; 000000b0H

; 9720 :                     // First, send the two CC commands to select which RPN or NRPN event.
; 9721 :                     if (pCurve->bType == DMUS_CURVET_RPNCURVE)

  007f0	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  007f3	0f b6 51 50	 movzx	 edx, BYTE PTR [ecx+80]
  007f7	83 fa 07	 cmp	 edx, 7
  007fa	75 19		 jne	 SHORT $L73300

; 9722 :                     {
; 9723 :                         dwMsg |= (MIDI_CC_RPN_MSB << 8);

  007fc	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  007ff	0d 00 65 00 00	 or	 eax, 25856		; 00006500H
  00804	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9724 :                         dwMsg2 |= (MIDI_CC_RPN_LSB << 8);

  00807	8b 4d b0	 mov	 ecx, DWORD PTR _dwMsg2$73299[ebp]
  0080a	81 c9 00 64 00
	00		 or	 ecx, 25600		; 00006400H
  00810	89 4d b0	 mov	 DWORD PTR _dwMsg2$73299[ebp], ecx

; 9725 :                     }
; 9726 :                     else

  00813	eb 17		 jmp	 SHORT $L73301
$L73300:

; 9727 :                     {
; 9728 :                         dwMsg |= (MIDI_CC_NRPN_MSB << 8);

  00815	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  00818	81 ca 00 63 00
	00		 or	 edx, 25344		; 00006300H
  0081e	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 9729 :                         dwMsg2 |= (MIDI_CC_NRPN_LSB << 8);

  00821	8b 45 b0	 mov	 eax, DWORD PTR _dwMsg2$73299[ebp]
  00824	0d 00 62 00 00	 or	 eax, 25088		; 00006200H
  00829	89 45 b0	 mov	 DWORD PTR _dwMsg2$73299[ebp], eax
$L73301:

; 9730 :                     }
; 9731 :                     dwMsg |= (pCurve->wParamType  & 0x3F80) << 9;  // Upper 8 bits of command #

  0082c	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0082f	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  00833	81 e2 80 3f 00
	00		 and	 edx, 16256		; 00003f80H
  00839	c1 e2 09	 shl	 edx, 9
  0083c	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  0083f	0b c2		 or	 eax, edx
  00841	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9732 :                     dwMsg2 |= (pCurve->wParamType & 0x7F) << 16;   // Lower 8 bits.

  00844	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00847	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  0084b	83 e2 7f	 and	 edx, 127		; 0000007fH
  0084e	c1 e2 10	 shl	 edx, 16			; 00000010H
  00851	8b 45 b0	 mov	 eax, DWORD PTR _dwMsg2$73299[ebp]
  00854	0b c2		 or	 eax, edx
  00856	89 45 b0	 mov	 DWORD PTR _dwMsg2$73299[ebp], eax

; 9733 :                     dwMsg |= pChannelMap->dwMChannel; // MIDI Channel

  00859	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0085c	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  0085f	0b 51 78	 or	 edx, DWORD PTR [ecx+120]
  00862	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 9734 :                     dwMsg2 |= pChannelMap->dwMChannel; // MIDI Channel

  00865	8b 45 e8	 mov	 eax, DWORD PTR _pChannelMap$[ebp]
  00868	8b 4d b0	 mov	 ecx, DWORD PTR _dwMsg2$73299[ebp]
  0086b	0b 48 78	 or	 ecx, DWORD PTR [eax+120]
  0086e	89 4d b0	 mov	 DWORD PTR _dwMsg2$73299[ebp], ecx

; 9735 :                     SendShortMsg(pBuffer,pPort,dwMsg,rt-3,pChannelMap->dwGroup); // Too bad if it fails!

  00871	8b 55 e8	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  00874	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00877	50		 push	 eax
  00878	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  0087b	83 e9 03	 sub	 ecx, 3
  0087e	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  00881	83 da 00	 sbb	 edx, 0
  00884	52		 push	 edx
  00885	51		 push	 ecx
  00886	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00889	50		 push	 eax
  0088a	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  0088d	51		 push	 ecx
  0088e	8b 55 f8	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00891	52		 push	 edx
  00892	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00895	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 9736 :                     SendShortMsg(pBuffer,pPort,dwMsg2,rt-2,pChannelMap->dwGroup);

  0089a	8b 45 e8	 mov	 eax, DWORD PTR _pChannelMap$[ebp]
  0089d	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  008a0	51		 push	 ecx
  008a1	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  008a4	83 ea 02	 sub	 edx, 2
  008a7	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  008aa	83 d8 00	 sbb	 eax, 0
  008ad	50		 push	 eax
  008ae	52		 push	 edx
  008af	8b 4d b0	 mov	 ecx, DWORD PTR _dwMsg2$73299[ebp]
  008b2	51		 push	 ecx
  008b3	8b 55 fc	 mov	 edx, DWORD PTR _pPort$[ebp]
  008b6	52		 push	 edx
  008b7	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  008ba	50		 push	 eax
  008bb	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  008be	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 9737 :                     // Then, send the two data CC commands.
; 9738 :                     dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYMSB << 8);

  008c3	c7 45 ec b0 06
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 1712 ; 000006b0H

; 9739 :                     dwMsg |= (dwCurve & 0x3F80) << 9;  // Upper 8 bits of data

  008ca	8b 4d c0	 mov	 ecx, DWORD PTR _dwCurve$73240[ebp]
  008cd	81 e1 80 3f 00
	00		 and	 ecx, 16256		; 00003f80H
  008d3	c1 e1 09	 shl	 ecx, 9
  008d6	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  008d9	0b d1		 or	 edx, ecx
  008db	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 9740 :                     dwMsg |= pChannelMap->dwMChannel; // MIDI Channel

  008de	8b 45 e8	 mov	 eax, DWORD PTR _pChannelMap$[ebp]
  008e1	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  008e4	0b 48 78	 or	 ecx, DWORD PTR [eax+120]
  008e7	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9741 :                     SendShortMsg(pBuffer,pPort,dwMsg,rt-1,pChannelMap->dwGroup);

  008ea	8b 55 e8	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  008ed	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  008f0	50		 push	 eax
  008f1	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  008f4	83 e9 01	 sub	 ecx, 1
  008f7	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  008fa	83 da 00	 sbb	 edx, 0
  008fd	52		 push	 edx
  008fe	51		 push	 ecx
  008ff	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00902	50		 push	 eax
  00903	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  00906	51		 push	 ecx
  00907	8b 55 f8	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  0090a	52		 push	 edx
  0090b	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0090e	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 9742 :                     dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYLSB << 8);

  00913	c7 45 ec b0 26
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 9904 ; 000026b0H

; 9743 :                     dwMsg |= (dwCurve & 0x7F) << 16;  // Lower 8 bits of data

  0091a	8b 45 c0	 mov	 eax, DWORD PTR _dwCurve$73240[ebp]
  0091d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00920	c1 e0 10	 shl	 eax, 16			; 00000010H
  00923	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00926	0b c8		 or	 ecx, eax
  00928	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx
$L73244:

; 9744 :                 }
; 9745 :             }
; 9746 :         }
; 9747 :         if (dwMsg) // Make sure we successfully created a message.

  0092b	83 7d ec 00	 cmp	 DWORD PTR _dwMsg$[ebp], 0
  0092f	0f 84 95 00 00
	00		 je	 $L73302

; 9748 :         {
; 9749 :             dwMsg |= pChannelMap->dwMChannel; // MIDI Channel

  00935	8b 55 e8	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  00938	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  0093b	0b 42 78	 or	 eax, DWORD PTR [edx+120]
  0093e	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9750 :             if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))

  00941	8b 4d e8	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00944	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00947	52		 push	 edx
  00948	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  0094b	50		 push	 eax
  0094c	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  0094f	51		 push	 ecx
  00950	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  00953	52		 push	 edx
  00954	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  00957	50		 push	 eax
  00958	8b 4d f8	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  0095b	51		 push	 ecx
  0095c	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0095f	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg
  00964	0f b6 d0	 movzx	 edx, al
  00967	85 d2		 test	 edx, edx
  00969	74 5f		 je	 SHORT $L73302

; 9751 :             {
; 9752 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 9753 :                 m_dwTempCurvesPerSecond++;

  0096b	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  0096e	8b 88 00 04 00
	00		 mov	 ecx, DWORD PTR [eax+1024]
  00974	83 c1 01	 add	 ecx, 1
  00977	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0097a	89 8a 00 04 00
	00		 mov	 DWORD PTR [edx+1024], ecx

; 9754 :                 UpdateDebugParams();

  00980	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00983	e8 00 00 00 00	 call	 ?UpdateDebugParams@CPerformance@@AAEXXZ ; CPerformance::UpdateDebugParams

; 9755 : #endif                
; 9756 : #ifdef DXAPI
; 9757 :                 m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
; 9758 :                 m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
; 9759 : #else
; 9760 :                 m_rtLastSendTime = rt;

  00988	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  0098b	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  0098e	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00991	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  00994	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 9761 : #endif
; 9762 : 
; 9763 :                 // ComputeCurve() will set this to 0 if it's time to free the event. Otherwise, it
; 9764 :                 // will set it to the next time this event should be performed.
; 9765 :                 if( pCurve->rtTime )

  00997	8b 45 f0	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0099a	89 45 9c	 mov	 DWORD PTR tv928[ebp], eax
  0099d	8b 4d 9c	 mov	 ecx, DWORD PTR tv928[ebp]
  009a0	8b 55 9c	 mov	 edx, DWORD PTR tv928[ebp]
  009a3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  009a6	0b 42 0c	 or	 eax, DWORD PTR [edx+12]
  009a9	85 c0		 test	 eax, eax
  009ab	74 1d		 je	 SHORT $L73302

; 9766 :                 {
; 9767 :                     // If we didn't calculate the time slice because we didn't know 
; 9768 :                     // what the start value was, do it now.
; 9769 :                     if (fCalcStartValue)

  009ad	83 7d e0 00	 cmp	 DWORD PTR _fCalcStartValue$[ebp], 0
  009b1	74 10		 je	 SHORT $L73305

; 9770 :                     {
; 9771 :                         pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.

  009b3	8b 4d f0	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  009b6	51		 push	 ecx
  009b7	e8 00 00 00 00	 call	 ?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurveTimeSlice
  009bc	8b 55 f0	 mov	 edx, DWORD PTR _pCurve$[ebp]
  009bf	66 89 42 4a	 mov	 WORD PTR [edx+74], ax
$L73305:

; 9772 :                     }
; 9773 :                     hr = DMUS_S_REQUEUE;

  009c3	c7 45 e4 00 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086656 ; 08781200H
$L73302:

; 9774 :                 }
; 9775 :             }
; 9776 :         }
; 9777 :     }
; 9778 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  009ca	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  009cd	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  009d2	50		 push	 eax
  009d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9779 :     if( pPort ) pPort->Release();

  009d9	83 7d fc 00	 cmp	 DWORD PTR _pPort$[ebp], 0
  009dd	74 0c		 je	 SHORT $L73311
  009df	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  009e2	8b 11		 mov	 edx, DWORD PTR [ecx]
  009e4	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  009e7	50		 push	 eax
  009e8	ff 52 08	 call	 DWORD PTR [edx+8]
$L73311:

; 9780 :     if( pBuffer ) pBuffer->Release();

  009eb	83 7d f8 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  009ef	74 0c		 je	 SHORT $L73312
  009f1	8b 4d f8	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  009f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  009f6	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  009f9	50		 push	 eax
  009fa	ff 52 08	 call	 DWORD PTR [edx+8]
$L73312:

; 9781 :     return hr;

  009fd	8b 45 e4	 mov	 eax, DWORD PTR _hr$[ebp]
$L73186:

; 9782 : }

  00a00	5e		 pop	 esi
  00a01	8b e5		 mov	 esp, ebp
  00a03	5d		 pop	 ebp
  00a04	c2 0c 00	 ret	 12			; 0000000cH
$L75825:
  00a07	00 00 00 00	 DD	 $L73247
  00a0b	00 00 00 00	 DD	 $L73259
  00a0f	00 00 00 00	 DD	 $L73294
  00a13	00 00 00 00	 DD	 $L73295
  00a17	00 00 00 00	 DD	 $L73296
  00a1b	00 00 00 00	 DD	 $L73296
$L75826:
  00a1f	00 00 00 00	 DD	 $L73264
  00a23	00 00 00 00	 DD	 $L73268
  00a27	00 00 00 00	 DD	 $L73272
  00a2b	00 00 00 00	 DD	 $L73276
  00a2f	00 00 00 00	 DD	 $L73280
  00a33	00 00 00 00	 DD	 $L73284
  00a37	00 00 00 00	 DD	 $L73288
  00a3b	00 00 00 00	 DD	 $L73292
  00a3f	00 00 00 00	 DD	 $L73293
$L75824:
  00a43	00		 DB	 0
  00a44	08		 DB	 8
  00a45	08		 DB	 8
  00a46	08		 DB	 8
  00a47	08		 DB	 8
  00a48	08		 DB	 8
  00a49	01		 DB	 1
  00a4a	08		 DB	 8
  00a4b	08		 DB	 8
  00a4c	02		 DB	 2
  00a4d	03		 DB	 3
  00a4e	08		 DB	 8
  00a4f	08		 DB	 8
  00a50	08		 DB	 8
  00a51	08		 DB	 8
  00a52	08		 DB	 8
  00a53	08		 DB	 8
  00a54	08		 DB	 8
  00a55	08		 DB	 8
  00a56	08		 DB	 8
  00a57	08		 DB	 8
  00a58	08		 DB	 8
  00a59	08		 DB	 8
  00a5a	08		 DB	 8
  00a5b	08		 DB	 8
  00a5c	08		 DB	 8
  00a5d	08		 DB	 8
  00a5e	08		 DB	 8
  00a5f	08		 DB	 8
  00a60	08		 DB	 8
  00a61	08		 DB	 8
  00a62	08		 DB	 8
  00a63	08		 DB	 8
  00a64	08		 DB	 8
  00a65	08		 DB	 8
  00a66	08		 DB	 8
  00a67	08		 DB	 8
  00a68	08		 DB	 8
  00a69	08		 DB	 8
  00a6a	08		 DB	 8
  00a6b	08		 DB	 8
  00a6c	08		 DB	 8
  00a6d	08		 DB	 8
  00a6e	08		 DB	 8
  00a6f	08		 DB	 8
  00a70	08		 DB	 8
  00a71	08		 DB	 8
  00a72	08		 DB	 8
  00a73	08		 DB	 8
  00a74	08		 DB	 8
  00a75	08		 DB	 8
  00a76	08		 DB	 8
  00a77	08		 DB	 8
  00a78	08		 DB	 8
  00a79	08		 DB	 8
  00a7a	08		 DB	 8
  00a7b	08		 DB	 8
  00a7c	08		 DB	 8
  00a7d	08		 DB	 8
  00a7e	08		 DB	 8
  00a7f	08		 DB	 8
  00a80	08		 DB	 8
  00a81	08		 DB	 8
  00a82	08		 DB	 8
  00a83	08		 DB	 8
  00a84	08		 DB	 8
  00a85	08		 DB	 8
  00a86	08		 DB	 8
  00a87	08		 DB	 8
  00a88	08		 DB	 8
  00a89	08		 DB	 8
  00a8a	08		 DB	 8
  00a8b	08		 DB	 8
  00a8c	04		 DB	 4
  00a8d	08		 DB	 8
  00a8e	08		 DB	 8
  00a8f	08		 DB	 8
  00a90	08		 DB	 8
  00a91	08		 DB	 8
  00a92	08		 DB	 8
  00a93	08		 DB	 8
  00a94	08		 DB	 8
  00a95	08		 DB	 8
  00a96	08		 DB	 8
  00a97	08		 DB	 8
  00a98	08		 DB	 8
  00a99	08		 DB	 8
  00a9a	08		 DB	 8
  00a9b	08		 DB	 8
  00a9c	08		 DB	 8
  00a9d	05		 DB	 5
  00a9e	08		 DB	 8
  00a9f	06		 DB	 6
  00aa0	08		 DB	 8
  00aa1	08		 DB	 8
  00aa2	08		 DB	 8
  00aa3	08		 DB	 8
  00aa4	08		 DB	 8
  00aa5	08		 DB	 8
  00aa6	08		 DB	 8
  00aa7	08		 DB	 8
  00aa8	08		 DB	 8
  00aa9	08		 DB	 8
  00aaa	08		 DB	 8
  00aab	08		 DB	 8
  00aac	08		 DB	 8
  00aad	08		 DB	 8
  00aae	08		 DB	 8
  00aaf	08		 DB	 8
  00ab0	08		 DB	 8
  00ab1	08		 DB	 8
  00ab2	08		 DB	 8
  00ab3	08		 DB	 8
  00ab4	08		 DB	 8
  00ab5	08		 DB	 8
  00ab6	08		 DB	 8
  00ab7	08		 DB	 8
  00ab8	08		 DB	 8
  00ab9	08		 DB	 8
  00aba	08		 DB	 8
  00abb	07		 DB	 7
?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ENDP	; CPerformance::PackCurve
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z
_TEXT	SEGMENT
_dwTotalDistance$ = -12
_dwResolution$ = -8
_lTimeIncrement$ = -4
_pCurve$ = 8
?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z PROC NEAR ; ComputeCurveTimeSlice, COMDAT

; 2912 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2913 :     long lTimeIncrement;
; 2914 :     DWORD dwTotalDistance;
; 2915 :     DWORD dwResolution;
; 2916 :     if (pCurve->bType == DMUS_CURVET_PBCURVE) 

  00006	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00009	0f b6 48 50	 movzx	 ecx, BYTE PTR [eax+80]
  0000d	83 f9 03	 cmp	 ecx, 3
  00010	75 09		 jne	 SHORT $L70395

; 2917 :     {
; 2918 :         dwResolution = 10;

  00012	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _dwResolution$[ebp], 10 ; 0000000aH

; 2919 :     }
; 2920 :     else if ((pCurve->bType == DMUS_CURVET_RPNCURVE) ||

  00019	eb 28		 jmp	 SHORT $L70396
$L70395:

; 2921 :         (pCurve->bType == DMUS_CURVET_NRPNCURVE))

  0001b	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0001e	0f b6 42 50	 movzx	 eax, BYTE PTR [edx+80]
  00022	83 f8 07	 cmp	 eax, 7
  00025	74 0c		 je	 SHORT $L70398
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0002a	0f b6 51 50	 movzx	 edx, BYTE PTR [ecx+80]
  0002e	83 fa 08	 cmp	 edx, 8
  00031	75 09		 jne	 SHORT $L70397
$L70398:

; 2922 :     {
; 2923 :         dwResolution = 100;

  00033	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _dwResolution$[ebp], 100 ; 00000064H

; 2924 :     }
; 2925 :     else

  0003a	eb 07		 jmp	 SHORT $L70396
$L70397:

; 2926 :     {
; 2927 :         dwResolution = 3;

  0003c	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _dwResolution$[ebp], 3
$L70396:

; 2928 :     }
; 2929 :     if (pCurve->nEndValue > pCurve->nStartValue)

  00043	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00046	0f bf 48 46	 movsx	 ecx, WORD PTR [eax+70]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0004d	0f bf 42 44	 movsx	 eax, WORD PTR [edx+68]
  00051	3b c8		 cmp	 ecx, eax
  00053	7e 15		 jle	 SHORT $L70400

; 2930 :         dwTotalDistance = pCurve->nEndValue - pCurve->nStartValue;

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00058	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  0005c	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0005f	0f bf 48 44	 movsx	 ecx, WORD PTR [eax+68]
  00063	2b d1		 sub	 edx, ecx
  00065	89 55 f4	 mov	 DWORD PTR _dwTotalDistance$[ebp], edx

; 2931 :     else 

  00068	eb 13		 jmp	 SHORT $L70401
$L70400:

; 2932 :         dwTotalDistance = pCurve->nStartValue - pCurve->nEndValue;

  0006a	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0006d	0f bf 42 44	 movsx	 eax, WORD PTR [edx+68]
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00074	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  00078	2b c2		 sub	 eax, edx
  0007a	89 45 f4	 mov	 DWORD PTR _dwTotalDistance$[ebp], eax
$L70401:

; 2933 :     if (dwTotalDistance == 0) dwTotalDistance = 1;

  0007d	83 7d f4 00	 cmp	 DWORD PTR _dwTotalDistance$[ebp], 0
  00081	75 07		 jne	 SHORT $L70402
  00083	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _dwTotalDistance$[ebp], 1
$L70402:

; 2934 :     lTimeIncrement = (pCurve->mtDuration * dwResolution) / dwTotalDistance;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0008d	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00090	0f af 45 f8	 imul	 eax, DWORD PTR _dwResolution$[ebp]
  00094	33 d2		 xor	 edx, edx
  00096	f7 75 f4	 div	 DWORD PTR _dwTotalDistance$[ebp]
  00099	89 45 fc	 mov	 DWORD PTR _lTimeIncrement$[ebp], eax

; 2935 :     // Force to no smaller than 192nd note (10ms at 120 bpm.)
; 2936 :     if( lTimeIncrement < (DMUS_PPQ/48) ) lTimeIncrement = DMUS_PPQ/48;

  0009c	83 7d fc 10	 cmp	 DWORD PTR _lTimeIncrement$[ebp], 16 ; 00000010H
  000a0	7d 07		 jge	 SHORT $L70403
  000a2	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _lTimeIncrement$[ebp], 16 ; 00000010H
$L70403:

; 2937 :     return lTimeIncrement;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _lTimeIncrement$[ebp]

; 2938 : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z ENDP	; ComputeCurveTimeSlice
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z
_TEXT	SEGMENT
tv66 = -20
_lIndex$ = -16
_dwRet$ = -12
_panTable$ = -8
_mtCurrent$ = -4
_pCurve$ = 8
?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z PROC NEAR	; ComputeCurve, COMDAT

; 2941 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 2942 :     DWORD dwRet;
; 2943 :     short *panTable;
; 2944 :     MUSIC_TIME mtCurrent;
; 2945 :     long lIndex;
; 2946 : 
; 2947 :     switch( pCurve->bCurveShape )
; 2948 :     {

  00006	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00009	0f b6 48 51	 movzx	 ecx, BYTE PTR [eax+81]
  0000d	89 4d ec	 mov	 DWORD PTR tv66[ebp], ecx
  00010	83 7d ec 04	 cmp	 DWORD PTR tv66[ebp], 4
  00014	77 0a		 ja	 SHORT $L70415
  00016	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  00019	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L75833[edx*4]
$L70415:

; 2949 :     case DMUS_CURVES_INSTANT:
; 2950 :     default:
; 2951 :         if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )

  00020	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00023	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00026	83 e1 20	 and	 ecx, 32			; 00000020H
  00029	85 c9		 test	 ecx, ecx
  0002b	74 1d		 je	 SHORT $L70416

; 2952 :         {
; 2953 :             pCurve->rtTime = 0;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00030	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00037	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 2954 :             return (DWORD)pCurve->nResetValue;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00041	0f bf 40 48	 movsx	 eax, WORD PTR [eax+72]
  00045	e9 82 02 00 00	 jmp	 $L70406
$L70416:

; 2955 :         }
; 2956 :         if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && ( pCurve->mtResetDuration > 0 ) )

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0004d	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  00051	83 e2 01	 and	 edx, 1
  00054	85 d2		 test	 edx, edx
  00056	74 36		 je	 SHORT $L70418
  00058	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0005b	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  0005f	7e 2d		 jle	 SHORT $L70418

; 2957 :         {
; 2958 :             pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart;

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00064	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00067	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0006a	03 50 3c	 add	 edx, DWORD PTR [eax+60]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00070	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 2959 :             pCurve->mtDuration = 0;

  00073	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00076	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 2960 :             pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00080	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00083	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00086	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00089	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 2961 :         }
; 2962 :         else

  0008c	eb 11		 jmp	 SHORT $L70419
$L70418:

; 2963 :         {
; 2964 :             pCurve->rtTime = 0; // setting this to 0 will free the event upon return

  0008e	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00091	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00098	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$L70419:

; 2965 :         }
; 2966 :         return (DWORD)pCurve->nEndValue;

  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000a2	0f bf 41 46	 movsx	 eax, WORD PTR [ecx+70]
  000a6	e9 21 02 00 00	 jmp	 $L70406
$L70421:

; 2967 :         break;
; 2968 :     case DMUS_CURVES_LINEAR:
; 2969 :         panTable = &ganCT_Linear[ 0 ];

  000ab	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Linear

; 2970 :         break;

  000b2	eb 19		 jmp	 SHORT $L70412
$L70422:

; 2971 :     case DMUS_CURVES_EXP:
; 2972 :         panTable = &ganCT_Exp[ 0 ];

  000b4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Exp

; 2973 :         break;

  000bb	eb 10		 jmp	 SHORT $L70412
$L70423:

; 2974 :     case DMUS_CURVES_LOG:
; 2975 :         panTable = &ganCT_Log[ 0 ];

  000bd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Log

; 2976 :         break;

  000c4	eb 07		 jmp	 SHORT $L70412
$L70424:

; 2977 :     case DMUS_CURVES_SINE:
; 2978 :         panTable = &ganCT_Sine[ 0 ];

  000c6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _panTable$[ebp], OFFSET FLAT:_ganCT_Sine
$L70412:

; 2979 :         break;
; 2980 :     }
; 2981 : 
; 2982 :     // compute index into table
; 2983 :     // there are CT_MAX + 1 elements in the table.
; 2984 :     mtCurrent = pCurve->mtTime - pCurve->mtOriginalStart;

  000cd	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  000d0	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  000d3	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  000d6	2b 48 3c	 sub	 ecx, DWORD PTR [eax+60]
  000d9	89 4d fc	 mov	 DWORD PTR _mtCurrent$[ebp], ecx

; 2985 : 
; 2986 :     // if we're flushing this event, send the reset value
; 2987 :     if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )

  000dc	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  000df	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000e2	83 e0 20	 and	 eax, 32			; 00000020H
  000e5	85 c0		 test	 eax, eax
  000e7	74 1d		 je	 SHORT $L70425

; 2988 :     {
; 2989 :         // it will only get here if pCurve->bFlags & 1, because that is checked in
; 2990 :         // the :Flush() routine.
; 2991 :         pCurve->rtTime = 0;

  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  000ec	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  000f3	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 2992 :         return pCurve->nResetValue;

  000fa	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  000fd	0f bf 42 48	 movsx	 eax, WORD PTR [edx+72]
  00101	e9 c6 01 00 00	 jmp	 $L70406
$L70425:

; 2993 :     }
; 2994 :     
; 2995 :     // this should now never happen, as a result of fixing 33987: Transition on a beat boundary invalidates CC's right away (doesn't wait for the beat)
; 2996 :     if( (pCurve->bFlags & DMUS_CURVE_RESET) &&
; 2997 :         (pCurve->mtResetDuration < 0 ) && // this can happen from flushing
; 2998 :         (pCurve->mtTime >= pCurve->mtOriginalStart + pCurve->mtDuration + pCurve->mtResetDuration ))

  00106	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00109	0f b6 48 53	 movzx	 ecx, BYTE PTR [eax+83]
  0010d	83 e1 01	 and	 ecx, 1
  00110	85 c9		 test	 ecx, ecx
  00112	74 40		 je	 SHORT $L70426
  00114	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00117	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  0011b	7d 37		 jge	 SHORT $L70426
  0011d	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00120	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00123	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00126	03 4a 38	 add	 ecx, DWORD PTR [edx+56]
  00129	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0012c	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0012f	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00132	39 4a 10	 cmp	 DWORD PTR [edx+16], ecx
  00135	7c 1d		 jl	 SHORT $L70426

; 2999 :     {
; 3000 :         pCurve->rtTime = 0;

  00137	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0013a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00141	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 3001 :         return pCurve->nResetValue;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0014b	0f bf 41 48	 movsx	 eax, WORD PTR [ecx+72]
  0014f	e9 78 01 00 00	 jmp	 $L70406
$L70426:

; 3002 :     }
; 3003 :     else if( (pCurve->mtDuration == 0) ||
; 3004 :         (pCurve->mtTime - pCurve->mtOriginalStart >= pCurve->mtDuration ))

  00154	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00157	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0015b	74 14		 je	 SHORT $L70429
  0015d	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00163	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00166	2b 51 3c	 sub	 edx, DWORD PTR [ecx+60]
  00169	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0016c	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  0016f	7c 57		 jl	 SHORT $L70428
$L70429:

; 3005 :     {
; 3006 :         // if we're supposed to send the return value (m_bFlags & 1) then
; 3007 :         // set it up to do so. Otherwise, free the event.
; 3008 :         if( pCurve->bFlags & DMUS_CURVE_RESET )

  00171	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00174	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  00178	83 e2 01	 and	 edx, 1
  0017b	85 d2		 test	 edx, edx
  0017d	74 29		 je	 SHORT $L70430

; 3009 :         {
; 3010 :             pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
; 3011 :                 pCurve->mtOriginalStart;

  0017f	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00182	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00185	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00188	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  0018b	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0018e	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  00191	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00194	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3012 :             pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

  00197	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0019a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0019d	83 e1 fe	 and	 ecx, -2			; fffffffeH
  001a0	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001a3	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 3013 :         }
; 3014 :         else

  001a6	eb 11		 jmp	 SHORT $L70431
$L70430:

; 3015 :         {
; 3016 :             pCurve->rtTime = 0; // time to free the event, we're done

  001a8	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ab	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001b2	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$L70431:

; 3017 :         }
; 3018 :         dwRet = pCurve->nEndValue;

  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001bc	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  001c0	89 55 f4	 mov	 DWORD PTR _dwRet$[ebp], edx

; 3019 :     }
; 3020 :     else

  001c3	e9 01 01 00 00	 jmp	 $L70427
$L70428:

; 3021 :     {
; 3022 :         // Calculate how far into the table we should be.
; 3023 :         lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

  001c8	8b 45 fc	 mov	 eax, DWORD PTR _mtCurrent$[ebp]
  001cb	69 c0 c1 00 00
	00		 imul	 eax, 193		; 000000c1H
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001d4	99		 cdq
  001d5	f7 79 38	 idiv	 DWORD PTR [ecx+56]
  001d8	89 45 f0	 mov	 DWORD PTR _lIndex$[ebp], eax

; 3024 : 
; 3025 :         // find an amount of time to add to the curve event such that there is at
; 3026 :         // least a change by CT_FACTOR. This will be used as the time stamp
; 3027 :         // for the next iteration of the curve.
; 3028 : 
; 3029 :         // clamp lIndex
; 3030 :         if( lIndex < 0 )

  001db	83 7d f0 00	 cmp	 DWORD PTR _lIndex$[ebp], 0
  001df	7d 07		 jge	 SHORT $L70433

; 3031 :         {
; 3032 :             lIndex = 0;

  001e1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _lIndex$[ebp], 0
$L70433:

; 3033 :         }
; 3034 :         if( lIndex >= CT_MAX )

  001e8	81 7d f0 c0 00
	00 00		 cmp	 DWORD PTR _lIndex$[ebp], 192 ; 000000c0H
  001ef	7c 13		 jl	 SHORT $L70434

; 3035 :         {
; 3036 :             lIndex = CT_MAX;

  001f1	c7 45 f0 c0 00
	00 00		 mov	 DWORD PTR _lIndex$[ebp], 192 ; 000000c0H

; 3037 :             dwRet = pCurve->nEndValue;

  001f8	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001fb	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  001ff	89 45 f4	 mov	 DWORD PTR _dwRet$[ebp], eax

; 3038 :         }
; 3039 :         else

  00202	eb 31		 jmp	 SHORT $L70435
$L70434:

; 3040 :         {
; 3041 :             // Okay, in the curve, so calculate the return value.
; 3042 :             dwRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) / 
; 3043 :                 CT_DIVFACTOR) + pCurve->nStartValue;

  00204	8b 4d f0	 mov	 ecx, DWORD PTR _lIndex$[ebp]
  00207	8b 55 f8	 mov	 edx, DWORD PTR _panTable$[ebp]
  0020a	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00211	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  00215	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00218	0f bf 49 44	 movsx	 ecx, WORD PTR [ecx+68]
  0021c	2b d1		 sub	 edx, ecx
  0021e	0f af c2	 imul	 eax, edx
  00221	99		 cdq
  00222	b9 00 4b 00 00	 mov	 ecx, 19200		; 00004b00H
  00227	f7 f9		 idiv	 ecx
  00229	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0022c	0f bf 4a 44	 movsx	 ecx, WORD PTR [edx+68]
  00230	03 c1		 add	 eax, ecx
  00232	89 45 f4	 mov	 DWORD PTR _dwRet$[ebp], eax
$L70435:

; 3044 :         }
; 3045 :         
; 3046 :         // this should now never happen, as a result of fixing 33987
; 3047 :         if( (pCurve->bFlags & DMUS_CURVE_RESET) && (pCurve->mtResetDuration < 0) )

  00235	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00238	0f b6 42 53	 movzx	 eax, BYTE PTR [edx+83]
  0023c	83 e0 01	 and	 eax, 1
  0023f	85 c0		 test	 eax, eax
  00241	74 23		 je	 SHORT $L70436
  00243	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00246	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  0024a	7d 1a		 jge	 SHORT $L70436

; 3048 :         {
; 3049 :             // this can happen as a result of flushing. We want to make sure the next
; 3050 :             // time is the reset flush time.
; 3051 :             pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
; 3052 :                 pCurve->mtOriginalStart;

  0024c	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0024f	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00252	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00255	03 41 40	 add	 eax, DWORD PTR [ecx+64]
  00258	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0025b	03 42 3c	 add	 eax, DWORD PTR [edx+60]
  0025e	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00261	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3053 :         }
; 3054 :         else

  00264	eb 2e		 jmp	 SHORT $L70437
$L70436:

; 3055 :         {
; 3056 :             // Within curve, so increment time.
; 3057 :             if (!pCurve->wMeasure) // oops --- better compute this.

  00266	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00269	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  0026d	85 c0		 test	 eax, eax
  0026f	75 10		 jne	 SHORT $L70438

; 3058 :             {
; 3059 :                 TraceI(2, "Warning: Computing curve time slice...\n");
; 3060 :                 pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);  // Use this to store the time slice interval.

  00271	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00274	51		 push	 ecx
  00275	e8 00 00 00 00	 call	 ?ComputeCurveTimeSlice@@YGJPAU_DMUS_CURVE_PMSG@@@Z ; ComputeCurveTimeSlice
  0027a	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0027d	66 89 42 4a	 mov	 WORD PTR [edx+74], ax
$L70438:

; 3061 :             }
; 3062 :             pCurve->mtTime += pCurve->wMeasure; // We are storing the time increment here.

  00281	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00284	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  00288	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0028b	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  0028e	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00291	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L70437:

; 3063 :         }
; 3064 :         if( pCurve->mtTime > pCurve->mtDuration + pCurve->mtOriginalStart )

  00294	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00297	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0029a	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  0029d	03 50 3c	 add	 edx, DWORD PTR [eax+60]
  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  002a3	39 51 10	 cmp	 DWORD PTR [ecx+16], edx
  002a6	7e 12		 jle	 SHORT $L70441

; 3065 :         {
; 3066 :             pCurve->mtTime = pCurve->mtDuration + pCurve->mtOriginalStart;

  002a8	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  002ab	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  002b1	03 41 3c	 add	 eax, DWORD PTR [ecx+60]
  002b4	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  002b7	89 42 10	 mov	 DWORD PTR [edx+16], eax
$L70441:

; 3067 :         }
; 3068 :         pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

  002ba	8b 45 08	 mov	 eax, DWORD PTR _pCurve$[ebp]
  002bd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002c0	83 e1 fe	 and	 ecx, -2			; fffffffeH
  002c3	8b 55 08	 mov	 edx, DWORD PTR _pCurve$[ebp]
  002c6	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$L70427:

; 3069 : 
; 3070 :     }
; 3071 :     return dwRet;

  002c9	8b 45 f4	 mov	 eax, DWORD PTR _dwRet$[ebp]
$L70406:

; 3072 : }

  002cc	8b e5		 mov	 esp, ebp
  002ce	5d		 pop	 ebp
  002cf	c2 04 00	 ret	 4
$L75833:
  002d2	00 00 00 00	 DD	 $L70421
  002d6	00 00 00 00	 DD	 $L70415
  002da	00 00 00 00	 DD	 $L70422
  002de	00 00 00 00	 DD	 $L70423
  002e2	00 00 00 00	 DD	 $L70424
?ComputeCurve@@YGKPAU_DMUS_CURVE_PMSG@@@Z ENDP		; ComputeCurve
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
_TEXT	ENDS
;	COMDAT ?IsActive@CAudioPath@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsActive@CAudioPath@@QAEHXZ PROC NEAR			; CAudioPath::IsActive, COMDAT
; _this$ = ecx

; 281  :     BOOL IsActive() { return m_fActive; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?IsActive@CAudioPath@@QAEHXZ ENDP			; CAudioPath::IsActive
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?NoPorts@CAudioPath@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?NoPorts@CAudioPath@@QAEHXZ PROC NEAR			; CAudioPath::NoPorts, COMDAT
; _this$ = ecx

; 282  :     BOOL NoPorts() { return m_PortConfigList.IsEmpty(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 68	 add	 ecx, 104		; 00000068H
  0000d	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?NoPorts@CAudioPath@@QAEHXZ ENDP			; CAudioPath::NoPorts
_TEXT	ENDS
EXTRN	?IsMember@AList@@QAEHPAVAListItem@@@Z:NEAR	; AList::IsMember
; Function compile flags: /Odt
;	COMDAT ?IsMember@CAudioPathList@@QAEHPAVCAudioPath@@@Z
_TEXT	SEGMENT
tv68 = -8
_this$ = -4
_pAudioPath$ = 8
?IsMember@CAudioPathList@@QAEHPAVCAudioPath@@@Z PROC NEAR ; CAudioPathList::IsMember, COMDAT
; _this$ = ecx

; 314  :     BOOL IsMember(CAudioPath* pAudioPath){return AList::IsMember((AListItem*)pAudioPath);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d 08 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  0000d	74 0b		 je	 SHORT $L75843
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00018	eb 07		 jmp	 SHORT $L75844
$L75843:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L75844:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?IsMember@AList@@QAEHPAVAListItem@@@Z ; AList::IsMember
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?IsMember@CAudioPathList@@QAEHPAVCAudioPath@@@Z ENDP	; CAudioPathList::IsMember
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.h
_TEXT	ENDS
;	COMDAT ?GetNext@CSegState@@QAEPAV1@XZ
_TEXT	SEGMENT
tv71 = -12
tv68 = -8
_this$ = -4
?GetNext@CSegState@@QAEPAV1@XZ PROC NEAR		; CSegState::GetNext, COMDAT
; _this$ = ecx

; 87   :     CSegState* GetNext() { return (CSegState*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 08	 add	 ecx, 8
  0000f	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00014	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00017	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0001b	74 0b		 je	 SHORT $L75848
  0001d	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00020	83 e8 08	 sub	 eax, 8
  00023	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00026	eb 07		 jmp	 SHORT $L75849
$L75848:
  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L75849:
  0002f	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GetNext@CSegState@@QAEPAV1@XZ ENDP			; CSegState::GetNext
_TEXT	ENDS
PUBLIC	?AddHead@AList@@QAEXPAVAListItem@@@Z		; AList::AddHead
; Function compile flags: /Odt
;	COMDAT ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT
tv67 = -8
_this$ = -4
_pSegState$ = 8
?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z PROC NEAR	; CSegStateList::AddHead, COMDAT
; _this$ = ecx

; 153  :     void AddHead(CSegState* pSegState) { AList::AddHead((AListItem*)pSegState);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d 08 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  0000d	74 0b		 je	 SHORT $L75853
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00018	eb 07		 jmp	 SHORT $L75854
$L75853:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L75854:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ENDP	; CSegStateList::AddHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::AddHead, COMDAT
; _this$ = ecx

; 51   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :             if (pItem!=NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 16		 je	 SHORT $L32730

; 53   :             {
; 54   :                 pItem->SetNext(m_pHead);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 55   :                 m_pHead=pItem;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00021	89 02		 mov	 DWORD PTR [edx], eax
$L32730:

; 56   :             }
; 57   :         };

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?AddHead@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::AddHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.h
_TEXT	ENDS
;	COMDAT ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT
tv69 = -12
tv66 = -8
_this$ = -4
?GetHead@CSegStateList@@QAEPAVCSegState@@XZ PROC NEAR	; CSegStateList::GetHead, COMDAT
; _this$ = ecx

; 155  :     CSegState* GetHead(){return (CSegState*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  00011	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00018	74 0b		 je	 SHORT $L75861
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001d	83 e8 08	 sub	 eax, 8
  00020	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L75862
$L75861:
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L75862:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ENDP	; CSegStateList::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT
tv69 = -12
tv66 = -8
_this$ = -4
?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ PROC NEAR ; CSegStateList::RemoveHead, COMDAT
; _this$ = ecx

; 157  :     CSegState* RemoveHead() {return (CSegState *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  00011	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00018	74 0b		 je	 SHORT $L75866
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001d	83 e8 08	 sub	 eax, 8
  00020	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L75867
$L75866:
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L75867:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?RemoveHead@CSegStateList@@QAEPAVCSegState@@XZ ENDP	; CSegStateList::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Remove@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT
tv67 = -8
_this$ = -4
_pSegState$ = 8
?Remove@CSegStateList@@QAEXPAVCSegState@@@Z PROC NEAR	; CSegStateList::Remove, COMDAT
; _this$ = ecx

; 158  :     void Remove(CSegState* pSegState){AList::Remove((AListItem*)pSegState);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d 08 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  0000d	74 0b		 je	 SHORT $L75871
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00018	eb 07		 jmp	 SHORT $L75872
$L75871:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L75872:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?Remove@CSegStateList@@QAEXPAVCSegState@@@Z ENDP	; CSegStateList::Remove
_TEXT	ENDS
PUBLIC	?GetTail@AList@@QBEPAVAListItem@@XZ		; AList::GetTail
; Function compile flags: /Odt
;	COMDAT ?GetTail@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT
tv69 = -12
tv66 = -8
_this$ = -4
?GetTail@CSegStateList@@QAEPAVCSegState@@XZ PROC NEAR	; CSegStateList::GetTail, COMDAT
; _this$ = ecx

; 160  :     CSegState* GetTail(){ return (CSegState*)AList::GetTail();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetTail@AList@@QBEPAVAListItem@@XZ ; AList::GetTail
  00011	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00018	74 0b		 je	 SHORT $L75876
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001d	83 e8 08	 sub	 eax, 8
  00020	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L75877
$L75876:
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L75877:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GetTail@CSegStateList@@QAEPAVCSegState@@XZ ENDP	; CSegStateList::GetTail
_TEXT	ENDS
PUBLIC	?GetPrev@AList@@QBEPAVAListItem@@PAV2@@Z	; AList::GetPrev
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
;	COMDAT ?GetTail@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetTail@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetTail, COMDAT
; _this$ = ecx

; 67   :     AListItem *GetTail() const {return GetPrev(NULL);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetPrev@AList@@QBEPAVAListItem@@PAV2@@Z ; AList::GetPrev
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetTail@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetTail
_TEXT	ENDS
EXTRN	?GetPrev@AListItem@@QBEPAV1@PAV1@@Z:NEAR	; AListItem::GetPrev
; Function compile flags: /Odt
;	COMDAT ?GetPrev@AList@@QBEPAVAListItem@@PAV2@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?GetPrev@AList@@QBEPAVAListItem@@PAV2@@Z PROC NEAR	; AList::GetPrev, COMDAT
; _this$ = ecx

; 66   :     AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	e8 00 00 00 00	 call	 ?GetPrev@AListItem@@QBEPAV1@PAV1@@Z ; AListItem::GetPrev
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?GetPrev@AList@@QBEPAVAListItem@@PAV2@@Z ENDP		; AList::GetPrev
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.h
_TEXT	ENDS
;	COMDAT ?SetID@CSegStateList@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4
_dwID$ = 8
?SetID@CSegStateList@@QAEXK@Z PROC NEAR			; CSegStateList::SetID, COMDAT
; _this$ = ecx

; 161  :     void SetID(DWORD dwID) { m_dwID = dwID; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwID$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetID@CSegStateList@@QAEXK@Z ENDP			; CSegStateList::SetID
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xboxutil.h
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT
___formal$ = 8
?DeleteCriticalSection@@YGXPAX@Z PROC NEAR		; DeleteCriticalSection, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   : }

  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
?DeleteCriticalSection@@YGXPAX@Z ENDP			; DeleteCriticalSection
_TEXT	ENDS
PUBLIC	?PackMidi@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z	; CPerformance::PackMidi
PUBLIC	??_C@_0CN@NPAKGIMN@Play?5MIDI?5failed?5on?5unassigned?5P@ ; `string'
;	COMDAT ??_C@_0CN@NPAKGIMN@Play?5MIDI?5failed?5on?5unassigned?5P@
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
??_C@_0CN@NPAKGIMN@Play?5MIDI?5failed?5on?5unassigned?5P@ DB 'Play MIDI f'
	DB	'ailed on unassigned PChannel %ld', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PackMidi@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
tv88 = -36
_this$ = -32
_lBend$73357 = -28
_hr$ = -24
_pMidi$ = -20
_pChannelMap$ = -16
_dwMsg$ = -12
_pBuffer$ = -8
_pPort$ = -4
_pEvent$ = 8
_rt$ = 12
?PackMidi@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::PackMidi, COMDAT
; _this$ = ecx

; 9789 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 9790 :     DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*)pEvent;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _pMidi$[ebp], eax

; 9791 :     IDirectMusicBuffer* pBuffer = NULL;

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pBuffer$[ebp], 0

; 9792 :     IDirectMusicPort* pPort = NULL;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pPort$[ebp], 0

; 9793 :     DWORD dwMsg;
; 9794 : //  DWORD dwGroup, dwMChannel, dwPortTableIndex;
; 9795 :     HRESULT hr = DMUS_S_FREE;

  0001d	c7 45 e8 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 9796 :     CChannelMap *pChannelMap = NULL;

  00024	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pChannelMap$[ebp], 0

; 9797 : 
; 9798 :     if( NULL == pMidi )

  0002b	83 7d ec 00	 cmp	 DWORD PTR _pMidi$[ebp], 0
  0002f	75 0a		 jne	 SHORT $L73329

; 9799 :         return E_INVALIDARG;

  00031	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00036	e9 12 03 00 00	 jmp	 $L73317
$L73329:

; 9800 : 
; 9801 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0003b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	81 c1 4c 03 00
	00		 add	 ecx, 844		; 0000034cH
  00044	51		 push	 ecx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9802 :     pChannelMap = GetPChannelMap(pMidi->dwPChannel);

  0004b	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  0004e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00051	50		 push	 eax
  00052	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z ; CPerformance::GetPChannelMap
  0005a	89 45 f0	 mov	 DWORD PTR _pChannelMap$[ebp], eax

; 9803 :     if (!pChannelMap)

  0005d	83 7d f0 00	 cmp	 DWORD PTR _pChannelMap$[ebp], 0
  00061	75 2f		 jne	 SHORT $L73331

; 9804 :     {
; 9805 :         Trace(1,"Play MIDI failed on unassigned PChannel %ld\n",pMidi->dwPChannel);

  00063	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  00066	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00069	52		 push	 edx
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@NPAKGIMN@Play?5MIDI?5failed?5on?5unassigned?5P@
  0006f	6a 01		 push	 1
  00071	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9806 :         LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00079	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  00081	50		 push	 eax
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9807 :         return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.

  00088	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  0008d	e9 bb 02 00 00	 jmp	 $L73317
$L73331:

; 9808 :     }
; 9809 : 
; 9810 : #ifdef DXAPI
; 9811 :     if( pChannelMap->dwPortIndex > m_dwNumPorts )
; 9812 :     {
; 9813 :         pPort = NULL; // the PChannel map is out of range of the number of ports
; 9814 :                     // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
; 9815 :     }
; 9816 :     else
; 9817 :     {
; 9818 :         pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
; 9819 :         if( pPort ) pPort->AddRef();
; 9820 :         pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
; 9821 :         if( pBuffer ) pBuffer->AddRef();
; 9822 :     }
; 9823 :     if(pPort && pBuffer )
; 9824 : #endif
; 9825 :     {
; 9826 :         pMidi->bStatus &= 0xF0;

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  00095	0f b6 51 38	 movzx	 edx, BYTE PTR [ecx+56]
  00099	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  0009f	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$[ebp]
  000a2	88 50 38	 mov	 BYTE PTR [eax+56], dl

; 9827 :         if (pMidi->bStatus == MIDI_CCHANGE)

  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  000a8	0f b6 51 38	 movzx	 edx, BYTE PTR [ecx+56]
  000ac	81 fa b0 00 00
	00		 cmp	 edx, 176		; 000000b0H
  000b2	0f 85 26 01 00
	00		 jne	 $L73337

; 9828 :         {
; 9829 :             switch (pMidi->bByte1)
; 9830 :             {

  000b8	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$[ebp]
  000bb	0f b6 48 39	 movzx	 ecx, BYTE PTR [eax+57]
  000bf	89 4d dc	 mov	 DWORD PTR tv88[ebp], ecx
  000c2	8b 55 dc	 mov	 edx, DWORD PTR tv88[ebp]
  000c5	83 ea 01	 sub	 edx, 1
  000c8	89 55 dc	 mov	 DWORD PTR tv88[ebp], edx
  000cb	83 7d dc 78	 cmp	 DWORD PTR tv88[ebp], 120 ; 00000078H
  000cf	0f 87 04 01 00
	00		 ja	 $L73339
  000d5	8b 45 dc	 mov	 eax, DWORD PTR tv88[ebp]
  000d8	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L75893[eax]
  000df	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L75894[ecx*4]
$L73342:

; 9831 :             case MIDI_CC_MOD_WHEEL:
; 9832 :                 pMidi->bByte2 = (BYTE) pChannelMap->m_ModWheelMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);

  000e6	6a 7f		 push	 127			; 0000007fH
  000e8	6a 7f		 push	 127			; 0000007fH
  000ea	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  000ed	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  000f1	50		 push	 eax
  000f2	6a 00		 push	 0
  000f4	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  000f7	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000fa	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  000ff	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  00102	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9833 :                 break;

  00105	e9 cf 00 00 00	 jmp	 $L73339
$L73344:

; 9834 :             case MIDI_CC_VOLUME:
; 9835 :                 pMidi->bByte2 = pChannelMap->m_VolumeMerger.MergeMidiVolume(0,pMidi->bByte2);

  0010a	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  0010d	8a 42 3a	 mov	 al, BYTE PTR [edx+58]
  00110	50		 push	 eax
  00111	6a 00		 push	 0
  00113	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00116	e8 00 00 00 00	 call	 ?MergeMidiVolume@CParamMerger@@QAEEKE@Z ; CParamMerger::MergeMidiVolume
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  0011e	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9836 :                 break;

  00121	e9 b3 00 00 00	 jmp	 $L73339
$L73345:

; 9837 :             case MIDI_CC_PAN:
; 9838 :                 pMidi->bByte2 = (BYTE) pChannelMap->m_PanMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);

  00126	6a 7f		 push	 127			; 0000007fH
  00128	6a 40		 push	 64			; 00000040H
  0012a	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  0012d	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  00131	50		 push	 eax
  00132	6a 00		 push	 0
  00134	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00137	83 c1 34	 add	 ecx, 52			; 00000034H
  0013a	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  0013f	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  00142	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9839 :                 break;

  00145	e9 8f 00 00 00	 jmp	 $L73339
$L73347:

; 9840 :             case MIDI_CC_EXPRESSION:
; 9841 :                 pMidi->bByte2 = pChannelMap->m_ExpressionMerger.MergeMidiVolume(0,pMidi->bByte2);

  0014a	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  0014d	8a 42 3a	 mov	 al, BYTE PTR [edx+58]
  00150	50		 push	 eax
  00151	6a 00		 push	 0
  00153	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00156	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00159	e8 00 00 00 00	 call	 ?MergeMidiVolume@CParamMerger@@QAEEKE@Z ; CParamMerger::MergeMidiVolume
  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  00161	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9842 :                 break;

  00164	eb 73		 jmp	 SHORT $L73339
$L73348:

; 9843 :             case MIDI_CC_FILTER:
; 9844 :                 pMidi->bByte2 = (BYTE) pChannelMap->m_FilterMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);

  00166	6a 7f		 push	 127			; 0000007fH
  00168	6a 40		 push	 64			; 00000040H
  0016a	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  0016d	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  00171	50		 push	 eax
  00172	6a 00		 push	 0
  00174	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00177	83 c1 40	 add	 ecx, 64			; 00000040H
  0017a	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  0017f	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  00182	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9845 :                 break;

  00185	eb 52		 jmp	 SHORT $L73339
$L73350:

; 9846 :             case MIDI_CC_REVERB:
; 9847 :                 pMidi->bByte2 = (BYTE) pChannelMap->m_ReverbMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);

  00187	6a 7f		 push	 127			; 0000007fH
  00189	6a 7f		 push	 127			; 0000007fH
  0018b	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  0018e	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  00192	50		 push	 eax
  00193	6a 00		 push	 0
  00195	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  00198	83 c1 58	 add	 ecx, 88			; 00000058H
  0019b	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  001a0	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  001a3	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9848 :                 break;

  001a6	eb 31		 jmp	 SHORT $L73339
$L73352:

; 9849 :             case MIDI_CC_CHORUS:
; 9850 :                 pMidi->bByte2 = (BYTE) pChannelMap->m_ChorusMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);

  001a8	6a 7f		 push	 127			; 0000007fH
  001aa	6a 7f		 push	 127			; 0000007fH
  001ac	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  001af	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  001b3	50		 push	 eax
  001b4	6a 00		 push	 0
  001b6	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  001b9	83 c1 64	 add	 ecx, 100		; 00000064H
  001bc	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  001c1	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  001c4	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 9851 :                 break;

  001c7	eb 10		 jmp	 SHORT $L73339
$L73354:

; 9852 :             case MIDI_CC_RESETALL:
; 9853 :                 pChannelMap->Reset(pMidi->bByte2);

  001c9	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  001cc	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  001d0	50		 push	 eax
  001d1	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  001d4	e8 00 00 00 00	 call	 ?Reset@CChannelMap@@QAEXH@Z ; CChannelMap::Reset
$L73339:

; 9854 :                 break;
; 9855 :             }
; 9856 : 
; 9857 :         }
; 9858 :         else if (pMidi->bStatus == MIDI_PBEND)

  001d9	e9 a9 00 00 00	 jmp	 $L73355
$L73337:
  001de	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$[ebp]
  001e1	0f b6 51 38	 movzx	 edx, BYTE PTR [ecx+56]
  001e5	81 fa e0 00 00
	00		 cmp	 edx, 224		; 000000e0H
  001eb	0f 85 96 00 00
	00		 jne	 $L73355

; 9859 :         {
; 9860 :             long lBend = pMidi->bByte1 | (pMidi->bByte2 << 7);

  001f1	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$[ebp]
  001f4	0f b6 48 39	 movzx	 ecx, BYTE PTR [eax+57]
  001f8	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  001fb	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  001ff	c1 e0 07	 shl	 eax, 7
  00202	0b c8		 or	 ecx, eax
  00204	89 4d e4	 mov	 DWORD PTR _lBend$73357[ebp], ecx

; 9861 :             lBend -= 0x2000;

  00207	8b 4d e4	 mov	 ecx, DWORD PTR _lBend$73357[ebp]
  0020a	81 e9 00 20 00
	00		 sub	 ecx, 8192		; 00002000H
  00210	89 4d e4	 mov	 DWORD PTR _lBend$73357[ebp], ecx

; 9862 :             lBend *= pChannelMap->m_PitchbendMerger.m_lBendRange;;

  00213	8b 55 f0	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  00216	8b 45 e4	 mov	 eax, DWORD PTR _lBend$73357[ebp]
  00219	0f af 42 30	 imul	 eax, DWORD PTR [edx+48]
  0021d	89 45 e4	 mov	 DWORD PTR _lBend$73357[ebp], eax

; 9863 :             lBend += 0x1000;        // handle rounding up.

  00220	8b 4d e4	 mov	 ecx, DWORD PTR _lBend$73357[ebp]
  00223	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  00229	89 4d e4	 mov	 DWORD PTR _lBend$73357[ebp], ecx

; 9864 :             lBend /= 0x2000;

  0022c	8b 45 e4	 mov	 eax, DWORD PTR _lBend$73357[ebp]
  0022f	99		 cdq
  00230	81 e2 ff 1f 00
	00		 and	 edx, 8191		; 00001fffH
  00236	03 c2		 add	 eax, edx
  00238	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  0023b	89 45 e4	 mov	 DWORD PTR _lBend$73357[ebp], eax

; 9865 :             lBend += 0x2000;

  0023e	8b 55 e4	 mov	 edx, DWORD PTR _lBend$73357[ebp]
  00241	81 c2 00 20 00
	00		 add	 edx, 8192		; 00002000H
  00247	89 55 e4	 mov	 DWORD PTR _lBend$73357[ebp], edx

; 9866 :             lBend = pChannelMap->m_PitchbendMerger.MergeValue(0,lBend,0x2000,0x3FFF);

  0024a	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0024f	68 00 20 00 00	 push	 8192			; 00002000H
  00254	8b 45 e4	 mov	 eax, DWORD PTR _lBend$73357[ebp]
  00257	50		 push	 eax
  00258	6a 00		 push	 0
  0025a	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  0025d	83 c1 24	 add	 ecx, 36			; 00000024H
  00260	e8 00 00 00 00	 call	 ?MergeValue@CParamMerger@@QAEJKJJJ@Z ; CParamMerger::MergeValue
  00265	89 45 e4	 mov	 DWORD PTR _lBend$73357[ebp], eax

; 9867 :             pMidi->bByte1 = (BYTE) lBend & 0x7F;

  00268	0f b6 4d e4	 movzx	 ecx, BYTE PTR _lBend$73357[ebp]
  0026c	83 e1 7f	 and	 ecx, 127		; 0000007fH
  0026f	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  00272	88 4a 39	 mov	 BYTE PTR [edx+57], cl

; 9868 :             pMidi->bByte2 = (BYTE) (lBend >> 7) & 0x7F;

  00275	8b 45 e4	 mov	 eax, DWORD PTR _lBend$73357[ebp]
  00278	c1 f8 07	 sar	 eax, 7
  0027b	0f b6 c8	 movzx	 ecx, al
  0027e	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00281	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  00284	88 4a 3a	 mov	 BYTE PTR [edx+58], cl
$L73355:

; 9869 :         }
; 9870 :         dwMsg = pMidi->bByte1 << 8;

  00287	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$[ebp]
  0028a	0f b6 48 39	 movzx	 ecx, BYTE PTR [eax+57]
  0028e	c1 e1 08	 shl	 ecx, 8
  00291	89 4d f4	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9871 :         dwMsg |= pMidi->bByte2 << 16;

  00294	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  00297	0f b6 42 3a	 movzx	 eax, BYTE PTR [edx+58]
  0029b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0029e	8b 4d f4	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  002a1	0b c8		 or	 ecx, eax
  002a3	89 4d f4	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9872 :         dwMsg |= pMidi->bStatus;

  002a6	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$[ebp]
  002a9	0f b6 42 38	 movzx	 eax, BYTE PTR [edx+56]
  002ad	8b 4d f4	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  002b0	0b c8		 or	 ecx, eax
  002b2	89 4d f4	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 9873 :         dwMsg |= pChannelMap->dwMChannel;

  002b5	8b 55 f0	 mov	 edx, DWORD PTR _pChannelMap$[ebp]
  002b8	8b 45 f4	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  002bb	0b 42 78	 or	 eax, DWORD PTR [edx+120]
  002be	89 45 f4	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 9874 :         if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))

  002c1	8b 4d f0	 mov	 ecx, DWORD PTR _pChannelMap$[ebp]
  002c4	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  002c7	52		 push	 edx
  002c8	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  002cb	50		 push	 eax
  002cc	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  002cf	51		 push	 ecx
  002d0	8b 55 f4	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  002d3	52		 push	 edx
  002d4	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  002d7	50		 push	 eax
  002d8	8b 4d f8	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  002db	51		 push	 ecx
  002dc	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002df	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg
  002e4	0f b6 d0	 movzx	 edx, al
  002e7	85 d2		 test	 edx, edx
  002e9	74 2c		 je	 SHORT $L73360

; 9875 :         {
; 9876 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 9877 :             m_dwTempMIDIPerSecond++;

  002eb	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  002ee	8b 88 08 04 00
	00		 mov	 ecx, DWORD PTR [eax+1032]
  002f4	83 c1 01	 add	 ecx, 1
  002f7	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  002fa	89 8a 08 04 00
	00		 mov	 DWORD PTR [edx+1032], ecx

; 9878 :             UpdateDebugParams();

  00300	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00303	e8 00 00 00 00	 call	 ?UpdateDebugParams@CPerformance@@AAEXXZ ; CPerformance::UpdateDebugParams

; 9879 : #endif               
; 9880 : #ifdef DXAPI
; 9881 :             m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
; 9882 :             m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
; 9883 : #else
; 9884 :             m_rtLastSendTime = rt;

  00308	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0030b	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  0030e	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00311	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  00314	89 50 2c	 mov	 DWORD PTR [eax+44], edx
$L73360:

; 9885 : #endif
; 9886 :         }
; 9887 :     }
; 9888 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00317	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0031a	05 4c 03 00 00	 add	 eax, 844		; 0000034cH
  0031f	50		 push	 eax
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 9889 :     if( pPort ) pPort->Release();

  00326	83 7d fc 00	 cmp	 DWORD PTR _pPort$[ebp], 0
  0032a	74 0c		 je	 SHORT $L73361
  0032c	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  0032f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00331	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  00334	50		 push	 eax
  00335	ff 52 08	 call	 DWORD PTR [edx+8]
$L73361:

; 9890 :     if( pBuffer ) pBuffer->Release();

  00338	83 7d f8 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  0033c	74 0c		 je	 SHORT $L73362
  0033e	8b 4d f8	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00341	8b 11		 mov	 edx, DWORD PTR [ecx]
  00343	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00346	50		 push	 eax
  00347	ff 52 08	 call	 DWORD PTR [edx+8]
$L73362:

; 9891 :     return hr;

  0034a	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
$L73317:

; 9892 : }

  0034d	8b e5		 mov	 esp, ebp
  0034f	5d		 pop	 ebp
  00350	c2 0c 00	 ret	 12			; 0000000cH
$L75894:
  00353	00 00 00 00	 DD	 $L73342
  00357	00 00 00 00	 DD	 $L73344
  0035b	00 00 00 00	 DD	 $L73345
  0035f	00 00 00 00	 DD	 $L73347
  00363	00 00 00 00	 DD	 $L73348
  00367	00 00 00 00	 DD	 $L73350
  0036b	00 00 00 00	 DD	 $L73352
  0036f	00 00 00 00	 DD	 $L73354
  00373	00 00 00 00	 DD	 $L73339
$L75893:
  00377	00		 DB	 0
  00378	08		 DB	 8
  00379	08		 DB	 8
  0037a	08		 DB	 8
  0037b	08		 DB	 8
  0037c	08		 DB	 8
  0037d	01		 DB	 1
  0037e	08		 DB	 8
  0037f	08		 DB	 8
  00380	02		 DB	 2
  00381	03		 DB	 3
  00382	08		 DB	 8
  00383	08		 DB	 8
  00384	08		 DB	 8
  00385	08		 DB	 8
  00386	08		 DB	 8
  00387	08		 DB	 8
  00388	08		 DB	 8
  00389	08		 DB	 8
  0038a	08		 DB	 8
  0038b	08		 DB	 8
  0038c	08		 DB	 8
  0038d	08		 DB	 8
  0038e	08		 DB	 8
  0038f	08		 DB	 8
  00390	08		 DB	 8
  00391	08		 DB	 8
  00392	08		 DB	 8
  00393	08		 DB	 8
  00394	08		 DB	 8
  00395	08		 DB	 8
  00396	08		 DB	 8
  00397	08		 DB	 8
  00398	08		 DB	 8
  00399	08		 DB	 8
  0039a	08		 DB	 8
  0039b	08		 DB	 8
  0039c	08		 DB	 8
  0039d	08		 DB	 8
  0039e	08		 DB	 8
  0039f	08		 DB	 8
  003a0	08		 DB	 8
  003a1	08		 DB	 8
  003a2	08		 DB	 8
  003a3	08		 DB	 8
  003a4	08		 DB	 8
  003a5	08		 DB	 8
  003a6	08		 DB	 8
  003a7	08		 DB	 8
  003a8	08		 DB	 8
  003a9	08		 DB	 8
  003aa	08		 DB	 8
  003ab	08		 DB	 8
  003ac	08		 DB	 8
  003ad	08		 DB	 8
  003ae	08		 DB	 8
  003af	08		 DB	 8
  003b0	08		 DB	 8
  003b1	08		 DB	 8
  003b2	08		 DB	 8
  003b3	08		 DB	 8
  003b4	08		 DB	 8
  003b5	08		 DB	 8
  003b6	08		 DB	 8
  003b7	08		 DB	 8
  003b8	08		 DB	 8
  003b9	08		 DB	 8
  003ba	08		 DB	 8
  003bb	08		 DB	 8
  003bc	08		 DB	 8
  003bd	08		 DB	 8
  003be	08		 DB	 8
  003bf	08		 DB	 8
  003c0	04		 DB	 4
  003c1	08		 DB	 8
  003c2	08		 DB	 8
  003c3	08		 DB	 8
  003c4	08		 DB	 8
  003c5	08		 DB	 8
  003c6	08		 DB	 8
  003c7	08		 DB	 8
  003c8	08		 DB	 8
  003c9	08		 DB	 8
  003ca	08		 DB	 8
  003cb	08		 DB	 8
  003cc	08		 DB	 8
  003cd	08		 DB	 8
  003ce	08		 DB	 8
  003cf	08		 DB	 8
  003d0	08		 DB	 8
  003d1	05		 DB	 5
  003d2	08		 DB	 8
  003d3	06		 DB	 6
  003d4	08		 DB	 8
  003d5	08		 DB	 8
  003d6	08		 DB	 8
  003d7	08		 DB	 8
  003d8	08		 DB	 8
  003d9	08		 DB	 8
  003da	08		 DB	 8
  003db	08		 DB	 8
  003dc	08		 DB	 8
  003dd	08		 DB	 8
  003de	08		 DB	 8
  003df	08		 DB	 8
  003e0	08		 DB	 8
  003e1	08		 DB	 8
  003e2	08		 DB	 8
  003e3	08		 DB	 8
  003e4	08		 DB	 8
  003e5	08		 DB	 8
  003e6	08		 DB	 8
  003e7	08		 DB	 8
  003e8	08		 DB	 8
  003e9	08		 DB	 8
  003ea	08		 DB	 8
  003eb	08		 DB	 8
  003ec	08		 DB	 8
  003ed	08		 DB	 8
  003ee	08		 DB	 8
  003ef	07		 DB	 7
?PackMidi@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ENDP	; CPerformance::PackMidi
_TEXT	ENDS
PUBLIC	?PackSysEx@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackSysEx
PUBLIC	??_C@_0CO@MHMNIDNE@Play?5SysEx?5failed?5on?5unassigned?5@ ; `string'
;	COMDAT ??_C@_0CO@MHMNIDNE@Play?5SysEx?5failed?5on?5unassigned?5@
CONST	SEGMENT
??_C@_0CO@MHMNIDNE@Play?5SysEx?5failed?5on?5unassigned?5@ DB 'Play SysEx '
	DB	'failed on unassigned PChannel %ld', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PackSysEx@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
_this$ = -32
_hr$ = -28
_pSysEx$ = -24
_dwGroup$ = -20
_dwPortTableIndex$ = -16
_dwMChannel$ = -12
_pBuffer$ = -8
_pPort$ = -4
_pEvent$ = 8
_rt$ = 12
?PackSysEx@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::PackSysEx, COMDAT
; _this$ = ecx

; 9899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 9900 :     DMUS_SYSEX_PMSG* pSysEx = (DMUS_SYSEX_PMSG*)pEvent;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _pSysEx$[ebp], eax

; 9901 :     IDirectMusicBuffer* pBuffer = NULL;

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pBuffer$[ebp], 0

; 9902 :     IDirectMusicPort* pPort = NULL;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pPort$[ebp], 0

; 9903 :     DWORD dwGroup, dwMChannel, dwPortTableIndex;
; 9904 :     HRESULT hr = DMUS_S_FREE;

  0001d	c7 45 e4 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 9905 : 
; 9906 :     if( NULL == pEvent )

  00024	83 7d 08 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  00028	75 07		 jne	 SHORT $L73380

; 9907 :         return E_INVALIDARG;

  0002a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002f	eb 69		 jmp	 SHORT $L73367
$L73380:

; 9908 : 
; 9909 :     if( FAILED( PChannelIndex( pSysEx->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))

  00031	6a 00		 push	 0
  00033	8d 4d f4	 lea	 ecx, DWORD PTR _dwMChannel$[ebp]
  00036	51		 push	 ecx
  00037	8d 55 ec	 lea	 edx, DWORD PTR _dwGroup$[ebp]
  0003a	52		 push	 edx
  0003b	8d 45 f0	 lea	 eax, DWORD PTR _dwPortTableIndex$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d e8	 mov	 ecx, DWORD PTR _pSysEx$[ebp]
  00042	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00045	52		 push	 edx
  00046	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  0004e	85 c0		 test	 eax, eax
  00050	7d 1d		 jge	 SHORT $L73383

; 9910 :     {
; 9911 :         Trace(1,"Play SysEx failed on unassigned PChannel %ld\n",pSysEx->dwPChannel);

  00052	8b 45 e8	 mov	 eax, DWORD PTR _pSysEx$[ebp]
  00055	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00058	51		 push	 ecx
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@MHMNIDNE@Play?5SysEx?5failed?5on?5unassigned?5@
  0005e	6a 01		 push	 1
  00060	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9912 :         return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.

  00068	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  0006d	eb 2b		 jmp	 SHORT $L73367
$L73383:

; 9913 :     }
; 9914 : #ifdef DXAPI
; 9915 :     if( NULL == m_pDirectMusic )
; 9916 :         return DMUS_E_NOT_INIT;
; 9917 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 9918 :     if( dwPortTableIndex > m_dwNumPorts )
; 9919 :     {
; 9920 :         pPort = NULL; // the PChannel map is out of range of the number of ports
; 9921 :                     // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
; 9922 :     }
; 9923 :     else
; 9924 :     {
; 9925 :         pPort = m_pPortTable[dwPortTableIndex].pPort;
; 9926 :         if( pPort ) pPort->AddRef();
; 9927 :     }
; 9928 :     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
; 9929 :     if( pPort )
; 9930 :     {
; 9931 :         // create a buffer of the right size
; 9932 :         DMUS_BUFFERDESC dmbd;
; 9933 :         memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
; 9934 :         dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
; 9935 :         dmbd.cbBuffer = pSysEx->dwLen + 48;
; 9936 : 
; 9937 :         ENTER_CRITICAL_SECTION(&m_MainCrSec);
; 9938 :         if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
; 9939 :         {
; 9940 :             if( SUCCEEDED( pBuffer->PackUnstructured( rt - 4, dwGroup, pSysEx->dwLen, pSysEx->abData ) ) )
; 9941 :             {
; 9942 : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 9943 :                 m_dwTempSysExPerSecond++;
; 9944 :                 UpdateDebugParams();
; 9945 : #endif   
; 9946 :                 pPort->PlayBuffer(pBuffer);
; 9947 :             }
; 9948 :             pBuffer->Release();
; 9949 :         }
; 9950 :         LEAVE_CRITICAL_SECTION(&m_MainCrSec);
; 9951 :     }
; 9952 :     if( pPort ) pPort->Release();
; 9953 : #else
; 9954 :     SendLongMsg(pSysEx->abData,pSysEx->dwLen,rt - 4, dwGroup);

  0006f	8b 55 ec	 mov	 edx, DWORD PTR _dwGroup$[ebp]
  00072	52		 push	 edx
  00073	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  00076	83 e8 04	 sub	 eax, 4
  00079	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  0007c	83 d9 00	 sbb	 ecx, 0
  0007f	51		 push	 ecx
  00080	50		 push	 eax
  00081	8b 55 e8	 mov	 edx, DWORD PTR _pSysEx$[ebp]
  00084	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00087	50		 push	 eax
  00088	8b 4d e8	 mov	 ecx, DWORD PTR _pSysEx$[ebp]
  0008b	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0008e	51		 push	 ecx
  0008f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?SendLongMsg@CPerformance@@AAEXPAEK_JK@Z ; CPerformance::SendLongMsg

; 9955 : #endif
; 9956 :     return hr;

  00097	8b 45 e4	 mov	 eax, DWORD PTR _hr$[ebp]
$L73367:

; 9957 : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 0c 00	 ret	 12			; 0000000cH
?PackSysEx@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ENDP	; CPerformance::PackSysEx
_TEXT	ENDS
PUBLIC	?PackPatch@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackPatch
PUBLIC	??_C@_0CO@NBCGDOIB@Play?5Patch?5failed?5on?5unassigned?5@ ; `string'
PUBLIC	??_C@_0BA@MKABIODL@dwMChannel?5?$DM?516?$AA@	; `string'
;	COMDAT ??_C@_0CO@NBCGDOIB@Play?5Patch?5failed?5on?5unassigned?5@
CONST	SEGMENT
??_C@_0CO@NBCGDOIB@Play?5Patch?5failed?5on?5unassigned?5@ DB 'Play Patch '
	DB	'failed on unassigned PChannel %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKABIODL@dwMChannel?5?$DM?516?$AA@
CONST	SEGMENT
??_C@_0BA@MKABIODL@dwMChannel?5?$DM?516?$AA@ DB 'dwMChannel < 16', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PackPatch@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
_this$ = -36
_hr$ = -32
_dwGroup$ = -28
_dwPortTableIndex$ = -24
_dwMsg$ = -20
_dwMChannel$ = -16
_pPatch$ = -12
_pBuffer$ = -8
_pPort$ = -4
_pEvent$ = 8
_rt$ = 12
?PackPatch@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::PackPatch, COMDAT
; _this$ = ecx

; 9964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 9965 :     DMUS_PATCH_PMSG* pPatch = (DMUS_PATCH_PMSG*)pEvent;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pEvent$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _pPatch$[ebp], eax

; 9966 :     IDirectMusicBuffer* pBuffer = NULL;

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pBuffer$[ebp], 0

; 9967 :     IDirectMusicPort* pPort = NULL;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pPort$[ebp], 0

; 9968 :     DWORD dwGroup, dwMChannel, dwPortTableIndex;
; 9969 :     DWORD dwMsg;
; 9970 :     HRESULT hr = DMUS_S_FREE;

  0001d	c7 45 e0 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 9971 : 
; 9972 :     if( NULL == pEvent )

  00024	83 7d 08 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  00028	75 0a		 jne	 SHORT $L73407

; 9973 :         return E_INVALIDARG;

  0002a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002f	e9 ce 01 00 00	 jmp	 $L73393
$L73407:

; 9974 : 
; 9975 :     if( FAILED( PChannelIndex( pPatch->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))

  00034	6a 00		 push	 0
  00036	8d 4d f0	 lea	 ecx, DWORD PTR _dwMChannel$[ebp]
  00039	51		 push	 ecx
  0003a	8d 55 e4	 lea	 edx, DWORD PTR _dwGroup$[ebp]
  0003d	52		 push	 edx
  0003e	8d 45 e8	 lea	 eax, DWORD PTR _dwPortTableIndex$[ebp]
  00041	50		 push	 eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _pPatch$[ebp]
  00045	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00048	52		 push	 edx
  00049	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  00051	85 c0		 test	 eax, eax
  00053	7d 20		 jge	 SHORT $L73410

; 9976 :     {
; 9977 :         Trace(1,"Play Patch failed on unassigned PChannel %ld\n",pPatch->dwPChannel);

  00055	8b 45 f4	 mov	 eax, DWORD PTR _pPatch$[ebp]
  00058	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005b	51		 push	 ecx
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@NBCGDOIB@Play?5Patch?5failed?5on?5unassigned?5@
  00061	6a 01		 push	 1
  00063	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9978 :         return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.

  0006b	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  00070	e9 8d 01 00 00	 jmp	 $L73393
$L73410:

; 9979 :     }
; 9980 :     ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00075	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00078	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  0007e	52		 push	 edx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 9981 : #ifdef DXAPI
; 9982 :     if( dwPortTableIndex > m_dwNumPorts )
; 9983 :     {
; 9984 :         pPort = NULL; // the PChannel map is out of range of the number of ports
; 9985 :                     // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
; 9986 :     }
; 9987 :     else
; 9988 :     {
; 9989 :         pPort = m_pPortTable[dwPortTableIndex].pPort;
; 9990 :         if( pPort ) pPort->AddRef();
; 9991 :         pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
; 9992 :         if( pBuffer ) pBuffer->AddRef();
; 9993 :     }
; 9994 :     if( pPort && pBuffer) 
; 9995 : #endif
; 9996 :     {
; 9997 :         // subtract 10 from rt to guarantee that patch events always go out earlier than
; 9998 :         // notes with the same time stamp.
; 9999 :         rt -= 10;

  00085	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  00088	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0008b	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  0008e	83 d9 00	 sbb	 ecx, 0
  00091	89 45 0c	 mov	 DWORD PTR _rt$[ebp], eax
  00094	89 4d 10	 mov	 DWORD PTR _rt$[ebp+4], ecx

; 10000:         // send the bank select lsb
; 10001:         dwMsg = MIDI_CCHANGE;

  00097	c7 45 ec b0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 176 ; 000000b0H

; 10002:         dwMsg |= ( MIDI_CC_BS_LSB << 8 );

  0009e	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  000a1	81 ca 00 20 00
	00		 or	 edx, 8192		; 00002000H
  000a7	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 10003:         dwMsg |= (pPatch->byLSB << 16);

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _pPatch$[ebp]
  000ad	0f b6 48 3a	 movzx	 ecx, BYTE PTR [eax+58]
  000b1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000b4	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  000b7	0b d1		 or	 edx, ecx
  000b9	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 10004:         ASSERT( dwMChannel < 16 );

  000bc	83 7d f0 10	 cmp	 DWORD PTR _dwMChannel$[ebp], 16 ; 00000010H
  000c0	72 17		 jb	 SHORT $L73416
  000c2	6a 00		 push	 0
  000c4	68 14 27 00 00	 push	 10004			; 00002714H
  000c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@MKABIODL@dwMChannel?5?$DM?516?$AA@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L73416:

; 10005:         dwMsg |= dwMChannel;

  000d9	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  000dc	0b 45 f0	 or	 eax, DWORD PTR _dwMChannel$[ebp]
  000df	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 10006:         SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup);

  000e2	8b 4d e4	 mov	 ecx, DWORD PTR _dwGroup$[ebp]
  000e5	51		 push	 ecx
  000e6	8b 55 0c	 mov	 edx, DWORD PTR _rt$[ebp]
  000e9	83 ea 02	 sub	 edx, 2
  000ec	8b 45 10	 mov	 eax, DWORD PTR _rt$[ebp+4]
  000ef	83 d8 00	 sbb	 eax, 0
  000f2	50		 push	 eax
  000f3	52		 push	 edx
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  000f7	51		 push	 ecx
  000f8	8b 55 fc	 mov	 edx, DWORD PTR _pPort$[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  000ff	50		 push	 eax
  00100	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 10007:         // send the bank select msb
; 10008:         dwMsg = MIDI_CCHANGE;

  00108	c7 45 ec b0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 176 ; 000000b0H

; 10009:         dwMsg |= ( MIDI_CC_BS_MSB << 8 );

  0010f	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00112	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 10010:         dwMsg |= (pPatch->byMSB << 16);

  00115	8b 55 f4	 mov	 edx, DWORD PTR _pPatch$[ebp]
  00118	0f b6 42 39	 movzx	 eax, BYTE PTR [edx+57]
  0011c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0011f	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00122	0b c8		 or	 ecx, eax
  00124	89 4d ec	 mov	 DWORD PTR _dwMsg$[ebp], ecx

; 10011:         dwMsg |= dwMChannel;

  00127	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  0012a	0b 55 f0	 or	 edx, DWORD PTR _dwMChannel$[ebp]
  0012d	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 10012:         SendShortMsg(pBuffer,pPort,dwMsg,rt-1,dwGroup);

  00130	8b 45 e4	 mov	 eax, DWORD PTR _dwGroup$[ebp]
  00133	50		 push	 eax
  00134	8b 4d 0c	 mov	 ecx, DWORD PTR _rt$[ebp]
  00137	83 e9 01	 sub	 ecx, 1
  0013a	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  0013d	83 da 00	 sbb	 edx, 0
  00140	52		 push	 edx
  00141	51		 push	 ecx
  00142	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00145	50		 push	 eax
  00146	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  00149	51		 push	 ecx
  0014a	8b 55 f8	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  0014d	52		 push	 edx
  0014e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg

; 10013:         // send the program change
; 10014:         dwMsg = MIDI_PCHANGE;

  00156	c7 45 ec c0 00
	00 00		 mov	 DWORD PTR _dwMsg$[ebp], 192 ; 000000c0H

; 10015:         dwMsg |= (pPatch->byInstrument << 8);

  0015d	8b 45 f4	 mov	 eax, DWORD PTR _pPatch$[ebp]
  00160	0f b6 48 38	 movzx	 ecx, BYTE PTR [eax+56]
  00164	c1 e1 08	 shl	 ecx, 8
  00167	8b 55 ec	 mov	 edx, DWORD PTR _dwMsg$[ebp]
  0016a	0b d1		 or	 edx, ecx
  0016c	89 55 ec	 mov	 DWORD PTR _dwMsg$[ebp], edx

; 10016:         dwMsg |= dwMChannel;

  0016f	8b 45 ec	 mov	 eax, DWORD PTR _dwMsg$[ebp]
  00172	0b 45 f0	 or	 eax, DWORD PTR _dwMChannel$[ebp]
  00175	89 45 ec	 mov	 DWORD PTR _dwMsg$[ebp], eax

; 10017:         if (SendShortMsg(pBuffer,pPort,dwMsg,rt,dwGroup))

  00178	8b 4d e4	 mov	 ecx, DWORD PTR _dwGroup$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 55 10	 mov	 edx, DWORD PTR _rt$[ebp+4]
  0017f	52		 push	 edx
  00180	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  00183	50		 push	 eax
  00184	8b 4d ec	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00187	51		 push	 ecx
  00188	8b 55 fc	 mov	 edx, DWORD PTR _pPort$[ebp]
  0018b	52		 push	 edx
  0018c	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0018f	50		 push	 eax
  00190	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ; CPerformance::SendShortMsg
  00198	0f b6 c8	 movzx	 ecx, al
  0019b	85 c9		 test	 ecx, ecx
  0019d	74 0f		 je	 SHORT $L73418

; 10018:         {
; 10019: #ifdef DXAPI
; 10020:             m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
; 10021:             m_pPortTable[dwPortTableIndex].rtLast = rt;
; 10022: #else
; 10023:             m_rtLastSendTime = rt;

  0019f	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001a2	8b 45 0c	 mov	 eax, DWORD PTR _rt$[ebp]
  001a5	89 42 28	 mov	 DWORD PTR [edx+40], eax
  001a8	8b 4d 10	 mov	 ecx, DWORD PTR _rt$[ebp+4]
  001ab	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$L73418:

; 10024: #endif
; 10025:         }
; 10026: #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 10027:         m_dwTempPatchesPerSecond++;

  001ae	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001b1	8b 82 0c 04 00
	00		 mov	 eax, DWORD PTR [edx+1036]
  001b7	83 c0 01	 add	 eax, 1
  001ba	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bd	89 81 0c 04 00
	00		 mov	 DWORD PTR [ecx+1036], eax

; 10028:         UpdateDebugParams();

  001c3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c6	e8 00 00 00 00	 call	 ?UpdateDebugParams@CPerformance@@AAEXXZ ; CPerformance::UpdateDebugParams

; 10029: #endif
; 10030:     }
; 10031:     LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  001cb	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001ce	81 c2 4c 03 00
	00		 add	 edx, 844		; 0000034cH
  001d4	52		 push	 edx
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10032:     if( pPort ) pPort->Release();

  001db	83 7d fc 00	 cmp	 DWORD PTR _pPort$[ebp], 0
  001df	74 0c		 je	 SHORT $L73419
  001e1	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  001e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e6	8b 55 fc	 mov	 edx, DWORD PTR _pPort$[ebp]
  001e9	52		 push	 edx
  001ea	ff 51 08	 call	 DWORD PTR [ecx+8]
$L73419:

; 10033:     if( pBuffer ) pBuffer->Release();

  001ed	83 7d f8 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  001f1	74 0c		 je	 SHORT $L73420
  001f3	8b 45 f8	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  001f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f8	8b 55 f8	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  001fb	52		 push	 edx
  001fc	ff 51 08	 call	 DWORD PTR [ecx+8]
$L73420:

; 10034:     return hr;

  001ff	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
$L73393:

; 10035: }

  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c2 0c 00	 ret	 12			; 0000000cH
?PackPatch@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ENDP	; CPerformance::PackPatch
_TEXT	ENDS
PUBLIC	?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z	; CPerformance::PackWave
; Function compile flags: /Odt
;	COMDAT ?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
_this$ = -24
_dwGroup$73436 = -20
_dwPortTableIndex$73435 = -16
_dwMChannel$73437 = -12
_hr$ = -8
_pWave$ = -4
_pPMsg$ = 8
_rtTime$ = 12
?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::PackWave, COMDAT
; _this$ = ecx

; 10038: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 10039:     DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pWave$[ebp], eax

; 10040:     HRESULT hr = DMUS_S_FREE;

  0000f	c7 45 f8 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 10041: #ifdef DXAPI
; 10042:     IDirectMusicVoiceP *pVoice = (IDirectMusicVoiceP *) pWave->punkUser;
; 10043:     if (pVoice)
; 10044: #endif
; 10045:     {
; 10046:         if (pWave->bFlags & DMUS_WAVEF_OFF)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  00019	0f b6 51 58	 movzx	 edx, BYTE PTR [ecx+88]
  0001d	83 e2 01	 and	 edx, 1
  00020	85 d2		 test	 edx, edx
  00022	74 26		 je	 SHORT $L73433

; 10047:         {
; 10048: #ifdef DXAPI
; 10049:             pVoice->Stop(rtTime);
; 10050:             ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
; 10051:             for (DWORD dwCount = 0; dwCount < SQ_COUNT; dwCount++)
; 10052:             {
; 10053:                 for( CSegState* pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
; 10054:                 {
; 10055: 	                CTrack* pTrack = pSegSt->m_TrackList.GetHead();
; 10056: 	                while( pTrack )
; 10057: 	                {
; 10058:                         if (pTrack->m_guidClassID == CLSID_DirectMusicWaveTrack)
; 10059:                         {
; 10060:                             IPrivateWaveTrack* pWaveTrack = NULL;
; 10061:                             if (pTrack->m_pTrack &&
; 10062:                                 SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pWaveTrack)))
; 10063:                             {
; 10064:                                 pWaveTrack->OnVoiceEnd(pVoice, pTrack->m_pTrackState);
; 10065:                                 pWaveTrack->Release();
; 10066:                             }
; 10067:                         }
; 10068: 		                pTrack = pTrack->GetNext();
; 10069: 	                }
; 10070:                 }
; 10071:             }
; 10072:             LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
; 10073: #else
; 10074:             m_pSynth->StopWave(rtTime,pWave->dwVoiceID);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  00027	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0002a	51		 push	 ecx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  0002e	52		 push	 edx
  0002f	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  00032	50		 push	 eax
  00033	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00039	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003f	8b 12		 mov	 edx, DWORD PTR [edx]
  00041	51		 push	 ecx
  00042	ff 52 38	 call	 DWORD PTR [edx+56]

; 10075: #endif
; 10076:         }
; 10077:         else

  00045	e9 13 01 00 00	 jmp	 $L73434
$L73433:

; 10078:         {
; 10079: #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 10080:             m_dwTempWavesPerSecond++;

  0004a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 88 fc 03 00
	00		 mov	 ecx, DWORD PTR [eax+1020]
  00053	83 c1 01	 add	 ecx, 1
  00056	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	89 8a fc 03 00
	00		 mov	 DWORD PTR [edx+1020], ecx

; 10081:             UpdateDebugParams();

  0005f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?UpdateDebugParams@CPerformance@@AAEXXZ ; CPerformance::UpdateDebugParams

; 10082: #endif      
; 10083: #ifdef DXAPI
; 10084:             if (SUCCEEDED(pVoice->Play(rtTime, pWave->lPitch, pWave->lVolume)))
; 10085:             {
; 10086: #else
; 10087:             DWORD dwPortTableIndex, dwGroup, dwMChannel;
; 10088:             if( SUCCEEDED( PChannelIndex( pWave->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))

  00067	6a 00		 push	 0
  00069	8d 45 f4	 lea	 eax, DWORD PTR _dwMChannel$73437[ebp]
  0006c	50		 push	 eax
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR _dwGroup$73436[ebp]
  00070	51		 push	 ecx
  00071	8d 55 f0	 lea	 edx, DWORD PTR _dwPortTableIndex$73435[ebp]
  00074	52		 push	 edx
  00075	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  00078	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0007b	51		 push	 ecx
  0007c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  00084	85 c0		 test	 eax, eax
  00086	0f 8c d1 00 00
	00		 jl	 $L73434

; 10089:             {
; 10090:                 if (SUCCEEDED(m_pSynth->PlayWave(rtTime,dwGroup,dwMChannel,
; 10091:                     pWave->lPitch, pWave->lVolume,pWave->dwStartOffset,
; 10092:                     pWave->dwLoopStart,pWave->dwLoopEnd,(IDirectSoundWave *)pWave->punkUser,&pWave->dwVoiceID)))

  0008c	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  0008f	83 c2 2c	 add	 edx, 44			; 0000002cH
  00092	52		 push	 edx
  00093	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  00096	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00099	51		 push	 ecx
  0009a	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  0009d	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000a0	33 c9		 xor	 ecx, ecx
  000a2	51		 push	 ecx
  000a3	50		 push	 eax
  000a4	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  000a7	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  000aa	33 c9		 xor	 ecx, ecx
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  000b1	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  000b4	33 c9		 xor	 ecx, ecx
  000b6	51		 push	 ecx
  000b7	50		 push	 eax
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  000bb	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000be	50		 push	 eax
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  000c2	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  000c5	52		 push	 edx
  000c6	8b 45 f4	 mov	 eax, DWORD PTR _dwMChannel$73437[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _dwGroup$73436[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 10	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  000d1	52		 push	 edx
  000d2	8b 45 0c	 mov	 eax, DWORD PTR _rtTime$[ebp]
  000d5	50		 push	 eax
  000d6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000dc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000e2	8b 12		 mov	 edx, DWORD PTR [edx]
  000e4	51		 push	 ecx
  000e5	ff 52 34	 call	 DWORD PTR [edx+52]
  000e8	85 c0		 test	 eax, eax
  000ea	7c 71		 jl	 SHORT $L73434

; 10093: #endif
; 10094:                 {
; 10095:                     if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  000ef	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000f2	83 e1 40	 and	 ecx, 64			; 00000040H
  000f5	85 c9		 test	 ecx, ecx
  000f7	74 2c		 je	 SHORT $L73443

; 10096:                     {
; 10097:                         // This is a clock time message. 
; 10098:                         pWave->rtTime += pWave->rtDuration ;

  000f9	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  000fc	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  000ff	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00102	03 48 38	 add	 ecx, DWORD PTR [eax+56]
  00105	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00108	13 50 3c	 adc	 edx, DWORD PTR [eax+60]
  0010b	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00111	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 10099:                         pWave->dwFlags &= ~DMUS_PMSGF_MUSICTIME; 

  00114	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  00117	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0011a	83 e2 fd	 and	 edx, -3			; fffffffdH
  0011d	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  00120	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 10100:                     
; 10101:                     }
; 10102:                     else

  00123	eb 21		 jmp	 SHORT $L73444
$L73443:

; 10103:                     {
; 10104:                         pWave->mtTime += (MUSIC_TIME) pWave->rtDuration;

  00125	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  00128	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0012b	8b 45 fc	 mov	 eax, DWORD PTR _pWave$[ebp]
  0012e	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00131	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  00134	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 10105:                         pWave->dwFlags &= ~DMUS_PMSGF_REFTIME; 

  00137	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  0013a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0013d	83 e0 fe	 and	 eax, -2			; fffffffeH
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  00143	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L73444:

; 10106:                     }
; 10107:                     pWave->bFlags |= DMUS_WAVEF_OFF;   // Queue this back up as a wave off.

  00146	8b 55 fc	 mov	 edx, DWORD PTR _pWave$[ebp]
  00149	0f b6 42 58	 movzx	 eax, BYTE PTR [edx+88]
  0014d	83 c8 01	 or	 eax, 1
  00150	8b 4d fc	 mov	 ecx, DWORD PTR _pWave$[ebp]
  00153	88 41 58	 mov	 BYTE PTR [ecx+88], al

; 10108:                     hr = DMUS_S_REQUEUE;

  00156	c7 45 f8 00 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086656 ; 08781200H
$L73434:

; 10109:                 }
; 10110:             }
; 10111:         }
; 10112:     }
; 10113:     return hr;

  0015d	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 10114: }

  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 0c 00	 ret	 12			; 0000000cH
?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ENDP	; CPerformance::PackWave
_TEXT	ENDS
PUBLIC	??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@ ; `string'
PUBLIC	??_C@_0O@OEBCMAMD@pPerf?5?$DN?$DN?5this?$AA@	; `string'
EXTRN	_SetEvent@4:NEAR
EXTRN	_GUID_NOTIFICATION_PRIVATE_CHORD:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicTool::ProcessPMsg', 00H		; `CPerformance::ProcessPMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
CONST	SEGMENT
??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@ DB '%s: Invali'
	DB	'd pointer pPerf', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
CONST	SEGMENT
??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@ DB '%s: Invali'
	DB	'd pointer pPMsg', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OEBCMAMD@pPerf?5?$DN?$DN?5this?$AA@
CONST	SEGMENT
??_C@_0O@OEBCMAMD@pPerf?5?$DN?$DN?5this?$AA@ DB 'pPerf == this', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
tv434 = -108
_pPort$73624 = -104
_dwGroup$73616 = -100
_dwPortTableIndex$73615 = -96
_pPriPMsg$73613 = -92
_dwMChannel$73617 = -88
_pNode$73587 = -84
_dwCount$73588 = -80
_pSegState$73575 = -76
_pSeg$73574 = -72
_pCheck$73560 = -68
_rtNow$73559 = -64
_pTimeSig$73556 = -52
_pNotify$73533 = -48
_wMergeIndex$73526 = -44
_pTrans$73522 = -40
_pChannelMap$73524 = -36
_pNewMsg$73508 = -32
_dwPChannel$73505 = -28
_pChannelMap$73501 = -24
_dwIndex$73497 = -20
_dwMax$73491 = -16
_pChannelBlock$73493 = -12
_pPrivPMsg$73475 = -8
_hr$ = -4
_this$ = 8
_pPerf$ = 12
_pPMsg$ = 16
?ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z PROC NEAR ; CPerformance::ProcessPMsg, COMDAT

; 10120: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 10121:     V_INAME(IDirectMusicTool::ProcessPMsg);
; 10122:     V_INTERFACE(pPerf);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L73458
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L73458:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L73461
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L73461:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L73463
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L73463:

; 10123:     V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

  00082	6a 38		 push	 56			; 00000038H
  00084	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0008d	85 c0		 test	 eax, eax
  0008f	74 19		 je	 SHORT $L73465
  00091	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z@4QBDB
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
  0009b	6a ff		 push	 -1
  0009d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	e8 00 00 00 00	 call	 _DebugBreak@0
$L73465:

; 10124: 
; 10125:     HRESULT hr = DMUS_S_FREE;

  000aa	c7 45 fc 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 10126: 
; 10127:     ASSERT( pPerf == this );

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	83 e9 04	 sub	 ecx, 4
  000b7	39 4d 0c	 cmp	 DWORD PTR _pPerf$[ebp], ecx
  000ba	74 17		 je	 SHORT $L73472
  000bc	6a 00		 push	 0
  000be	68 8f 27 00 00	 push	 10127			; 0000278fH
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@OEBCMAMD@pPerf?5?$DN?$DN?5this?$AA@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L73472:

; 10128:     if( pPMsg->dwType == DMUS_PMSGT_TEMPO )

  000d3	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000d6	83 7a 28 04	 cmp	 DWORD PTR [edx+40], 4
  000da	75 3c		 jne	 SHORT $L73474

; 10129:     {
; 10130:         PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMsg);

  000dc	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  000df	83 e8 18	 sub	 eax, 24			; 00000018H
  000e2	89 45 f8	 mov	 DWORD PTR _pPrivPMsg$73475[ebp], eax

; 10131:         // If the pmsg was generated by a track, discard it
; 10132:         // because it was already placed in the tempo map.
; 10133:         if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_TRACK )

  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _pPrivPMsg$73475[ebp]
  000e8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000eb	83 e2 04	 and	 edx, 4
  000ee	85 d2		 test	 edx, edx
  000f0	74 0a		 je	 SHORT $L73478

; 10134:         {
; 10135:             return DMUS_S_FREE;

  000f2	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  000f7	e9 8b 07 00 00	 jmp	 $L73454
$L73478:

; 10136:         }
; 10137:         // Otherwise, this was generated by the application, so it's not already
; 10138:         // in the tempo map and we need to add it.
; 10139:         AddEventToTempoMap( DMUS_TO_PRIV(pPMsg));

  000fc	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  000ff	83 e8 18	 sub	 eax, 24			; 00000018H
  00102	50		 push	 eax
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	83 e9 04	 sub	 ecx, 4
  00109	e8 00 00 00 00	 call	 ?AddEventToTempoMap@CPerformance@@AAEXPAUPRIV_PMSG@@@Z ; CPerformance::AddEventToTempoMap

; 10140:         return DMUS_S_FREE; // OK to free this event; not requeued

  0010e	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  00113	e9 6f 07 00 00	 jmp	 $L73454
$L73474:

; 10141:     }
; 10142: 
; 10143:     if ((pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) ||
; 10144:         (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE))

  00118	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0011b	83 79 18 fc	 cmp	 DWORD PTR [ecx+24], -4	; fffffffcH
  0011f	74 0d		 je	 SHORT $L73490
  00121	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00124	83 7a 18 ff	 cmp	 DWORD PTR [edx+24], -1
  00128	0f 85 33 01 00
	00		 jne	 $L73489
$L73490:

; 10145:     {
; 10146:         // Scan through all the pchannels and make copies of the message for each pchannel. 
; 10147:         // Then, release this one. 
; 10148:         DWORD dwMax = PCHANNEL_BLOCKSIZE;

  0012e	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _dwMax$73491[ebp], 16 ; 00000010H

; 10149:         // If one per channel group (for sysex, for example,) do only one per block.
; 10150:         if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) dwMax = 1;

  00135	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00138	83 78 18 fc	 cmp	 DWORD PTR [eax+24], -4	; fffffffcH
  0013c	75 07		 jne	 SHORT $L73492
  0013e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dwMax$73491[ebp], 1
$L73492:

; 10151:         ENTER_CRITICAL_SECTION(&m_PipelineCrSec); // Make sure we are in this so we don't deadlock in SendPMsg().

  00145	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	81 c1 2c 03 00
	00		 add	 ecx, 812		; 0000032cH
  0014e	51		 push	 ecx
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10152:         ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00155	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00158	81 c2 48 03 00
	00		 add	 edx, 840		; 00000348H
  0015e	52		 push	 edx
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10153:         CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();

  00165	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	83 c1 38	 add	 ecx, 56			; 00000038H
  0016b	e8 00 00 00 00	 call	 ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ; CChannelBlockList::GetHead
  00170	89 45 f4	 mov	 DWORD PTR _pChannelBlock$73493[ebp], eax

; 10154:         for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )

  00173	eb 0b		 jmp	 SHORT $L73494
$L73495:
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _pChannelBlock$73493[ebp]
  00178	e8 00 00 00 00	 call	 ?GetNext@CChannelBlock@@QAEPAV1@XZ ; CChannelBlock::GetNext
  0017d	89 45 f4	 mov	 DWORD PTR _pChannelBlock$73493[ebp], eax
$L73494:
  00180	83 7d f4 00	 cmp	 DWORD PTR _pChannelBlock$73493[ebp], 0
  00184	0f 84 ae 00 00
	00		 je	 $L73496

; 10155:         {
; 10156:             DWORD dwIndex;
; 10157:             for (dwIndex = 0; dwIndex < dwMax; dwIndex++)

  0018a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwIndex$73497[ebp], 0
  00191	eb 09		 jmp	 SHORT $L73498
$L73499:
  00193	8b 45 ec	 mov	 eax, DWORD PTR _dwIndex$73497[ebp]
  00196	83 c0 01	 add	 eax, 1
  00199	89 45 ec	 mov	 DWORD PTR _dwIndex$73497[ebp], eax
$L73498:
  0019c	8b 4d ec	 mov	 ecx, DWORD PTR _dwIndex$73497[ebp]
  0019f	3b 4d f0	 cmp	 ecx, DWORD PTR _dwMax$73491[ebp]
  001a2	0f 83 8b 00 00
	00		 jae	 $L73500

; 10158:             {
; 10159:                 CChannelMap* pChannelMap = &pChannelBlock->m_aChannelMap[ dwIndex ];

  001a8	8b 55 ec	 mov	 edx, DWORD PTR _dwIndex$73497[ebp]
  001ab	c1 e2 07	 shl	 edx, 7
  001ae	8b 45 f4	 mov	 eax, DWORD PTR _pChannelBlock$73493[ebp]
  001b1	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  001b5	89 4d e8	 mov	 DWORD PTR _pChannelMap$73501[ebp], ecx

; 10160:                 if( pChannelMap->dwGroup && 
; 10161:                     (pChannelMap->wFlags & (CMAP_STATIC | CMAP_VIRTUAL)))

  001b8	8b 55 e8	 mov	 edx, DWORD PTR _pChannelMap$73501[ebp]
  001bb	83 7a 74 00	 cmp	 DWORD PTR [edx+116], 0
  001bf	74 6d		 je	 SHORT $L73504
  001c1	8b 45 e8	 mov	 eax, DWORD PTR _pChannelMap$73501[ebp]
  001c4	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  001c8	83 e1 06	 and	 ecx, 6
  001cb	85 c9		 test	 ecx, ecx
  001cd	74 5f		 je	 SHORT $L73504

; 10162:                 {
; 10163:                     DWORD dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;

  001cf	8b 55 f4	 mov	 edx, DWORD PTR _pChannelBlock$73493[ebp]
  001d2	8b 45 ec	 mov	 eax, DWORD PTR _dwIndex$73497[ebp]
  001d5	03 42 04	 add	 eax, DWORD PTR [edx+4]
  001d8	89 45 e4	 mov	 DWORD PTR _dwPChannel$73505[ebp], eax

; 10164:                     // If this is a transpose on the drum channel, don't send it.
; 10165:                     if ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwPChannel & 0xF) != 9))

  001db	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  001de	83 79 28 08	 cmp	 DWORD PTR [ecx+40], 8
  001e2	75 0b		 jne	 SHORT $L73507
  001e4	8b 55 e4	 mov	 edx, DWORD PTR _dwPChannel$73505[ebp]
  001e7	83 e2 0f	 and	 edx, 15			; 0000000fH
  001ea	83 fa 09	 cmp	 edx, 9
  001ed	74 3f		 je	 SHORT $L73504
$L73507:

; 10166:                     {
; 10167:                         DMUS_PMSG *pNewMsg;
; 10168:                         if (SUCCEEDED(ClonePMsg(pPMsg,&pNewMsg)))

  001ef	8d 45 e0	 lea	 eax, DWORD PTR _pNewMsg$73508[ebp]
  001f2	50		 push	 eax
  001f3	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  001f6	51		 push	 ecx
  001f7	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001fa	83 ea 04	 sub	 edx, 4
  001fd	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00200	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00203	52		 push	 edx
  00204	ff 51 48	 call	 DWORD PTR [ecx+72]
  00207	85 c0		 test	 eax, eax
  00209	7c 23		 jl	 SHORT $L73504

; 10169:                         {
; 10170:                             pNewMsg->dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;

  0020b	8b 55 f4	 mov	 edx, DWORD PTR _pChannelBlock$73493[ebp]
  0020e	8b 45 ec	 mov	 eax, DWORD PTR _dwIndex$73497[ebp]
  00211	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00214	8b 4d e0	 mov	 ecx, DWORD PTR _pNewMsg$73508[ebp]
  00217	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 10171:                             SendPMsg(pNewMsg);

  0021a	8b 55 e0	 mov	 edx, DWORD PTR _pNewMsg$73508[ebp]
  0021d	52		 push	 edx
  0021e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00221	83 e8 04	 sub	 eax, 4
  00224	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00227	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0022a	50		 push	 eax
  0022b	ff 52 10	 call	 DWORD PTR [edx+16]
$L73504:

; 10172:                         }
; 10173:                     }
; 10174:                 }
; 10175:             }

  0022e	e9 60 ff ff ff	 jmp	 $L73499
$L73500:

; 10176:         }

  00233	e9 3d ff ff ff	 jmp	 $L73495
$L73496:

; 10177:         LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00238	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0023b	05 48 03 00 00	 add	 eax, 840		; 00000348H
  00240	50		 push	 eax
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10178:         LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00247	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	81 c1 2c 03 00
	00		 add	 ecx, 812		; 0000032cH
  00250	51		 push	 ecx
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10179:         return DMUS_S_FREE;

  00257	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  0025c	e9 26 06 00 00	 jmp	 $L73454
$L73489:

; 10180:     }
; 10181: 
; 10182:     if(pPMsg->dwType == DMUS_PMSGT_TRANSPOSE)

  00261	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00264	83 7a 28 08	 cmp	 DWORD PTR [edx+40], 8
  00268	0f 85 bf 00 00
	00		 jne	 $L73515

; 10183:     {
; 10184:         if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_QUEUE ))

  0026e	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00271	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00274	83 e1 08	 and	 ecx, 8
  00277	85 c9		 test	 ecx, ecx
  00279	75 28		 jne	 SHORT $L73516

; 10185:         {
; 10186:             // requeue any tranpose event to be queue time
; 10187:             pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;

  0027b	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0027e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00281	83 c8 08	 or	 eax, 8
  00284	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00287	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 10188:             pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );

  0028a	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0028d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00290	83 e0 eb	 and	 eax, -21		; ffffffebH
  00293	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00296	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 10189:             return DMUS_S_REQUEUE;

  00299	b8 00 12 78 08	 mov	 eax, 142086656		; 08781200H
  0029e	e9 e4 05 00 00	 jmp	 $L73454
$L73516:

; 10190:         }
; 10191:         else
; 10192:         {
; 10193:             DMUS_TRANSPOSE_PMSG* pTrans = (DMUS_TRANSPOSE_PMSG*)pPMsg;

  002a3	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  002a6	89 55 d8	 mov	 DWORD PTR _pTrans$73522[ebp], edx

; 10194:             // set the PChannel for this transpose message
; 10195:             ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  002a9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002ac	05 48 03 00 00	 add	 eax, 840		; 00000348H
  002b1	50		 push	 eax
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10196:             CChannelMap * pChannelMap = GetPChannelMap(pPMsg->dwPChannel);

  002b8	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  002bb	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  002be	52		 push	 edx
  002bf	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	83 e9 04	 sub	 ecx, 4
  002c5	e8 00 00 00 00	 call	 ?GetPChannelMap@CPerformance@@AAEPAVCChannelMap@@K@Z ; CPerformance::GetPChannelMap
  002ca	89 45 dc	 mov	 DWORD PTR _pChannelMap$73524[ebp], eax

; 10197:             if (pChannelMap)

  002cd	83 7d dc 00	 cmp	 DWORD PTR _pChannelMap$73524[ebp], 0
  002d1	74 40		 je	 SHORT $L73525

; 10198:             {
; 10199:                 WORD wMergeIndex = 0;

  002d3	66 c7 45 d4 00
	00		 mov	 WORD PTR _wMergeIndex$73526[ebp], 0

; 10200:                 if (pPMsg->dwFlags & DMUS_PMSGF_DX8)

  002d9	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  002dc	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002df	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002e5	85 c9		 test	 ecx, ecx
  002e7	74 0b		 je	 SHORT $L73527

; 10201:                 {
; 10202:                     wMergeIndex = pTrans->wMergeIndex;

  002e9	8b 55 d8	 mov	 edx, DWORD PTR _pTrans$73522[ebp]
  002ec	66 8b 42 3a	 mov	 ax, WORD PTR [edx+58]
  002f0	66 89 45 d4	 mov	 WORD PTR _wMergeIndex$73526[ebp], ax
$L73527:

; 10203:                 }
; 10204:                 pChannelMap->nTranspose = pChannelMap->m_TransposeMerger.MergeTranspose(
; 10205:                     wMergeIndex,pTrans->nTranspose);

  002f4	8b 4d d8	 mov	 ecx, DWORD PTR _pTrans$73522[ebp]
  002f7	66 8b 51 38	 mov	 dx, WORD PTR [ecx+56]
  002fb	52		 push	 edx
  002fc	0f b7 45 d4	 movzx	 eax, WORD PTR _wMergeIndex$73526[ebp]
  00300	50		 push	 eax
  00301	8b 4d dc	 mov	 ecx, DWORD PTR _pChannelMap$73524[ebp]
  00304	83 c1 18	 add	 ecx, 24			; 00000018H
  00307	e8 00 00 00 00	 call	 ?MergeTranspose@CParamMerger@@QAEFKF@Z ; CParamMerger::MergeTranspose
  0030c	8b 4d dc	 mov	 ecx, DWORD PTR _pChannelMap$73524[ebp]
  0030f	66 89 41 7c	 mov	 WORD PTR [ecx+124], ax
$L73525:

; 10206:             }
; 10207:             LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00313	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00316	81 c2 48 03 00
	00		 add	 edx, 840		; 00000348H
  0031c	52		 push	 edx
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10208:             return DMUS_S_FREE;

  00323	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  00328	e9 5a 05 00 00	 jmp	 $L73454
$L73515:

; 10209:         }
; 10210:     }
; 10211: 
; 10212:     if(pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )

  0032d	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00330	83 78 28 03	 cmp	 DWORD PTR [eax+40], 3
  00334	0f 85 48 01 00
	00		 jne	 $L73532

; 10213:     {
; 10214:         DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;

  0033a	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0033d	89 4d d0	 mov	 DWORD PTR _pNotify$73533[ebp], ecx

; 10215:         if (pNotify->guidNotificationType == GUID_NOTIFICATION_PRIVATE_CHORD)

  00340	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_NOTIFICATION_PRIVATE_CHORD
  00345	8b 55 d0	 mov	 edx, DWORD PTR _pNotify$73533[ebp]
  00348	83 c2 38	 add	 edx, 56			; 00000038H
  0034b	52		 push	 edx
  0034c	e8 00 00 00 00	 call	 _==@8
  00351	85 c0		 test	 eax, eax
  00353	74 38		 je	 SHORT $L73535

; 10216:         {
; 10217:             // if we've got a GUID_NOTIFICATION_PRIVATE_CHORD, 
; 10218:             // invalidate/regenerate queued note events as necessary
; 10219:             ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00355	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00358	05 2c 03 00 00	 add	 eax, 812		; 0000032cH
  0035d	50		 push	 eax
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10220:             OnChordUpdateEventQueues(pNotify);

  00364	8b 4d d0	 mov	 ecx, DWORD PTR _pNotify$73533[ebp]
  00367	51		 push	 ecx
  00368	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0036b	83 e9 04	 sub	 ecx, 4
  0036e	e8 00 00 00 00	 call	 ?OnChordUpdateEventQueues@CPerformance@@AAEXPAU_DMUS_NOTIFICATION_PMSG@@@Z ; CPerformance::OnChordUpdateEventQueues

; 10221:             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00373	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00376	81 c2 2c 03 00
	00		 add	 edx, 812		; 0000032cH
  0037c	52		 push	 edx
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10222:             return DMUS_S_FREE;

  00383	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  00388	e9 fa 04 00 00	 jmp	 $L73454
$L73535:

; 10223:         }
; 10224:         else if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_ATTIME ))

  0038d	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00390	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00393	83 e1 10	 and	 ecx, 16			; 00000010H
  00396	85 c9		 test	 ecx, ecx
  00398	75 28		 jne	 SHORT $L73541

; 10225:         {
; 10226:             // requeue any notification event to be ontime
; 10227:             pPMsg->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;

  0039a	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0039d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  003a0	83 c8 10	 or	 eax, 16			; 00000010H
  003a3	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  003a6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 10228:             pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_IMMEDIATE );

  003a9	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  003ac	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  003af	83 e0 f3	 and	 eax, -13		; fffffff3H
  003b2	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  003b5	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 10229:             return DMUS_S_REQUEUE;

  003b8	b8 00 12 78 08	 mov	 eax, 142086656		; 08781200H
  003bd	e9 c5 04 00 00	 jmp	 $L73454
$L73541:

; 10230:         }
; 10231:         else
; 10232:         {
; 10233:             // otherwise, fire the notification
; 10234:             // first, move the event into the notification queue.
; 10235:             // The app then calls GetNotificationPMsg to get the event.
; 10236:             CLEARTOOLGRAPH(pPMsg);

  003c2	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  003c5	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  003c9	74 1c		 je	 SHORT $L73547
  003cb	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  003ce	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003d1	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  003d4	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  003d7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003d9	50		 push	 eax
  003da	ff 51 08	 call	 DWORD PTR [ecx+8]
  003dd	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  003e0	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
$L73547:
  003e7	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  003ea	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  003ee	74 1c		 je	 SHORT $L73548
  003f0	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  003f3	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  003f6	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  003f9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  003fc	8b 12		 mov	 edx, DWORD PTR [edx]
  003fe	51		 push	 ecx
  003ff	ff 52 08	 call	 DWORD PTR [edx+8]
  00402	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00405	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$L73548:

; 10237:             ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  0040c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0040f	81 c1 2c 03 00
	00		 add	 ecx, 812		; 0000032cH
  00415	51		 push	 ecx
  00416	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10238:             m_NotificationQueue.Enqueue( DMUS_TO_PRIV(pPMsg) );

  0041c	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0041f	83 ea 18	 sub	 edx, 24			; 00000018H
  00422	52		 push	 edx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00426	81 c1 4c 01 00
	00		 add	 ecx, 332		; 0000014cH
  0042c	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 10239:             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00431	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00434	05 2c 03 00 00	 add	 eax, 812		; 0000032cH
  00439	50		 push	 eax
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10240:             ENTER_CRITICAL_SECTION(&m_MainCrSec);

  00440	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00443	81 c1 9c 03 00
	00		 add	 ecx, 924		; 0000039cH
  00449	51		 push	 ecx
  0044a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10241:             if( m_hNotification )

  00450	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00453	83 ba ec 00 00
	00 00		 cmp	 DWORD PTR [edx+236], 0
  0045a	74 0f		 je	 SHORT $L73551

; 10242:             {
; 10243:                 SetEvent(m_hNotification);

  0045c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0045f	8b 88 ec 00 00
	00		 mov	 ecx, DWORD PTR [eax+236]
  00465	51		 push	 ecx
  00466	e8 00 00 00 00	 call	 _SetEvent@4
$L73551:

; 10244:             }
; 10245:             LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  0046b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0046e	81 c2 9c 03 00
	00		 add	 edx, 924		; 0000039cH
  00474	52		 push	 edx
  00475	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10246:             return S_OK; // don't free since we've placed the event into the

  0047b	33 c0		 xor	 eax, eax
  0047d	e9 05 04 00 00	 jmp	 $L73454
$L73532:

; 10247:             // notification queue
; 10248:         }
; 10249:     }
; 10250: 
; 10251:     // add time signature changes to the time sig queue
; 10252:     if(pPMsg->dwType == DMUS_PMSGT_TIMESIG )

  00482	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00485	83 78 28 06	 cmp	 DWORD PTR [eax+40], 6
  00489	0f 85 27 01 00
	00		 jne	 $L73553

; 10253:     {
; 10254:         CLEARTOOLGRAPH(pPMsg);

  0048f	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00492	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00496	74 1c		 je	 SHORT $L73554
  00498	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0049b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0049e	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  004a1	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  004a4	8b 00		 mov	 eax, DWORD PTR [eax]
  004a6	52		 push	 edx
  004a7	ff 50 08	 call	 DWORD PTR [eax+8]
  004aa	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  004ad	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
$L73554:
  004b4	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  004b7	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  004bb	74 1c		 je	 SHORT $L73555
  004bd	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  004c0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  004c3	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  004c6	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  004c9	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004cb	50		 push	 eax
  004cc	ff 51 08	 call	 DWORD PTR [ecx+8]
  004cf	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  004d2	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
$L73555:

; 10255:         DMUS_TIMESIG_PMSG* pTimeSig = (DMUS_TIMESIG_PMSG*)pPMsg;

  004d9	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  004dc	89 45 cc	 mov	 DWORD PTR _pTimeSig$73556[ebp], eax

; 10256: 
; 10257:         // check for a legal time signature, which may not have any
; 10258:         // members equal to 0, and bBeat must be evenly divisible by 2.
; 10259:         if( pTimeSig->wGridsPerBeat &&
; 10260:             pTimeSig->bBeatsPerMeasure &&
; 10261:             pTimeSig->bBeat &&
; 10262:             ( 0 == ( pTimeSig->bBeat % 2 )))

  004df	8b 4d cc	 mov	 ecx, DWORD PTR _pTimeSig$73556[ebp]
  004e2	0f b7 51 3a	 movzx	 edx, WORD PTR [ecx+58]
  004e6	85 d2		 test	 edx, edx
  004e8	0f 84 be 00 00
	00		 je	 $L73558
  004ee	8b 45 cc	 mov	 eax, DWORD PTR _pTimeSig$73556[ebp]
  004f1	0f b6 48 38	 movzx	 ecx, BYTE PTR [eax+56]
  004f5	85 c9		 test	 ecx, ecx
  004f7	0f 84 af 00 00
	00		 je	 $L73558
  004fd	8b 55 cc	 mov	 edx, DWORD PTR _pTimeSig$73556[ebp]
  00500	0f b6 42 39	 movzx	 eax, BYTE PTR [edx+57]
  00504	85 c0		 test	 eax, eax
  00506	0f 84 a0 00 00
	00		 je	 $L73558
  0050c	8b 4d cc	 mov	 ecx, DWORD PTR _pTimeSig$73556[ebp]
  0050f	0f b6 51 39	 movzx	 edx, BYTE PTR [ecx+57]
  00513	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  00519	79 05		 jns	 SHORT $L75907
  0051b	4a		 dec	 edx
  0051c	83 ca fe	 or	 edx, -2			; fffffffeH
  0051f	42		 inc	 edx
$L75907:
  00520	85 d2		 test	 edx, edx
  00522	0f 85 84 00 00
	00		 jne	 $L73558

; 10263:         {
; 10264:             ENTER_CRITICAL_SECTION(&m_PipelineCrSec);

  00528	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0052b	05 2c 03 00 00	 add	 eax, 812		; 0000032cH
  00530	50		 push	 eax
  00531	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10265:             REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.

  00537	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0053a	83 e9 04	 sub	 ecx, 4
  0053d	e8 00 00 00 00	 call	 ?GetTime@CPerformance@@AAE_JXZ ; CPerformance::GetTime
  00542	2d 80 96 98 00	 sub	 eax, 10000000		; 00989680H
  00547	83 da 00	 sbb	 edx, 0
  0054a	89 45 c0	 mov	 DWORD PTR _rtNow$73559[ebp], eax
  0054d	89 55 c4	 mov	 DWORD PTR _rtNow$73559[ebp+4], edx
$L73562:

; 10266:             PRIV_PMSG* pCheck;
; 10267:             while (pCheck = m_TimeSigQueue.FlushOldest(rtNow))

  00550	8b 4d c4	 mov	 ecx, DWORD PTR _rtNow$73559[ebp+4]
  00553	51		 push	 ecx
  00554	8b 55 c0	 mov	 edx, DWORD PTR _rtNow$73559[ebp]
  00557	52		 push	 edx
  00558	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0055b	81 c1 58 01 00
	00		 add	 ecx, 344		; 00000158H
  00561	e8 00 00 00 00	 call	 ?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z ; CPMsgQueue::FlushOldest
  00566	89 45 bc	 mov	 DWORD PTR _pCheck$73560[ebp], eax
  00569	83 7d bc 00	 cmp	 DWORD PTR _pCheck$73560[ebp], 0
  0056d	74 11		 je	 SHORT $L73563

; 10268:             {
; 10269:                 FreePMsg(pCheck);

  0056f	8b 45 bc	 mov	 eax, DWORD PTR _pCheck$73560[ebp]
  00572	50		 push	 eax
  00573	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00576	83 e9 04	 sub	 ecx, 4
  00579	e8 00 00 00 00	 call	 ?FreePMsg@CPerformance@@AAEJPAUPRIV_PMSG@@@Z ; CPerformance::FreePMsg

; 10270:             }

  0057e	eb d0		 jmp	 SHORT $L73562
$L73563:

; 10271:             m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pPMsg) );

  00580	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00583	83 e9 18	 sub	 ecx, 24			; 00000018H
  00586	51		 push	 ecx
  00587	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0058a	81 c1 58 01 00
	00		 add	 ecx, 344		; 00000158H
  00590	e8 00 00 00 00	 call	 ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ; CPMsgQueue::Enqueue

; 10272:             LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

  00595	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00598	81 c2 2c 03 00
	00		 add	 edx, 812		; 0000032cH
  0059e	52		 push	 edx
  0059f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10273:             return S_OK;

  005a5	33 c0		 xor	 eax, eax
  005a7	e9 db 02 00 00	 jmp	 $L73454
$L73558:

; 10274:         }
; 10275:         else
; 10276:         {
; 10277:             return DMUS_S_FREE;

  005ac	b8 01 12 78 08	 mov	 eax, 142086657		; 08781201H
  005b1	e9 d1 02 00 00	 jmp	 $L73454
$L73553:

; 10278:         }
; 10279:     }
; 10280: 
; 10281:     // requeue anything else that's early to be neartime
; 10282:     if (pPMsg->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)

  005b6	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  005b9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005bc	83 e1 04	 and	 ecx, 4
  005bf	85 c9		 test	 ecx, ecx
  005c1	0f 84 5d 01 00
	00		 je	 $L73572

; 10283:     {
; 10284:         // if this is a stop command, make sure the segment state doesn't keep going
; 10285:         if( pPMsg->dwType == DMUS_PMSGT_STOP )

  005c7	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  005ca	83 7a 28 0a	 cmp	 DWORD PTR [edx+40], 10	; 0000000aH
  005ce	0f 85 28 01 00
	00		 jne	 $L73573

; 10286:         {
; 10287:             IDirectMusicSegment* pSeg = NULL;

  005d4	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _pSeg$73574[ebp], 0

; 10288:             IDirectMusicSegmentState* pSegState = NULL;

  005db	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pSegState$73575[ebp], 0

; 10289:             if( pPMsg->punkUser )

  005e2	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  005e5	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  005e9	74 4c		 je	 SHORT $L73576

; 10290:             {
; 10291:                 if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegment,
; 10292:                     (void**)&pSeg )))

  005eb	8d 4d b8	 lea	 ecx, DWORD PTR _pSeg$73574[ebp]
  005ee	51		 push	 ecx
  005ef	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegment
  005f4	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  005f7	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  005fa	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  005fd	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00600	8b 00		 mov	 eax, DWORD PTR [eax]
  00602	52		 push	 edx
  00603	ff 10		 call	 DWORD PTR [eax]
  00605	85 c0		 test	 eax, eax
  00607	7d 09		 jge	 SHORT $L73579

; 10293:                 {
; 10294:                     pSeg = NULL;

  00609	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _pSeg$73574[ebp], 0

; 10295:                 }
; 10296:                 else if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState,

  00610	eb 25		 jmp	 SHORT $L73576
$L73579:

; 10297:                     (void**)&pSegState )))

  00612	8d 4d b4	 lea	 ecx, DWORD PTR _pSegState$73575[ebp]
  00615	51		 push	 ecx
  00616	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegmentState
  0061b	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0061e	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00621	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00624	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00627	8b 00		 mov	 eax, DWORD PTR [eax]
  00629	52		 push	 edx
  0062a	ff 10		 call	 DWORD PTR [eax]
  0062c	85 c0		 test	 eax, eax
  0062e	7d 07		 jge	 SHORT $L73576

; 10298:                 {
; 10299:                     pSegState = NULL;

  00630	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pSegState$73575[ebp], 0
$L73576:

; 10300:                 }
; 10301:             }
; 10302:             if( pSeg || pSegState )

  00637	83 7d b8 00	 cmp	 DWORD PTR _pSeg$73574[ebp], 0
  0063b	75 0a		 jne	 SHORT $L73585
  0063d	83 7d b4 00	 cmp	 DWORD PTR _pSegState$73575[ebp], 0
  00641	0f 84 b5 00 00
	00		 je	 $L73573
$L73585:

; 10303:             {
; 10304:                 ENTER_CRITICAL_SECTION(&m_SegmentCrSec);

  00647	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0064a	81 c1 10 03 00
	00		 add	 ecx, 784		; 00000310H
  00650	51		 push	 ecx
  00651	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10305:                 if( pPMsg->mtTime > m_mtTransported )

  00657	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0065a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0065d	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00660	3b 88 cc 02 00
	00		 cmp	 ecx, DWORD PTR [eax+716]
  00666	7e 60		 jle	 SHORT $L73586

; 10306:                 {
; 10307:                     // find and mark the segment and/or segment state to not play beyond
; 10308:                     // the stop point.
; 10309:                     CSegState* pNode;
; 10310:                     DWORD dwCount;
; 10311:                     for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)

  00668	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _dwCount$73588[ebp], 0
  0066f	eb 09		 jmp	 SHORT $L73589
$L73590:
  00671	8b 55 b0	 mov	 edx, DWORD PTR _dwCount$73588[ebp]
  00674	83 c2 01	 add	 edx, 1
  00677	89 55 b0	 mov	 DWORD PTR _dwCount$73588[ebp], edx
$L73589:
  0067a	83 7d b0 09	 cmp	 DWORD PTR _dwCount$73588[ebp], 9
  0067e	73 48		 jae	 SHORT $L73586

; 10312:                     {
; 10313:                         for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )

  00680	8b 45 b0	 mov	 eax, DWORD PTR _dwCount$73588[ebp]
  00683	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00686	8d 4c c1 40	 lea	 ecx, DWORD PTR [ecx+eax*8+64]
  0068a	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  0068f	89 45 ac	 mov	 DWORD PTR _pNode$73587[ebp], eax
  00692	eb 0b		 jmp	 SHORT $L73592
$L73593:
  00694	8b 4d ac	 mov	 ecx, DWORD PTR _pNode$73587[ebp]
  00697	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0069c	89 45 ac	 mov	 DWORD PTR _pNode$73587[ebp], eax
$L73592:
  0069f	83 7d ac 00	 cmp	 DWORD PTR _pNode$73587[ebp], 0
  006a3	74 21		 je	 SHORT $L73594

; 10314:                         {
; 10315:                             if( (pNode->m_pSegment == pSeg) ||
; 10316:                                 (pNode == pSegState) )

  006a5	8b 55 ac	 mov	 edx, DWORD PTR _pNode$73587[ebp]
  006a8	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  006ab	3b 45 b8	 cmp	 eax, DWORD PTR _pSeg$73574[ebp]
  006ae	74 08		 je	 SHORT $L73596
  006b0	8b 4d ac	 mov	 ecx, DWORD PTR _pNode$73587[ebp]
  006b3	3b 4d b4	 cmp	 ecx, DWORD PTR _pSegState$73575[ebp]
  006b6	75 0c		 jne	 SHORT $L73595
$L73596:

; 10317:                             {
; 10318:                                 pNode->m_mtStopTime = pPMsg->mtTime;

  006b8	8b 55 ac	 mov	 edx, DWORD PTR _pNode$73587[ebp]
  006bb	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  006be	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006c1	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
$L73595:

; 10319:                             }
; 10320:                         }

  006c4	eb ce		 jmp	 SHORT $L73593
$L73594:

; 10321:                     }

  006c6	eb a9		 jmp	 SHORT $L73590
$L73586:

; 10322:                 }
; 10323:                 LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

  006c8	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  006cb	81 c2 10 03 00
	00		 add	 edx, 784		; 00000310H
  006d1	52		 push	 edx
  006d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10324:                 if( pSeg )

  006d8	83 7d b8 00	 cmp	 DWORD PTR _pSeg$73574[ebp], 0
  006dc	74 0c		 je	 SHORT $L73597

; 10325:                 {
; 10326:                     pSeg->Release();

  006de	8b 45 b8	 mov	 eax, DWORD PTR _pSeg$73574[ebp]
  006e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006e3	8b 55 b8	 mov	 edx, DWORD PTR _pSeg$73574[ebp]
  006e6	52		 push	 edx
  006e7	ff 51 08	 call	 DWORD PTR [ecx+8]
$L73597:

; 10327:                 }
; 10328:                 if( pSegState )

  006ea	83 7d b4 00	 cmp	 DWORD PTR _pSegState$73575[ebp], 0
  006ee	74 0c		 je	 SHORT $L73573

; 10329:                 {
; 10330:                     pSegState->Release();

  006f0	8b 45 b4	 mov	 eax, DWORD PTR _pSegState$73575[ebp]
  006f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f5	8b 55 b4	 mov	 edx, DWORD PTR _pSegState$73575[ebp]
  006f8	52		 push	 edx
  006f9	ff 51 08	 call	 DWORD PTR [ecx+8]
$L73573:

; 10331:                 }
; 10332:             }
; 10333:         }
; 10334:         pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;

  006fc	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  006ff	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00702	83 c9 08	 or	 ecx, 8
  00705	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00708	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 10335:         pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );

  0070b	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0070e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00711	83 e1 eb	 and	 ecx, -21		; ffffffebH
  00714	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00717	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 10336:         return DMUS_S_REQUEUE;

  0071a	b8 00 12 78 08	 mov	 eax, 142086656		; 08781200H
  0071f	e9 63 01 00 00	 jmp	 $L73454
$L73572:

; 10337:     }
; 10338: 
; 10339:     switch( pPMsg->dwType )
; 10340:     {

  00724	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00727	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0072a	89 4d 94	 mov	 DWORD PTR tv434[ebp], ecx
  0072d	83 7d 94 0c	 cmp	 DWORD PTR tv434[ebp], 12 ; 0000000cH
  00731	0f 87 4d 01 00
	00		 ja	 $L73604
  00737	8b 55 94	 mov	 edx, DWORD PTR tv434[ebp]
  0073a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L75908[edx*4]
$L73607:

; 10341:     case DMUS_PMSGT_NOTE:
; 10342:         {
; 10343:             hr = PackNote(  pPMsg, pPMsg->rtTime );

  00741	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00744	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00747	51		 push	 ecx
  00748	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0074b	52		 push	 edx
  0074c	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0074f	50		 push	 eax
  00750	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00753	83 e9 04	 sub	 ecx, 4
  00756	e8 00 00 00 00	 call	 ?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackNote
  0075b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 10344:         }
; 10345:         break;

  0075e	e9 21 01 00 00	 jmp	 $L73604
$L73608:

; 10346:     case DMUS_PMSGT_CURVE:
; 10347:         {
; 10348:             hr = PackCurve( pPMsg, pPMsg->rtTime );

  00763	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00766	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00769	52		 push	 edx
  0076a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0076d	50		 push	 eax
  0076e	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00771	51		 push	 ecx
  00772	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00775	83 e9 04	 sub	 ecx, 4
  00778	e8 00 00 00 00	 call	 ?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackCurve
  0077d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 10349:         }
; 10350:         break;

  00780	e9 ff 00 00 00	 jmp	 $L73604
$L73609:

; 10351:     case DMUS_PMSGT_SYSEX:
; 10352:         {
; 10353:             hr = PackSysEx( pPMsg, pPMsg->rtTime );

  00785	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00788	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0078b	50		 push	 eax
  0078c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0078f	51		 push	 ecx
  00790	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00793	52		 push	 edx
  00794	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00797	83 e9 04	 sub	 ecx, 4
  0079a	e8 00 00 00 00	 call	 ?PackSysEx@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackSysEx
  0079f	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 10354:         }
; 10355:         break;

  007a2	e9 dd 00 00 00	 jmp	 $L73604
$L73610:

; 10356:     case DMUS_PMSGT_MIDI:
; 10357:         {
; 10358:             hr = PackMidi( pPMsg, pPMsg->rtTime );

  007a7	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  007aa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  007ad	51		 push	 ecx
  007ae	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  007b1	52		 push	 edx
  007b2	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  007b5	50		 push	 eax
  007b6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  007b9	83 e9 04	 sub	 ecx, 4
  007bc	e8 00 00 00 00	 call	 ?PackMidi@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackMidi
  007c1	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 10359:         }
; 10360:         break;

  007c4	e9 bb 00 00 00	 jmp	 $L73604
$L73611:

; 10361:     case DMUS_PMSGT_PATCH:
; 10362:         {
; 10363:             hr = PackPatch( pPMsg, pPMsg->rtTime );

  007c9	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  007cc	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  007cf	52		 push	 edx
  007d0	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  007d3	50		 push	 eax
  007d4	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  007d7	51		 push	 ecx
  007d8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  007db	83 e9 04	 sub	 ecx, 4
  007de	e8 00 00 00 00	 call	 ?PackPatch@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackPatch
  007e3	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 10364:         }
; 10365:         break;

  007e6	e9 99 00 00 00	 jmp	 $L73604
$L73612:

; 10366:     case DMUS_PMSGT_CHANNEL_PRIORITY:
; 10367:         {
; 10368:             DMUS_CHANNEL_PRIORITY_PMSG* pPriPMsg = (DMUS_CHANNEL_PRIORITY_PMSG*)pPMsg;

  007eb	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  007ee	89 55 a4	 mov	 DWORD PTR _pPriPMsg$73613[ebp], edx

; 10369:             DWORD dwPortTableIndex, dwGroup, dwMChannel;
; 10370: 
; 10371:             hr = DMUS_S_FREE;

  007f1	c7 45 fc 01 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086657 ; 08781201H

; 10372:             if( SUCCEEDED( PChannelIndex( pPriPMsg->dwPChannel, &dwPortTableIndex, &dwGroup, 
; 10373:                 &dwMChannel )))

  007f8	6a 00		 push	 0
  007fa	8d 45 a8	 lea	 eax, DWORD PTR _dwMChannel$73617[ebp]
  007fd	50		 push	 eax
  007fe	8d 4d 9c	 lea	 ecx, DWORD PTR _dwGroup$73616[ebp]
  00801	51		 push	 ecx
  00802	8d 55 a0	 lea	 edx, DWORD PTR _dwPortTableIndex$73615[ebp]
  00805	52		 push	 edx
  00806	8b 45 a4	 mov	 eax, DWORD PTR _pPriPMsg$73613[ebp]
  00809	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0080c	51		 push	 ecx
  0080d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00810	83 e9 04	 sub	 ecx, 4
  00813	e8 00 00 00 00	 call	 ?PChannelIndex@CPerformance@@AAEJKPAK00PAF@Z ; CPerformance::PChannelIndex
  00818	85 c0		 test	 eax, eax
  0081a	7c 49		 jl	 SHORT $L73623

; 10374:             {
; 10375:                 ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  0081c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0081f	81 c2 48 03 00
	00		 add	 edx, 840		; 00000348H
  00825	52		 push	 edx
  00826	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10376: #ifdef DXAPI
; 10377:                 if( dwPortTableIndex <= m_dwNumPorts )
; 10378: #endif
; 10379:                 {
; 10380: #ifdef DXAPI
; 10381:                     IDirectMusicPort* pPort = m_pPortTable[dwPortTableIndex].pPort;
; 10382: #else
; 10383:                     IDirectMusicSynthX* pPort = m_pSynth;

  0082c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0082f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00832	89 4d 98	 mov	 DWORD PTR _pPort$73624[ebp], ecx

; 10384: #endif
; 10385:                     if( pPort )

  00835	83 7d 98 00	 cmp	 DWORD PTR _pPort$73624[ebp], 0
  00839	74 1b		 je	 SHORT $L73625

; 10386:                     {
; 10387:                         pPort->SetChannelPriority( dwGroup, dwMChannel, 
; 10388:                             pPriPMsg->dwChannelPriority );

  0083b	8b 55 a4	 mov	 edx, DWORD PTR _pPriPMsg$73613[ebp]
  0083e	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00841	50		 push	 eax
  00842	8b 4d a8	 mov	 ecx, DWORD PTR _dwMChannel$73617[ebp]
  00845	51		 push	 ecx
  00846	8b 55 9c	 mov	 edx, DWORD PTR _dwGroup$73616[ebp]
  00849	52		 push	 edx
  0084a	8b 45 98	 mov	 eax, DWORD PTR _pPort$73624[ebp]
  0084d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0084f	8b 55 98	 mov	 edx, DWORD PTR _pPort$73624[ebp]
  00852	52		 push	 edx
  00853	ff 51 2c	 call	 DWORD PTR [ecx+44]
$L73625:

; 10389:                     }
; 10390:                 }
; 10391:                 LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);

  00856	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00859	05 48 03 00 00	 add	 eax, 840		; 00000348H
  0085e	50		 push	 eax
  0085f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L73623:

; 10392:             }
; 10393:         }
; 10394:         break;

  00865	eb 1d		 jmp	 SHORT $L73604
$L73626:

; 10395:     case DMUS_PMSGT_WAVE:
; 10396:         {
; 10397:             hr = PackWave( pPMsg, pPMsg->rtTime );

  00867	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0086a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0086d	52		 push	 edx
  0086e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00871	50		 push	 eax
  00872	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00875	51		 push	 ecx
  00876	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00879	83 e9 04	 sub	 ecx, 4
  0087c	e8 00 00 00 00	 call	 ?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackWave
  00881	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L73604:

; 10398:         }
; 10399:     default:
; 10400:         break;
; 10401:     }
; 10402:     return hr;

  00884	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L73454:

; 10403: }

  00887	8b e5		 mov	 esp, ebp
  00889	5d		 pop	 ebp
  0088a	c2 0c 00	 ret	 12			; 0000000cH
$L75908:
  0088d	00 00 00 00	 DD	 $L73610
  00891	00 00 00 00	 DD	 $L73607
  00895	00 00 00 00	 DD	 $L73609
  00899	00 00 00 00	 DD	 $L73604
  0089d	00 00 00 00	 DD	 $L73604
  008a1	00 00 00 00	 DD	 $L73608
  008a5	00 00 00 00	 DD	 $L73604
  008a9	00 00 00 00	 DD	 $L73611
  008ad	00 00 00 00	 DD	 $L73604
  008b1	00 00 00 00	 DD	 $L73612
  008b5	00 00 00 00	 DD	 $L73604
  008b9	00 00 00 00	 DD	 $L73604
  008bd	00 00 00 00	 DD	 $L73626
?ProcessPMsg@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@@Z ENDP ; CPerformance::ProcessPMsg
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.h
_TEXT	ENDS
;	COMDAT ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ PROC NEAR	; CPMsgQueue::GetHead, COMDAT
; _this$ = ecx

; 252  :     PRIV_PMSG *     GetHead() { return (m_pTop);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ENDP		; CPMsgQueue::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@CMergeParam@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CMergeParam@@QAEPAV1@XZ PROC NEAR		; CMergeParam::GetNext, COMDAT
; _this$ = ecx

; 286  :     CMergeParam* GetNext() { return (CMergeParam*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CMergeParam@@QAEPAV1@XZ ENDP			; CMergeParam::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@CParamMerger@@AAEXPAVCMergeParam@@@Z
_TEXT	SEGMENT
_this$ = -4
_pMergeParam$ = 8
?AddHead@CParamMerger@@AAEXPAVCMergeParam@@@Z PROC NEAR	; CParamMerger::AddHead, COMDAT
; _this$ = ecx

; 304  :     void AddHead(CMergeParam* pMergeParam) { AList::AddHead((AListItem*)pMergeParam);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pMergeParam$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddHead@CParamMerger@@AAEXPAVCMergeParam@@@Z ENDP	; CParamMerger::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ PROC NEAR	; CParamMerger::GetHead, COMDAT
; _this$ = ecx

; 305  :     CMergeParam* GetHead(){return (CMergeParam*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CParamMerger@@AAEPAVCMergeParam@@XZ ENDP	; CParamMerger::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@CParamMerger@@AAEPAVCMergeParam@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CParamMerger@@AAEPAVCMergeParam@@XZ PROC NEAR ; CParamMerger::RemoveHead, COMDAT
; _this$ = ecx

; 306  :     CMergeParam* RemoveHead() {return (CMergeParam *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CParamMerger@@AAEPAVCMergeParam@@XZ ENDP	; CParamMerger::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@CChannelBlock@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CChannelBlock@@QAEPAV1@XZ PROC NEAR		; CChannelBlock::GetNext, COMDAT
; _this$ = ecx

; 354  :     CChannelBlock* GetNext() { return (CChannelBlock*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CChannelBlock@@QAEPAV1@XZ ENDP			; CChannelBlock::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z
_TEXT	SEGMENT
_this$ = -4
_pChannelBlock$ = 8
?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z PROC NEAR ; CChannelBlockList::AddHead, COMDAT
; _this$ = ecx

; 366  :     void AddHead(CChannelBlock* pChannelBlock) { AList::AddHead((AListItem*)pChannelBlock);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddHead@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ENDP ; CChannelBlockList::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ PROC NEAR ; CChannelBlockList::GetHead, COMDAT
; _this$ = ecx

; 367  :     CChannelBlock* GetHead(){return (CChannelBlock*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ENDP ; CChannelBlockList::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ PROC NEAR ; CChannelBlockList::RemoveHead, COMDAT
; _this$ = ecx

; 368  :     CChannelBlock* RemoveHead() {return (CChannelBlock *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CChannelBlockList@@QAEPAVCChannelBlock@@XZ ENDP ; CChannelBlockList::RemoveHead
_TEXT	ENDS
EXTRN	?AddTail@AList@@QAEXPAVAListItem@@@Z:NEAR	; AList::AddTail
; Function compile flags: /Odt
;	COMDAT ?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z
_TEXT	SEGMENT
_this$ = -4
_pChannelBlock$ = 8
?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z PROC NEAR ; CChannelBlockList::AddTail, COMDAT
; _this$ = ecx

; 370  :     void AddTail(CChannelBlock* pChannelBlock){AList::AddTail((AListItem*)pChannelBlock);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pChannelBlock$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddTail@AList@@QAEXPAVAListItem@@@Z ; AList::AddTail
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddTail@CChannelBlockList@@QAEXPAVCChannelBlock@@@Z ENDP ; CChannelBlockList::AddTail
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1GlobalData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
$T75942 = -4
??1GlobalData@@QAE@XZ PROC NEAR				; GlobalData::~GlobalData, COMDAT
; _this$ = ecx

; 377  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 378  :         if( pData )

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	74 15		 je	 SHORT $L43281

; 379  :         {
; 380  :             delete [] pData;

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00018	89 55 fc	 mov	 DWORD PTR $T75942[ebp], edx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR $T75942[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00024	83 c4 04	 add	 esp, 4
$L43281:

; 381  :         }
; 382  :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1GlobalData@@QAE@XZ ENDP				; GlobalData::~GlobalData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z
_TEXT	SEGMENT
_this$ = -4
_pBuffer$ = 8
_pPort$ = 12
_dwMsg$ = 16
_rt$ = 20
_dwGroup$ = 28
?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z PROC NEAR ; CPerformance::SendShortMsg, COMDAT
; _this$ = ecx

; 606  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 607  :         if (m_pSynth)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0000e	74 22		 je	 SHORT $L43852

; 608  :         {
; 609  :             m_pSynth->SendShortMsg(rt,dwGroup,dwMsg);

  00010	8b 4d 10	 mov	 ecx, DWORD PTR _dwMsg$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 1c	 mov	 edx, DWORD PTR _dwGroup$[ebp]
  00017	52		 push	 edx
  00018	8b 45 18	 mov	 eax, DWORD PTR _rt$[ebp+4]
  0001b	50		 push	 eax
  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _rt$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	52		 push	 edx
  0002f	ff 50 20	 call	 DWORD PTR [eax+32]
$L43852:

; 610  :         }
; 611  :         return true;

  00032	b0 01		 mov	 al, 1

; 612  :     }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 18 00	 ret	 24			; 00000018H
?SendShortMsg@CPerformance@@AAE_NPAUIDirectMusicBuffer@@PAUIDirectMusicPort@@K_JK@Z ENDP ; CPerformance::SendShortMsg
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.cpp
CONST	SEGMENT
?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB DB 'I'
	DB	'DirectMusicTool::Flush', 00H		; `CPerformance::Flush'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z
_TEXT	SEGMENT
tv131 = -20
_pWave$73661 = -16
_pCurve$73657 = -12
_pNote$73653 = -8
_hr$ = -4
_this$ = 8
_pPerf$ = 12
_pPMsg$ = 16
_rtTime$ = 20
?Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z PROC NEAR ; CPerformance::Flush, COMDAT

; 10410: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 10411:     V_INAME(IDirectMusicTool::Flush);
; 10412:     V_INTERFACE(pPerf);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L73637
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L73637:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L73640
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L73640:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L73642
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L73642:

; 10413:     V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

  00082	6a 38		 push	 56			; 00000038H
  00084	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0008d	85 c0		 test	 eax, eax
  0008f	74 19		 je	 SHORT $L73644
  00091	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z@4QBDB
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
  0009b	6a ff		 push	 -1
  0009d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	e8 00 00 00 00	 call	 _DebugBreak@0
$L73644:

; 10414: 
; 10415:     HRESULT hr = S_OK;

  000aa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 10416: 
; 10417:     ASSERT( pPerf == this );

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	83 e9 04	 sub	 ecx, 4
  000b7	39 4d 0c	 cmp	 DWORD PTR _pPerf$[ebp], ecx
  000ba	74 17		 je	 SHORT $L73647
  000bc	6a 00		 push	 0
  000be	68 b1 28 00 00	 push	 10417			; 000028b1H
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@ILEIKEPJ@c?3?2xbox?2private?2windows?2directx?2@
  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@OEBCMAMD@pPerf?5?$DN?$DN?5this?$AA@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L73647:

; 10418:     switch( pPMsg->dwType )
; 10419:     {

  000d3	8b 55 10	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000d6	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000d9	89 45 ec	 mov	 DWORD PTR tv131[ebp], eax
  000dc	83 7d ec 01	 cmp	 DWORD PTR tv131[ebp], 1
  000e0	74 11		 je	 SHORT $L73652
  000e2	83 7d ec 05	 cmp	 DWORD PTR tv131[ebp], 5
  000e6	74 38		 je	 SHORT $L73656
  000e8	83 7d ec 0c	 cmp	 DWORD PTR tv131[ebp], 12 ; 0000000cH
  000ec	74 5f		 je	 SHORT $L73660
  000ee	e9 85 00 00 00	 jmp	 $L73649
$L73652:

; 10420:     case DMUS_PMSGT_NOTE:
; 10421:         {
; 10422:             DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;

  000f3	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000f6	89 4d f8	 mov	 DWORD PTR _pNote$73653[ebp], ecx

; 10423:             if( !(pNote->bFlags & DMUS_NOTEF_NOTEON) )

  000f9	8b 55 f8	 mov	 edx, DWORD PTR _pNote$73653[ebp]
  000fc	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00100	83 e0 01	 and	 eax, 1
  00103	85 c0		 test	 eax, eax
  00105	75 17		 jne	 SHORT $L73655

; 10424:             {
; 10425:                 PackNote( pPMsg, rtTime );

  00107	8b 4d 18	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  0010a	51		 push	 ecx
  0010b	8b 55 14	 mov	 edx, DWORD PTR _rtTime$[ebp]
  0010e	52		 push	 edx
  0010f	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00112	50		 push	 eax
  00113	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	83 e9 04	 sub	 ecx, 4
  00119	e8 00 00 00 00	 call	 ?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackNote
$L73655:

; 10426:             }           
; 10427:         }
; 10428:         break;

  0011e	eb 58		 jmp	 SHORT $L73649
$L73656:

; 10429:     case DMUS_PMSGT_CURVE:
; 10430:         {
; 10431:             DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pPMsg;

  00120	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00123	89 4d f4	 mov	 DWORD PTR _pCurve$73657[ebp], ecx

; 10432:             if( pCurve->bFlags & DMUS_CURVE_RESET )

  00126	8b 55 f4	 mov	 edx, DWORD PTR _pCurve$73657[ebp]
  00129	0f b6 42 53	 movzx	 eax, BYTE PTR [edx+83]
  0012d	83 e0 01	 and	 eax, 1
  00130	85 c0		 test	 eax, eax
  00132	74 17		 je	 SHORT $L73659

; 10433:             {
; 10434:                 PackCurve( pPMsg, rtTime );

  00134	8b 4d 18	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  00137	51		 push	 ecx
  00138	8b 55 14	 mov	 edx, DWORD PTR _rtTime$[ebp]
  0013b	52		 push	 edx
  0013c	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0013f	50		 push	 eax
  00140	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	83 e9 04	 sub	 ecx, 4
  00146	e8 00 00 00 00	 call	 ?PackCurve@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackCurve
$L73659:

; 10435:             }
; 10436:         }
; 10437:         break;

  0014b	eb 2b		 jmp	 SHORT $L73649
$L73660:

; 10438:     case DMUS_PMSGT_WAVE:
; 10439:         {
; 10440:             DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;

  0014d	8b 4d 10	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00150	89 4d f0	 mov	 DWORD PTR _pWave$73661[ebp], ecx

; 10441:             if (pWave->bFlags & DMUS_WAVEF_OFF)

  00153	8b 55 f0	 mov	 edx, DWORD PTR _pWave$73661[ebp]
  00156	0f b6 42 58	 movzx	 eax, BYTE PTR [edx+88]
  0015a	83 e0 01	 and	 eax, 1
  0015d	85 c0		 test	 eax, eax
  0015f	74 17		 je	 SHORT $L73649

; 10442:             {
; 10443:                 PackWave( pPMsg, rtTime );

  00161	8b 4d 18	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  00164	51		 push	 ecx
  00165	8b 55 14	 mov	 edx, DWORD PTR _rtTime$[ebp]
  00168	52		 push	 edx
  00169	8b 45 10	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0016c	50		 push	 eax
  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	83 e9 04	 sub	 ecx, 4
  00173	e8 00 00 00 00	 call	 ?PackWave@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackWave
$L73649:

; 10444:             }
; 10445:         }
; 10446:     default:
; 10447:         break;
; 10448:     }
; 10449:     return hr;

  00178	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 10450: }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 14 00	 ret	 20			; 00000014H
?Flush@CPerformance@@UAGJPAUIDirectMusicPerformance@@PAU_DMUS_PMSG@@_J@Z ENDP ; CPerformance::Flush
_TEXT	ENDS
PUBLIC	??_C@_0CF@FDPGNHJG@?$CFs?3?5Invalid?5pointer?5pdwDeliveryT@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetMsgDeliveryType@CPerformance@@UAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetMsgDeliveryType@CPerformance@@UAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicTool::GetMsgDeliveryType', 00H	; `CPerformance::GetMsgDeliveryType'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CF@FDPGNHJG@?$CFs?3?5Invalid?5pointer?5pdwDeliveryT@
CONST	SEGMENT
??_C@_0CF@FDPGNHJG@?$CFs?3?5Invalid?5pointer?5pdwDeliveryT@ DB '%s: Inval'
	DB	'id pointer pdwDeliveryType', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetMsgDeliveryType@CPerformance@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwDeliveryType$ = 12
?GetMsgDeliveryType@CPerformance@@UAGJPAK@Z PROC NEAR	; CPerformance::GetMsgDeliveryType, COMDAT

; 10455: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10456:     V_INAME(IDirectMusicTool::GetMsgDeliveryType);
; 10457:     V_PTR_WRITE(pdwDeliveryType,DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwDeliveryType$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L73672
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetMsgDeliveryType@CPerformance@@UAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@FDPGNHJG@?$CFs?3?5Invalid?5pointer?5pdwDeliveryT@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L73672:

; 10458: 
; 10459:     *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwDeliveryType$[ebp]
  0002e	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4

; 10460:     return S_OK;

  00034	33 c0		 xor	 eax, eax

; 10461: }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?GetMsgDeliveryType@CPerformance@@UAGJPAK@Z ENDP	; CPerformance::GetMsgDeliveryType
_TEXT	ENDS
PUBLIC	??_C@_0CE@CCINKPEL@?$CFs?3?5Invalid?5pointer?5pdwNumElemen@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicTool::GetMediaTypeArraySize', 00H ; `CPerformance::GetMediaTypeArraySize'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CE@CCINKPEL@?$CFs?3?5Invalid?5pointer?5pdwNumElemen@
CONST	SEGMENT
??_C@_0CE@CCINKPEL@?$CFs?3?5Invalid?5pointer?5pdwNumElemen@ DB '%s: Inval'
	DB	'id pointer pdwNumElements', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwNumElements$ = 12
?GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z PROC NEAR ; CPerformance::GetMediaTypeArraySize, COMDAT

; 10465: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10466:     V_INAME(IDirectMusicTool::GetMediaTypeArraySize);
; 10467:     V_PTR_WRITE(pdwNumElements,DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwNumElements$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L73682
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@CCINKPEL@?$CFs?3?5Invalid?5pointer?5pdwNumElemen@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L73682:

; 10468: 
; 10469:     *pdwNumElements = 0;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwNumElements$[ebp]
  0002e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 10470:     return S_OK;

  00034	33 c0		 xor	 eax, eax

; 10471: }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?GetMediaTypeArraySize@CPerformance@@UAGJPAK@Z ENDP	; CPerformance::GetMediaTypeArraySize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetMediaTypes@CPerformance@@UAGJPAPAKK@Z
_TEXT	SEGMENT
_this$ = 8
_padwMediaTypes$ = 12
_dwNumElements$ = 16
?GetMediaTypes@CPerformance@@UAGJPAPAKK@Z PROC NEAR	; CPerformance::GetMediaTypes, COMDAT

; 10484: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10485:     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 10486: }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?GetMediaTypes@CPerformance@@UAGJPAPAKK@Z ENDP		; CPerformance::GetMediaTypes
_TEXT	ENDS
PUBLIC	?Shutdown@CPerformance@@QAGJXZ			; CPerformance::Shutdown
; Function compile flags: /Odt
;	COMDAT ?Shutdown@CPerformance@@QAGJXZ
_TEXT	SEGMENT
_this$ = 8
?Shutdown@CPerformance@@QAGJXZ PROC NEAR		; CPerformance::Shutdown, COMDAT

; 10490: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10491:     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 10492: }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?Shutdown@CPerformance@@QAGJXZ ENDP			; CPerformance::Shutdown
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InsertTool@CPerformance@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
_TEXT	SEGMENT
_this$ = 8
_pTool$ = 12
_pdwPChannels$ = 16
_cPChannels$ = 20
_lIndex$ = 24
?InsertTool@CPerformance@@UAGJPAUIDirectMusicTool@@PAKKJ@Z PROC NEAR ; CPerformance::InsertTool, COMDAT

; 10499: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10500:     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 10501: }

  00008	5d		 pop	 ebp
  00009	c2 14 00	 ret	 20			; 00000014H
?InsertTool@CPerformance@@UAGJPAUIDirectMusicTool@@PAKKJ@Z ENDP ; CPerformance::InsertTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetTool@CPerformance@@UAGJKPAPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT
_this$ = 8
_dwIndex$ = 12
_ppTool$ = 16
?GetTool@CPerformance@@UAGJKPAPAUIDirectMusicTool@@@Z PROC NEAR ; CPerformance::GetTool, COMDAT

; 10506: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10507:     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 10508: }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?GetTool@CPerformance@@UAGJKPAPAUIDirectMusicTool@@@Z ENDP ; CPerformance::GetTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveTool@CPerformance@@UAGJPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT
_this$ = 8
_pTool$ = 12
?RemoveTool@CPerformance@@UAGJPAUIDirectMusicTool@@@Z PROC NEAR ; CPerformance::RemoveTool, COMDAT

; 10512: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10513:     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 10514: }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?RemoveTool@CPerformance@@UAGJPAUIDirectMusicTool@@@Z ENDP ; CPerformance::RemoveTool
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicGraph::StampPMsg', 00H		; `CPerformance::StampPMsg'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
tv188 = -12
tv143 = -8
tv94 = -4
_this$ = 8
_pPMsg$ = 12
?StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z PROC NEAR ; CPerformance::StampPMsg, COMDAT

; 10517: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 10518:     V_INAME(IDirectMusicGraph::StampPMsg);
; 10519: #ifdef DXAPI
; 10520:     if( m_dwVersion < 8)
; 10521:     {
; 10522:         V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
; 10523:     }
; 10524:     else
; 10525:     {
; 10526: #ifdef DBG
; 10527:         V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
; 10528: #else
; 10529:         if (!pPMsg)
; 10530:         {
; 10531:             return E_POINTER;
; 10532:         }
; 10533: #endif
; 10534:     }
; 10535: #else
; 10536:     V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L73721
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L73721:

; 10537: #endif
; 10538:     
; 10539:     ENTER_CRITICAL_SECTION(&m_MainCrSec);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 98 03 00
	00		 add	 ecx, 920		; 00000398H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 10540: 	ENTER_API_CRITICAL_SECTION;
; 10541:     if( m_pGraph && ( S_OK == m_pGraph->StampPMsg( pPMsg )))

  0003e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  00045	0f 84 b2 00 00
	00		 je	 $L73723
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00055	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0005b	8b 12		 mov	 edx, DWORD PTR [edx]
  0005d	51		 push	 ecx
  0005e	ff 52 0c	 call	 DWORD PTR [edx+12]
  00061	85 c0		 test	 eax, eax
  00063	0f 85 94 00 00
	00		 jne	 $L73723

; 10542:     {
; 10543:         if (pPMsg->pGraph != this)

  00069	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	83 e8 08	 sub	 eax, 8
  0006f	85 c0		 test	 eax, eax
  00071	74 08		 je	 SHORT $L75973
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	89 4d fc	 mov	 DWORD PTR tv94[ebp], ecx
  00079	eb 07		 jmp	 SHORT $L75974
$L75973:
  0007b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
$L75974:
  00082	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00085	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00088	3b 45 fc	 cmp	 eax, DWORD PTR tv94[ebp]
  0008b	74 59		 je	 SHORT $L73724

; 10544:         {
; 10545:             if( pPMsg->pGraph )

  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00090	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00094	74 1c		 je	 SHORT $L73725

; 10546:             {
; 10547:                 pPMsg->pGraph->Release();

  00096	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00099	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0009f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	52		 push	 edx
  000a5	ff 50 08	 call	 DWORD PTR [eax+8]

; 10548:                 pPMsg->pGraph = NULL;

  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000ab	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$L73725:

; 10549:             }
; 10550:             pPMsg->pGraph = this;

  000b2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	83 ea 08	 sub	 edx, 8
  000b8	85 d2		 test	 edx, edx
  000ba	74 08		 je	 SHORT $L75975
  000bc	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	89 45 f8	 mov	 DWORD PTR tv143[ebp], eax
  000c2	eb 07		 jmp	 SHORT $L75976
$L75975:
  000c4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv143[ebp], 0
$L75976:
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000ce	8b 55 f8	 mov	 edx, DWORD PTR tv143[ebp]
  000d1	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 10551:             pPMsg->pGraph->AddRef();

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  000d7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000da	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000dd	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000e0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e2	50		 push	 eax
  000e3	ff 51 04	 call	 DWORD PTR [ecx+4]
$L73724:

; 10552:         }
; 10553:         LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000e6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	81 c2 98 03 00
	00		 add	 edx, 920		; 00000398H
  000ef	52		 push	 edx
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10554: 		LEAVE_API_CRITICAL_SECTION;
; 10555:         return S_OK;

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 b0 00 00 00	 jmp	 $L73717
$L73723:

; 10556:     }
; 10557:     LEAVE_CRITICAL_SECTION(&m_MainCrSec);

  000fd	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00100	05 98 03 00 00	 add	 eax, 920		; 00000398H
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 10558: 	LEAVE_API_CRITICAL_SECTION;
; 10559:     if( pPMsg->pGraph )

  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0010f	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00113	74 1c		 je	 SHORT $L73727

; 10560:     {
; 10561:         pPMsg->pGraph->Release();

  00115	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00118	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0011e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00121	8b 00		 mov	 eax, DWORD PTR [eax]
  00123	52		 push	 edx
  00124	ff 50 08	 call	 DWORD PTR [eax+8]

; 10562:         pPMsg->pGraph = NULL;

  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0012a	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$L73727:

; 10563:     }
; 10564:     if( pPMsg->pTool )

  00131	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00134	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00138	74 1c		 je	 SHORT $L73728

; 10565:     {
; 10566:         pPMsg->pTool->Release();

  0013a	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0013d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00140	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00143	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00146	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00148	50		 push	 eax
  00149	ff 51 08	 call	 DWORD PTR [ecx+8]

; 10567:         pPMsg->pTool = NULL;

  0014c	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  0014f	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
$L73728:

; 10568:     }
; 10569: 
; 10570:     //otherwise there is no graph: set it to the internal Performance Tool
; 10571:     pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);

  00156	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00159	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015c	83 e1 e3	 and	 ecx, -29		; ffffffe3H
  0015f	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00162	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 10572:     pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;

  00165	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00168	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0016b	83 c9 08	 or	 ecx, 8
  0016e	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00171	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 10573:     pPMsg->pTool = this;

  00174	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00177	83 e8 08	 sub	 eax, 8
  0017a	85 c0		 test	 eax, eax
  0017c	74 0b		 je	 SHORT $L75977
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	83 e9 04	 sub	 ecx, 4
  00184	89 4d f4	 mov	 DWORD PTR tv188[ebp], ecx
  00187	eb 07		 jmp	 SHORT $L75978
$L75977:
  00189	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv188[ebp], 0
$L75978:
  00190	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00193	8b 45 f4	 mov	 eax, DWORD PTR tv188[ebp]
  00196	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 10574:     pPMsg->pTool->AddRef();

  00199	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0019c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0019f	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  001a2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001a5	8b 12		 mov	 edx, DWORD PTR [edx]
  001a7	51		 push	 ecx
  001a8	ff 52 04	 call	 DWORD PTR [edx+4]

; 10575:     return S_OK;

  001ab	33 c0		 xor	 eax, eax
$L73717:

; 10576: }

  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c2 08 00	 ret	 8
?StampPMsg@CPerformance@@UAGJPAU_DMUS_PMSG@@@Z ENDP	; CPerformance::StampPMsg
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
PUBLIC	?FixScale@@YGKK@Z				; FixScale
PUBLIC	?ThreeOctave@@YGKK@Z				; ThreeOctave
PUBLIC	?AddRootToScale@@YGKEK@Z			; AddRootToScale
PUBLIC	?MusicValueAccidentals@@YGFG@Z			; MusicValueAccidentals
PUBLIC	?BitsInChord@@YGFK@Z				; BitsInChord
PUBLIC	?MusicValueIntervals@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ; MusicValueIntervals
; Function compile flags: /Odt
;	COMDAT ?MusicValueIntervals@@YGFGEPAU_DMUS_SUBCHORD@@E@Z
_TEXT	SEGMENT
tv73 = -48
_nChordBits$73938 = -44
_nSemitones$73939 = -40
_nTransposetones$73940 = -36
_dwDefaultScale$73931 = -32
_dwPattern$73941 = -28
_bOctRoot$73943 = -21
_dwChordPattern$73932 = -20
_nChordPosition$73936 = -16
_fBelowRoot$73934 = -9
_nPosition$73942 = -8
_nScalePosition$73937 = -4
_wMusicValue$ = 8
_bPlayModes$ = 12
_pSubChord$ = 16
_bRoot$ = 20
?MusicValueIntervals@@YGFGEPAU_DMUS_SUBCHORD@@E@Z PROC NEAR ; MusicValueIntervals, COMDAT

; 11004: { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi

; 11005:     if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) || (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS))

  00007	0f b6 45 0c	 movzx	 eax, BYTE PTR _bPlayModes$[ebp]
  0000b	83 e0 08	 and	 eax, 8
  0000e	85 c0		 test	 eax, eax
  00010	75 0f		 jne	 SHORT $L73930
  00012	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPlayModes$[ebp]
  00016	83 e1 04	 and	 ecx, 4
  00019	85 c9		 test	 ecx, ecx
  0001b	0f 84 e1 02 00
	00		 je	 $L73929
$L73930:

; 11006:     {
; 11007:         DWORD dwDefaultScale = 
; 11008:             (pSubChord->dwScalePattern) ? (pSubChord->dwScalePattern) : DEFAULT_SCALE_PATTERN;

  00021	8b 55 10	 mov	 edx, DWORD PTR _pSubChord$[ebp]
  00024	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00028	74 0b		 je	 SHORT $L75985
  0002a	8b 45 10	 mov	 eax, DWORD PTR _pSubChord$[ebp]
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	89 4d d0	 mov	 DWORD PTR tv73[ebp], ecx
  00033	eb 07		 jmp	 SHORT $L75986
$L75985:
  00035	c7 45 d0 b5 5a
	ab 00		 mov	 DWORD PTR tv73[ebp], 11229877 ; 00ab5ab5H
$L75986:
  0003c	8b 55 d0	 mov	 edx, DWORD PTR tv73[ebp]
  0003f	89 55 e0	 mov	 DWORD PTR _dwDefaultScale$73931[ebp], edx

; 11009:         dwDefaultScale = AddRootToScale(pSubChord->bScaleRoot, dwDefaultScale);

  00042	8b 45 e0	 mov	 eax, DWORD PTR _dwDefaultScale$73931[ebp]
  00045	50		 push	 eax
  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pSubChord$[ebp]
  00049	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 ?AddRootToScale@@YGKEK@Z ; AddRootToScale
  00052	89 45 e0	 mov	 DWORD PTR _dwDefaultScale$73931[ebp], eax

; 11010:         dwDefaultScale = ThreeOctave(FixScale(dwDefaultScale));

  00055	8b 45 e0	 mov	 eax, DWORD PTR _dwDefaultScale$73931[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?FixScale@@YGKK@Z	; FixScale
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?ThreeOctave@@YGKK@Z	; ThreeOctave
  00064	89 45 e0	 mov	 DWORD PTR _dwDefaultScale$73931[ebp], eax

; 11011:         DWORD dwChordPattern = pSubChord->dwChordPattern;

  00067	8b 4d 10	 mov	 ecx, DWORD PTR _pSubChord$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	89 55 ec	 mov	 DWORD PTR _dwChordPattern$73932[ebp], edx

; 11012:         if (!dwChordPattern) dwChordPattern = 1;

  0006f	83 7d ec 00	 cmp	 DWORD PTR _dwChordPattern$73932[ebp], 0
  00073	75 07		 jne	 SHORT $L73933
  00075	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dwChordPattern$73932[ebp], 1
$L73933:

; 11013:         bool fBelowRoot = false;

  0007c	c6 45 f7 00	 mov	 BYTE PTR _fBelowRoot$73934[ebp], 0

; 11014:         if ((bPlayModes & DMUS_PLAYMODE_KEY_ROOT) && bPlayModes != DMUS_PLAYMODE_PEDALPOINT)

  00080	0f b6 45 0c	 movzx	 eax, BYTE PTR _bPlayModes$[ebp]
  00084	83 e0 01	 and	 eax, 1
  00087	85 c0		 test	 eax, eax
  00089	74 24		 je	 SHORT $L73935
  0008b	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPlayModes$[ebp]
  0008f	83 f9 05	 cmp	 ecx, 5
  00092	74 1b		 je	 SHORT $L73935

; 11015:         {
; 11016:             dwChordPattern = InvertChord(bRoot, pSubChord->bChordRoot, dwChordPattern, fBelowRoot);

  00094	8d 55 f7	 lea	 edx, DWORD PTR _fBelowRoot$73934[ebp]
  00097	52		 push	 edx
  00098	8b 45 ec	 mov	 eax, DWORD PTR _dwChordPattern$73932[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d 10	 mov	 ecx, DWORD PTR _pSubChord$[ebp]
  0009f	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  000a2	52		 push	 edx
  000a3	8a 45 14	 mov	 al, BYTE PTR _bRoot$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?InvertChord@@YGKEEKAA_N@Z ; InvertChord
  000ac	89 45 ec	 mov	 DWORD PTR _dwChordPattern$73932[ebp], eax
$L73935:

; 11017:         }
; 11018:         const short nChordPosition = (wMusicValue >> 8) & 0xf;

  000af	0f b7 4d 08	 movzx	 ecx, WORD PTR _wMusicValue$[ebp]
  000b3	c1 f9 08	 sar	 ecx, 8
  000b6	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000b9	66 89 4d f0	 mov	 WORD PTR _nChordPosition$73936[ebp], cx

; 11019: //      const short nScalePosition = (wMusicValue >> 4) & 0xf;
; 11020:         // ensure that scale position is < 8
; 11021:         const short nScalePosition = (wMusicValue >> 4) & 0x7;

  000bd	0f b7 55 08	 movzx	 edx, WORD PTR _wMusicValue$[ebp]
  000c1	c1 fa 04	 sar	 edx, 4
  000c4	83 e2 07	 and	 edx, 7
  000c7	66 89 55 fc	 mov	 WORD PTR _nScalePosition$73937[ebp], dx

; 11022:         const short nChordBits = BitsInChord(dwChordPattern);

  000cb	8b 45 ec	 mov	 eax, DWORD PTR _dwChordPattern$73932[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?BitsInChord@@YGFK@Z	; BitsInChord
  000d4	66 89 45 d4	 mov	 WORD PTR _nChordBits$73938[ebp], ax

; 11023:         short nSemitones = 0;

  000d8	66 c7 45 d8 00
	00		 mov	 WORD PTR _nSemitones$73939[ebp], 0

; 11024:         // If the chord doesn't have a root or second, but does have a seventh, it's been inverted and
; 11025:         // we need to start below the root
; 11026:         short nTransposetones;
; 11027:         DWORD dwPattern;
; 11028:         short nPosition;
; 11029:         BYTE bOctRoot = bRoot % 12; // root in one octave

  000de	0f b6 45 14	 movzx	 eax, BYTE PTR _bRoot$[ebp]
  000e2	99		 cdq
  000e3	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000e8	f7 f9		 idiv	 ecx
  000ea	88 55 eb	 mov	 BYTE PTR _bOctRoot$73943[ebp], dl

; 11030:         // if using chord intervals and the note is in the chord
; 11031:         if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) && 
; 11032:             !nScalePosition &&
; 11033:             (nChordPosition < nChordBits) )

  000ed	0f b6 55 0c	 movzx	 edx, BYTE PTR _bPlayModes$[ebp]
  000f1	83 e2 08	 and	 edx, 8
  000f4	85 d2		 test	 edx, edx
  000f6	74 3e		 je	 SHORT $L73944
  000f8	0f bf 45 fc	 movsx	 eax, WORD PTR _nScalePosition$73937[ebp]
  000fc	85 c0		 test	 eax, eax
  000fe	75 36		 jne	 SHORT $L73944
  00100	0f bf 4d f0	 movsx	 ecx, WORD PTR _nChordPosition$73936[ebp]
  00104	0f bf 55 d4	 movsx	 edx, WORD PTR _nChordBits$73938[ebp]
  00108	3b ca		 cmp	 ecx, edx
  0010a	7d 2a		 jge	 SHORT $L73944

; 11034:         {
; 11035:             nTransposetones = bRoot + MusicValueAccidentals(wMusicValue);

  0010c	0f b6 75 14	 movzx	 esi, BYTE PTR _bRoot$[ebp]
  00110	66 8b 45 08	 mov	 ax, WORD PTR _wMusicValue$[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?MusicValueAccidentals@@YGFG@Z ; MusicValueAccidentals
  0011a	0f bf c8	 movsx	 ecx, ax
  0011d	03 f1		 add	 esi, ecx
  0011f	66 89 75 dc	 mov	 WORD PTR _nTransposetones$73940[ebp], si

; 11036:             dwPattern = dwChordPattern;

  00123	8b 55 ec	 mov	 edx, DWORD PTR _dwChordPattern$73932[ebp]
  00126	89 55 e4	 mov	 DWORD PTR _dwPattern$73941[ebp], edx

; 11037:             nPosition = nChordPosition;

  00129	66 8b 45 f0	 mov	 ax, WORD PTR _nChordPosition$73936[ebp]
  0012d	66 89 45 f8	 mov	 WORD PTR _nPosition$73942[ebp], ax

; 11038:         }
; 11039:         // if using chord intervals and note is inside the chord (including 6ths)
; 11040:         else if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&

  00131	e9 49 01 00 00	 jmp	 $L73945
$L73944:

; 11041:                  (nChordPosition < nChordBits) )

  00136	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPlayModes$[ebp]
  0013a	83 e1 08	 and	 ecx, 8
  0013d	85 c9		 test	 ecx, ecx
  0013f	0f 84 df 00 00
	00		 je	 $L73946
  00145	0f bf 55 f0	 movsx	 edx, WORD PTR _nChordPosition$73936[ebp]
  00149	0f bf 45 d4	 movsx	 eax, WORD PTR _nChordBits$73938[ebp]
  0014d	3b d0		 cmp	 edx, eax
  0014f	0f 8d cf 00 00
	00		 jge	 $L73946

; 11042:         {
; 11043:             dwPattern = dwChordPattern;

  00155	8b 4d ec	 mov	 ecx, DWORD PTR _dwChordPattern$73932[ebp]
  00158	89 4d e4	 mov	 DWORD PTR _dwPattern$73941[ebp], ecx

; 11044:             nPosition = nChordPosition;

  0015b	66 8b 55 f0	 mov	 dx, WORD PTR _nChordPosition$73936[ebp]
  0015f	66 89 55 f8	 mov	 WORD PTR _nPosition$73942[ebp], dx

; 11045:             if (dwPattern)

  00163	83 7d e4 00	 cmp	 DWORD PTR _dwPattern$73941[ebp], 0
  00167	74 20		 je	 SHORT $L73947
$L73949:

; 11046:             {
; 11047:                 // skip to the first note in the chord
; 11048:                 while (!(dwPattern & 1))

  00169	8b 45 e4	 mov	 eax, DWORD PTR _dwPattern$73941[ebp]
  0016c	83 e0 01	 and	 eax, 1
  0016f	85 c0		 test	 eax, eax
  00171	75 16		 jne	 SHORT $L73947

; 11049:                 {
; 11050:                     dwPattern >>= 1;

  00173	8b 4d e4	 mov	 ecx, DWORD PTR _dwPattern$73941[ebp]
  00176	d1 e9		 shr	 ecx, 1
  00178	89 4d e4	 mov	 DWORD PTR _dwPattern$73941[ebp], ecx

; 11051:                     nSemitones++;

  0017b	66 8b 55 d8	 mov	 dx, WORD PTR _nSemitones$73939[ebp]
  0017f	66 83 c2 01	 add	 dx, 1
  00183	66 89 55 d8	 mov	 WORD PTR _nSemitones$73939[ebp], dx

; 11052:                 }

  00187	eb e0		 jmp	 SHORT $L73949
$L73947:

; 11053:             }
; 11054:             if (nPosition > 0)

  00189	0f bf 45 f8	 movsx	 eax, WORD PTR _nPosition$73942[ebp]
  0018d	85 c0		 test	 eax, eax
  0018f	7e 48		 jle	 SHORT $L73951
$L73952:

; 11055:             {
; 11056:                 do
; 11057:                 {
; 11058:                     dwPattern >>= 1; // this will ignore the first note in the chord

  00191	8b 4d e4	 mov	 ecx, DWORD PTR _dwPattern$73941[ebp]
  00194	d1 e9		 shr	 ecx, 1
  00196	89 4d e4	 mov	 DWORD PTR _dwPattern$73941[ebp], ecx

; 11059:                     nSemitones++;

  00199	66 8b 55 d8	 mov	 dx, WORD PTR _nSemitones$73939[ebp]
  0019d	66 83 c2 01	 add	 dx, 1
  001a1	66 89 55 d8	 mov	 WORD PTR _nSemitones$73939[ebp], dx

; 11060:                     if (dwPattern & 1)

  001a5	8b 45 e4	 mov	 eax, DWORD PTR _dwPattern$73941[ebp]
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	74 0c		 je	 SHORT $L73955

; 11061:                     {
; 11062:                         nPosition--;

  001af	66 8b 4d f8	 mov	 cx, WORD PTR _nPosition$73942[ebp]
  001b3	66 83 e9 01	 sub	 cx, 1
  001b7	66 89 4d f8	 mov	 WORD PTR _nPosition$73942[ebp], cx
$L73955:

; 11063:                     }
; 11064:                     if (!dwPattern)

  001bb	83 7d e4 00	 cmp	 DWORD PTR _dwPattern$73941[ebp], 0
  001bf	75 10		 jne	 SHORT $L73953

; 11065:                     {
; 11066:                         nSemitones += nPosition;

  001c1	0f bf 55 f8	 movsx	 edx, WORD PTR _nPosition$73942[ebp]
  001c5	0f bf 45 d8	 movsx	 eax, WORD PTR _nSemitones$73939[ebp]
  001c9	03 c2		 add	 eax, edx
  001cb	66 89 45 d8	 mov	 WORD PTR _nSemitones$73939[ebp], ax

; 11067: //                      assert (0); // This shouldn't happen...
; 11068:                         break;

  001cf	eb 08		 jmp	 SHORT $L73951
$L73953:

; 11069:                     }
; 11070:                 } while (nPosition > 0);

  001d1	0f bf 4d f8	 movsx	 ecx, WORD PTR _nPosition$73942[ebp]
  001d5	85 c9		 test	 ecx, ecx
  001d7	7f b8		 jg	 SHORT $L73952
$L73951:

; 11071:             }
; 11072: 
; 11073:             nSemitones += bOctRoot;

  001d9	0f b6 55 eb	 movzx	 edx, BYTE PTR _bOctRoot$73943[ebp]
  001dd	0f bf 45 d8	 movsx	 eax, WORD PTR _nSemitones$73939[ebp]
  001e1	03 c2		 add	 eax, edx
  001e3	66 89 45 d8	 mov	 WORD PTR _nSemitones$73939[ebp], ax

; 11074:             nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;

  001e7	66 8b 4d 08	 mov	 cx, WORD PTR _wMusicValue$[ebp]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 ?MusicValueAccidentals@@YGFG@Z ; MusicValueAccidentals
  001f1	0f bf d0	 movsx	 edx, ax
  001f4	0f b6 45 14	 movzx	 eax, BYTE PTR _bRoot$[ebp]
  001f8	03 d0		 add	 edx, eax
  001fa	0f b6 4d eb	 movzx	 ecx, BYTE PTR _bOctRoot$73943[ebp]
  001fe	2b d1		 sub	 edx, ecx
  00200	66 89 55 dc	 mov	 WORD PTR _nTransposetones$73940[ebp], dx

; 11075:             dwPattern = dwDefaultScale >> (nSemitones % 12);  // start comparing partway through the pattern

  00204	0f bf 45 d8	 movsx	 eax, WORD PTR _nSemitones$73939[ebp]
  00208	99		 cdq
  00209	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0020e	f7 f9		 idiv	 ecx
  00210	8b 45 e0	 mov	 eax, DWORD PTR _dwDefaultScale$73931[ebp]
  00213	8b ca		 mov	 ecx, edx
  00215	d3 e8		 shr	 eax, cl
  00217	89 45 e4	 mov	 DWORD PTR _dwPattern$73941[ebp], eax

; 11076:             nPosition = nScalePosition;

  0021a	66 8b 4d fc	 mov	 cx, WORD PTR _nScalePosition$73937[ebp]
  0021e	66 89 4d f8	 mov	 WORD PTR _nPosition$73942[ebp], cx

; 11077:         }
; 11078:         // if using scale intervals
; 11079:         else if (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS)

  00222	eb 5b		 jmp	 SHORT $L73945
$L73946:
  00224	0f b6 55 0c	 movzx	 edx, BYTE PTR _bPlayModes$[ebp]
  00228	83 e2 04	 and	 edx, 4
  0022b	85 d2		 test	 edx, edx
  0022d	74 47		 je	 SHORT $L73958

; 11080:         {
; 11081:             fBelowRoot = false; // forget about chord inversions

  0022f	c6 45 f7 00	 mov	 BYTE PTR _fBelowRoot$73934[ebp], 0

; 11082:             nSemitones = bOctRoot;

  00233	66 0f b6 45 eb	 movzx	 ax, BYTE PTR _bOctRoot$73943[ebp]
  00238	66 89 45 d8	 mov	 WORD PTR _nSemitones$73939[ebp], ax

; 11083:             nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;

  0023c	66 8b 4d 08	 mov	 cx, WORD PTR _wMusicValue$[ebp]
  00240	51		 push	 ecx
  00241	e8 00 00 00 00	 call	 ?MusicValueAccidentals@@YGFG@Z ; MusicValueAccidentals
  00246	0f bf d0	 movsx	 edx, ax
  00249	0f b6 45 14	 movzx	 eax, BYTE PTR _bRoot$[ebp]
  0024d	03 d0		 add	 edx, eax
  0024f	0f b6 4d eb	 movzx	 ecx, BYTE PTR _bOctRoot$73943[ebp]
  00253	2b d1		 sub	 edx, ecx
  00255	66 89 55 dc	 mov	 WORD PTR _nTransposetones$73940[ebp], dx

; 11084:             dwPattern = dwDefaultScale >> bOctRoot;  // start comparing partway through the pattern

  00259	0f b6 4d eb	 movzx	 ecx, BYTE PTR _bOctRoot$73943[ebp]
  0025d	8b 55 e0	 mov	 edx, DWORD PTR _dwDefaultScale$73931[ebp]
  00260	d3 ea		 shr	 edx, cl
  00262	89 55 e4	 mov	 DWORD PTR _dwPattern$73941[ebp], edx

; 11085:             nPosition = nChordPosition * 2 + nScalePosition;

  00265	0f bf 45 f0	 movsx	 eax, WORD PTR _nChordPosition$73936[ebp]
  00269	0f bf 4d fc	 movsx	 ecx, WORD PTR _nScalePosition$73937[ebp]
  0026d	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00270	66 89 55 f8	 mov	 WORD PTR _nPosition$73942[ebp], dx

; 11086:         }
; 11087:         else

  00274	eb 09		 jmp	 SHORT $L73945
$L73958:

; 11088:         {
; 11089:             return S_OVER_CHORD;  // 

  00276	66 b8 00 10	 mov	 ax, 4096		; 00001000H
  0027a	e9 8d 00 00 00	 jmp	 $L73928
$L73945:

; 11090:         }
; 11091:         nPosition++; // Now nPosition corresponds to actual scale positions

  0027f	66 8b 45 f8	 mov	 ax, WORD PTR _nPosition$73942[ebp]
  00283	66 05 01 00	 add	 ax, 1
  00287	66 89 45 f8	 mov	 WORD PTR _nPosition$73942[ebp], ax

; 11092:         for (; nPosition > 0; dwPattern >>= 1)

  0028b	eb 08		 jmp	 SHORT $L73960
$L73961:
  0028d	8b 4d e4	 mov	 ecx, DWORD PTR _dwPattern$73941[ebp]
  00290	d1 e9		 shr	 ecx, 1
  00292	89 4d e4	 mov	 DWORD PTR _dwPattern$73941[ebp], ecx
$L73960:
  00295	0f bf 55 f8	 movsx	 edx, WORD PTR _nPosition$73942[ebp]
  00299	85 d2		 test	 edx, edx
  0029b	7e 3a		 jle	 SHORT $L73962

; 11093:         {
; 11094:             nSemitones++;

  0029d	66 8b 45 d8	 mov	 ax, WORD PTR _nSemitones$73939[ebp]
  002a1	66 05 01 00	 add	 ax, 1
  002a5	66 89 45 d8	 mov	 WORD PTR _nSemitones$73939[ebp], ax

; 11095:             if (dwPattern & 1)

  002a9	8b 4d e4	 mov	 ecx, DWORD PTR _dwPattern$73941[ebp]
  002ac	83 e1 01	 and	 ecx, 1
  002af	85 c9		 test	 ecx, ecx
  002b1	74 0c		 je	 SHORT $L73963

; 11096:             {
; 11097:                 nPosition--;

  002b3	66 8b 55 f8	 mov	 dx, WORD PTR _nPosition$73942[ebp]
  002b7	66 83 ea 01	 sub	 dx, 1
  002bb	66 89 55 f8	 mov	 WORD PTR _nPosition$73942[ebp], dx
$L73963:

; 11098:             }
; 11099:             if (!dwPattern)

  002bf	83 7d e4 00	 cmp	 DWORD PTR _dwPattern$73941[ebp], 0
  002c3	75 10		 jne	 SHORT $L73964

; 11100:             {
; 11101:                 nSemitones += nPosition;

  002c5	0f bf 45 f8	 movsx	 eax, WORD PTR _nPosition$73942[ebp]
  002c9	0f bf 4d d8	 movsx	 ecx, WORD PTR _nSemitones$73939[ebp]
  002cd	03 c8		 add	 ecx, eax
  002cf	66 89 4d d8	 mov	 WORD PTR _nSemitones$73939[ebp], cx

; 11102: //              assert (0); // This shouldn't happen...
; 11103:                 break;

  002d3	eb 02		 jmp	 SHORT $L73962
$L73964:

; 11104:             }
; 11105:         }

  002d5	eb b6		 jmp	 SHORT $L73961
$L73962:

; 11106:         nSemitones--; // the loop counts one too many semitones...

  002d7	66 8b 55 d8	 mov	 dx, WORD PTR _nSemitones$73939[ebp]
  002db	66 83 ea 01	 sub	 dx, 1
  002df	66 89 55 d8	 mov	 WORD PTR _nSemitones$73939[ebp], dx

; 11107:         if (fBelowRoot)

  002e3	0f b6 45 f7	 movzx	 eax, BYTE PTR _fBelowRoot$73934[ebp]
  002e7	85 c0		 test	 eax, eax
  002e9	74 0b		 je	 SHORT $L73965

; 11108:         {
; 11109:             nSemitones -=12; 

  002eb	0f bf 4d d8	 movsx	 ecx, WORD PTR _nSemitones$73939[ebp]
  002ef	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  002f2	66 89 4d d8	 mov	 WORD PTR _nSemitones$73939[ebp], cx
$L73965:

; 11110:         }
; 11111:         return nSemitones + nTransposetones;

  002f6	0f bf 45 d8	 movsx	 eax, WORD PTR _nSemitones$73939[ebp]
  002fa	0f bf 55 dc	 movsx	 edx, WORD PTR _nTransposetones$73940[ebp]
  002fe	03 c2		 add	 eax, edx
  00300	eb 0a		 jmp	 SHORT $L73928
$L73929:

; 11112:     }
; 11113:     else
; 11114:     {
; 11115:         // should be impossible for 2.5 format
; 11116:         return bRoot + wMusicValue;

  00302	0f b6 45 14	 movzx	 eax, BYTE PTR _bRoot$[ebp]
  00306	0f b7 4d 08	 movzx	 ecx, WORD PTR _wMusicValue$[ebp]
  0030a	03 c1		 add	 eax, ecx
$L73928:

; 11117:     }
; 11118: }

  0030c	5e		 pop	 esi
  0030d	8b e5		 mov	 esp, ebp
  0030f	5d		 pop	 ebp
  00310	c2 10 00	 ret	 16			; 00000010H
?MusicValueIntervals@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ENDP	; MusicValueIntervals
_TEXT	ENDS
PUBLIC	?BitCount@@YGKK@Z				; BitCount
PUBLIC	?PatternMatch@@YGKKK@Z				; PatternMatch
; Function compile flags: /Odt
;	COMDAT ?FixScale@@YGKK@Z
_TEXT	SEGMENT
_dwTest$73769 = -16
_dwBestPattern$ = -12
_dwBest$ = -8
_dwX$ = -4
_dwScale$ = 8
?FixScale@@YGKK@Z PROC NEAR				; FixScale, COMDAT

; 10644: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 10645:     if (BitCount(dwScale & 0xFFF) > 4)

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwScale$[ebp]
  00009	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?BitCount@@YGKK@Z	; BitCount
  00014	83 f8 04	 cmp	 eax, 4
  00017	76 05		 jbe	 SHORT $L73762

; 10646:     {
; 10647:         return dwScale;

  00019	8b 45 08	 mov	 eax, DWORD PTR _dwScale$[ebp]
  0001c	eb 5d		 jmp	 SHORT $L73761
$L73762:

; 10648:     }
; 10649:     DWORD dwBest = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwBest$[ebp], 0

; 10650:     DWORD dwBestPattern = DEFAULT_SCALE_PATTERN;

  00025	c7 45 f4 b5 5a
	ab 00		 mov	 DWORD PTR _dwBestPattern$[ebp], 11229877 ; 00ab5ab5H

; 10651:     DWORD dwX;
; 10652:     for (dwX = 0;dwX < 12; dwX++)

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwX$[ebp], 0
  00033	eb 09		 jmp	 SHORT $L73766
$L73767:
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _dwX$[ebp]
  00038	83 c1 01	 add	 ecx, 1
  0003b	89 4d fc	 mov	 DWORD PTR _dwX$[ebp], ecx
$L73766:
  0003e	83 7d fc 0c	 cmp	 DWORD PTR _dwX$[ebp], 12 ; 0000000cH
  00042	73 34		 jae	 SHORT $L73768

; 10653:     {
; 10654:         DWORD dwTest = PatternMatch(dwScale,dwFallbackScales[dwX]);

  00044	8b 55 fc	 mov	 edx, DWORD PTR _dwX$[ebp]
  00047	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _dwFallbackScales[edx*4]
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _dwScale$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?PatternMatch@@YGKKK@Z	; PatternMatch
  00058	89 45 f0	 mov	 DWORD PTR _dwTest$73769[ebp], eax

; 10655:         if (dwTest > dwBest)

  0005b	8b 55 f0	 mov	 edx, DWORD PTR _dwTest$73769[ebp]
  0005e	3b 55 f8	 cmp	 edx, DWORD PTR _dwBest$[ebp]
  00061	76 13		 jbe	 SHORT $L73770

; 10656:         {
; 10657:             dwBestPattern = dwFallbackScales[dwX];

  00063	8b 45 fc	 mov	 eax, DWORD PTR _dwX$[ebp]
  00066	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _dwFallbackScales[eax*4]
  0006d	89 4d f4	 mov	 DWORD PTR _dwBestPattern$[ebp], ecx

; 10658:             dwBest = dwTest;

  00070	8b 55 f0	 mov	 edx, DWORD PTR _dwTest$73769[ebp]
  00073	89 55 f8	 mov	 DWORD PTR _dwBest$[ebp], edx
$L73770:

; 10659:         }
; 10660:     }

  00076	eb bd		 jmp	 SHORT $L73767
$L73768:

; 10661:     return dwBestPattern;

  00078	8b 45 f4	 mov	 eax, DWORD PTR _dwBestPattern$[ebp]
$L73761:

; 10662: }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?FixScale@@YGKK@Z ENDP					; FixScale
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?BitCount@@YGKK@Z
_TEXT	SEGMENT
_dwCount$ = -4
_dwPattern$ = 8
?BitCount@@YGKK@Z PROC NEAR				; BitCount, COMDAT

; 10583: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10584:     DWORD dwCount = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0
$L73736:

; 10585: 
; 10586:     while (dwPattern)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _dwPattern$[ebp], 0
  0000f	74 19		 je	 SHORT $L73737

; 10587:     {
; 10588:         dwPattern &= (dwPattern - 1);

  00011	8b 45 08	 mov	 eax, DWORD PTR _dwPattern$[ebp]
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _dwPattern$[ebp]
  0001a	23 c8		 and	 ecx, eax
  0001c	89 4d 08	 mov	 DWORD PTR _dwPattern$[ebp], ecx

; 10589:         dwCount++;

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _dwCount$[ebp]
  00022	83 c2 01	 add	 edx, 1
  00025	89 55 fc	 mov	 DWORD PTR _dwCount$[ebp], edx

; 10590:     }

  00028	eb e1		 jmp	 SHORT $L73736
$L73737:

; 10591: 
; 10592:     return dwCount;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]

; 10593: }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?BitCount@@YGKK@Z ENDP					; BitCount
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?PatternMatch@@YGKKK@Z
_TEXT	SEGMENT
_dwIndex$ = -8
_dwHit$ = -4
_dwA$ = 8
_dwB$ = 12
?PatternMatch@@YGKKK@Z PROC NEAR			; PatternMatch, COMDAT

; 10619: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 10620:     DWORD dwHit = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwHit$[ebp], 0

; 10621:     DWORD dwIndex = 0;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0

; 10622:     for (;dwIndex < 24; dwIndex++)

  00014	eb 09		 jmp	 SHORT $L73754
$L73755:
  00016	8b 45 f8	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 45 f8	 mov	 DWORD PTR _dwIndex$[ebp], eax
$L73754:
  0001f	83 7d f8 18	 cmp	 DWORD PTR _dwIndex$[ebp], 24 ; 00000018H
  00023	73 2d		 jae	 SHORT $L73756

; 10623:     {
; 10624:         if ((dwA & (1 << dwIndex)) == (dwB & (1 << dwIndex)))

  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0002d	d3 e2		 shl	 edx, cl
  0002f	8b 45 08	 mov	 eax, DWORD PTR _dwA$[ebp]
  00032	23 c2		 and	 eax, edx
  00034	ba 01 00 00 00	 mov	 edx, 1
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0003c	d3 e2		 shl	 edx, cl
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _dwB$[ebp]
  00041	23 ca		 and	 ecx, edx
  00043	3b c1		 cmp	 eax, ecx
  00045	75 09		 jne	 SHORT $L73757

; 10625:         {
; 10626:             dwHit++;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _dwHit$[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 fc	 mov	 DWORD PTR _dwHit$[ebp], edx
$L73757:

; 10627:         }
; 10628:     }

  00050	eb c4		 jmp	 SHORT $L73755
$L73756:

; 10629:     return dwHit;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _dwHit$[ebp]

; 10630: }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?PatternMatch@@YGKKK@Z ENDP				; PatternMatch
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ThreeOctave@@YGKK@Z
_TEXT	SEGMENT
tv75 = -12
_dwResult$ = -4
_dwScale$ = 8
?ThreeOctave@@YGKK@Z PROC NEAR				; ThreeOctave, COMDAT

; 10665: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 10666:     DWORD dwResult = dwScale;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwScale$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _dwResult$[ebp], eax

; 10667:      // don't change third octave if there's something there
; 10668:     if ( !(0xFFF000000 & dwScale) )

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _dwScale$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	81 e1 00 00 00
	ff		 and	 ecx, -16777216		; ff000000H
  00017	83 e2 0f	 and	 edx, 15			; 0000000fH
  0001a	89 4d f4	 mov	 DWORD PTR tv75[ebp], ecx
  0001d	89 55 f8	 mov	 DWORD PTR tv75[ebp+4], edx
  00020	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00023	0b 45 f8	 or	 eax, DWORD PTR tv75[ebp+4]
  00026	85 c0		 test	 eax, eax
  00028	75 14		 jne	 SHORT $L73775

; 10669:     {
; 10670:         // copy second octave to third octave
; 10671:         dwResult |= (dwScale & 0xFFF000) << 12;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _dwScale$[ebp]
  0002d	81 e1 00 f0 ff
	00		 and	 ecx, 16773120		; 00fff000H
  00033	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00036	8b 55 fc	 mov	 edx, DWORD PTR _dwResult$[ebp]
  00039	0b d1		 or	 edx, ecx
  0003b	89 55 fc	 mov	 DWORD PTR _dwResult$[ebp], edx
$L73775:

; 10672:     }
; 10673:     return dwResult;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _dwResult$[ebp]

; 10674: }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?ThreeOctave@@YGKK@Z ENDP				; ThreeOctave
_TEXT	ENDS
PUBLIC	?CleanupScale@@YGKK@Z				; CleanupScale
; Function compile flags: /Odt
;	COMDAT ?AddRootToScale@@YGKEK@Z
_TEXT	SEGMENT
_bScaleRoot$ = 8
_dwScalePattern$ = 12
?AddRootToScale@@YGKEK@Z PROC NEAR			; AddRootToScale, COMDAT

; 10678: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10679:     dwScalePattern = CleanupScale(dwScalePattern);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  0000c	89 45 0c	 mov	 DWORD PTR _dwScalePattern$[ebp], eax

; 10680:     dwScalePattern >>= (12 - (bScaleRoot % 12));

  0000f	0f b6 45 08	 movzx	 eax, BYTE PTR _bScaleRoot$[ebp]
  00013	99		 cdq
  00014	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00019	f7 f9		 idiv	 ecx
  0001b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00020	2b ca		 sub	 ecx, edx
  00022	8b 55 0c	 mov	 edx, DWORD PTR _dwScalePattern$[ebp]
  00025	d3 ea		 shr	 edx, cl
  00027	89 55 0c	 mov	 DWORD PTR _dwScalePattern$[ebp], edx

; 10681:     dwScalePattern = CleanupScale(dwScalePattern);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  00033	89 45 0c	 mov	 DWORD PTR _dwScalePattern$[ebp], eax

; 10682:     return dwScalePattern;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]

; 10683: }

  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
?AddRootToScale@@YGKEK@Z ENDP				; AddRootToScale
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?CleanupScale@@YGKK@Z
_TEXT	SEGMENT
_dwPattern$ = 8
?CleanupScale@@YGKK@Z PROC NEAR				; CleanupScale, COMDAT

; 10611: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10612:     dwPattern &= 0x0FFF;            // Clear upper octave.

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwPattern$[ebp]
  00006	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0000b	89 45 08	 mov	 DWORD PTR _dwPattern$[ebp], eax

; 10613:     dwPattern |= (dwPattern << 12); // Copy lower octave to top.

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _dwPattern$[ebp]
  00011	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00014	8b 55 08	 mov	 edx, DWORD PTR _dwPattern$[ebp]
  00017	0b d1		 or	 edx, ecx
  00019	89 55 08	 mov	 DWORD PTR _dwPattern$[ebp], edx

; 10614:     return dwPattern;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _dwPattern$[ebp]

; 10615: }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?CleanupScale@@YGKK@Z ENDP				; CleanupScale
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InvertChord@@YGKEEKAA_N@Z
_TEXT	SEGMENT
_bRotate2$73811 = -2
_bRotate$ = -1
_bKey$ = 8
_bChordRoot$ = 12
_dwChordPattern$ = 16
_rfBelowRoot$ = 20
?InvertChord@@YGKEEKAA_N@Z PROC NEAR			; InvertChord, COMDAT

; 10717: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10718:     // rotate the chord by the difference between the key and chord root
; 10719:     rfBelowRoot = false;

  00004	8b 45 14	 mov	 eax, DWORD PTR _rfBelowRoot$[ebp]
  00007	c6 00 00	 mov	 BYTE PTR [eax], 0

; 10720:     bKey %= 12;

  0000a	0f b6 45 08	 movzx	 eax, BYTE PTR _bKey$[ebp]
  0000e	99		 cdq
  0000f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00014	f7 f9		 idiv	 ecx
  00016	88 55 08	 mov	 BYTE PTR _bKey$[ebp], dl

; 10721:     bChordRoot %= 12;

  00019	0f b6 45 0c	 movzx	 eax, BYTE PTR _bChordRoot$[ebp]
  0001d	99		 cdq
  0001e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00023	f7 f9		 idiv	 ecx
  00025	88 55 0c	 mov	 BYTE PTR _bChordRoot$[ebp], dl

; 10722:     if (bKey < bChordRoot) bKey += 12;

  00028	0f b6 55 08	 movzx	 edx, BYTE PTR _bKey$[ebp]
  0002c	0f b6 45 0c	 movzx	 eax, BYTE PTR _bChordRoot$[ebp]
  00030	3b d0		 cmp	 edx, eax
  00032	7d 0a		 jge	 SHORT $L73804
  00034	0f b6 4d 08	 movzx	 ecx, BYTE PTR _bKey$[ebp]
  00038	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003b	88 4d 08	 mov	 BYTE PTR _bKey$[ebp], cl
$L73804:

; 10723:     BYTE bRotate = bKey - bChordRoot;

  0003e	0f b6 55 08	 movzx	 edx, BYTE PTR _bKey$[ebp]
  00042	0f b6 45 0c	 movzx	 eax, BYTE PTR _bChordRoot$[ebp]
  00046	2b d0		 sub	 edx, eax
  00048	88 55 ff	 mov	 BYTE PTR _bRotate$[ebp], dl

; 10724:     // first check if the whole chord fits into one octave
; 10725:     if ( !(dwChordPattern & 0xFFF000) )

  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  0004e	81 e1 00 f0 ff
	00		 and	 ecx, 16773120		; 00fff000H
  00054	85 c9		 test	 ecx, ecx
  00056	75 7c		 jne	 SHORT $L73806

; 10726:     {
; 10727:         dwChordPattern = ThreeOctave(CleanupScale(dwChordPattern));

  00058	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?ThreeOctave@@YGKK@Z	; ThreeOctave
  00067	89 45 10	 mov	 DWORD PTR _dwChordPattern$[ebp], eax

; 10728:         dwChordPattern >>= bRotate;

  0006a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bRotate$[ebp]
  0006e	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00071	d3 e8		 shr	 eax, cl
  00073	89 45 10	 mov	 DWORD PTR _dwChordPattern$[ebp], eax

; 10729:         dwChordPattern &= 0xFFF;

  00076	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  00079	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0007f	89 4d 10	 mov	 DWORD PTR _dwChordPattern$[ebp], ecx

; 10730:         if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) || 
; 10731:             !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)))

  00082	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  00085	83 e2 07	 and	 edx, 7
  00088	85 d2		 test	 edx, edx
  0008a	75 0c		 jne	 SHORT $L73809
  0008c	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  0008f	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00094	85 c0		 test	 eax, eax
  00096	75 17		 jne	 SHORT $L73808
$L73809:
  00098	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  0009b	83 e1 03	 and	 ecx, 3
  0009e	85 c9		 test	 ecx, ecx
  000a0	75 2d		 jne	 SHORT $L73807
  000a2	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  000a5	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  000ab	85 d2		 test	 edx, edx
  000ad	74 20		 je	 SHORT $L73807
$L73808:

; 10732:         {
; 10733:             dwChordPattern |= (dwChordPattern << 12);

  000af	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  000b2	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  000b8	0b c8		 or	 ecx, eax
  000ba	89 4d 10	 mov	 DWORD PTR _dwChordPattern$[ebp], ecx

; 10734:             dwChordPattern &= 0x3FFC00;

  000bd	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  000c0	81 e2 00 fc 3f
	00		 and	 edx, 4193280		; 003ffc00H
  000c6	89 55 10	 mov	 DWORD PTR _dwChordPattern$[ebp], edx

; 10735:             rfBelowRoot = true;

  000c9	8b 45 14	 mov	 eax, DWORD PTR _rfBelowRoot$[ebp]
  000cc	c6 00 01	 mov	 BYTE PTR [eax], 1
$L73807:

; 10736:         }
; 10737:     }
; 10738:     else

  000cf	e9 9b 01 00 00	 jmp	 $L73810
$L73806:

; 10739:     {
; 10740:         dwChordPattern &= 0xFFFFFF; // make sure there are only notes in the two-octave range

  000d4	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  000d7	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000dd	89 4d 10	 mov	 DWORD PTR _dwChordPattern$[ebp], ecx

; 10741:         // do a circular shift in the closest direction
; 10742:         BYTE bRotate2 = (bChordRoot + 12) - bKey;

  000e0	0f b6 55 0c	 movzx	 edx, BYTE PTR _bChordRoot$[ebp]
  000e4	83 c2 0c	 add	 edx, 12			; 0000000cH
  000e7	0f b6 45 08	 movzx	 eax, BYTE PTR _bKey$[ebp]
  000eb	2b d0		 sub	 edx, eax
  000ed	88 55 fe	 mov	 BYTE PTR _bRotate2$73811[ebp], dl

; 10743:         if (bRotate <= bRotate2)

  000f0	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bRotate$[ebp]
  000f4	0f b6 55 fe	 movzx	 edx, BYTE PTR _bRotate2$73811[ebp]
  000f8	3b ca		 cmp	 ecx, edx
  000fa	7f 20		 jg	 SHORT $L73812

; 10744:         {
; 10745:             dwChordPattern = (dwChordPattern << (24 - bRotate)) | (dwChordPattern >> bRotate);

  000fc	0f b6 45 ff	 movzx	 eax, BYTE PTR _bRotate$[ebp]
  00100	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00105	2b c8		 sub	 ecx, eax
  00107	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  0010a	d3 e2		 shl	 edx, cl
  0010c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bRotate$[ebp]
  00110	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00113	d3 e8		 shr	 eax, cl
  00115	0b d0		 or	 edx, eax
  00117	89 55 10	 mov	 DWORD PTR _dwChordPattern$[ebp], edx

; 10746:         }
; 10747:         else

  0011a	eb 20		 jmp	 SHORT $L73813
$L73812:

; 10748:         {
; 10749:             dwChordPattern = (dwChordPattern >> (24 - bRotate2)) | (dwChordPattern << bRotate2);

  0011c	0f b6 4d fe	 movzx	 ecx, BYTE PTR _bRotate2$73811[ebp]
  00120	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00125	2b d1		 sub	 edx, ecx
  00127	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  0012a	8b ca		 mov	 ecx, edx
  0012c	d3 e8		 shr	 eax, cl
  0012e	0f b6 4d fe	 movzx	 ecx, BYTE PTR _bRotate2$73811[ebp]
  00132	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  00135	d3 e2		 shl	 edx, cl
  00137	0b c2		 or	 eax, edx
  00139	89 45 10	 mov	 DWORD PTR _dwChordPattern$[ebp], eax
$L73813:

; 10750:         }
; 10751:         dwChordPattern &= 0xFFFFFF;

  0013c	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  0013f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00144	89 45 10	 mov	 DWORD PTR _dwChordPattern$[ebp], eax

; 10752:         if (!(dwChordPattern & 0x7) &&
; 10753:             (!(dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000)) || 
; 10754:              !(dwChordPattern & 0x3000) && ((dwChordPattern & 0x800000)) ||
; 10755:              !(dwChordPattern & 0x1000) && ((dwChordPattern & 0x1000000)) ||
; 10756:              !(dwChordPattern & 0x7) && (dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000))) )

  00147	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  0014a	83 e1 07	 and	 ecx, 7
  0014d	85 c9		 test	 ecx, ecx
  0014f	0f 85 8c 00 00
	00		 jne	 $L73814
  00155	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  00158	81 e2 00 70 00
	00		 and	 edx, 28672		; 00007000H
  0015e	85 d2		 test	 edx, edx
  00160	75 0c		 jne	 SHORT $L73816
  00162	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00165	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 56		 jne	 SHORT $L73815
$L73816:
  0016e	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  00171	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H
  00177	85 c9		 test	 ecx, ecx
  00179	75 0d		 jne	 SHORT $L73817
  0017b	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  0017e	81 e2 00 00 80
	00		 and	 edx, 8388608		; 00800000H
  00184	85 d2		 test	 edx, edx
  00186	75 3c		 jne	 SHORT $L73815
$L73817:
  00188	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  0018b	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00190	85 c0		 test	 eax, eax
  00192	75 0d		 jne	 SHORT $L73818
  00194	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  00197	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  0019d	85 c9		 test	 ecx, ecx
  0019f	75 23		 jne	 SHORT $L73815
$L73818:
  001a1	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  001a4	83 e2 07	 and	 edx, 7
  001a7	85 d2		 test	 edx, edx
  001a9	75 36		 jne	 SHORT $L73814
  001ab	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  001ae	25 00 70 00 00	 and	 eax, 28672		; 00007000H
  001b3	85 c0		 test	 eax, eax
  001b5	74 2a		 je	 SHORT $L73814
  001b7	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  001ba	81 e1 00 00 c0
	00		 and	 ecx, 12582912		; 00c00000H
  001c0	85 c9		 test	 ecx, ecx
  001c2	74 1d		 je	 SHORT $L73814
$L73815:

; 10757:         {
; 10758:             dwChordPattern = (dwChordPattern << 12) | (dwChordPattern >> 12);

  001c4	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  001c7	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  001ca	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  001cd	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  001d0	0b d0		 or	 edx, eax
  001d2	89 55 10	 mov	 DWORD PTR _dwChordPattern$[ebp], edx

; 10759:             dwChordPattern &= 0xFFFFFF;

  001d5	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  001d8	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001de	89 4d 10	 mov	 DWORD PTR _dwChordPattern$[ebp], ecx
$L73814:

; 10760:         }
; 10761:         if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) || 
; 10762:             !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)) ||
; 10763:             !(dwChordPattern & 0x1) && ((dwChordPattern & 0x1000)) )

  001e1	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  001e4	83 e2 07	 and	 edx, 7
  001e7	85 d2		 test	 edx, edx
  001e9	75 0c		 jne	 SHORT $L73821
  001eb	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  001ee	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  001f3	85 c0		 test	 eax, eax
  001f5	75 2e		 jne	 SHORT $L73820
$L73821:
  001f7	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  001fa	83 e1 03	 and	 ecx, 3
  001fd	85 c9		 test	 ecx, ecx
  001ff	75 0d		 jne	 SHORT $L73822
  00201	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  00204	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0020a	85 d2		 test	 edx, edx
  0020c	75 17		 jne	 SHORT $L73820
$L73822:
  0020e	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00211	83 e0 01	 and	 eax, 1
  00214	85 c0		 test	 eax, eax
  00216	75 57		 jne	 SHORT $L73810
  00218	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  0021b	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00221	85 c9		 test	 ecx, ecx
  00223	74 4a		 je	 SHORT $L73810
$L73820:

; 10764:         {
; 10765:             // put everything up to the G in the first octave two octaves up; 
; 10766:             // put G# and A one octave up
; 10767:             dwChordPattern |= (((dwChordPattern & 0xFF) << 24) | ((dwChordPattern & 0x300) << 12));

  00225	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  00228	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0022e	c1 e2 18	 shl	 edx, 24			; 00000018H
  00231	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00234	25 00 03 00 00	 and	 eax, 768		; 00000300H
  00239	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0023c	0b d0		 or	 edx, eax
  0023e	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  00241	0b ca		 or	 ecx, edx
  00243	89 4d 10	 mov	 DWORD PTR _dwChordPattern$[ebp], ecx

; 10768:             // get rid of everything below A# in the first octave
; 10769:             dwChordPattern &= 0xFFFFFC00;

  00246	8b 55 10	 mov	 edx, DWORD PTR _dwChordPattern$[ebp]
  00249	81 e2 00 fc ff
	ff		 and	 edx, -1024		; fffffc00H
  0024f	89 55 10	 mov	 DWORD PTR _dwChordPattern$[ebp], edx

; 10770:             // If there are no notes lower than C2, shift everything back down an octave
; 10771:             if (!(dwChordPattern & 0xFFF))

  00252	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00255	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0025a	85 c0		 test	 eax, eax
  0025c	75 0b		 jne	 SHORT $L73823

; 10772:             {
; 10773:                 dwChordPattern >>= 12;

  0025e	8b 4d 10	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  00261	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00264	89 4d 10	 mov	 DWORD PTR _dwChordPattern$[ebp], ecx

; 10774:             }
; 10775:             else

  00267	eb 06		 jmp	 SHORT $L73810
$L73823:

; 10776:             {
; 10777:                 rfBelowRoot = true;

  00269	8b 55 14	 mov	 edx, DWORD PTR _rfBelowRoot$[ebp]
  0026c	c6 02 01	 mov	 BYTE PTR [edx], 1
$L73810:

; 10778:             }
; 10779:         }
; 10780:     }
; 10781:     return dwChordPattern;

  0026f	8b 45 10	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]

; 10782: 
; 10783: }

  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	c2 10 00	 ret	 16			; 00000010H
?InvertChord@@YGKEEKAA_N@Z ENDP				; InvertChord
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?MusicValueAccidentals@@YGFG@Z
_TEXT	SEGMENT
tv72 = -8
_acc$ = -4
_wMusicValue$ = 8
?MusicValueAccidentals@@YGFG@Z PROC NEAR		; MusicValueAccidentals, COMDAT

; 10987: { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 10988:     short acc = short(wMusicValue & 0xf);

  00006	0f b7 45 08	 movzx	 eax, WORD PTR _wMusicValue$[ebp]
  0000a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0000d	66 89 45 fc	 mov	 WORD PTR _acc$[ebp], ax

; 10989:     return (acc > 8) ? acc - 16 : acc;

  00011	0f bf 4d fc	 movsx	 ecx, WORD PTR _acc$[ebp]
  00015	83 f9 08	 cmp	 ecx, 8
  00018	7e 0c		 jle	 SHORT $L76011
  0001a	0f bf 55 fc	 movsx	 edx, WORD PTR _acc$[ebp]
  0001e	83 ea 10	 sub	 edx, 16			; 00000010H
  00021	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  00024	eb 07		 jmp	 SHORT $L76012
$L76011:
  00026	0f bf 45 fc	 movsx	 eax, WORD PTR _acc$[ebp]
  0002a	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$L76012:
  0002d	66 8b 45 f8	 mov	 ax, WORD PTR tv72[ebp]

; 10990: }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?MusicValueAccidentals@@YGFG@Z ENDP			; MusicValueAccidentals
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?BitsInChord@@YGFK@Z
_TEXT	SEGMENT
_nResult$73918 = -4
_dwChordPattern$ = 8
?BitsInChord@@YGFK@Z PROC NEAR				; BitsInChord, COMDAT

; 10993: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10994:     
; 10995:     for (short nResult = 0; dwChordPattern != 0; dwChordPattern >>= 1)

  00004	66 c7 45 fc 00
	00		 mov	 WORD PTR _nResult$73918[ebp], 0
  0000a	eb 08		 jmp	 SHORT $L73919
$L73920:
  0000c	8b 45 08	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  0000f	d1 e8		 shr	 eax, 1
  00011	89 45 08	 mov	 DWORD PTR _dwChordPattern$[ebp], eax
$L73919:
  00014	83 7d 08 00	 cmp	 DWORD PTR _dwChordPattern$[ebp], 0
  00018	74 18		 je	 SHORT $L73921

; 10996:         if (dwChordPattern & 1) nResult++;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _dwChordPattern$[ebp]
  0001d	83 e1 01	 and	 ecx, 1
  00020	85 c9		 test	 ecx, ecx
  00022	74 0c		 je	 SHORT $L73922
  00024	66 8b 55 fc	 mov	 dx, WORD PTR _nResult$73918[ebp]
  00028	66 83 c2 01	 add	 dx, 1
  0002c	66 89 55 fc	 mov	 WORD PTR _nResult$73918[ebp], dx
$L73922:

; 10997:     return nResult;

  00030	eb da		 jmp	 SHORT $L73920
$L73921:
  00032	66 8b 45 fc	 mov	 ax, WORD PTR _nResult$73918[ebp]

; 10998: }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?BitsInChord@@YGFK@Z ENDP				; BitsInChord
_TEXT	ENDS
PUBLIC	?SubtractRootFromScale@@YGKEK@Z			; SubtractRootFromScale
PUBLIC	?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z	; MusicValueConvert
PUBLIC	??_C@_0BM@CCDOAEII@?$CFs?3?5Invalid?5pointer?5pChord?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@MBABIGFP@?$CFs?3?5Invalid?5pointer?5pwMusicValue@ ; `string'
PUBLIC	??_C@_0GN@DNOCFEOA@Error?3?5MIDIToMusic?5conversion?5fa@ ; `string'
PUBLIC	??_C@_0GC@GBMAAGGG@Warning?3?5MIDIToMusic?5had?5to?5bump@ ; `string'
PUBLIC	??_C@_0GE@PGBKAKLP@Warning?3?5MIDIToMusic?5had?5to?5bump@ ; `string'
PUBLIC	??_C@_0GG@CCLPDFFN@Warning?3?5MIDIToMusic?5had?5to?5bump@ ; `string'
PUBLIC	??_C@_0GA@HLFPPIBN@Warning?3?5MIDIToMusic?5had?5to?5bump@ ; `string'
PUBLIC	??_C@_0JA@CPGAIEHN@Error?3?5Unable?5to?5convert?5MIDI?5va@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::MIDIToMusic', 00H	; `CPerformance::MIDIToMusic'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@CCDOAEII@?$CFs?3?5Invalid?5pointer?5pChord?6?$AA@
CONST	SEGMENT
??_C@_0BM@CCDOAEII@?$CFs?3?5Invalid?5pointer?5pChord?6?$AA@ DB '%s: Inval'
	DB	'id pointer pChord', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MBABIGFP@?$CFs?3?5Invalid?5pointer?5pwMusicValue@
CONST	SEGMENT
??_C@_0CC@MBABIGFP@?$CFs?3?5Invalid?5pointer?5pwMusicValue@ DB '%s: Inval'
	DB	'id pointer pwMusicValue', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@DNOCFEOA@Error?3?5MIDIToMusic?5conversion?5fa@
CONST	SEGMENT
??_C@_0GN@DNOCFEOA@Error?3?5MIDIToMusic?5conversion?5fa@ DB 'Error: MIDIT'
	DB	'oMusic conversion failed either because there is no playmode '
	DB	'or MIDI value %ld is out of range.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@GBMAAGGG@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT
??_C@_0GC@GBMAAGGG@Warning?3?5MIDIToMusic?5had?5to?5bump@ DB 'Warning: MI'
	DB	'DIToMusic had to bump the music value up an octave for DMUS_P'
	DB	'LAYMODE_FIXEDTOKEY note.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@PGBKAKLP@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT
??_C@_0GE@PGBKAKLP@Warning?3?5MIDIToMusic?5had?5to?5bump@ DB 'Warning: MI'
	DB	'DIToMusic had to bump the music value up an octave for DMUS_P'
	DB	'LAYMODE_FIXEDTOCHORD note.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@CCLPDFFN@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT
??_C@_0GG@CCLPDFFN@Warning?3?5MIDIToMusic?5had?5to?5bump@ DB 'Warning: MI'
	DB	'DIToMusic had to bump the music value down an octave for DMUS'
	DB	'_PLAYMODE_FIXEDTOCHORD note.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HLFPPIBN@Warning?3?5MIDIToMusic?5had?5to?5bump@
CONST	SEGMENT
??_C@_0GA@HLFPPIBN@Warning?3?5MIDIToMusic?5had?5to?5bump@ DB 'Warning: MI'
	DB	'DIToMusic had to bump the music value up an octave for DMUS_P'
	DB	'LAYMODE_KEY_ROOT note.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@CPGAIEHN@Error?3?5Unable?5to?5convert?5MIDI?5va@
CONST	SEGMENT
??_C@_0JA@CPGAIEHN@Error?3?5Unable?5to?5convert?5MIDI?5va@ DB 'Error: Una'
	DB	'ble to convert MIDI value %ld to Music value. This usually me'
	DB	'ans the DMUS_CHORD_KEY structure has an invalid chord or scal'
	DB	'e pattern.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z
_TEXT	SEGMENT
_dwOldChordPattern$74107 = -60
_bNewChordRoot$74086 = -53
_i$74045 = -52
_pSubChord$74042 = -48
_dwScalePattern$74070 = -44
_bKeyRoot$74072 = -37
_dwLevel$74043 = -36
_wNewMusicValue$74097 = -32
_nTest$74101 = -28
_dwChordPattern$74071 = -24
_fBelowRoot$74069 = -19
_bChordRoot$74073 = -18
_fFoundLevel$74044 = -17
_fDropOctave$74095 = -16
_lMusicValue$ = -12
_hr$ = -8
_lMIDIInTraceValue$ = -4
_this$ = 8
_bMIDIValue$ = 12
_pChord$ = 16
_bPlayMode$ = 20
_bChordLevel$ = 24
_pwMusicValue$ = 28
?MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z PROC NEAR ; CPerformance::MIDIToMusic, COMDAT

; 11178: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi

; 11179:     V_INAME(IDirectMusicPerformance::MIDIToMusic);
; 11180:     V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );

  00007	68 cc 00 00 00	 push	 204			; 000000ccH
  0000c	8b 45 10	 mov	 eax, DWORD PTR _pChord$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00015	85 c0		 test	 eax, eax
  00017	74 19		 je	 SHORT $L74006
  00019	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z@4QBDB
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@CCDOAEII@?$CFs?3?5Invalid?5pointer?5pChord?6?$AA@
  00023	6a ff		 push	 -1
  00025	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	e8 00 00 00 00	 call	 _DebugBreak@0
$L74006:

; 11181:     V_PTR_WRITE(pwMusicValue,WORD);

  00032	6a 02		 push	 2
  00034	8b 4d 1c	 mov	 ecx, DWORD PTR _pwMusicValue$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0003d	85 c0		 test	 eax, eax
  0003f	74 19		 je	 SHORT $L74009
  00041	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z@4QBDB
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@MBABIGFP@?$CFs?3?5Invalid?5pointer?5pwMusicValue@
  0004b	6a ff		 push	 -1
  0004d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	e8 00 00 00 00	 call	 _DebugBreak@0
$L74009:

; 11182: 
; 11183:     long lMusicValue;
; 11184:     HRESULT hr = S_OK;

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 11185: #ifdef DBG
; 11186:     long lMIDIInTraceValue = bMIDIValue;

  00061	0f b6 55 0c	 movzx	 edx, BYTE PTR _bMIDIValue$[ebp]
  00065	89 55 fc	 mov	 DWORD PTR _lMIDIInTraceValue$[ebp], edx

; 11187: #endif
; 11188: 
; 11189:     if ((bPlayMode & DMUS_PLAYMODE_NONE ) || (bMIDIValue & 0x80))

  00068	0f b6 45 14	 movzx	 eax, BYTE PTR _bPlayMode$[ebp]
  0006c	83 e0 10	 and	 eax, 16			; 00000010H
  0006f	85 c0		 test	 eax, eax
  00071	75 0e		 jne	 SHORT $L74016
  00073	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  00077	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0007d	85 c9		 test	 ecx, ecx
  0007f	74 1e		 je	 SHORT $L74015
$L74016:

; 11190:     {
; 11191:         Trace(1,"Error: MIDIToMusic conversion failed either because there is no playmode or MIDI value %ld is out of range.\n",(long)bMIDIValue);

  00081	0f b6 55 0c	 movzx	 edx, BYTE PTR _bMIDIValue$[ebp]
  00085	52		 push	 edx
  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GN@DNOCFEOA@Error?3?5MIDIToMusic?5conversion?5fa@
  0008b	6a 01		 push	 1
  0008d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11192:         return E_INVALIDARG;

  00095	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0009a	e9 33 04 00 00	 jmp	 $L74002
$L74015:

; 11193:     }
; 11194:     else if( bPlayMode == DMUS_PLAYMODE_FIXED )

  0009f	0f b6 45 14	 movzx	 eax, BYTE PTR _bPlayMode$[ebp]
  000a3	85 c0		 test	 eax, eax
  000a5	75 14		 jne	 SHORT $L74021

; 11195:     {
; 11196:         *pwMusicValue = bMIDIValue & 0x7F;

  000a7	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  000ab	83 e1 7f	 and	 ecx, 127		; 0000007fH
  000ae	8b 55 1c	 mov	 edx, DWORD PTR _pwMusicValue$[ebp]
  000b1	66 89 0a	 mov	 WORD PTR [edx], cx

; 11197:         return S_OK;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 17 04 00 00	 jmp	 $L74002
$L74021:

; 11198:     }
; 11199:     else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to key

  000bb	0f b6 45 14	 movzx	 eax, BYTE PTR _bPlayMode$[ebp]
  000bf	83 f8 01	 cmp	 eax, 1
  000c2	75 73		 jne	 SHORT $L74024

; 11200:     {
; 11201:         lMusicValue = bMIDIValue - pChord->bKey;

  000c4	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  000c8	8b 55 10	 mov	 edx, DWORD PTR _pChord$[ebp]
  000cb	0f b6 82 c8 00
	00 00		 movzx	 eax, BYTE PTR [edx+200]
  000d2	2b c8		 sub	 ecx, eax
  000d4	89 4d f4	 mov	 DWORD PTR _lMusicValue$[ebp], ecx
$L74026:

; 11202:         while (lMusicValue < 0)

  000d7	83 7d f4 00	 cmp	 DWORD PTR _lMusicValue$[ebp], 0
  000db	7d 21		 jge	 SHORT $L74034

; 11203:         {
; 11204:             lMusicValue += 12;

  000dd	8b 4d f4	 mov	 ecx, DWORD PTR _lMusicValue$[ebp]
  000e0	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000e3	89 4d f4	 mov	 DWORD PTR _lMusicValue$[ebp], ecx

; 11205:             Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");

  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GC@GBMAAGGG@Warning?3?5MIDIToMusic?5had?5to?5bump@
  000eb	6a 02		 push	 2
  000ed	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000f2	83 c4 08	 add	 esp, 8

; 11206:             hr = DMUS_S_UP_OCTAVE;

  000f5	c7 45 f8 13 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086675 ; 08781213H

; 11207:         }

  000fc	eb d9		 jmp	 SHORT $L74026
$L74034:

; 11208:         while (lMusicValue > 127)

  000fe	83 7d f4 7f	 cmp	 DWORD PTR _lMusicValue$[ebp], 127 ; 0000007fH
  00102	7e 21		 jle	 SHORT $L74035

; 11209:         {
; 11210:             lMusicValue -= 12;

  00104	8b 55 f4	 mov	 edx, DWORD PTR _lMusicValue$[ebp]
  00107	83 ea 0c	 sub	 edx, 12			; 0000000cH
  0010a	89 55 f4	 mov	 DWORD PTR _lMusicValue$[ebp], edx

; 11211:             Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");

  0010d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GC@GBMAAGGG@Warning?3?5MIDIToMusic?5had?5to?5bump@
  00112	6a 02		 push	 2
  00114	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00119	83 c4 08	 add	 esp, 8

; 11212:             hr = DMUS_S_DOWN_OCTAVE;

  0011c	c7 45 f8 14 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086676 ; 08781214H

; 11213:         }

  00123	eb d9		 jmp	 SHORT $L74034
$L74035:

; 11214:         *pwMusicValue = (WORD) lMusicValue;

  00125	8b 45 1c	 mov	 eax, DWORD PTR _pwMusicValue$[ebp]
  00128	66 8b 4d f4	 mov	 cx, WORD PTR _lMusicValue$[ebp]
  0012c	66 89 08	 mov	 WORD PTR [eax], cx

; 11215:         return hr;

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  00132	e9 9b 03 00 00	 jmp	 $L74002
$L74024:

; 11216:     }
; 11217:     else
; 11218:     {
; 11219:         DMUS_SUBCHORD *pSubChord;
; 11220:         DWORD dwLevel = 1 << bChordLevel;

  00137	0f b6 4d 18	 movzx	 ecx, BYTE PTR _bChordLevel$[ebp]
  0013b	ba 01 00 00 00	 mov	 edx, 1
  00140	d3 e2		 shl	 edx, cl
  00142	89 55 dc	 mov	 DWORD PTR _dwLevel$74043[ebp], edx

; 11221:         bool fFoundLevel = false;

  00145	c6 45 ef 00	 mov	 BYTE PTR _fFoundLevel$74044[ebp], 0

; 11222:         for (int i = 0; i < pChord->bSubChordCount; i++)

  00149	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$74045[ebp], 0
  00150	eb 09		 jmp	 SHORT $L74046
$L74047:
  00152	8b 45 cc	 mov	 eax, DWORD PTR _i$74045[ebp]
  00155	83 c0 01	 add	 eax, 1
  00158	89 45 cc	 mov	 DWORD PTR _i$74045[ebp], eax
$L74046:
  0015b	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  0015e	0f b6 51 23	 movzx	 edx, BYTE PTR [ecx+35]
  00162	39 55 cc	 cmp	 DWORD PTR _i$74045[ebp], edx
  00165	7d 2c		 jge	 SHORT $L74048

; 11223:         {
; 11224:             if (dwLevel & pChord->SubChordList[i].dwLevels)

  00167	8b 45 cc	 mov	 eax, DWORD PTR _i$74045[ebp]
  0016a	6b c0 14	 imul	 eax, 20			; 00000014H
  0016d	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  00170	8b 55 dc	 mov	 edx, DWORD PTR _dwLevel$74043[ebp]
  00173	23 54 01 30	 and	 edx, DWORD PTR [ecx+eax+48]
  00177	85 d2		 test	 edx, edx
  00179	74 16		 je	 SHORT $L74049

; 11225:             {
; 11226:                 pSubChord = &pChord->SubChordList[i];

  0017b	8b 45 cc	 mov	 eax, DWORD PTR _i$74045[ebp]
  0017e	6b c0 14	 imul	 eax, 20			; 00000014H
  00181	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  00184	8d 54 01 24	 lea	 edx, DWORD PTR [ecx+eax+36]
  00188	89 55 d0	 mov	 DWORD PTR _pSubChord$74042[ebp], edx

; 11227:                 fFoundLevel = true;

  0018b	c6 45 ef 01	 mov	 BYTE PTR _fFoundLevel$74044[ebp], 1

; 11228:                 break;

  0018f	eb 02		 jmp	 SHORT $L74048
$L74049:

; 11229:             }
; 11230:         }

  00191	eb bf		 jmp	 SHORT $L74047
$L74048:

; 11231:         if (!fFoundLevel) // No luck? Use first chord.

  00193	0f b6 45 ef	 movzx	 eax, BYTE PTR _fFoundLevel$74044[ebp]
  00197	85 c0		 test	 eax, eax
  00199	75 09		 jne	 SHORT $L74050

; 11232:         {
; 11233:             pSubChord = &pChord->SubChordList[0];

  0019b	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  0019e	83 c1 24	 add	 ecx, 36			; 00000024H
  001a1	89 4d d0	 mov	 DWORD PTR _pSubChord$74042[ebp], ecx
$L74050:

; 11234:         }
; 11235:         if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord

  001a4	0f b6 55 14	 movzx	 edx, BYTE PTR _bPlayMode$[ebp]
  001a8	83 fa 02	 cmp	 edx, 2
  001ab	75 78		 jne	 SHORT $L74051

; 11236:         {
; 11237:             lMusicValue = bMIDIValue - (pSubChord->bChordRoot % 24);

  001ad	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  001b1	8b 55 d0	 mov	 edx, DWORD PTR _pSubChord$74042[ebp]
  001b4	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  001b8	99		 cdq
  001b9	be 18 00 00 00	 mov	 esi, 24			; 00000018H
  001be	f7 fe		 idiv	 esi
  001c0	2b ca		 sub	 ecx, edx
  001c2	89 4d f4	 mov	 DWORD PTR _lMusicValue$[ebp], ecx
$L74053:

; 11238:             while (lMusicValue < 0)

  001c5	83 7d f4 00	 cmp	 DWORD PTR _lMusicValue$[ebp], 0
  001c9	7d 21		 jge	 SHORT $L74061

; 11239:             {
; 11240:                 lMusicValue += 12;

  001cb	8b 45 f4	 mov	 eax, DWORD PTR _lMusicValue$[ebp]
  001ce	83 c0 0c	 add	 eax, 12			; 0000000cH
  001d1	89 45 f4	 mov	 DWORD PTR _lMusicValue$[ebp], eax

; 11241:                 Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");

  001d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GE@PGBKAKLP@Warning?3?5MIDIToMusic?5had?5to?5bump@
  001d9	6a 02		 push	 2
  001db	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001e0	83 c4 08	 add	 esp, 8

; 11242:                 hr = DMUS_S_UP_OCTAVE;

  001e3	c7 45 f8 13 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086675 ; 08781213H

; 11243:             }

  001ea	eb d9		 jmp	 SHORT $L74053
$L74061:

; 11244:             while (lMusicValue > 127)

  001ec	83 7d f4 7f	 cmp	 DWORD PTR _lMusicValue$[ebp], 127 ; 0000007fH
  001f0	7e 21		 jle	 SHORT $L74062

; 11245:             {
; 11246:                 lMusicValue -= 12;

  001f2	8b 4d f4	 mov	 ecx, DWORD PTR _lMusicValue$[ebp]
  001f5	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  001f8	89 4d f4	 mov	 DWORD PTR _lMusicValue$[ebp], ecx

; 11247:                 Trace(2,"Warning: MIDIToMusic had to bump the music value down an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");

  001fb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GG@CCLPDFFN@Warning?3?5MIDIToMusic?5had?5to?5bump@
  00200	6a 02		 push	 2
  00202	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00207	83 c4 08	 add	 esp, 8

; 11248:                 hr = DMUS_S_DOWN_OCTAVE;

  0020a	c7 45 f8 14 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086676 ; 08781214H

; 11249:             }

  00211	eb d9		 jmp	 SHORT $L74061
$L74062:

; 11250:             *pwMusicValue = (WORD) lMusicValue;

  00213	8b 55 1c	 mov	 edx, DWORD PTR _pwMusicValue$[ebp]
  00216	66 8b 45 f4	 mov	 ax, WORD PTR _lMusicValue$[ebp]
  0021a	66 89 02	 mov	 WORD PTR [edx], ax

; 11251:             return hr;

  0021d	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  00220	e9 ad 02 00 00	 jmp	 $L74002
$L74051:

; 11252:         }
; 11253:         bool fBelowRoot = false;

  00225	c6 45 ed 00	 mov	 BYTE PTR _fBelowRoot$74069[ebp], 0

; 11254:         DWORD dwScalePattern = AddRootToScale(pSubChord->bScaleRoot, pSubChord->dwScalePattern);

  00229	8b 4d d0	 mov	 ecx, DWORD PTR _pSubChord$74042[ebp]
  0022c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0022f	52		 push	 edx
  00230	8b 45 d0	 mov	 eax, DWORD PTR _pSubChord$74042[ebp]
  00233	8a 48 11	 mov	 cl, BYTE PTR [eax+17]
  00236	51		 push	 ecx
  00237	e8 00 00 00 00	 call	 ?AddRootToScale@@YGKEK@Z ; AddRootToScale
  0023c	89 45 d4	 mov	 DWORD PTR _dwScalePattern$74070[ebp], eax

; 11255:         DWORD dwChordPattern = pSubChord->dwChordPattern;

  0023f	8b 55 d0	 mov	 edx, DWORD PTR _pSubChord$74042[ebp]
  00242	8b 02		 mov	 eax, DWORD PTR [edx]
  00244	89 45 e8	 mov	 DWORD PTR _dwChordPattern$74071[ebp], eax

; 11256:         BYTE bKeyRoot = pChord->bKey;

  00247	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  0024a	8a 91 c8 00 00
	00		 mov	 dl, BYTE PTR [ecx+200]
  00250	88 55 db	 mov	 BYTE PTR _bKeyRoot$74072[ebp], dl

; 11257:         BYTE bChordRoot = pSubChord->bChordRoot;

  00253	8b 45 d0	 mov	 eax, DWORD PTR _pSubChord$74042[ebp]
  00256	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  00259	88 4d ee	 mov	 BYTE PTR _bChordRoot$74073[ebp], cl

; 11258:         dwScalePattern = FixScale(dwScalePattern);

  0025c	8b 55 d4	 mov	 edx, DWORD PTR _dwScalePattern$74070[ebp]
  0025f	52		 push	 edx
  00260	e8 00 00 00 00	 call	 ?FixScale@@YGKK@Z	; FixScale
  00265	89 45 d4	 mov	 DWORD PTR _dwScalePattern$74070[ebp], eax

; 11259:         bPlayMode &= 0xF;   // We only know about the bottom four flags, at this point.

  00268	0f b6 45 14	 movzx	 eax, BYTE PTR _bPlayMode$[ebp]
  0026c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0026f	88 45 14	 mov	 BYTE PTR _bPlayMode$[ebp], al

; 11260: //        if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT) 
; 11261:         // Do this for any non-fixed key root mode (Pedalpoint, PedalpointChord, PedalpointAlways)
; 11262:         if (bPlayMode & DMUS_PLAYMODE_KEY_ROOT) 

  00272	0f b6 4d 14	 movzx	 ecx, BYTE PTR _bPlayMode$[ebp]
  00276	83 e1 01	 and	 ecx, 1
  00279	85 c9		 test	 ecx, ecx
  0027b	0f 84 c1 00 00
	00		 je	 $L74074
$L74076:

; 11263:         {
; 11264:             while (bKeyRoot > bMIDIValue)

  00281	0f b6 55 db	 movzx	 edx, BYTE PTR _bKeyRoot$74072[ebp]
  00285	0f b6 45 0c	 movzx	 eax, BYTE PTR _bMIDIValue$[ebp]
  00289	3b d0		 cmp	 edx, eax
  0028b	7e 22		 jle	 SHORT $L74077

; 11265:             {
; 11266:                 hr = DMUS_S_UP_OCTAVE;

  0028d	c7 45 f8 13 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086675 ; 08781213H

; 11267:                 Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_KEY_ROOT note.\n");

  00294	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GA@HLFPPIBN@Warning?3?5MIDIToMusic?5had?5to?5bump@
  00299	6a 02		 push	 2
  0029b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002a0	83 c4 08	 add	 esp, 8

; 11268:                 bMIDIValue += 12;

  002a3	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  002a7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002aa	88 4d 0c	 mov	 BYTE PTR _bMIDIValue$[ebp], cl

; 11269:             }

  002ad	eb d2		 jmp	 SHORT $L74076
$L74077:

; 11270:             dwScalePattern = SubtractRootFromScale(bKeyRoot,dwScalePattern);

  002af	8b 55 d4	 mov	 edx, DWORD PTR _dwScalePattern$74070[ebp]
  002b2	52		 push	 edx
  002b3	8a 45 db	 mov	 al, BYTE PTR _bKeyRoot$74072[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 ?SubtractRootFromScale@@YGKEK@Z ; SubtractRootFromScale
  002bc	89 45 d4	 mov	 DWORD PTR _dwScalePattern$74070[ebp], eax

; 11271:             if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT || !dwChordPattern)

  002bf	0f b6 4d 14	 movzx	 ecx, BYTE PTR _bPlayMode$[ebp]
  002c3	83 f9 05	 cmp	 ecx, 5
  002c6	74 06		 je	 SHORT $L74084
  002c8	83 7d e8 00	 cmp	 DWORD PTR _dwChordPattern$74071[ebp], 0
  002cc	75 16		 jne	 SHORT $L74083
$L74084:

; 11272:             {
; 11273:                 bChordRoot = bKeyRoot;

  002ce	8a 55 db	 mov	 dl, BYTE PTR _bKeyRoot$74072[ebp]
  002d1	88 55 ee	 mov	 BYTE PTR _bChordRoot$74073[ebp], dl

; 11274:                 dwChordPattern = ChordFromScale(0,dwScalePattern);

  002d4	8b 45 d4	 mov	 eax, DWORD PTR _dwScalePattern$74070[ebp]
  002d7	50		 push	 eax
  002d8	6a 00		 push	 0
  002da	e8 00 00 00 00	 call	 ?ChordFromScale@@YGKEK@Z ; ChordFromScale
  002df	89 45 e8	 mov	 DWORD PTR _dwChordPattern$74071[ebp], eax

; 11275:             }
; 11276:             else

  002e2	eb 5c		 jmp	 SHORT $L74085
$L74083:

; 11277:             {
; 11278:                 dwChordPattern = InvertChord(bKeyRoot, bChordRoot, dwChordPattern, fBelowRoot);

  002e4	8d 4d ed	 lea	 ecx, DWORD PTR _fBelowRoot$74069[ebp]
  002e7	51		 push	 ecx
  002e8	8b 55 e8	 mov	 edx, DWORD PTR _dwChordPattern$74071[ebp]
  002eb	52		 push	 edx
  002ec	8a 45 ee	 mov	 al, BYTE PTR _bChordRoot$74073[ebp]
  002ef	50		 push	 eax
  002f0	8a 4d db	 mov	 cl, BYTE PTR _bKeyRoot$74072[ebp]
  002f3	51		 push	 ecx
  002f4	e8 00 00 00 00	 call	 ?InvertChord@@YGKEEKAA_N@Z ; InvertChord
  002f9	89 45 e8	 mov	 DWORD PTR _dwChordPattern$74071[ebp], eax

; 11279:                 BYTE bNewChordRoot = 0;

  002fc	c6 45 cb 00	 mov	 BYTE PTR _bNewChordRoot$74086[ebp], 0

; 11280:                 if (dwChordPattern)

  00300	83 7d e8 00	 cmp	 DWORD PTR _dwChordPattern$74071[ebp], 0
  00304	74 21		 je	 SHORT $L74087

; 11281:                 {
; 11282:                     for (; !(dwChordPattern & (1 << bNewChordRoot)); bNewChordRoot++);

  00306	eb 09		 jmp	 SHORT $L74088
$L74089:
  00308	8a 55 cb	 mov	 dl, BYTE PTR _bNewChordRoot$74086[ebp]
  0030b	80 c2 01	 add	 dl, 1
  0030e	88 55 cb	 mov	 BYTE PTR _bNewChordRoot$74086[ebp], dl
$L74088:
  00311	0f b6 4d cb	 movzx	 ecx, BYTE PTR _bNewChordRoot$74086[ebp]
  00315	b8 01 00 00 00	 mov	 eax, 1
  0031a	d3 e0		 shl	 eax, cl
  0031c	8b 4d e8	 mov	 ecx, DWORD PTR _dwChordPattern$74071[ebp]
  0031f	23 c8		 and	 ecx, eax
  00321	85 c9		 test	 ecx, ecx
  00323	75 02		 jne	 SHORT $L74087
  00325	eb e1		 jmp	 SHORT $L74089
$L74087:

; 11283:                 }
; 11284:                 bChordRoot = bNewChordRoot + bKeyRoot;

  00327	0f b6 55 cb	 movzx	 edx, BYTE PTR _bNewChordRoot$74086[ebp]
  0032b	0f b6 45 db	 movzx	 eax, BYTE PTR _bKeyRoot$74072[ebp]
  0032f	03 d0		 add	 edx, eax
  00331	88 55 ee	 mov	 BYTE PTR _bChordRoot$74073[ebp], dl

; 11285:                 dwChordPattern >>= bNewChordRoot;

  00334	0f b6 4d cb	 movzx	 ecx, BYTE PTR _bNewChordRoot$74086[ebp]
  00338	8b 55 e8	 mov	 edx, DWORD PTR _dwChordPattern$74071[ebp]
  0033b	d3 ea		 shr	 edx, cl
  0033d	89 55 e8	 mov	 DWORD PTR _dwChordPattern$74071[ebp], edx
$L74085:

; 11286:             }
; 11287:         }
; 11288:         else if (bPlayMode == DMUS_PLAYMODE_MELODIC)

  00340	eb 39		 jmp	 SHORT $L74091
$L74074:
  00342	0f b6 45 14	 movzx	 eax, BYTE PTR _bPlayMode$[ebp]
  00346	83 f8 06	 cmp	 eax, 6
  00349	75 16		 jne	 SHORT $L74092

; 11289:         {
; 11290:             bKeyRoot = 0;

  0034b	c6 45 db 00	 mov	 BYTE PTR _bKeyRoot$74072[ebp], 0

; 11291:             dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);

  0034f	8b 4d d4	 mov	 ecx, DWORD PTR _dwScalePattern$74070[ebp]
  00352	51		 push	 ecx
  00353	8a 55 ee	 mov	 dl, BYTE PTR _bChordRoot$74073[ebp]
  00356	52		 push	 edx
  00357	e8 00 00 00 00	 call	 ?ChordFromScale@@YGKEK@Z ; ChordFromScale
  0035c	89 45 e8	 mov	 DWORD PTR _dwChordPattern$74071[ebp], eax

; 11292:         }
; 11293:         else

  0035f	eb 1a		 jmp	 SHORT $L74091
$L74092:

; 11294:         {
; 11295:             bKeyRoot = 0;

  00361	c6 45 db 00	 mov	 BYTE PTR _bKeyRoot$74072[ebp], 0

; 11296:             if (!dwChordPattern) 

  00365	83 7d e8 00	 cmp	 DWORD PTR _dwChordPattern$74071[ebp], 0
  00369	75 10		 jne	 SHORT $L74091

; 11297:             {
; 11298:                 dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);

  0036b	8b 45 d4	 mov	 eax, DWORD PTR _dwScalePattern$74070[ebp]
  0036e	50		 push	 eax
  0036f	8a 4d ee	 mov	 cl, BYTE PTR _bChordRoot$74073[ebp]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?ChordFromScale@@YGKEK@Z ; ChordFromScale
  00378	89 45 e8	 mov	 DWORD PTR _dwChordPattern$74071[ebp], eax
$L74091:

; 11299:             }
; 11300:         }
; 11301:         BOOL fDropOctave = FALSE;

  0037b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fDropOctave$74095[ebp], 0

; 11302:         if (bMIDIValue < 24)

  00382	0f b6 55 0c	 movzx	 edx, BYTE PTR _bMIDIValue$[ebp]
  00386	83 fa 18	 cmp	 edx, 24			; 00000018H
  00389	7d 11		 jge	 SHORT $L74096

; 11303:         {
; 11304:             fDropOctave = TRUE;

  0038b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _fDropOctave$74095[ebp], 1

; 11305:             bMIDIValue += 24;

  00392	0f b6 45 0c	 movzx	 eax, BYTE PTR _bMIDIValue$[ebp]
  00396	83 c0 18	 add	 eax, 24			; 00000018H
  00399	88 45 0c	 mov	 BYTE PTR _bMIDIValue$[ebp], al
$L74096:

; 11306:         }
; 11307:         WORD wNewMusicValue = OldNoteToMusicValue( bMIDIValue, 
; 11308:             dwScalePattern,
; 11309:             bKeyRoot, 
; 11310:             dwChordPattern, 
; 11311:             bChordRoot );

  0039c	8a 4d ee	 mov	 cl, BYTE PTR _bChordRoot$74073[ebp]
  0039f	51		 push	 ecx
  003a0	8b 55 e8	 mov	 edx, DWORD PTR _dwChordPattern$74071[ebp]
  003a3	52		 push	 edx
  003a4	8a 45 db	 mov	 al, BYTE PTR _bKeyRoot$74072[ebp]
  003a7	50		 push	 eax
  003a8	8b 4d d4	 mov	 ecx, DWORD PTR _dwScalePattern$74070[ebp]
  003ab	51		 push	 ecx
  003ac	8a 55 0c	 mov	 dl, BYTE PTR _bMIDIValue$[ebp]
  003af	52		 push	 edx
  003b0	e8 00 00 00 00	 call	 ?OldNoteToMusicValue@@YGGEJDJD@Z ; OldNoteToMusicValue
  003b5	66 89 45 e0	 mov	 WORD PTR _wNewMusicValue$74097[ebp], ax

; 11312:         if (fDropOctave)

  003b9	83 7d f0 00	 cmp	 DWORD PTR _fDropOctave$74095[ebp], 0
  003bd	74 17		 je	 SHORT $L74098

; 11313:         {
; 11314:             wNewMusicValue -= 0x2000;

  003bf	0f b7 45 e0	 movzx	 eax, WORD PTR _wNewMusicValue$74097[ebp]
  003c3	2d 00 20 00 00	 sub	 eax, 8192		; 00002000H
  003c8	66 89 45 e0	 mov	 WORD PTR _wNewMusicValue$74097[ebp], ax

; 11315:             bMIDIValue -= 24;

  003cc	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  003d0	83 e9 18	 sub	 ecx, 24			; 00000018H
  003d3	88 4d 0c	 mov	 BYTE PTR _bMIDIValue$[ebp], cl
$L74098:

; 11316:         }
; 11317: 
; 11318:         // If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
; 11319:         // // also take the result up for the new pedalpoint chord modes.
; 11320:         if( (bPlayMode & DMUS_PLAYMODE_CHORD_ROOT)  ||
; 11321:             fBelowRoot)

  003d6	0f b6 55 14	 movzx	 edx, BYTE PTR _bPlayMode$[ebp]
  003da	83 e2 02	 and	 edx, 2
  003dd	85 d2		 test	 edx, edx
  003df	75 08		 jne	 SHORT $L74100
  003e1	0f b6 45 ed	 movzx	 eax, BYTE PTR _fBelowRoot$74069[ebp]
  003e5	85 c0		 test	 eax, eax
  003e7	74 0e		 je	 SHORT $L74099
$L74100:

; 11322:             //((bPlayMode & DMUS_PLAYMODE_KEY_ROOT) && bPlayMode != DMUS_PLAYMODE_PEDALPOINT) )
; 11323:         {
; 11324:             wNewMusicValue += 0x1000;

  003e9	0f b7 4d e0	 movzx	 ecx, WORD PTR _wNewMusicValue$74097[ebp]
  003ed	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  003f3	66 89 4d e0	 mov	 WORD PTR _wNewMusicValue$74097[ebp], cx
$L74099:

; 11325:         }
; 11326:         short nTest = 
; 11327:             MusicValueConvert(wNewMusicValue, bPlayMode, 
; 11328:                 pSubChord, pChord->bKey);

  003f7	8b 55 10	 mov	 edx, DWORD PTR _pChord$[ebp]
  003fa	8a 82 c8 00 00
	00		 mov	 al, BYTE PTR [edx+200]
  00400	50		 push	 eax
  00401	8b 4d d0	 mov	 ecx, DWORD PTR _pSubChord$74042[ebp]
  00404	51		 push	 ecx
  00405	8a 55 14	 mov	 dl, BYTE PTR _bPlayMode$[ebp]
  00408	52		 push	 edx
  00409	66 8b 45 e0	 mov	 ax, WORD PTR _wNewMusicValue$74097[ebp]
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 ?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ; MusicValueConvert
  00413	66 89 45 e4	 mov	 WORD PTR _nTest$74101[ebp], ax

; 11329:         
; 11330:         if (nTest == (short) bMIDIValue)

  00417	0f bf 4d e4	 movsx	 ecx, WORD PTR _nTest$74101[ebp]
  0041b	0f b6 55 0c	 movzx	 edx, BYTE PTR _bMIDIValue$[ebp]
  0041f	3b ca		 cmp	 ecx, edx
  00421	75 0f		 jne	 SHORT $L74103

; 11331:         {
; 11332:             *pwMusicValue = wNewMusicValue;

  00423	8b 45 1c	 mov	 eax, DWORD PTR _pwMusicValue$[ebp]
  00426	66 8b 4d e0	 mov	 cx, WORD PTR _wNewMusicValue$74097[ebp]
  0042a	66 89 08	 mov	 WORD PTR [eax], cx

; 11333:         }
; 11334:         else

  0042d	e9 9d 00 00 00	 jmp	 $L74020
$L74103:

; 11335:         {
; 11336:             if (nTest == S_OVER_CHORD)

  00432	0f bf 55 e4	 movsx	 edx, WORD PTR _nTest$74101[ebp]
  00436	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0043c	75 6d		 jne	 SHORT $L74105

; 11337:             {
; 11338:                 if (BitCount(pSubChord->dwChordPattern) < 4)

  0043e	8b 45 d0	 mov	 eax, DWORD PTR _pSubChord$74042[ebp]
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	51		 push	 ecx
  00444	e8 00 00 00 00	 call	 ?BitCount@@YGKK@Z	; BitCount
  00449	83 f8 04	 cmp	 eax, 4
  0044c	73 5d		 jae	 SHORT $L74105

; 11339:                 {
; 11340:                     DWORD dwOldChordPattern = pSubChord->dwChordPattern;

  0044e	8b 55 d0	 mov	 edx, DWORD PTR _pSubChord$74042[ebp]
  00451	8b 02		 mov	 eax, DWORD PTR [edx]
  00453	89 45 c4	 mov	 DWORD PTR _dwOldChordPattern$74107[ebp], eax

; 11341:                     pSubChord->dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);

  00456	8b 4d d4	 mov	 ecx, DWORD PTR _dwScalePattern$74070[ebp]
  00459	51		 push	 ecx
  0045a	8a 55 ee	 mov	 dl, BYTE PTR _bChordRoot$74073[ebp]
  0045d	52		 push	 edx
  0045e	e8 00 00 00 00	 call	 ?ChordFromScale@@YGKEK@Z ; ChordFromScale
  00463	8b 4d d0	 mov	 ecx, DWORD PTR _pSubChord$74042[ebp]
  00466	89 01		 mov	 DWORD PTR [ecx], eax

; 11342:                     nTest = 
; 11343:                         MusicValueConvert(wNewMusicValue, bPlayMode, 
; 11344:                             pSubChord, pChord->bKey);

  00468	8b 55 10	 mov	 edx, DWORD PTR _pChord$[ebp]
  0046b	8a 82 c8 00 00
	00		 mov	 al, BYTE PTR [edx+200]
  00471	50		 push	 eax
  00472	8b 4d d0	 mov	 ecx, DWORD PTR _pSubChord$74042[ebp]
  00475	51		 push	 ecx
  00476	8a 55 14	 mov	 dl, BYTE PTR _bPlayMode$[ebp]
  00479	52		 push	 edx
  0047a	66 8b 45 e0	 mov	 ax, WORD PTR _wNewMusicValue$74097[ebp]
  0047e	50		 push	 eax
  0047f	e8 00 00 00 00	 call	 ?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ; MusicValueConvert
  00484	66 89 45 e4	 mov	 WORD PTR _nTest$74101[ebp], ax

; 11345:                     pSubChord->dwChordPattern = dwOldChordPattern;

  00488	8b 4d d0	 mov	 ecx, DWORD PTR _pSubChord$74042[ebp]
  0048b	8b 55 c4	 mov	 edx, DWORD PTR _dwOldChordPattern$74107[ebp]
  0048e	89 11		 mov	 DWORD PTR [ecx], edx

; 11346:                     if (nTest == (short) bMIDIValue)

  00490	0f bf 45 e4	 movsx	 eax, WORD PTR _nTest$74101[ebp]
  00494	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bMIDIValue$[ebp]
  00498	3b c1		 cmp	 eax, ecx
  0049a	75 0f		 jne	 SHORT $L74105

; 11347:                     {
; 11348:                         *pwMusicValue = wNewMusicValue;

  0049c	8b 55 1c	 mov	 edx, DWORD PTR _pwMusicValue$[ebp]
  0049f	66 8b 45 e0	 mov	 ax, WORD PTR _wNewMusicValue$74097[ebp]
  004a3	66 89 02	 mov	 WORD PTR [edx], ax

; 11349:                         return hr;

  004a6	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  004a9	eb 27		 jmp	 SHORT $L74002
$L74105:

; 11350:                     }
; 11351:                 }
; 11352:             }
; 11353:             *pwMusicValue = wNewMusicValue;

  004ab	8b 4d 1c	 mov	 ecx, DWORD PTR _pwMusicValue$[ebp]
  004ae	66 8b 55 e0	 mov	 dx, WORD PTR _wNewMusicValue$74097[ebp]
  004b2	66 89 11	 mov	 WORD PTR [ecx], dx

; 11354: #ifdef DBG // Put in brackets just in case the compiler is using something different than DBG for turning on Trace.
; 11355:             Trace(1,"Error: Unable to convert MIDI value %ld to Music value. This usually means the DMUS_CHORD_KEY structure has an invalid chord or scale pattern.\n",
; 11356:                 lMIDIInTraceValue);

  004b5	8b 45 fc	 mov	 eax, DWORD PTR _lMIDIInTraceValue$[ebp]
  004b8	50		 push	 eax
  004b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0JA@CPGAIEHN@Error?3?5Unable?5to?5convert?5MIDI?5va@
  004be	6a 01		 push	 1
  004c0	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  004c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11357: #endif
; 11358:             return DMUS_E_CANNOT_CONVERT;

  004c8	b8 07 12 78 88	 mov	 eax, -2005396985	; 88781207H
  004cd	eb 03		 jmp	 SHORT $L74002
$L74020:

; 11359:         }
; 11360:     }
; 11361:     return hr;

  004cf	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L74002:

; 11362: }

  004d2	5e		 pop	 esi
  004d3	8b e5		 mov	 esp, ebp
  004d5	5d		 pop	 ebp
  004d6	c2 18 00	 ret	 24			; 00000018H
?MIDIToMusic@CPerformance@@UAGJEPAU_DMUS_CHORD_KEY@@EEPAG@Z ENDP ; CPerformance::MIDIToMusic
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SubtractRootFromScale@@YGKEK@Z
_TEXT	SEGMENT
_bScaleRoot$ = 8
_dwScalePattern$ = 12
?SubtractRootFromScale@@YGKEK@Z PROC NEAR		; SubtractRootFromScale, COMDAT

; 10687: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10688:     dwScalePattern = CleanupScale(dwScalePattern);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  0000c	89 45 0c	 mov	 DWORD PTR _dwScalePattern$[ebp], eax

; 10689:     dwScalePattern >>= (bScaleRoot % 12);

  0000f	0f b6 45 08	 movzx	 eax, BYTE PTR _bScaleRoot$[ebp]
  00013	99		 cdq
  00014	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00019	f7 f9		 idiv	 ecx
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]
  0001e	8b ca		 mov	 ecx, edx
  00020	d3 e8		 shr	 eax, cl
  00022	89 45 0c	 mov	 DWORD PTR _dwScalePattern$[ebp], eax

; 10690:     dwScalePattern = CleanupScale(dwScalePattern);

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _dwScalePattern$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  0002e	89 45 0c	 mov	 DWORD PTR _dwScalePattern$[ebp], eax

; 10691:     return dwScalePattern;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]

; 10692: }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?SubtractRootFromScale@@YGKEK@Z ENDP			; SubtractRootFromScale
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ChordFromScale@@YGKEK@Z
_TEXT	SEGMENT
_dwBit$73794 = -16
_dwChordPattern$ = -12
_dwBitCount$ = -8
_dwX$ = -4
_bRoot$ = 8
_dwScalePattern$ = 12
?ChordFromScale@@YGKEK@Z PROC NEAR			; ChordFromScale, COMDAT

; 10696: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 10697:     DWORD dwChordPattern = CleanupScale(dwScalePattern >> (bRoot % 12));

  00006	0f b6 45 08	 movzx	 eax, BYTE PTR _bRoot$[ebp]
  0000a	99		 cdq
  0000b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00010	f7 f9		 idiv	 ecx
  00012	8b 45 0c	 mov	 eax, DWORD PTR _dwScalePattern$[ebp]
  00015	8b ca		 mov	 ecx, edx
  00017	d3 e8		 shr	 eax, cl
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  0001f	89 45 f4	 mov	 DWORD PTR _dwChordPattern$[ebp], eax

; 10698:     DWORD dwX;
; 10699:     DWORD dwBitCount = 0;

  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwBitCount$[ebp], 0

; 10700:     for (dwX = 0; dwX < 24; dwX++)

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwX$[ebp], 0
  00030	eb 09		 jmp	 SHORT $L73791
$L73792:
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _dwX$[ebp]
  00035	83 c1 01	 add	 ecx, 1
  00038	89 4d fc	 mov	 DWORD PTR _dwX$[ebp], ecx
$L73791:
  0003b	83 7d fc 18	 cmp	 DWORD PTR _dwX$[ebp], 24 ; 00000018H
  0003f	73 3f		 jae	 SHORT $L73793

; 10701:     {
; 10702:         DWORD dwBit = 1 << dwX;

  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _dwX$[ebp]
  00049	d3 e2		 shl	 edx, cl
  0004b	89 55 f0	 mov	 DWORD PTR _dwBit$73794[ebp], edx

; 10703:         if (dwChordPattern & dwBit)

  0004e	8b 45 f4	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00051	23 45 f0	 and	 eax, DWORD PTR _dwBit$73794[ebp]
  00054	85 c0		 test	 eax, eax
  00056	74 26		 je	 SHORT $L73795

; 10704:         {
; 10705:             if ((dwBitCount & 1) || (dwBitCount > 7))

  00058	8b 4d f8	 mov	 ecx, DWORD PTR _dwBitCount$[ebp]
  0005b	83 e1 01	 and	 ecx, 1
  0005e	85 c9		 test	 ecx, ecx
  00060	75 06		 jne	 SHORT $L73797
  00062	83 7d f8 07	 cmp	 DWORD PTR _dwBitCount$[ebp], 7
  00066	76 0d		 jbe	 SHORT $L73796
$L73797:

; 10706:             {
; 10707:                 dwChordPattern &= ~dwBit;

  00068	8b 55 f0	 mov	 edx, DWORD PTR _dwBit$73794[ebp]
  0006b	f7 d2		 not	 edx
  0006d	8b 45 f4	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]
  00070	23 c2		 and	 eax, edx
  00072	89 45 f4	 mov	 DWORD PTR _dwChordPattern$[ebp], eax
$L73796:

; 10708:             }
; 10709:             dwBitCount++;

  00075	8b 4d f8	 mov	 ecx, DWORD PTR _dwBitCount$[ebp]
  00078	83 c1 01	 add	 ecx, 1
  0007b	89 4d f8	 mov	 DWORD PTR _dwBitCount$[ebp], ecx
$L73795:

; 10710:         }
; 10711:     }

  0007e	eb b2		 jmp	 SHORT $L73792
$L73793:

; 10712:     return dwChordPattern;

  00080	8b 45 f4	 mov	 eax, DWORD PTR _dwChordPattern$[ebp]

; 10713: }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?ChordFromScale@@YGKEK@Z ENDP				; ChordFromScale
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OldNoteToMusicValue@@YGGEJDJD@Z
_TEXT	SEGMENT
_chordpart$ = -21
_testb$ = -20
_scan$ = -15
_test$ = -14
_octpart$ = -13
_testa$ = -12
_pattern$ = -8
_keypart$ = -4
_base$ = -3
_last$ = -2
_accpart$ = -1
_note$ = 8
_keypattern$ = 12
_keyroot$ = 16
_chordpattern$ = 20
_chordroot$ = 24
?OldNoteToMusicValue@@YGGEJDJD@Z PROC NEAR		; OldNoteToMusicValue, COMDAT

; 10856: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 10857:     unsigned char   octpart = 0 ;

  00006	c6 45 f3 00	 mov	 BYTE PTR _octpart$[ebp], 0

; 10858:     unsigned char   chordpart = 0;

  0000a	c6 45 eb 00	 mov	 BYTE PTR _chordpart$[ebp], 0

; 10859:     unsigned char   keypart = (BYTE)-1 ;       

  0000e	c6 45 fc ff	 mov	 BYTE PTR _keypart$[ebp], 255 ; 000000ffH

; 10860:     unsigned char   accpart = 0 ;

  00012	c6 45 ff 00	 mov	 BYTE PTR _accpart$[ebp], 0

; 10861:     unsigned char   scan, test, base, last ;    // was char
; 10862:     long            pattern ;
; 10863:     short           testa, testb ;
; 10864: 
; 10865: 
; 10866:     scan = chordroot ;

  00016	8a 45 18	 mov	 al, BYTE PTR _chordroot$[ebp]
  00019	88 45 f1	 mov	 BYTE PTR _scan$[ebp], al

; 10867: 
; 10868:     // If we're trying to play a note below the bottom of our chord, forget it
; 10869:     if( note < scan)

  0001c	0f b6 4d 08	 movzx	 ecx, BYTE PTR _note$[ebp]
  00020	0f b6 55 f1	 movzx	 edx, BYTE PTR _scan$[ebp]
  00024	3b ca		 cmp	 ecx, edx
  00026	7d 08		 jge	 SHORT $L73878

; 10870:     {
; 10871:         return 0;

  00028	66 33 c0	 xor	 ax, ax
  0002b	e9 0b 03 00 00	 jmp	 $L73863
$L73878:

; 10872:     }
; 10873: 
; 10874:     while( scan < (note - 24) )

  00030	0f b6 45 f1	 movzx	 eax, BYTE PTR _scan$[ebp]
  00034	0f b6 4d 08	 movzx	 ecx, BYTE PTR _note$[ebp]
  00038	83 e9 18	 sub	 ecx, 24			; 00000018H
  0003b	3b c1		 cmp	 eax, ecx
  0003d	7d 14		 jge	 SHORT $L73879

; 10875:     {
; 10876:         scan += 12 ;

  0003f	0f b6 55 f1	 movzx	 edx, BYTE PTR _scan$[ebp]
  00043	83 c2 0c	 add	 edx, 12			; 0000000cH
  00046	88 55 f1	 mov	 BYTE PTR _scan$[ebp], dl

; 10877:         octpart++ ;

  00049	8a 45 f3	 mov	 al, BYTE PTR _octpart$[ebp]
  0004c	04 01		 add	 al, 1
  0004e	88 45 f3	 mov	 BYTE PTR _octpart$[ebp], al

; 10878:     }

  00051	eb dd		 jmp	 SHORT $L73878
$L73879:

; 10879: 
; 10880:     base = last = scan ;

  00053	8a 4d f1	 mov	 cl, BYTE PTR _scan$[ebp]
  00056	88 4d fe	 mov	 BYTE PTR _last$[ebp], cl
  00059	8a 55 fe	 mov	 dl, BYTE PTR _last$[ebp]
  0005c	88 55 fd	 mov	 BYTE PTR _base$[ebp], dl

; 10881: 
; 10882:     for( ;  base<=note ;  base+=12 )

  0005f	eb 0a		 jmp	 SHORT $L73880
$L73881:
  00061	0f b6 45 fd	 movzx	 eax, BYTE PTR _base$[ebp]
  00065	83 c0 0c	 add	 eax, 12			; 0000000cH
  00068	88 45 fd	 mov	 BYTE PTR _base$[ebp], al
$L73880:
  0006b	0f b6 4d fd	 movzx	 ecx, BYTE PTR _base$[ebp]
  0006f	0f b6 55 08	 movzx	 edx, BYTE PTR _note$[ebp]
  00073	3b ca		 cmp	 ecx, edx
  00075	0f 8f fc 00 00
	00		 jg	 $L73882

; 10883:     {
; 10884:         chordpart = (unsigned char)-1 ;

  0007b	c6 45 eb ff	 mov	 BYTE PTR _chordpart$[ebp], 255 ; 000000ffH

; 10885:         pattern   = chordpattern ;

  0007f	8b 45 14	 mov	 eax, DWORD PTR _chordpattern$[ebp]
  00082	89 45 f8	 mov	 DWORD PTR _pattern$[ebp], eax

; 10886:         scan      = last = base ;

  00085	8a 4d fd	 mov	 cl, BYTE PTR _base$[ebp]
  00088	88 4d fe	 mov	 BYTE PTR _last$[ebp], cl
  0008b	8a 55 fe	 mov	 dl, BYTE PTR _last$[ebp]
  0008e	88 55 f1	 mov	 BYTE PTR _scan$[ebp], dl

; 10887:         if( scan == note )

  00091	0f b6 45 f1	 movzx	 eax, BYTE PTR _scan$[ebp]
  00095	0f b6 4d 08	 movzx	 ecx, BYTE PTR _note$[ebp]
  00099	3b c1		 cmp	 eax, ecx
  0009b	75 3e		 jne	 SHORT $L73884

; 10888:         {
; 10889:             accpart = 0;

  0009d	c6 45 ff 00	 mov	 BYTE PTR _accpart$[ebp], 0
$L73886:

; 10890:             while (!(pattern & 1) && pattern)

  000a1	8b 55 f8	 mov	 edx, DWORD PTR _pattern$[ebp]
  000a4	83 e2 01	 and	 edx, 1
  000a7	85 d2		 test	 edx, edx
  000a9	75 18		 jne	 SHORT $L73887
  000ab	83 7d f8 00	 cmp	 DWORD PTR _pattern$[ebp], 0
  000af	74 12		 je	 SHORT $L73887

; 10891:             {
; 10892:                 accpart--;

  000b1	8a 45 ff	 mov	 al, BYTE PTR _accpart$[ebp]
  000b4	2c 01		 sub	 al, 1
  000b6	88 45 ff	 mov	 BYTE PTR _accpart$[ebp], al

; 10893:                 pattern >>= 1;

  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _pattern$[ebp]
  000bc	d1 f9		 sar	 ecx, 1
  000be	89 4d f8	 mov	 DWORD PTR _pattern$[ebp], ecx

; 10894:             }

  000c1	eb de		 jmp	 SHORT $L73886
$L73887:

; 10895:             return( (unsigned short) (octpart << 12) + (accpart & 0xF)) ;           // if octave, return.

  000c3	0f b6 55 f3	 movzx	 edx, BYTE PTR _octpart$[ebp]
  000c7	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  000ca	0f b7 c2	 movzx	 eax, dx
  000cd	0f b6 4d ff	 movzx	 ecx, BYTE PTR _accpart$[ebp]
  000d1	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000d4	03 c1		 add	 eax, ecx
  000d6	e9 60 02 00 00	 jmp	 $L73863
$L73884:

; 10896:         }
; 10897:         for( ;  pattern ;  pattern=pattern >> 1 )

  000db	eb 08		 jmp	 SHORT $L73889
$L73890:
  000dd	8b 55 f8	 mov	 edx, DWORD PTR _pattern$[ebp]
  000e0	d1 fa		 sar	 edx, 1
  000e2	89 55 f8	 mov	 DWORD PTR _pattern$[ebp], edx
$L73889:
  000e5	83 7d f8 00	 cmp	 DWORD PTR _pattern$[ebp], 0
  000e9	74 61		 je	 SHORT $L73891

; 10898:         {
; 10899:             if( pattern & 1 )                   // chord interval?

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _pattern$[ebp]
  000ee	83 e0 01	 and	 eax, 1
  000f1	85 c0		 test	 eax, eax
  000f3	74 4c		 je	 SHORT $L73892

; 10900:             {                 
; 10901:                 if( scan == note )              // note in chord?

  000f5	0f b6 4d f1	 movzx	 ecx, BYTE PTR _scan$[ebp]
  000f9	0f b6 55 08	 movzx	 edx, BYTE PTR _note$[ebp]
  000fd	3b ca		 cmp	 ecx, edx
  000ff	75 1d		 jne	 SHORT $L73893

; 10902:                 {            
; 10903:                     chordpart++ ;

  00101	8a 45 eb	 mov	 al, BYTE PTR _chordpart$[ebp]
  00104	04 01		 add	 al, 1
  00106	88 45 eb	 mov	 BYTE PTR _chordpart$[ebp], al

; 10904:                     return((unsigned short) ((octpart << 12) | (chordpart << 8))) ; // yes, return.

  00109	0f b6 45 f3	 movzx	 eax, BYTE PTR _octpart$[ebp]
  0010d	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00110	0f b6 4d eb	 movzx	 ecx, BYTE PTR _chordpart$[ebp]
  00114	c1 e1 08	 shl	 ecx, 8
  00117	0b c1		 or	 eax, ecx
  00119	e9 1d 02 00 00	 jmp	 $L73863
$L73893:

; 10905:                 }
; 10906:                 else if (scan > note)           // above note?

  0011e	0f b6 55 f1	 movzx	 edx, BYTE PTR _scan$[ebp]
  00122	0f b6 45 08	 movzx	 eax, BYTE PTR _note$[ebp]
  00126	3b d0		 cmp	 edx, eax
  00128	7e 08		 jle	 SHORT $L73895

; 10907:                 {         
; 10908:                     test = scan ;

  0012a	8a 4d f1	 mov	 cl, BYTE PTR _scan$[ebp]
  0012d	88 4d f2	 mov	 BYTE PTR _test$[ebp], cl

; 10909:                     break ;                     // go on to key.

  00130	eb 1a		 jmp	 SHORT $L73891
$L73895:

; 10910:                 }
; 10911:                 chordpart++ ;

  00132	8a 55 eb	 mov	 dl, BYTE PTR _chordpart$[ebp]
  00135	80 c2 01	 add	 dl, 1
  00138	88 55 eb	 mov	 BYTE PTR _chordpart$[ebp], dl

; 10912:                 last = scan ;

  0013b	8a 45 f1	 mov	 al, BYTE PTR _scan$[ebp]
  0013e	88 45 fe	 mov	 BYTE PTR _last$[ebp], al
$L73892:

; 10913:             }
; 10914:             scan++ ;

  00141	8a 4d f1	 mov	 cl, BYTE PTR _scan$[ebp]
  00144	80 c1 01	 add	 cl, 1
  00147	88 4d f1	 mov	 BYTE PTR _scan$[ebp], cl

; 10915:         }

  0014a	eb 91		 jmp	 SHORT $L73890
$L73891:

; 10916:         if( !pattern )                          // end of chord.

  0014c	83 7d f8 00	 cmp	 DWORD PTR _pattern$[ebp], 0
  00150	75 0a		 jne	 SHORT $L73897

; 10917:         {                        
; 10918:             test = unsigned char(base + 12) ;                  // set to next note.

  00152	0f b6 55 fd	 movzx	 edx, BYTE PTR _base$[ebp]
  00156	83 c2 0c	 add	 edx, 12			; 0000000cH
  00159	88 55 f2	 mov	 BYTE PTR _test$[ebp], dl
$L73897:

; 10919:         }
; 10920:         octpart++ ;

  0015c	8a 45 f3	 mov	 al, BYTE PTR _octpart$[ebp]
  0015f	04 01		 add	 al, 1
  00161	88 45 f3	 mov	 BYTE PTR _octpart$[ebp], al

; 10921:         if( test > note )

  00164	0f b6 4d f2	 movzx	 ecx, BYTE PTR _test$[ebp]
  00168	0f b6 55 08	 movzx	 edx, BYTE PTR _note$[ebp]
  0016c	3b ca		 cmp	 ecx, edx
  0016e	7e 02		 jle	 SHORT $L73898

; 10922:         {
; 10923:             break ;                             // above our note?

  00170	eb 05		 jmp	 SHORT $L73882
$L73898:

; 10924:         }
; 10925:     }

  00172	e9 ea fe ff ff	 jmp	 $L73881
$L73882:

; 10926: 
; 10927:     octpart-- ;

  00177	8a 45 f3	 mov	 al, BYTE PTR _octpart$[ebp]
  0017a	2c 01		 sub	 al, 1
  0017c	88 45 f3	 mov	 BYTE PTR _octpart$[ebp], al

; 10928: 
; 10929: //  To get here, the note is not in the chord.  Scan should show the last
; 10930: //  note in the chord.  octpart and chordpart have their final values.
; 10931: //  Now, increment up the key to find the match.
; 10932: 
; 10933:     scan        = last ;

  0017f	8a 4d fe	 mov	 cl, BYTE PTR _last$[ebp]
  00182	88 4d f1	 mov	 BYTE PTR _scan$[ebp], cl

; 10934:     pattern     = CleanupScale(keypattern);

  00185	8b 55 0c	 mov	 edx, DWORD PTR _keypattern$[ebp]
  00188	52		 push	 edx
  00189	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  0018e	89 45 f8	 mov	 DWORD PTR _pattern$[ebp], eax

; 10935:     pattern     = pattern >> ((scan - keyroot) % 12) ;

  00191	0f b6 45 f1	 movzx	 eax, BYTE PTR _scan$[ebp]
  00195	0f be 4d 10	 movsx	 ecx, BYTE PTR _keyroot$[ebp]
  00199	2b c1		 sub	 eax, ecx
  0019b	99		 cdq
  0019c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  001a1	f7 f9		 idiv	 ecx
  001a3	8b 45 f8	 mov	 eax, DWORD PTR _pattern$[ebp]
  001a6	8b ca		 mov	 ecx, edx
  001a8	d3 f8		 sar	 eax, cl
  001aa	89 45 f8	 mov	 DWORD PTR _pattern$[ebp], eax

; 10936: 
; 10937:     for( ;  pattern ;  pattern=pattern >> 1 )

  001ad	eb 08		 jmp	 SHORT $L73899
$L73900:
  001af	8b 4d f8	 mov	 ecx, DWORD PTR _pattern$[ebp]
  001b2	d1 f9		 sar	 ecx, 1
  001b4	89 4d f8	 mov	 DWORD PTR _pattern$[ebp], ecx
$L73899:
  001b7	83 7d f8 00	 cmp	 DWORD PTR _pattern$[ebp], 0
  001bb	74 3a		 je	 SHORT $L73901

; 10938:     {
; 10939:         if( 1 & pattern )

  001bd	8b 55 f8	 mov	 edx, DWORD PTR _pattern$[ebp]
  001c0	83 e2 01	 and	 edx, 1
  001c3	85 d2		 test	 edx, edx
  001c5	74 0e		 je	 SHORT $L73902

; 10940:         {
; 10941:             keypart++ ;

  001c7	8a 45 fc	 mov	 al, BYTE PTR _keypart$[ebp]
  001ca	04 01		 add	 al, 1
  001cc	88 45 fc	 mov	 BYTE PTR _keypart$[ebp], al

; 10942:             accpart = 0 ;

  001cf	c6 45 ff 00	 mov	 BYTE PTR _accpart$[ebp], 0

; 10943:         }
; 10944:         else

  001d3	eb 09		 jmp	 SHORT $L73903
$L73902:

; 10945:         {
; 10946:             accpart++ ;

  001d5	8a 4d ff	 mov	 cl, BYTE PTR _accpart$[ebp]
  001d8	80 c1 01	 add	 cl, 1
  001db	88 4d ff	 mov	 BYTE PTR _accpart$[ebp], cl
$L73903:

; 10947:         }
; 10948:         if( scan == note )

  001de	0f b6 55 f1	 movzx	 edx, BYTE PTR _scan$[ebp]
  001e2	0f b6 45 08	 movzx	 eax, BYTE PTR _note$[ebp]
  001e6	3b d0		 cmp	 edx, eax
  001e8	75 02		 jne	 SHORT $L73904

; 10949:             break ;

  001ea	eb 0b		 jmp	 SHORT $L73901
$L73904:

; 10950:         scan++;

  001ec	8a 4d f1	 mov	 cl, BYTE PTR _scan$[ebp]
  001ef	80 c1 01	 add	 cl, 1
  001f2	88 4d f1	 mov	 BYTE PTR _scan$[ebp], cl

; 10951:     }

  001f5	eb b8		 jmp	 SHORT $L73900
$L73901:

; 10952: 
; 10953:     if( accpart && keypart )

  001f7	0f b6 55 ff	 movzx	 edx, BYTE PTR _accpart$[ebp]
  001fb	85 d2		 test	 edx, edx
  001fd	0f 84 ad 00 00
	00		 je	 $L73905
  00203	0f b6 45 fc	 movzx	 eax, BYTE PTR _keypart$[ebp]
  00207	85 c0		 test	 eax, eax
  00209	0f 84 a1 00 00
	00		 je	 $L73905

; 10954:     {
; 10955:         testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);

  0020f	0f b6 4d f3	 movzx	 ecx, BYTE PTR _octpart$[ebp]
  00213	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00216	0f b6 55 eb	 movzx	 edx, BYTE PTR _chordpart$[ebp]
  0021a	c1 e2 08	 shl	 edx, 8
  0021d	03 ca		 add	 ecx, edx
  0021f	0f b6 45 fc	 movzx	 eax, BYTE PTR _keypart$[ebp]
  00223	c1 e0 04	 shl	 eax, 4
  00226	03 c8		 add	 ecx, eax
  00228	0f b6 55 ff	 movzx	 edx, BYTE PTR _accpart$[ebp]
  0022c	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  00230	66 89 45 f4	 mov	 WORD PTR _testa$[ebp], ax

; 10956:         testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);

  00234	0f b6 4d f3	 movzx	 ecx, BYTE PTR _octpart$[ebp]
  00238	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  0023b	0f b6 55 eb	 movzx	 edx, BYTE PTR _chordpart$[ebp]
  0023f	83 c2 01	 add	 edx, 1
  00242	c1 e2 08	 shl	 edx, 8
  00245	03 ca		 add	 ecx, edx
  00247	66 89 4d ec	 mov	 WORD PTR _testb$[ebp], cx

; 10957:         testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
; 10958:                                      chordpattern, chordroot );

  0024b	8a 45 18	 mov	 al, BYTE PTR _chordroot$[ebp]
  0024e	50		 push	 eax
  0024f	8b 4d 14	 mov	 ecx, DWORD PTR _chordpattern$[ebp]
  00252	51		 push	 ecx
  00253	8a 55 10	 mov	 dl, BYTE PTR _keyroot$[ebp]
  00256	52		 push	 edx
  00257	8b 45 0c	 mov	 eax, DWORD PTR _keypattern$[ebp]
  0025a	50		 push	 eax
  0025b	6a 00		 push	 0
  0025d	66 8b 4d f4	 mov	 cx, WORD PTR _testa$[ebp]
  00261	51		 push	 ecx
  00262	e8 00 00 00 00	 call	 ?OldMusicValueToNote@@YGEGDJDJD@Z ; OldMusicValueToNote
  00267	66 0f b6 d0	 movzx	 dx, al
  0026b	66 89 55 f4	 mov	 WORD PTR _testa$[ebp], dx

; 10959:         testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
; 10960:                                      chordpattern, chordroot );

  0026f	8a 45 18	 mov	 al, BYTE PTR _chordroot$[ebp]
  00272	50		 push	 eax
  00273	8b 4d 14	 mov	 ecx, DWORD PTR _chordpattern$[ebp]
  00276	51		 push	 ecx
  00277	8a 55 10	 mov	 dl, BYTE PTR _keyroot$[ebp]
  0027a	52		 push	 edx
  0027b	8b 45 0c	 mov	 eax, DWORD PTR _keypattern$[ebp]
  0027e	50		 push	 eax
  0027f	6a 00		 push	 0
  00281	66 8b 4d ec	 mov	 cx, WORD PTR _testb$[ebp]
  00285	51		 push	 ecx
  00286	e8 00 00 00 00	 call	 ?OldMusicValueToNote@@YGEGDJDJD@Z ; OldMusicValueToNote
  0028b	66 0f b6 d0	 movzx	 dx, al
  0028f	66 89 55 ec	 mov	 WORD PTR _testb$[ebp], dx

; 10961:         if( testa == testb )

  00293	0f bf 45 f4	 movsx	 eax, WORD PTR _testa$[ebp]
  00297	0f bf 4d ec	 movsx	 ecx, WORD PTR _testb$[ebp]
  0029b	3b c1		 cmp	 eax, ecx
  0029d	75 11		 jne	 SHORT $L73905

; 10962:         {
; 10963:             chordpart++ ;

  0029f	8a 55 eb	 mov	 dl, BYTE PTR _chordpart$[ebp]
  002a2	80 c2 01	 add	 dl, 1
  002a5	88 55 eb	 mov	 BYTE PTR _chordpart$[ebp], dl

; 10964:             keypart = 0 ;

  002a8	c6 45 fc 00	 mov	 BYTE PTR _keypart$[ebp], 0

; 10965:             accpart = -1 ;

  002ac	c6 45 ff ff	 mov	 BYTE PTR _accpart$[ebp], 255 ; 000000ffH
$L73905:

; 10966:         }
; 10967:     }
; 10968: 
; 10969:     // If the conversion didn't find an exact match, fudge accpart to make it work
; 10970:     testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

  002b0	0f b6 45 f3	 movzx	 eax, BYTE PTR _octpart$[ebp]
  002b4	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  002b7	0f b6 4d eb	 movzx	 ecx, BYTE PTR _chordpart$[ebp]
  002bb	c1 e1 08	 shl	 ecx, 8
  002be	03 c1		 add	 eax, ecx
  002c0	0f b6 55 fc	 movzx	 edx, BYTE PTR _keypart$[ebp]
  002c4	c1 e2 04	 shl	 edx, 4
  002c7	03 c2		 add	 eax, edx
  002c9	0f b6 4d ff	 movzx	 ecx, BYTE PTR _accpart$[ebp]
  002cd	83 e1 0f	 and	 ecx, 15			; 0000000fH
  002d0	03 c1		 add	 eax, ecx
  002d2	66 89 45 f4	 mov	 WORD PTR _testa$[ebp], ax

; 10971:     testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
; 10972:                                  chordpattern, chordroot );

  002d6	8a 55 18	 mov	 dl, BYTE PTR _chordroot$[ebp]
  002d9	52		 push	 edx
  002da	8b 45 14	 mov	 eax, DWORD PTR _chordpattern$[ebp]
  002dd	50		 push	 eax
  002de	8a 4d 10	 mov	 cl, BYTE PTR _keyroot$[ebp]
  002e1	51		 push	 ecx
  002e2	8b 55 0c	 mov	 edx, DWORD PTR _keypattern$[ebp]
  002e5	52		 push	 edx
  002e6	6a 00		 push	 0
  002e8	66 8b 45 f4	 mov	 ax, WORD PTR _testa$[ebp]
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 ?OldMusicValueToNote@@YGEGDJDJD@Z ; OldMusicValueToNote
  002f2	66 0f b6 c8	 movzx	 cx, al
  002f6	66 89 4d f4	 mov	 WORD PTR _testa$[ebp], cx

; 10973: 
; 10974:     if( testa != note )

  002fa	0f bf 55 f4	 movsx	 edx, WORD PTR _testa$[ebp]
  002fe	0f b6 45 08	 movzx	 eax, BYTE PTR _note$[ebp]
  00302	3b d0		 cmp	 edx, eax
  00304	74 13		 je	 SHORT $L73907

; 10975:     {
; 10976:         accpart += note - testa;

  00306	0f b6 4d 08	 movzx	 ecx, BYTE PTR _note$[ebp]
  0030a	0f bf 55 f4	 movsx	 edx, WORD PTR _testa$[ebp]
  0030e	2b ca		 sub	 ecx, edx
  00310	0f b6 45 ff	 movzx	 eax, BYTE PTR _accpart$[ebp]
  00314	03 c1		 add	 eax, ecx
  00316	88 45 ff	 mov	 BYTE PTR _accpart$[ebp], al
$L73907:

; 10977:     }
; 10978: 
; 10979:     return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

  00319	0f b6 45 f3	 movzx	 eax, BYTE PTR _octpart$[ebp]
  0031d	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00320	0f b6 4d eb	 movzx	 ecx, BYTE PTR _chordpart$[ebp]
  00324	c1 e1 08	 shl	 ecx, 8
  00327	03 c1		 add	 eax, ecx
  00329	0f b6 55 fc	 movzx	 edx, BYTE PTR _keypart$[ebp]
  0032d	c1 e2 04	 shl	 edx, 4
  00330	03 c2		 add	 eax, edx
  00332	0f b6 4d ff	 movzx	 ecx, BYTE PTR _accpart$[ebp]
  00336	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00339	03 c1		 add	 eax, ecx
$L73863:

; 10980: 
; 10981: }

  0033b	8b e5		 mov	 esp, ebp
  0033d	5d		 pop	 ebp
  0033e	c2 14 00	 ret	 20			; 00000014H
?OldNoteToMusicValue@@YGGEJDJD@Z ENDP			; OldNoteToMusicValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OldMusicValueToNote@@YGEGDJDJD@Z
_TEXT	SEGMENT
_chordpart$ = -5
_result$ = -4
_octpart$ = -3
_keypart$ = -2
_accpart$ = -1
_value$ = 8
_scalevalue$ = 12
_keypattern$ = 16
_keyroot$ = 20
_chordpattern$ = 24
_chordroot$ = 28
?OldMusicValueToNote@@YGEGDJDJD@Z PROC NEAR		; OldMusicValueToNote, COMDAT

; 10796: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 10797:     unsigned char   result ;
; 10798:     char            octpart   = (char)(value >> 12) ;

  00006	0f b7 45 08	 movzx	 eax, WORD PTR _value$[ebp]
  0000a	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  0000d	88 45 fd	 mov	 BYTE PTR _octpart$[ebp], al

; 10799:     char            chordpart = (char)((value >> 8) & 0xF) ;

  00010	0f b7 4d 08	 movzx	 ecx, WORD PTR _value$[ebp]
  00014	c1 f9 08	 sar	 ecx, 8
  00017	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0001a	88 4d fb	 mov	 BYTE PTR _chordpart$[ebp], cl

; 10800:     char            keypart   = (char)((value >> 4) & 0xF) ;

  0001d	0f b7 55 08	 movzx	 edx, WORD PTR _value$[ebp]
  00021	c1 fa 04	 sar	 edx, 4
  00024	83 e2 0f	 and	 edx, 15			; 0000000fH
  00027	88 55 fe	 mov	 BYTE PTR _keypart$[ebp], dl

; 10801:     char            accpart   = (char)(value & 0xF) ;

  0002a	0f b7 45 08	 movzx	 eax, WORD PTR _value$[ebp]
  0002e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00031	88 45 ff	 mov	 BYTE PTR _accpart$[ebp], al

; 10802: 
; 10803:     result  = unsigned char(12 * octpart) ;

  00034	0f be 4d fd	 movsx	 ecx, BYTE PTR _octpart$[ebp]
  00038	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0003b	88 4d fc	 mov	 BYTE PTR _result$[ebp], cl

; 10804:     result += chordroot ;

  0003e	0f be 55 1c	 movsx	 edx, BYTE PTR _chordroot$[ebp]
  00042	0f b6 45 fc	 movzx	 eax, BYTE PTR _result$[ebp]
  00046	03 c2		 add	 eax, edx
  00048	88 45 fc	 mov	 BYTE PTR _result$[ebp], al

; 10805: 
; 10806:     if( accpart > 8 )

  0004b	0f be 4d ff	 movsx	 ecx, BYTE PTR _accpart$[ebp]
  0004f	83 f9 08	 cmp	 ecx, 8
  00052	7e 0a		 jle	 SHORT $L73842

; 10807:         accpart -= 16 ;

  00054	0f be 55 ff	 movsx	 edx, BYTE PTR _accpart$[ebp]
  00058	83 ea 10	 sub	 edx, 16			; 00000010H
  0005b	88 55 ff	 mov	 BYTE PTR _accpart$[ebp], dl
$L73842:

; 10808: 
; 10809:     for( ;  chordpattern ;  result++ ) {

  0005e	eb 08		 jmp	 SHORT $L73843
$L73844:
  00060	8a 45 fc	 mov	 al, BYTE PTR _result$[ebp]
  00063	04 01		 add	 al, 1
  00065	88 45 fc	 mov	 BYTE PTR _result$[ebp], al
$L73843:
  00068	83 7d 18 00	 cmp	 DWORD PTR _chordpattern$[ebp], 0
  0006c	74 68		 je	 SHORT $L73845

; 10810:         if( chordpattern & 1L ) {

  0006e	8b 4d 18	 mov	 ecx, DWORD PTR _chordpattern$[ebp]
  00071	83 e1 01	 and	 ecx, 1
  00074	85 c9		 test	 ecx, ecx
  00076	74 12		 je	 SHORT $L73846

; 10811:             if( !chordpart )

  00078	0f be 55 fb	 movsx	 edx, BYTE PTR _chordpart$[ebp]
  0007c	85 d2		 test	 edx, edx
  0007e	75 02		 jne	 SHORT $L73847

; 10812:                 break ;

  00080	eb 54		 jmp	 SHORT $L73845
$L73847:

; 10813:             chordpart-- ;

  00082	8a 45 fb	 mov	 al, BYTE PTR _chordpart$[ebp]
  00085	2c 01		 sub	 al, 1
  00087	88 45 fb	 mov	 BYTE PTR _chordpart$[ebp], al
$L73846:

; 10814:         }
; 10815:         chordpattern = chordpattern >> 1L ;

  0008a	8b 4d 18	 mov	 ecx, DWORD PTR _chordpattern$[ebp]
  0008d	d1 f9		 sar	 ecx, 1
  0008f	89 4d 18	 mov	 DWORD PTR _chordpattern$[ebp], ecx

; 10816:         if( !chordpattern ) {

  00092	83 7d 18 00	 cmp	 DWORD PTR _chordpattern$[ebp], 0
  00096	75 3c		 jne	 SHORT $L73848

; 10817:             if( !scalevalue )

  00098	0f be 55 0c	 movsx	 edx, BYTE PTR _scalevalue$[ebp]
  0009c	85 d2		 test	 edx, edx
  0009e	75 07		 jne	 SHORT $L73849

; 10818:                 return( 0 ) ;

  000a0	32 c0		 xor	 al, al
  000a2	e9 a7 00 00 00	 jmp	 $L73832
$L73849:

; 10819:             result  = unsigned char(12 * octpart) ;

  000a7	0f be 45 fd	 movsx	 eax, BYTE PTR _octpart$[ebp]
  000ab	6b c0 0c	 imul	 eax, 12			; 0000000cH
  000ae	88 45 fc	 mov	 BYTE PTR _result$[ebp], al

; 10820:             result += chordroot ;

  000b1	0f be 4d 1c	 movsx	 ecx, BYTE PTR _chordroot$[ebp]
  000b5	0f b6 55 fc	 movzx	 edx, BYTE PTR _result$[ebp]
  000b9	03 d1		 add	 edx, ecx
  000bb	88 55 fc	 mov	 BYTE PTR _result$[ebp], dl

; 10821:             keypart = char(scalevalue >> 4) ;

  000be	0f be 45 0c	 movsx	 eax, BYTE PTR _scalevalue$[ebp]
  000c2	c1 f8 04	 sar	 eax, 4
  000c5	88 45 fe	 mov	 BYTE PTR _keypart$[ebp], al

; 10822:             accpart = char(scalevalue & 0x0F) ;

  000c8	0f be 4d 0c	 movsx	 ecx, BYTE PTR _scalevalue$[ebp]
  000cc	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000cf	88 4d ff	 mov	 BYTE PTR _accpart$[ebp], cl

; 10823:             break ;

  000d2	eb 02		 jmp	 SHORT $L73845
$L73848:

; 10824:         }
; 10825:     }

  000d4	eb 8a		 jmp	 SHORT $L73844
$L73845:

; 10826: 
; 10827:     if( keypart ) {

  000d6	0f be 55 fe	 movsx	 edx, BYTE PTR _keypart$[ebp]
  000da	85 d2		 test	 edx, edx
  000dc	74 60		 je	 SHORT $L73850

; 10828:         keypattern = CleanupScale(keypattern) ;

  000de	8b 45 10	 mov	 eax, DWORD PTR _keypattern$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?CleanupScale@@YGKK@Z	; CleanupScale
  000e7	89 45 10	 mov	 DWORD PTR _keypattern$[ebp], eax

; 10829:         keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;

  000ea	0f b6 45 fc	 movzx	 eax, BYTE PTR _result$[ebp]
  000ee	0f be 4d 14	 movsx	 ecx, BYTE PTR _keyroot$[ebp]
  000f2	2b c1		 sub	 eax, ecx
  000f4	99		 cdq
  000f5	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000fa	f7 f9		 idiv	 ecx
  000fc	8b 45 10	 mov	 eax, DWORD PTR _keypattern$[ebp]
  000ff	8b ca		 mov	 ecx, edx
  00101	d3 f8		 sar	 eax, cl
  00103	89 45 10	 mov	 DWORD PTR _keypattern$[ebp], eax

; 10830:         for( ;  keypattern ;  result++ ) {

  00106	eb 09		 jmp	 SHORT $L73852
$L73853:
  00108	8a 4d fc	 mov	 cl, BYTE PTR _result$[ebp]
  0010b	80 c1 01	 add	 cl, 1
  0010e	88 4d fc	 mov	 BYTE PTR _result$[ebp], cl
$L73852:
  00111	83 7d 10 00	 cmp	 DWORD PTR _keypattern$[ebp], 0
  00115	74 27		 je	 SHORT $L73850

; 10831:             if( keypattern & 1L ) {

  00117	8b 55 10	 mov	 edx, DWORD PTR _keypattern$[ebp]
  0011a	83 e2 01	 and	 edx, 1
  0011d	85 d2		 test	 edx, edx
  0011f	74 13		 je	 SHORT $L73855

; 10832:                 if( !keypart )

  00121	0f be 45 fe	 movsx	 eax, BYTE PTR _keypart$[ebp]
  00125	85 c0		 test	 eax, eax
  00127	75 02		 jne	 SHORT $L73856

; 10833:                     break ;

  00129	eb 13		 jmp	 SHORT $L73850
$L73856:

; 10834:                 keypart-- ;

  0012b	8a 4d fe	 mov	 cl, BYTE PTR _keypart$[ebp]
  0012e	80 e9 01	 sub	 cl, 1
  00131	88 4d fe	 mov	 BYTE PTR _keypart$[ebp], cl
$L73855:

; 10835:             }
; 10836:             keypattern = keypattern >> 1L ;

  00134	8b 55 10	 mov	 edx, DWORD PTR _keypattern$[ebp]
  00137	d1 fa		 sar	 edx, 1
  00139	89 55 10	 mov	 DWORD PTR _keypattern$[ebp], edx

; 10837:         }

  0013c	eb ca		 jmp	 SHORT $L73853
$L73850:

; 10838:     }
; 10839: 
; 10840:     result += unsigned char(accpart) ;

  0013e	0f b6 45 ff	 movzx	 eax, BYTE PTR _accpart$[ebp]
  00142	0f b6 4d fc	 movzx	 ecx, BYTE PTR _result$[ebp]
  00146	03 c8		 add	 ecx, eax
  00148	88 4d fc	 mov	 BYTE PTR _result$[ebp], cl

; 10841:     return( result ) ;

  0014b	8a 45 fc	 mov	 al, BYTE PTR _result$[ebp]
$L73832:

; 10842: 
; 10843: }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 18 00	 ret	 24			; 00000018H
?OldMusicValueToNote@@YGEGDJDJD@Z ENDP			; OldMusicValueToNote
_TEXT	ENDS
PUBLIC	?MusicValueOctave@@YGFG@Z			; MusicValueOctave
PUBLIC	?MusicValueChord@@YGFGEPAU_DMUS_SUBCHORD@@E@Z	; MusicValueChord
; Function compile flags: /Odt
;	COMDAT ?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z
_TEXT	SEGMENT
_wTemp$ = -16
_nResult$ = -12
_nOffset$ = -8
_nChordValue$ = -4
_wMV$ = 8
_bPlayModes$ = 12
_pSubChord$ = 16
_bKey$ = 20
?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z PROC NEAR ; MusicValueConvert, COMDAT

; 11135: { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 11136:     short nResult = 0;

  00006	66 c7 45 f4 00
	00		 mov	 WORD PTR _nResult$[ebp], 0

; 11137:     // First, make sure the octave is not negative.
; 11138:     short nOffset = 0;

  0000c	66 c7 45 f8 00
	00		 mov	 WORD PTR _nOffset$[ebp], 0
$L73986:

; 11139:     while (wMV >= 0xE000)

  00012	0f b7 45 08	 movzx	 eax, WORD PTR _wMV$[ebp]
  00016	3d 00 e0 00 00	 cmp	 eax, 57344		; 0000e000H
  0001b	7c 1b		 jl	 SHORT $L73987

; 11140:     {
; 11141:         wMV += 0x1000;

  0001d	0f b7 4d 08	 movzx	 ecx, WORD PTR _wMV$[ebp]
  00021	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  00027	66 89 4d 08	 mov	 WORD PTR _wMV$[ebp], cx

; 11142:         nOffset -= 12;

  0002b	0f bf 55 f8	 movsx	 edx, WORD PTR _nOffset$[ebp]
  0002f	83 ea 0c	 sub	 edx, 12			; 0000000cH
  00032	66 89 55 f8	 mov	 WORD PTR _nOffset$[ebp], dx

; 11143:     }

  00036	eb da		 jmp	 SHORT $L73986
$L73987:

; 11144: 
; 11145:     // If the music value has a negative scale offset, convert to an equivalent
; 11146:     // music value with a positive offset (up an octave) and shift the whole thing
; 11147:     // down an octave
; 11148:     WORD wTemp = (wMV & 0x00f0) + 0x0070;

  00038	0f b7 45 08	 movzx	 eax, WORD PTR _wMV$[ebp]
  0003c	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00041	83 c0 70	 add	 eax, 112		; 00000070H
  00044	66 89 45 f0	 mov	 WORD PTR _wTemp$[ebp], ax

; 11149:     if (wTemp & 0x0f00)

  00048	0f b7 4d f0	 movzx	 ecx, WORD PTR _wTemp$[ebp]
  0004c	81 e1 00 0f 00
	00		 and	 ecx, 3840		; 00000f00H
  00052	85 c9		 test	 ecx, ecx
  00054	74 1f		 je	 SHORT $L73989

; 11150:     {
; 11151:         wMV = (wMV & 0xff0f) | (wTemp & 0x00f0);

  00056	0f b7 55 08	 movzx	 edx, WORD PTR _wMV$[ebp]
  0005a	81 e2 0f ff 00
	00		 and	 edx, 65295		; 0000ff0fH
  00060	0f b7 45 f0	 movzx	 eax, WORD PTR _wTemp$[ebp]
  00064	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00069	0b d0		 or	 edx, eax
  0006b	66 89 55 08	 mov	 WORD PTR _wMV$[ebp], dx

; 11152:         nOffset = -12;

  0006f	66 c7 45 f8 f4
	ff		 mov	 WORD PTR _nOffset$[ebp], -12 ; fffffff4H
$L73989:

; 11153:     }
; 11154: 
; 11155:     short nChordValue = MusicValueChord(wMV, bPlayModes, pSubChord, bKey);

  00075	8a 4d 14	 mov	 cl, BYTE PTR _bKey$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 10	 mov	 edx, DWORD PTR _pSubChord$[ebp]
  0007c	52		 push	 edx
  0007d	8a 45 0c	 mov	 al, BYTE PTR _bPlayModes$[ebp]
  00080	50		 push	 eax
  00081	66 8b 4d 08	 mov	 cx, WORD PTR _wMV$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?MusicValueChord@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ; MusicValueChord
  0008b	66 89 45 fc	 mov	 WORD PTR _nChordValue$[ebp], ax

; 11156:     if (nChordValue != S_OVER_CHORD)

  0008f	0f bf 55 fc	 movsx	 edx, WORD PTR _nChordValue$[ebp]
  00093	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00099	74 4d		 je	 SHORT $L73991

; 11157:     {
; 11158:         nChordValue += nOffset;

  0009b	0f bf 45 f8	 movsx	 eax, WORD PTR _nOffset$[ebp]
  0009f	0f bf 4d fc	 movsx	 ecx, WORD PTR _nChordValue$[ebp]
  000a3	03 c8		 add	 ecx, eax
  000a5	66 89 4d fc	 mov	 WORD PTR _nChordValue$[ebp], cx

; 11159:         // If the chord root is < 12, take the result down an octave.
; 11160:         if ((bPlayModes & DMUS_PLAYMODE_CHORD_ROOT))

  000a9	0f b6 55 0c	 movzx	 edx, BYTE PTR _bPlayModes$[ebp]
  000ad	83 e2 02	 and	 edx, 2
  000b0	85 d2		 test	 edx, edx
  000b2	74 1b		 je	 SHORT $L73992

; 11161:             nResult = MusicValueOctave(wMV) + nChordValue - 12;

  000b4	66 8b 45 08	 mov	 ax, WORD PTR _wMV$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?MusicValueOctave@@YGFG@Z ; MusicValueOctave
  000be	0f bf c8	 movsx	 ecx, ax
  000c1	0f bf 55 fc	 movsx	 edx, WORD PTR _nChordValue$[ebp]
  000c5	8d 44 11 f4	 lea	 eax, DWORD PTR [ecx+edx-12]
  000c9	66 89 45 f4	 mov	 WORD PTR _nResult$[ebp], ax

; 11162:         else

  000cd	eb 17		 jmp	 SHORT $L73993
$L73992:

; 11163:             nResult = MusicValueOctave(wMV) + nChordValue;

  000cf	66 8b 4d 08	 mov	 cx, WORD PTR _wMV$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ?MusicValueOctave@@YGFG@Z ; MusicValueOctave
  000d9	0f bf d0	 movsx	 edx, ax
  000dc	0f bf 45 fc	 movsx	 eax, WORD PTR _nChordValue$[ebp]
  000e0	03 d0		 add	 edx, eax
  000e2	66 89 55 f4	 mov	 WORD PTR _nResult$[ebp], dx
$L73993:

; 11164:     }
; 11165:     else

  000e6	eb 06		 jmp	 SHORT $L73994
$L73991:

; 11166:         nResult = S_OVER_CHORD;

  000e8	66 c7 45 f4 00
	10		 mov	 WORD PTR _nResult$[ebp], 4096 ; 00001000H
$L73994:

; 11167:     return nResult;

  000ee	66 8b 45 f4	 mov	 ax, WORD PTR _nResult$[ebp]

; 11168: }

  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 10 00	 ret	 16			; 00000010H
?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ENDP	; MusicValueConvert
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?MusicValueOctave@@YGFG@Z
_TEXT	SEGMENT
_wMusicValue$ = 8
?MusicValueOctave@@YGFG@Z PROC NEAR			; MusicValueOctave, COMDAT

; 10984: { return short((wMusicValue >> 12) & 0xf) * 12; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b7 45 08	 movzx	 eax, WORD PTR _wMusicValue$[ebp]
  00007	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  0000a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0000d	0f bf c0	 movsx	 eax, ax
  00010	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?MusicValueOctave@@YGFG@Z ENDP				; MusicValueOctave
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?MusicValueChord@@YGFGEPAU_DMUS_SUBCHORD@@E@Z
_TEXT	SEGMENT
_bRoot$ = -1
_wMusicValue$ = 8
_bPlayModes$ = 12
_pSubChord$ = 16
_bKey$ = 20
?MusicValueChord@@YGFGEPAU_DMUS_SUBCHORD@@E@Z PROC NEAR	; MusicValueChord, COMDAT

; 11121: { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11122:     // first, get the root for transposition.
; 11123:     BYTE bRoot = 0;

  00004	c6 45 ff 00	 mov	 BYTE PTR _bRoot$[ebp], 0

; 11124:     if (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT)

  00008	0f b6 45 0c	 movzx	 eax, BYTE PTR _bPlayModes$[ebp]
  0000c	83 e0 02	 and	 eax, 2
  0000f	85 c0		 test	 eax, eax
  00011	74 0b		 je	 SHORT $L73974

; 11125:     {
; 11126:         bRoot = pSubChord->bChordRoot;

  00013	8b 4d 10	 mov	 ecx, DWORD PTR _pSubChord$[ebp]
  00016	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00019	88 55 ff	 mov	 BYTE PTR _bRoot$[ebp], dl

; 11127:     }
; 11128:     else if (bPlayModes & DMUS_PLAYMODE_KEY_ROOT)

  0001c	eb 11		 jmp	 SHORT $L73975
$L73974:
  0001e	0f b6 45 0c	 movzx	 eax, BYTE PTR _bPlayModes$[ebp]
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 06		 je	 SHORT $L73975

; 11129:         bRoot = bKey;

  00029	8a 4d 14	 mov	 cl, BYTE PTR _bKey$[ebp]
  0002c	88 4d ff	 mov	 BYTE PTR _bRoot$[ebp], cl
$L73975:

; 11130:     // Next, get an interval and combine it with the root.
; 11131:     return MusicValueIntervals(wMusicValue, bPlayModes, pSubChord, bRoot);

  0002f	8a 55 ff	 mov	 dl, BYTE PTR _bRoot$[ebp]
  00032	52		 push	 edx
  00033	8b 45 10	 mov	 eax, DWORD PTR _pSubChord$[ebp]
  00036	50		 push	 eax
  00037	8a 4d 0c	 mov	 cl, BYTE PTR _bPlayModes$[ebp]
  0003a	51		 push	 ecx
  0003b	66 8b 55 08	 mov	 dx, WORD PTR _wMusicValue$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ?MusicValueIntervals@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ; MusicValueIntervals

; 11132: }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 10 00	 ret	 16			; 00000010H
?MusicValueChord@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ENDP	; MusicValueChord
_TEXT	ENDS
PUBLIC	??_C@_0CB@BNPKJPGL@?$CFs?3?5Invalid?5pointer?5pbMIDIValue?6@ ; `string'
PUBLIC	??_C@_0FK@DFDKHCLP@Error?3?5Unable?5to?5convert?5Music?5v@ ; `string'
PUBLIC	??_C@_0EJ@LIJCFGNJ@Warning?3?5MIDIToMusic?5unable?5to?5c@ ; `string'
PUBLIC	??_C@_0FG@ONMLMHBI@Warning?3?5MusicToMIDI?5had?5to?5bump@ ; `string'
PUBLIC	??_C@_0FI@GOIHIAAE@Warning?3?5MusicToMIDI?5had?5to?5bump@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::MusicToMIDI', 00H	; `CPerformance::MusicToMIDI'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CB@BNPKJPGL@?$CFs?3?5Invalid?5pointer?5pbMIDIValue?6@
CONST	SEGMENT
??_C@_0CB@BNPKJPGL@?$CFs?3?5Invalid?5pointer?5pbMIDIValue?6@ DB '%s: Inva'
	DB	'lid pointer pbMIDIValue', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@DFDKHCLP@Error?3?5Unable?5to?5convert?5Music?5v@
CONST	SEGMENT
??_C@_0FK@DFDKHCLP@Error?3?5Unable?5to?5convert?5Music?5v@ DB 'Error: Una'
	DB	'ble to convert Music value to MIDI because the playmode is DM'
	DB	'US_PLAYMODE_NONE.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@LIJCFGNJ@Warning?3?5MIDIToMusic?5unable?5to?5c@
CONST	SEGMENT
??_C@_0EJ@LIJCFGNJ@Warning?3?5MIDIToMusic?5unable?5to?5c@ DB 'Warning: MI'
	DB	'DIToMusic unable to convert because note out of chord range.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@ONMLMHBI@Warning?3?5MusicToMIDI?5had?5to?5bump@
CONST	SEGMENT
??_C@_0FG@ONMLMHBI@Warning?3?5MusicToMIDI?5had?5to?5bump@ DB 'Warning: Mu'
	DB	'sicToMIDI had to bump the music value up an octave to stay in'
	DB	' MIDI range.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@GOIHIAAE@Warning?3?5MusicToMIDI?5had?5to?5bump@
CONST	SEGMENT
??_C@_0FI@GOIHIAAE@Warning?3?5MusicToMIDI?5had?5to?5bump@ DB 'Warning: Mu'
	DB	'sicToMIDI had to bump the music value down an octave to stay '
	DB	'in MIDI range.', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z
_TEXT	SEGMENT
_i$74137 = -24
_pSubChord$74134 = -20
_dwLevel$74135 = -16
_fFoundLevel$74136 = -9
_hr$ = -8
_lReturnVal$ = -4
_this$ = 8
_wMusicValue$ = 12
_pChord$ = 16
_bPlayMode$ = 20
_bChordLevel$ = 24
_pbMIDIValue$ = 28
?MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z PROC NEAR ; CPerformance::MusicToMIDI, COMDAT

; 11373: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 11374:     V_INAME(IDirectMusicPerformance::MusicToMIDI);
; 11375:     V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );

  00006	68 cc 00 00 00	 push	 204			; 000000ccH
  0000b	8b 45 10	 mov	 eax, DWORD PTR _pChord$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $L74126
  00018	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z@4QBDB
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@CCDOAEII@?$CFs?3?5Invalid?5pointer?5pChord?6?$AA@
  00022	6a ff		 push	 -1
  00024	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	e8 00 00 00 00	 call	 _DebugBreak@0
$L74126:

; 11376:     V_PTR_WRITE(pbMIDIValue,BYTE);

  00031	6a 01		 push	 1
  00033	8b 4d 1c	 mov	 ecx, DWORD PTR _pbMIDIValue$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0003c	85 c0		 test	 eax, eax
  0003e	74 19		 je	 SHORT $L74128
  00040	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z@4QBDB
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@BNPKJPGL@?$CFs?3?5Invalid?5pointer?5pbMIDIValue?6@
  0004a	6a ff		 push	 -1
  0004c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	e8 00 00 00 00	 call	 _DebugBreak@0
$L74128:

; 11377: 
; 11378:     long lReturnVal = wMusicValue;

  00059	0f b7 55 0c	 movzx	 edx, WORD PTR _wMusicValue$[ebp]
  0005d	89 55 fc	 mov	 DWORD PTR _lReturnVal$[ebp], edx

; 11379:     HRESULT hr = S_OK;

  00060	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 11380: 
; 11381:     if (bPlayMode != DMUS_PLAYMODE_FIXED)

  00067	0f b6 45 14	 movzx	 eax, BYTE PTR _bPlayMode$[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 f8 00 00
	00		 je	 $L74133

; 11382:     {
; 11383:         DMUS_SUBCHORD *pSubChord;
; 11384:         DWORD dwLevel = 1 << bChordLevel;

  00073	0f b6 4d 18	 movzx	 ecx, BYTE PTR _bChordLevel$[ebp]
  00077	ba 01 00 00 00	 mov	 edx, 1
  0007c	d3 e2		 shl	 edx, cl
  0007e	89 55 f0	 mov	 DWORD PTR _dwLevel$74135[ebp], edx

; 11385:         bool fFoundLevel = false;

  00081	c6 45 f7 00	 mov	 BYTE PTR _fFoundLevel$74136[ebp], 0

; 11386:         for (int i = 0; i < pChord->bSubChordCount; i++)

  00085	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$74137[ebp], 0
  0008c	eb 09		 jmp	 SHORT $L74138
$L74139:
  0008e	8b 45 e8	 mov	 eax, DWORD PTR _i$74137[ebp]
  00091	83 c0 01	 add	 eax, 1
  00094	89 45 e8	 mov	 DWORD PTR _i$74137[ebp], eax
$L74138:
  00097	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  0009a	0f b6 51 23	 movzx	 edx, BYTE PTR [ecx+35]
  0009e	39 55 e8	 cmp	 DWORD PTR _i$74137[ebp], edx
  000a1	7d 2c		 jge	 SHORT $L74140

; 11387:         {
; 11388:             if (dwLevel & pChord->SubChordList[i].dwLevels)

  000a3	8b 45 e8	 mov	 eax, DWORD PTR _i$74137[ebp]
  000a6	6b c0 14	 imul	 eax, 20			; 00000014H
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  000ac	8b 55 f0	 mov	 edx, DWORD PTR _dwLevel$74135[ebp]
  000af	23 54 01 30	 and	 edx, DWORD PTR [ecx+eax+48]
  000b3	85 d2		 test	 edx, edx
  000b5	74 16		 je	 SHORT $L74141

; 11389:             {
; 11390:                 pSubChord = &pChord->SubChordList[i];

  000b7	8b 45 e8	 mov	 eax, DWORD PTR _i$74137[ebp]
  000ba	6b c0 14	 imul	 eax, 20			; 00000014H
  000bd	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  000c0	8d 54 01 24	 lea	 edx, DWORD PTR [ecx+eax+36]
  000c4	89 55 ec	 mov	 DWORD PTR _pSubChord$74134[ebp], edx

; 11391:                 fFoundLevel = true;

  000c7	c6 45 f7 01	 mov	 BYTE PTR _fFoundLevel$74136[ebp], 1

; 11392:                 break;

  000cb	eb 02		 jmp	 SHORT $L74140
$L74141:

; 11393:             }
; 11394:         }

  000cd	eb bf		 jmp	 SHORT $L74139
$L74140:

; 11395:         if (!fFoundLevel) // No luck? Use first chord.

  000cf	0f b6 45 f7	 movzx	 eax, BYTE PTR _fFoundLevel$74136[ebp]
  000d3	85 c0		 test	 eax, eax
  000d5	75 09		 jne	 SHORT $L74142

; 11396:         {
; 11397:             pSubChord = &pChord->SubChordList[0];

  000d7	8b 4d 10	 mov	 ecx, DWORD PTR _pChord$[ebp]
  000da	83 c1 24	 add	 ecx, 36			; 00000024H
  000dd	89 4d ec	 mov	 DWORD PTR _pSubChord$74134[ebp], ecx
$L74142:

; 11398:         }
; 11399:         if (bPlayMode & DMUS_PLAYMODE_NONE )

  000e0	0f b6 55 14	 movzx	 edx, BYTE PTR _bPlayMode$[ebp]
  000e4	83 e2 10	 and	 edx, 16			; 00000010H
  000e7	85 d2		 test	 edx, edx
  000e9	74 1f		 je	 SHORT $L74143

; 11400:         {
; 11401:             *pbMIDIValue = 0;

  000eb	8b 45 1c	 mov	 eax, DWORD PTR _pbMIDIValue$[ebp]
  000ee	c6 00 00	 mov	 BYTE PTR [eax], 0

; 11402:             Trace(1,"Error: Unable to convert Music value to MIDI because the playmode is DMUS_PLAYMODE_NONE.\n");

  000f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FK@DFDKHCLP@Error?3?5Unable?5to?5convert?5Music?5v@
  000f6	6a 01		 push	 1
  000f8	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000fd	83 c4 08	 add	 esp, 8

; 11403:             return E_INVALIDARG;

  00100	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00105	e9 d9 00 00 00	 jmp	 $L74122
$L74143:

; 11404:         }
; 11405:         if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord

  0010a	0f b6 4d 14	 movzx	 ecx, BYTE PTR _bPlayMode$[ebp]
  0010e	83 f9 02	 cmp	 ecx, 2
  00111	75 19		 jne	 SHORT $L74146

; 11406:         {
; 11407:             lReturnVal += (pSubChord->bChordRoot % 24);

  00113	8b 55 ec	 mov	 edx, DWORD PTR _pSubChord$74134[ebp]
  00116	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  0011a	99		 cdq
  0011b	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00120	f7 f9		 idiv	 ecx
  00122	8b 45 fc	 mov	 eax, DWORD PTR _lReturnVal$[ebp]
  00125	03 c2		 add	 eax, edx
  00127	89 45 fc	 mov	 DWORD PTR _lReturnVal$[ebp], eax

; 11408:         }
; 11409:         else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to scale

  0012a	eb 3f		 jmp	 SHORT $L74133
$L74146:
  0012c	0f b6 4d 14	 movzx	 ecx, BYTE PTR _bPlayMode$[ebp]
  00130	83 f9 01	 cmp	 ecx, 1
  00133	75 14		 jne	 SHORT $L74148

; 11410:         {
; 11411:             lReturnVal += pChord->bKey;

  00135	8b 55 10	 mov	 edx, DWORD PTR _pChord$[ebp]
  00138	0f b6 82 c8 00
	00 00		 movzx	 eax, BYTE PTR [edx+200]
  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _lReturnVal$[ebp]
  00142	03 c8		 add	 ecx, eax
  00144	89 4d fc	 mov	 DWORD PTR _lReturnVal$[ebp], ecx

; 11412:         }
; 11413:         else

  00147	eb 22		 jmp	 SHORT $L74133
$L74148:

; 11414:         {
; 11415:             lReturnVal = 
; 11416:                 MusicValueConvert((WORD)lReturnVal, bPlayMode, pSubChord, pChord->bKey);

  00149	8b 55 10	 mov	 edx, DWORD PTR _pChord$[ebp]
  0014c	8a 82 c8 00 00
	00		 mov	 al, BYTE PTR [edx+200]
  00152	50		 push	 eax
  00153	8b 4d ec	 mov	 ecx, DWORD PTR _pSubChord$74134[ebp]
  00156	51		 push	 ecx
  00157	8a 55 14	 mov	 dl, BYTE PTR _bPlayMode$[ebp]
  0015a	52		 push	 edx
  0015b	66 8b 45 fc	 mov	 ax, WORD PTR _lReturnVal$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 ?MusicValueConvert@@YGFGEPAU_DMUS_SUBCHORD@@E@Z ; MusicValueConvert
  00165	0f bf c8	 movsx	 ecx, ax
  00168	89 4d fc	 mov	 DWORD PTR _lReturnVal$[ebp], ecx
$L74133:

; 11417:         }
; 11418:     }
; 11419:     if (lReturnVal == S_OVER_CHORD)

  0016b	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR _lReturnVal$[ebp], 4096 ; 00001000H
  00172	75 16		 jne	 SHORT $L74158

; 11420:     {
; 11421:         Trace(5,"Warning: MIDIToMusic unable to convert because note out of chord range.\n");

  00174	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EJ@LIJCFGNJ@Warning?3?5MIDIToMusic?5unable?5to?5c@
  00179	6a 05		 push	 5
  0017b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00180	83 c4 08	 add	 esp, 8

; 11422:         return DMUS_S_OVER_CHORD;

  00183	b8 12 12 78 08	 mov	 eax, 142086674		; 08781212H
  00188	eb 59		 jmp	 SHORT $L74122
$L74158:

; 11423:     }
; 11424:     while (lReturnVal < 0) 

  0018a	83 7d fc 00	 cmp	 DWORD PTR _lReturnVal$[ebp], 0
  0018e	7d 21		 jge	 SHORT $L74166

; 11425:     {
; 11426:         lReturnVal += 12;

  00190	8b 55 fc	 mov	 edx, DWORD PTR _lReturnVal$[ebp]
  00193	83 c2 0c	 add	 edx, 12			; 0000000cH
  00196	89 55 fc	 mov	 DWORD PTR _lReturnVal$[ebp], edx

; 11427:         Trace(2,"Warning: MusicToMIDI had to bump the music value up an octave to stay in MIDI range.\n");

  00199	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FG@ONMLMHBI@Warning?3?5MusicToMIDI?5had?5to?5bump@
  0019e	6a 02		 push	 2
  001a0	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001a5	83 c4 08	 add	 esp, 8

; 11428:         hr = DMUS_S_UP_OCTAVE;

  001a8	c7 45 f8 13 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086675 ; 08781213H

; 11429:     }

  001af	eb d9		 jmp	 SHORT $L74158
$L74166:

; 11430:     while (lReturnVal > 127) 

  001b1	83 7d fc 7f	 cmp	 DWORD PTR _lReturnVal$[ebp], 127 ; 0000007fH
  001b5	7e 21		 jle	 SHORT $L74167

; 11431:     {
; 11432:         lReturnVal -= 12;

  001b7	8b 45 fc	 mov	 eax, DWORD PTR _lReturnVal$[ebp]
  001ba	83 e8 0c	 sub	 eax, 12			; 0000000cH
  001bd	89 45 fc	 mov	 DWORD PTR _lReturnVal$[ebp], eax

; 11433:         Trace(2,"Warning: MusicToMIDI had to bump the music value down an octave to stay in MIDI range.\n");

  001c0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FI@GOIHIAAE@Warning?3?5MusicToMIDI?5had?5to?5bump@
  001c5	6a 02		 push	 2
  001c7	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001cc	83 c4 08	 add	 esp, 8

; 11434:         hr = DMUS_S_DOWN_OCTAVE;

  001cf	c7 45 f8 14 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086676 ; 08781214H

; 11435:     }

  001d6	eb d9		 jmp	 SHORT $L74166
$L74167:

; 11436:     *pbMIDIValue = (BYTE) lReturnVal;

  001d8	8b 4d 1c	 mov	 ecx, DWORD PTR _pbMIDIValue$[ebp]
  001db	8a 55 fc	 mov	 dl, BYTE PTR _lReturnVal$[ebp]
  001de	88 11		 mov	 BYTE PTR [ecx], dl

; 11437:     return hr;

  001e0	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L74122:

; 11438: }

  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c2 18 00	 ret	 24			; 00000018H
?MusicToMIDI@CPerformance@@UAGJGPAU_DMUS_CHORD_KEY@@EEPAE@Z ENDP ; CPerformance::MusicToMIDI
_TEXT	ENDS
PUBLIC	?InScale@@YG_NEEK@Z				; InScale
EXTRN	_GUID_ChordParam:BYTE
; Function compile flags: /Odt
;	COMDAT ?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
tv176 = -244
_this$ = -240
_pNewNote$74210 = -236
_mtDuration$74204 = -232
_pNewPMsg$74206 = -228
_bNewMidiValue$74201 = -222
_bRoot$74190 = -221
_dwScale$74191 = -220
_hr$ = -216
_mtTime$ = -212
_CurrentChord$ = -208
_pNote$ = 8
_dwTrackGroup$ = 12
_rtTime$ = 16
_ppNew$ = 24
?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z PROC NEAR ; CPerformance::GetChordNotificationStatus, COMDAT
; _this$ = ecx

; 11449: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 11450:     HRESULT hr = S_FALSE; // default: succeed, but don't invalidate the note

  0000f	c7 85 28 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _hr$[ebp], 1

; 11451: 
; 11452:     DMUS_CHORD_PARAM CurrentChord;
; 11453:     MUSIC_TIME mtTime;
; 11454:     ReferenceToMusicTime(rtTime, &mtTime);

  00019	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _mtTime$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 14	 mov	 ecx, DWORD PTR _rtTime$[ebp+4]
  00023	51		 push	 ecx
  00024	8b 55 10	 mov	 edx, DWORD PTR _rtTime$[ebp]
  00027	52		 push	 edx
  00028	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00036	52		 push	 edx
  00037	ff 51 18	 call	 DWORD PTR [ecx+24]

; 11455: 
; 11456:     if (pNote->bFlags & (DMUS_NOTEF_NOINVALIDATE_INSCALE | DMUS_NOTEF_NOINVALIDATE_INCHORD))

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pNote$[ebp]
  0003d	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  00041	83 e1 0c	 and	 ecx, 12			; 0000000cH
  00044	85 c9		 test	 ecx, ecx
  00046	0f 84 c6 00 00
	00		 je	 $L74185

; 11457:     {
; 11458:         // If the note is inconsistent with the current scale/chord, invalidate it
; 11459:         if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK, 
; 11460:                                 mtTime, NULL, (void*) &CurrentChord)))

  0004c	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _CurrentChord$[ebp]
  00052	52		 push	 edx
  00053	6a 00		 push	 0
  00055	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _mtTime$[ebp]
  0005b	50		 push	 eax
  0005c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _dwTrackGroup$[ebp]
  00064	51		 push	 ecx
  00065	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_ChordParam
  0006a	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00078	51		 push	 ecx
  00079	ff 50 6c	 call	 DWORD PTR [eax+108]
  0007c	85 c0		 test	 eax, eax
  0007e	0f 8c 89 00 00
	00		 jl	 $L74188

; 11461:         {
; 11462:             if (CurrentChord.bSubChordCount > 0)

  00084	0f b6 95 53 ff
	ff ff		 movzx	 edx, BYTE PTR _CurrentChord$[ebp+35]
  0008b	85 d2		 test	 edx, edx
  0008d	7e 7e		 jle	 SHORT $L74188

; 11463:             {
; 11464:                 BYTE bRoot = CurrentChord.SubChordList[0].bChordRoot;

  0008f	8a 85 64 ff ff
	ff		 mov	 al, BYTE PTR _CurrentChord$[ebp+52]
  00095	88 85 23 ff ff
	ff		 mov	 BYTE PTR _bRoot$74190[ebp], al

; 11465:                 DWORD dwScale = CurrentChord.SubChordList[0].dwScalePattern;

  0009b	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _CurrentChord$[ebp+40]
  000a1	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _dwScale$74191[ebp], ecx

; 11466:                 if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE_INCHORD)

  000a7	8b 55 08	 mov	 edx, DWORD PTR _pNote$[ebp]
  000aa	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  000ae	83 e0 08	 and	 eax, 8
  000b1	85 c0		 test	 eax, eax
  000b3	74 0e		 je	 SHORT $L74192

; 11467:                 {
; 11468:                     dwScale = CurrentChord.SubChordList[0].dwChordPattern;

  000b5	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _CurrentChord$[ebp+36]
  000bb	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _dwScale$74191[ebp], ecx

; 11469:                 }
; 11470:                 else

  000c1	eb 1f		 jmp	 SHORT $L74193
$L74192:

; 11471:                 {
; 11472:                     dwScale = FixScale(SubtractRootFromScale(bRoot, dwScale));

  000c3	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _dwScale$74191[ebp]
  000c9	52		 push	 edx
  000ca	8a 85 23 ff ff
	ff		 mov	 al, BYTE PTR _bRoot$74190[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?SubtractRootFromScale@@YGKEK@Z ; SubtractRootFromScale
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?FixScale@@YGKK@Z	; FixScale
  000dc	89 85 24 ff ff
	ff		 mov	 DWORD PTR _dwScale$74191[ebp], eax
$L74193:

; 11473:                 }
; 11474:                 if (!InScale(pNote->bMidiValue, bRoot, dwScale))

  000e2	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _dwScale$74191[ebp]
  000e8	51		 push	 ecx
  000e9	8a 95 23 ff ff
	ff		 mov	 dl, BYTE PTR _bRoot$74190[ebp]
  000ef	52		 push	 edx
  000f0	8b 45 08	 mov	 eax, DWORD PTR _pNote$[ebp]
  000f3	8a 48 4b	 mov	 cl, BYTE PTR [eax+75]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 ?InScale@@YG_NEEK@Z	; InScale
  000fc	0f b6 d0	 movzx	 edx, al
  000ff	85 d2		 test	 edx, edx
  00101	75 0a		 jne	 SHORT $L74188

; 11475:                 {
; 11476:                     hr = S_OK;

  00103	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0
$L74188:

; 11477:                 }
; 11478:             }
; 11479:         }
; 11480:     }
; 11481:     else if (pNote->bFlags & DMUS_NOTEF_REGENERATE)

  0010d	e9 84 03 00 00	 jmp	 $L74196
$L74185:
  00112	8b 45 08	 mov	 eax, DWORD PTR _pNote$[ebp]
  00115	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  00119	83 e1 10	 and	 ecx, 16			; 00000010H
  0011c	85 c9		 test	 ecx, ecx
  0011e	0f 84 72 03 00
	00		 je	 $L74196

; 11482:     {
; 11483:         // this always causes an invalidation, and in addition generates a new note event, 
; 11484:         // based on the Music Value of the current one, that starts at rtTime 
; 11485:         // and continues until pNote->mtTime + pNote->Duration
; 11486:         // EXCEPTION: the newly generated note is the same as the currently playing one
; 11487:         if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK, 
; 11488:                                 mtTime, NULL, (void*) &CurrentChord)))

  00124	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _CurrentChord$[ebp]
  0012a	52		 push	 edx
  0012b	6a 00		 push	 0
  0012d	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _mtTime$[ebp]
  00133	50		 push	 eax
  00134	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _dwTrackGroup$[ebp]
  0013c	51		 push	 ecx
  0013d	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_ChordParam
  00142	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00148	8b 02		 mov	 eax, DWORD PTR [edx]
  0014a	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00150	51		 push	 ecx
  00151	ff 50 6c	 call	 DWORD PTR [eax+108]
  00154	85 c0		 test	 eax, eax
  00156	0f 8c 3a 03 00
	00		 jl	 $L74196

; 11489:         {
; 11490:             BYTE bNewMidiValue = 0;

  0015c	c6 85 22 ff ff
	ff 00		 mov	 BYTE PTR _bNewMidiValue$74201[ebp], 0

; 11491:             if (SUCCEEDED(MusicToMIDI(pNote->wMusicValue, &CurrentChord, pNote->bPlayModeFlags,
; 11492:                                         pNote->bSubChordLevel, &bNewMidiValue)) &&
; 11493:                 bNewMidiValue != pNote->bMidiValue)

  00163	8d 95 22 ff ff
	ff		 lea	 edx, DWORD PTR _bNewMidiValue$74201[ebp]
  00169	52		 push	 edx
  0016a	8b 45 08	 mov	 eax, DWORD PTR _pNote$[ebp]
  0016d	8a 48 4a	 mov	 cl, BYTE PTR [eax+74]
  00170	51		 push	 ecx
  00171	8b 55 08	 mov	 edx, DWORD PTR _pNote$[ebp]
  00174	8a 42 49	 mov	 al, BYTE PTR [edx+73]
  00177	50		 push	 eax
  00178	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _CurrentChord$[ebp]
  0017e	51		 push	 ecx
  0017f	8b 55 08	 mov	 edx, DWORD PTR _pNote$[ebp]
  00182	66 8b 42 3c	 mov	 ax, WORD PTR [edx+60]
  00186	50		 push	 eax
  00187	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00195	50		 push	 eax
  00196	ff 52 7c	 call	 DWORD PTR [edx+124]
  00199	85 c0		 test	 eax, eax
  0019b	0f 8c f5 02 00
	00		 jl	 $L74196
  001a1	0f b6 8d 22 ff
	ff ff		 movzx	 ecx, BYTE PTR _bNewMidiValue$74201[ebp]
  001a8	8b 55 08	 mov	 edx, DWORD PTR _pNote$[ebp]
  001ab	0f b6 42 4b	 movzx	 eax, BYTE PTR [edx+75]
  001af	3b c8		 cmp	 ecx, eax
  001b1	0f 84 df 02 00
	00		 je	 $L74196

; 11494:             {
; 11495:                 MUSIC_TIME mtDuration = (pNote->bFlags & DMUS_NOTEF_NOTEON) ? pNote->mtDuration - (mtTime - pNote->mtTime) : pNote->mtTime - mtTime;

  001b7	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  001ba	0f b6 51 45	 movzx	 edx, BYTE PTR [ecx+69]
  001be	83 e2 01	 and	 edx, 1
  001c1	85 d2		 test	 edx, edx
  001c3	74 1c		 je	 SHORT $L76046
  001c5	8b 45 08	 mov	 eax, DWORD PTR _pNote$[ebp]
  001c8	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _mtTime$[ebp]
  001ce	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  001d1	8b 55 08	 mov	 edx, DWORD PTR _pNote$[ebp]
  001d4	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001d7	2b c1		 sub	 eax, ecx
  001d9	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  001df	eb 12		 jmp	 SHORT $L76047
$L76046:
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  001e4	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001e7	2b 95 2c ff ff
	ff		 sub	 edx, DWORD PTR _mtTime$[ebp]
  001ed	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
$L76047:
  001f3	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  001f9	89 85 18 ff ff
	ff		 mov	 DWORD PTR _mtDuration$74204[ebp], eax

; 11496:                 // Make any duration < 1 be 0; this will cause the note not to 
; 11497:                 // sound.  Can happen if the note's logical time is well before
; 11498:                 // its physical time.
; 11499:                 if( mtDuration < 1 ) mtDuration = 0;

  001ff	83 bd 18 ff ff
	ff 01		 cmp	 DWORD PTR _mtDuration$74204[ebp], 1
  00206	7d 0a		 jge	 SHORT $L74205
  00208	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _mtDuration$74204[ebp], 0
$L74205:

; 11500:                 DMUS_PMSG* pNewPMsg = NULL;

  00212	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pNewPMsg$74206[ebp], 0

; 11501:                 if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTE_PMSG), &pNewPMsg )))

  0021c	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _pNewPMsg$74206[ebp]
  00222	51		 push	 ecx
  00223	6a 50		 push	 80			; 00000050H
  00225	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0022b	8b 02		 mov	 eax, DWORD PTR [edx]
  0022d	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00233	51		 push	 ecx
  00234	ff 50 24	 call	 DWORD PTR [eax+36]
  00237	85 c0		 test	 eax, eax
  00239	0f 8c 4d 02 00
	00		 jl	 $L74209

; 11502:                 {
; 11503:                     DMUS_NOTE_PMSG* pNewNote = (DMUS_NOTE_PMSG*)pNewPMsg;

  0023f	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _pNewPMsg$74206[ebp]
  00245	89 95 14 ff ff
	ff		 mov	 DWORD PTR _pNewNote$74210[ebp], edx

; 11504:                     // start by copying the current note into the new one
; 11505:                     pNewNote->dwFlags = pNote->dwFlags;

  0024b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00251	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00254	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00257	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 11506:                     pNewNote->dwPChannel = pNote->dwPChannel;

  0025a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00260	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00263	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00266	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 11507:                     pNewNote->dwVirtualTrackID = pNote->dwVirtualTrackID;

  00269	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  0026f	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00272	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00275	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 11508:                     pNewNote->pTool = pNote->pTool;

  00278	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  0027e	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00281	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00284	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 11509:                     if (pNewNote->pTool) pNewNote->pTool->AddRef();

  00287	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  0028d	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00291	74 18		 je	 SHORT $L74212
  00293	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _pNewNote$74210[ebp]
  00299	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0029c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  002a2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  002a5	8b 12		 mov	 edx, DWORD PTR [edx]
  002a7	51		 push	 ecx
  002a8	ff 52 04	 call	 DWORD PTR [edx+4]
$L74212:

; 11510:                     pNewNote->pGraph = pNote->pGraph;

  002ab	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  002b1	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  002b4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002b7	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 11511:                     if (pNewNote->pGraph) pNewNote->pGraph->AddRef();

  002ba	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  002c0	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  002c4	74 18		 je	 SHORT $L74213
  002c6	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _pNewNote$74210[ebp]
  002cc	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002cf	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  002d5	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002d8	8b 12		 mov	 edx, DWORD PTR [edx]
  002da	51		 push	 ecx
  002db	ff 52 04	 call	 DWORD PTR [edx+4]
$L74213:

; 11512:                     pNewNote->dwType = pNote->dwType;

  002de	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  002e4	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  002e7	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  002ea	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 11513:                     pNewNote->dwVoiceID = pNote->dwVoiceID;

  002ed	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  002f3	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  002f6	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  002f9	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 11514:                     pNewNote->dwGroupID = pNote->dwGroupID;

  002fc	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00302	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00305	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00308	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 11515:                     pNewNote->punkUser = pNote->punkUser;

  0030b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00311	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00314	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00317	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 11516:                     if (pNewNote->punkUser) pNewNote->punkUser->AddRef();

  0031a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00320	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00324	74 18		 je	 SHORT $L74214
  00326	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _pNewNote$74210[ebp]
  0032c	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0032f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00335	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00338	8b 12		 mov	 edx, DWORD PTR [edx]
  0033a	51		 push	 ecx
  0033b	ff 52 04	 call	 DWORD PTR [edx+4]
$L74214:

; 11517:                     pNewNote->wMusicValue = pNote->wMusicValue;

  0033e	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00344	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00347	66 8b 51 3c	 mov	 dx, WORD PTR [ecx+60]
  0034b	66 89 50 3c	 mov	 WORD PTR [eax+60], dx

; 11518:                     pNewNote->wMeasure = pNote->wMeasure;

  0034f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00355	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00358	66 8b 51 3e	 mov	 dx, WORD PTR [ecx+62]
  0035c	66 89 50 3e	 mov	 WORD PTR [eax+62], dx

; 11519:                     pNewNote->nOffset = pNote->nOffset;

  00360	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00366	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00369	66 8b 51 40	 mov	 dx, WORD PTR [ecx+64]
  0036d	66 89 50 40	 mov	 WORD PTR [eax+64], dx

; 11520:                     pNewNote->bBeat = pNote->bBeat;

  00371	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00377	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  0037a	8a 51 42	 mov	 dl, BYTE PTR [ecx+66]
  0037d	88 50 42	 mov	 BYTE PTR [eax+66], dl

; 11521:                     pNewNote->bGrid = pNote->bGrid;

  00380	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00386	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00389	8a 51 43	 mov	 dl, BYTE PTR [ecx+67]
  0038c	88 50 43	 mov	 BYTE PTR [eax+67], dl

; 11522:                     pNewNote->bVelocity = pNote->bVelocity;

  0038f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00395	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  00398	8a 51 44	 mov	 dl, BYTE PTR [ecx+68]
  0039b	88 50 44	 mov	 BYTE PTR [eax+68], dl

; 11523:                     pNewNote->bTimeRange = pNote->bTimeRange;

  0039e	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003a4	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003a7	8a 51 46	 mov	 dl, BYTE PTR [ecx+70]
  003aa	88 50 46	 mov	 BYTE PTR [eax+70], dl

; 11524:                     pNewNote->bDurRange = pNote->bDurRange;

  003ad	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003b3	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003b6	8a 51 47	 mov	 dl, BYTE PTR [ecx+71]
  003b9	88 50 47	 mov	 BYTE PTR [eax+71], dl

; 11525:                     pNewNote->bVelRange = pNote->bVelRange;

  003bc	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003c2	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003c5	8a 51 48	 mov	 dl, BYTE PTR [ecx+72]
  003c8	88 50 48	 mov	 BYTE PTR [eax+72], dl

; 11526:                     pNewNote->bPlayModeFlags = pNote->bPlayModeFlags;

  003cb	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003d1	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003d4	8a 51 49	 mov	 dl, BYTE PTR [ecx+73]
  003d7	88 50 49	 mov	 BYTE PTR [eax+73], dl

; 11527:                     pNewNote->bSubChordLevel = pNote->bSubChordLevel;

  003da	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003e0	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003e3	8a 51 4a	 mov	 dl, BYTE PTR [ecx+74]
  003e6	88 50 4a	 mov	 BYTE PTR [eax+74], dl

; 11528:                     pNewNote->cTranspose = pNote->cTranspose;

  003e9	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003ef	8b 4d 08	 mov	 ecx, DWORD PTR _pNote$[ebp]
  003f2	8a 51 4c	 mov	 dl, BYTE PTR [ecx+76]
  003f5	88 50 4c	 mov	 BYTE PTR [eax+76], dl

; 11529:                     // only things that need to change are flags, MIDI value, start time, and duration
; 11530:                     pNewNote->mtTime = mtTime;

  003f8	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  003fe	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00404	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 11531:                     MusicToReferenceTime(pNewNote->mtTime, &pNewNote->rtTime);

  00407	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _pNewNote$74210[ebp]
  0040d	83 c2 08	 add	 edx, 8
  00410	52		 push	 edx
  00411	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00417	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0041a	51		 push	 ecx
  0041b	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00421	8b 02		 mov	 eax, DWORD PTR [edx]
  00423	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00429	51		 push	 ecx
  0042a	ff 50 14	 call	 DWORD PTR [eax+20]

; 11532:                     pNewNote->mtDuration = mtDuration;

  0042d	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _pNewNote$74210[ebp]
  00433	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _mtDuration$74204[ebp]
  00439	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 11533:                     pNewNote->bMidiValue = bNewMidiValue;

  0043c	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _pNewNote$74210[ebp]
  00442	8a 95 22 ff ff
	ff		 mov	 dl, BYTE PTR _bNewMidiValue$74201[ebp]
  00448	88 51 4b	 mov	 BYTE PTR [ecx+75], dl

; 11534:                     pNewNote->bFlags = DMUS_NOTEF_NOTEON | DMUS_NOTEF_REGENERATE;

  0044b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pNewNote$74210[ebp]
  00451	c6 40 45 11	 mov	 BYTE PTR [eax+69], 17	; 00000011H

; 11535:                     PackNote(pNewPMsg, rtTime + 1); // play the note on

  00455	8b 4d 10	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  00458	83 c1 01	 add	 ecx, 1
  0045b	8b 55 14	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  0045e	83 d2 00	 adc	 edx, 0
  00461	52		 push	 edx
  00462	51		 push	 ecx
  00463	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _pNewPMsg$74206[ebp]
  00469	50		 push	 eax
  0046a	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00470	e8 00 00 00 00	 call	 ?PackNote@CPerformance@@AAEJPAU_DMUS_PMSG@@_J@Z ; CPerformance::PackNote

; 11536:                     *ppNew = pNewPMsg;  // PackNote modifies event to be note-off; queue this

  00475	8b 4d 18	 mov	 ecx, DWORD PTR _ppNew$[ebp]
  00478	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _pNewPMsg$74206[ebp]
  0047e	89 11		 mov	 DWORD PTR [ecx], edx

; 11537:                     // invalidate the current note
; 11538:                     hr = S_OK;

  00480	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 11539:                 }
; 11540:                 else hr = E_OUTOFMEMORY;

  0048a	eb 0a		 jmp	 SHORT $L74196
$L74209:
  0048c	c7 85 28 ff ff
	ff 0e 00 07 80	 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L74196:

; 11541:             }
; 11542:         }
; 11543:     }
; 11544:     return hr;

  00496	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 11545: }

  0049c	8b e5		 mov	 esp, ebp
  0049e	5d		 pop	 ebp
  0049f	c2 14 00	 ret	 20			; 00000014H
?GetChordNotificationStatus@CPerformance@@AAEJPAU_DMUS_NOTE_PMSG@@K_JPAPAU_DMUS_PMSG@@@Z ENDP ; CPerformance::GetChordNotificationStatus
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InScale@@YG_NEEK@Z
_TEXT	SEGMENT
_bMIDI$ = 8
_bRoot$ = 12
_dwScale$ = 16
?InScale@@YG_NEEK@Z PROC NEAR				; InScale, COMDAT

; 10596: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 10597:     TraceI(3, "note: %d root: %d scale: %x\n", bMIDI, bRoot, dwScale);
; 10598:     // shift the note by the scale root, and put it in a one-octave range
; 10599:     bMIDI = ((bMIDI + 12) - (bRoot % 12)) % 12; 

  00004	0f b6 4d 08	 movzx	 ecx, BYTE PTR _bMIDI$[ebp]
  00008	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000b	0f b6 45 0c	 movzx	 eax, BYTE PTR _bRoot$[ebp]
  0000f	99		 cdq
  00010	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  00015	f7 fe		 idiv	 esi
  00017	2b ca		 sub	 ecx, edx
  00019	8b c1		 mov	 eax, ecx
  0001b	99		 cdq
  0001c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00021	f7 f9		 idiv	 ecx
  00023	88 55 08	 mov	 BYTE PTR _bMIDI$[ebp], dl

; 10600:      // merge two octaves of scale into one
; 10601:     dwScale = (dwScale & 0x0fff) | ((dwScale >> 12) & 0x0fff);

  00026	8b 55 10	 mov	 edx, DWORD PTR _dwScale$[ebp]
  00029	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0002f	8b 45 10	 mov	 eax, DWORD PTR _dwScale$[ebp]
  00032	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00035	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003a	0b d0		 or	 edx, eax
  0003c	89 55 10	 mov	 DWORD PTR _dwScale$[ebp], edx

; 10602:     // note n is in scale if there's a bit in position n
; 10603:     TraceI(3, "shifted note: %d shifted scale: %x\n", bMIDI, dwScale);
; 10604:     return ((1 << bMIDI) & dwScale) ? true : false;

  0003f	0f b6 4d 08	 movzx	 ecx, BYTE PTR _bMIDI$[ebp]
  00043	ba 01 00 00 00	 mov	 edx, 1
  00048	d3 e2		 shl	 edx, cl
  0004a	23 55 10	 and	 edx, DWORD PTR _dwScale$[ebp]
  0004d	85 d2		 test	 edx, edx
  0004f	0f 95 c0	 setne	 al

; 10605: }

  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
?InScale@@YG_NEEK@Z ENDP				; InScale
_TEXT	ENDS
PUBLIC	?TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z ; CPerformance::TimeToRhythm
PUBLIC	??_C@_0BO@PEJFPBBM@?$CFs?3?5Invalid?5pointer?5pTimeSig?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@DEDHCBOL@?$CFs?3?5Invalid?5pointer?5pwMeasure?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@PJPJFDFA@?$CFs?3?5Invalid?5pointer?5pbBeat?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@KCGGACOO@?$CFs?3?5Invalid?5pointer?5pbGrid?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@GBHHHLEA@?$CFs?3?5Invalid?5pointer?5pnOffset?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::TimeToRhythm', 00H	; `CPerformance::TimeToRhythm'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@PEJFPBBM@?$CFs?3?5Invalid?5pointer?5pTimeSig?6?$AA@
CONST	SEGMENT
??_C@_0BO@PEJFPBBM@?$CFs?3?5Invalid?5pointer?5pTimeSig?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pTimeSig', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEDHCBOL@?$CFs?3?5Invalid?5pointer?5pwMeasure?6?$AA@
CONST	SEGMENT
??_C@_0BP@DEDHCBOL@?$CFs?3?5Invalid?5pointer?5pwMeasure?6?$AA@ DB '%s: In'
	DB	'valid pointer pwMeasure', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PJPJFDFA@?$CFs?3?5Invalid?5pointer?5pbBeat?6?$AA@
CONST	SEGMENT
??_C@_0BM@PJPJFDFA@?$CFs?3?5Invalid?5pointer?5pbBeat?6?$AA@ DB '%s: Inval'
	DB	'id pointer pbBeat', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KCGGACOO@?$CFs?3?5Invalid?5pointer?5pbGrid?6?$AA@
CONST	SEGMENT
??_C@_0BM@KCGGACOO@?$CFs?3?5Invalid?5pointer?5pbGrid?6?$AA@ DB '%s: Inval'
	DB	'id pointer pbGrid', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBHHHLEA@?$CFs?3?5Invalid?5pointer?5pnOffset?6?$AA@
CONST	SEGMENT
??_C@_0BO@GBHHHLEA@?$CFs?3?5Invalid?5pointer?5pnOffset?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pnOffset', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z
_TEXT	SEGMENT
_lMeasureLength$ = -16
_lTemp$ = -12
_lBeatLength$ = -8
_lGridLength$ = -4
_this$ = 8
_mtTime$ = 12
_pTimeSig$ = 16
_pwMeasure$ = 20
_pbBeat$ = 24
_pbGrid$ = 28
_pnOffset$ = 32
?TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z PROC NEAR ; CPerformance::TimeToRhythm, COMDAT

; 11556: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 11557:     V_INAME(IDirectMusicPerformance::TimeToRhythm);
; 11558:     V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );

  00006	6a 08		 push	 8
  00008	8b 45 10	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L74230
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@PEJFPBBM@?$CFs?3?5Invalid?5pointer?5pTimeSig?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L74230:

; 11559:     V_PTR_WRITE(pwMeasure,WORD);

  0002e	6a 02		 push	 2
  00030	8b 4d 14	 mov	 ecx, DWORD PTR _pwMeasure$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L74233
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DEDHCBOL@?$CFs?3?5Invalid?5pointer?5pwMeasure?6?$AA@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L74233:

; 11560:     V_PTR_WRITE(pbBeat,BYTE);

  00056	6a 01		 push	 1
  00058	8b 55 18	 mov	 edx, DWORD PTR _pbBeat$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00061	85 c0		 test	 eax, eax
  00063	74 19		 je	 SHORT $L74236
  00065	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PJPJFDFA@?$CFs?3?5Invalid?5pointer?5pbBeat?6?$AA@
  0006f	6a ff		 push	 -1
  00071	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	e8 00 00 00 00	 call	 _DebugBreak@0
$L74236:

; 11561:     V_PTR_WRITE(pbGrid,BYTE);

  0007e	6a 01		 push	 1
  00080	8b 45 1c	 mov	 eax, DWORD PTR _pbGrid$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00089	85 c0		 test	 eax, eax
  0008b	74 19		 je	 SHORT $L74239
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@KCGGACOO@?$CFs?3?5Invalid?5pointer?5pbGrid?6?$AA@
  00097	6a ff		 push	 -1
  00099	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	e8 00 00 00 00	 call	 _DebugBreak@0
$L74239:

; 11562:     V_PTR_WRITE(pnOffset,short);

  000a6	6a 02		 push	 2
  000a8	8b 4d 20	 mov	 ecx, DWORD PTR _pnOffset$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  000b1	85 c0		 test	 eax, eax
  000b3	74 19		 je	 SHORT $L74242
  000b5	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z@4QBDB
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@GBHHHLEA@?$CFs?3?5Invalid?5pointer?5pnOffset?6?$AA@
  000bf	6a ff		 push	 -1
  000c1	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	e8 00 00 00 00	 call	 _DebugBreak@0
$L74242:

; 11563: 
; 11564:     long lMeasureLength;
; 11565:     long lBeatLength = DMUS_PPQ;

  000ce	c7 45 f8 00 03
	00 00		 mov	 DWORD PTR _lBeatLength$[ebp], 768 ; 00000300H

; 11566:     long lGridLength;
; 11567: 
; 11568:     if( pTimeSig->bBeat )

  000d5	8b 55 10	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  000d8	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  000dc	85 c0		 test	 eax, eax
  000de	74 12		 je	 SHORT $L74247

; 11569:     {
; 11570:         lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;

  000e0	8b 4d 10	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  000e3	0f b6 49 05	 movzx	 ecx, BYTE PTR [ecx+5]
  000e7	b8 00 0c 00 00	 mov	 eax, 3072		; 00000c00H
  000ec	99		 cdq
  000ed	f7 f9		 idiv	 ecx
  000ef	89 45 f8	 mov	 DWORD PTR _lBeatLength$[ebp], eax
$L74247:

; 11571:     }
; 11572:     lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;

  000f2	8b 55 10	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  000f5	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _lBeatLength$[ebp]
  000fc	0f af c8	 imul	 ecx, eax
  000ff	89 4d f0	 mov	 DWORD PTR _lMeasureLength$[ebp], ecx

; 11573:     if( pTimeSig->wGridsPerBeat )

  00102	8b 55 10	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  00105	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00109	85 c0		 test	 eax, eax
  0010b	74 12		 je	 SHORT $L74248

; 11574:     {
; 11575:         lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;

  0010d	8b 4d 10	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  00110	0f b7 49 06	 movzx	 ecx, WORD PTR [ecx+6]
  00114	8b 45 f8	 mov	 eax, DWORD PTR _lBeatLength$[ebp]
  00117	99		 cdq
  00118	f7 f9		 idiv	 ecx
  0011a	89 45 fc	 mov	 DWORD PTR _lGridLength$[ebp], eax

; 11576:     }
; 11577:     else

  0011d	eb 12		 jmp	 SHORT $L74249
$L74248:

; 11578:     {
; 11579:         lGridLength = lBeatLength / 256;

  0011f	8b 45 f8	 mov	 eax, DWORD PTR _lBeatLength$[ebp]
  00122	99		 cdq
  00123	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00129	03 c2		 add	 eax, edx
  0012b	c1 f8 08	 sar	 eax, 8
  0012e	89 45 fc	 mov	 DWORD PTR _lGridLength$[ebp], eax
$L74249:

; 11580:     }
; 11581:     long lTemp = mtTime - pTimeSig->mtTime;

  00131	8b 55 10	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  00134	8b 45 0c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00137	2b 02		 sub	 eax, DWORD PTR [edx]
  00139	89 45 f4	 mov	 DWORD PTR _lTemp$[ebp], eax

; 11582:     *pwMeasure = (WORD)((lTemp / lMeasureLength));

  0013c	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  0013f	99		 cdq
  00140	f7 7d f0	 idiv	 DWORD PTR _lMeasureLength$[ebp]
  00143	8b 4d 14	 mov	 ecx, DWORD PTR _pwMeasure$[ebp]
  00146	66 89 01	 mov	 WORD PTR [ecx], ax

; 11583:     lTemp = lTemp % lMeasureLength;

  00149	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  0014c	99		 cdq
  0014d	f7 7d f0	 idiv	 DWORD PTR _lMeasureLength$[ebp]
  00150	89 55 f4	 mov	 DWORD PTR _lTemp$[ebp], edx

; 11584:     *pbBeat = (BYTE)(lTemp / lBeatLength);

  00153	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  00156	99		 cdq
  00157	f7 7d f8	 idiv	 DWORD PTR _lBeatLength$[ebp]
  0015a	8b 55 18	 mov	 edx, DWORD PTR _pbBeat$[ebp]
  0015d	88 02		 mov	 BYTE PTR [edx], al

; 11585:     lTemp = lTemp % lBeatLength;

  0015f	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  00162	99		 cdq
  00163	f7 7d f8	 idiv	 DWORD PTR _lBeatLength$[ebp]
  00166	89 55 f4	 mov	 DWORD PTR _lTemp$[ebp], edx

; 11586:     *pbGrid = (BYTE)(lTemp / lGridLength);

  00169	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  0016c	99		 cdq
  0016d	f7 7d fc	 idiv	 DWORD PTR _lGridLength$[ebp]
  00170	8b 4d 1c	 mov	 ecx, DWORD PTR _pbGrid$[ebp]
  00173	88 01		 mov	 BYTE PTR [ecx], al

; 11587:     *pnOffset = (short)(lTemp % lGridLength);

  00175	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  00178	99		 cdq
  00179	f7 7d fc	 idiv	 DWORD PTR _lGridLength$[ebp]
  0017c	8b 45 20	 mov	 eax, DWORD PTR _pnOffset$[ebp]
  0017f	66 89 10	 mov	 WORD PTR [eax], dx

; 11588:     if (*pnOffset > (lGridLength >> 1))

  00182	8b 4d 20	 mov	 ecx, DWORD PTR _pnOffset$[ebp]
  00185	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00188	8b 45 fc	 mov	 eax, DWORD PTR _lGridLength$[ebp]
  0018b	d1 f8		 sar	 eax, 1
  0018d	3b d0		 cmp	 edx, eax
  0018f	7e 69		 jle	 SHORT $L74255

; 11589:     {
; 11590:         *pnOffset -= (short) lGridLength;

  00191	0f bf 4d fc	 movsx	 ecx, WORD PTR _lGridLength$[ebp]
  00195	8b 55 20	 mov	 edx, DWORD PTR _pnOffset$[ebp]
  00198	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0019b	2b c1		 sub	 eax, ecx
  0019d	8b 4d 20	 mov	 ecx, DWORD PTR _pnOffset$[ebp]
  001a0	66 89 01	 mov	 WORD PTR [ecx], ax

; 11591:         (*pbGrid)++;

  001a3	8b 55 1c	 mov	 edx, DWORD PTR _pbGrid$[ebp]
  001a6	8a 02		 mov	 al, BYTE PTR [edx]
  001a8	04 01		 add	 al, 1
  001aa	8b 4d 1c	 mov	 ecx, DWORD PTR _pbGrid$[ebp]
  001ad	88 01		 mov	 BYTE PTR [ecx], al

; 11592:         if (*pbGrid == pTimeSig->wGridsPerBeat)

  001af	8b 55 1c	 mov	 edx, DWORD PTR _pbGrid$[ebp]
  001b2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001b5	8b 4d 10	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  001b8	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  001bc	3b c2		 cmp	 eax, edx
  001be	75 3a		 jne	 SHORT $L74255

; 11593:         {
; 11594:             *pbGrid = 0;

  001c0	8b 45 1c	 mov	 eax, DWORD PTR _pbGrid$[ebp]
  001c3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 11595:             (*pbBeat)++;

  001c6	8b 4d 18	 mov	 ecx, DWORD PTR _pbBeat$[ebp]
  001c9	8a 11		 mov	 dl, BYTE PTR [ecx]
  001cb	80 c2 01	 add	 dl, 1
  001ce	8b 45 18	 mov	 eax, DWORD PTR _pbBeat$[ebp]
  001d1	88 10		 mov	 BYTE PTR [eax], dl

; 11596:             if (*pbBeat == pTimeSig->bBeatsPerMeasure)

  001d3	8b 4d 18	 mov	 ecx, DWORD PTR _pbBeat$[ebp]
  001d6	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001d9	8b 45 10	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  001dc	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001e0	3b d1		 cmp	 edx, ecx
  001e2	75 16		 jne	 SHORT $L74255

; 11597:             {
; 11598:                 *pbBeat = 0;

  001e4	8b 55 18	 mov	 edx, DWORD PTR _pbBeat$[ebp]
  001e7	c6 02 00	 mov	 BYTE PTR [edx], 0

; 11599:                 (*pwMeasure)++;

  001ea	8b 45 14	 mov	 eax, DWORD PTR _pwMeasure$[ebp]
  001ed	66 8b 08	 mov	 cx, WORD PTR [eax]
  001f0	66 83 c1 01	 add	 cx, 1
  001f4	8b 55 14	 mov	 edx, DWORD PTR _pwMeasure$[ebp]
  001f7	66 89 0a	 mov	 WORD PTR [edx], cx
$L74255:

; 11600:             }
; 11601:         }
; 11602:     }
; 11603:     return S_OK;

  001fa	33 c0		 xor	 eax, eax

; 11604: }

  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c2 1c 00	 ret	 28			; 0000001cH
?TimeToRhythm@CPerformance@@QAGJJPAU_DMUS_TIMESIGNATURE@@PAGPAE2PAF@Z ENDP ; CPerformance::TimeToRhythm
_TEXT	ENDS
PUBLIC	?RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z ; CPerformance::RhythmToTime
;	COMDAT ?__szValidateInterfaceName@?1??RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z@4QBDB DB 'I'
	DB	'DirectMusicPerformance::RhythmToTime', 00H	; `CPerformance::RhythmToTime'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z
_TEXT	SEGMENT
_lMeasureLength$ = -16
_lTemp$ = -12
_lBeatLength$ = -8
_lGridLength$ = -4
_this$ = 8
_wMeasure$ = 12
_bBeat$ = 16
_bGrid$ = 20
_nOffset$ = 24
_pTimeSig$ = 28
_pmtTime$ = 32
?RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z PROC NEAR ; CPerformance::RhythmToTime, COMDAT

; 11615: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 11616:     V_INAME(IDirectMusicPerformance::RhythmToTime);
; 11617:     V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );

  00006	6a 08		 push	 8
  00008	8b 45 1c	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L74272
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@PEJFPBBM@?$CFs?3?5Invalid?5pointer?5pTimeSig?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L74272:

; 11618:     V_PTR_WRITE(pmtTime,MUSIC_TIME);

  0002e	6a 04		 push	 4
  00030	8b 4d 20	 mov	 ecx, DWORD PTR _pmtTime$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L74274
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BCCCMJCI@?$CFs?3?5Invalid?5pointer?5pmtTime?6?$AA@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L74274:

; 11619: 
; 11620:     long lMeasureLength;
; 11621:     long lBeatLength = DMUS_PPQ;

  00056	c7 45 f8 00 03
	00 00		 mov	 DWORD PTR _lBeatLength$[ebp], 768 ; 00000300H

; 11622:     long lGridLength;
; 11623: 
; 11624:     if( pTimeSig->bBeat )

  0005d	8b 55 1c	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  00060	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00064	85 c0		 test	 eax, eax
  00066	74 12		 je	 SHORT $L74278

; 11625:     {
; 11626:         lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;

  00068	8b 4d 1c	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  0006b	0f b6 49 05	 movzx	 ecx, BYTE PTR [ecx+5]
  0006f	b8 00 0c 00 00	 mov	 eax, 3072		; 00000c00H
  00074	99		 cdq
  00075	f7 f9		 idiv	 ecx
  00077	89 45 f8	 mov	 DWORD PTR _lBeatLength$[ebp], eax
$L74278:

; 11627:     }
; 11628:     lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;

  0007a	8b 55 1c	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  0007d	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _lBeatLength$[ebp]
  00084	0f af c8	 imul	 ecx, eax
  00087	89 4d f0	 mov	 DWORD PTR _lMeasureLength$[ebp], ecx

; 11629:     if( pTimeSig->wGridsPerBeat )

  0008a	8b 55 1c	 mov	 edx, DWORD PTR _pTimeSig$[ebp]
  0008d	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00091	85 c0		 test	 eax, eax
  00093	74 12		 je	 SHORT $L74279

; 11630:     {
; 11631:         lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;

  00095	8b 4d 1c	 mov	 ecx, DWORD PTR _pTimeSig$[ebp]
  00098	0f b7 49 06	 movzx	 ecx, WORD PTR [ecx+6]
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _lBeatLength$[ebp]
  0009f	99		 cdq
  000a0	f7 f9		 idiv	 ecx
  000a2	89 45 fc	 mov	 DWORD PTR _lGridLength$[ebp], eax

; 11632:     }
; 11633:     else

  000a5	eb 12		 jmp	 SHORT $L74280
$L74279:

; 11634:     {
; 11635:         lGridLength = lBeatLength / 256;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _lBeatLength$[ebp]
  000aa	99		 cdq
  000ab	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b1	03 c2		 add	 eax, edx
  000b3	c1 f8 08	 sar	 eax, 8
  000b6	89 45 fc	 mov	 DWORD PTR _lGridLength$[ebp], eax
$L74280:

; 11636:     }
; 11637:     long lTemp = nOffset + pTimeSig->mtTime;

  000b9	0f bf 55 18	 movsx	 edx, WORD PTR _nOffset$[ebp]
  000bd	8b 45 1c	 mov	 eax, DWORD PTR _pTimeSig$[ebp]
  000c0	03 10		 add	 edx, DWORD PTR [eax]
  000c2	89 55 f4	 mov	 DWORD PTR _lTemp$[ebp], edx

; 11638:     lTemp += wMeasure * lMeasureLength;

  000c5	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wMeasure$[ebp]
  000c9	0f af 4d f0	 imul	 ecx, DWORD PTR _lMeasureLength$[ebp]
  000cd	8b 55 f4	 mov	 edx, DWORD PTR _lTemp$[ebp]
  000d0	03 d1		 add	 edx, ecx
  000d2	89 55 f4	 mov	 DWORD PTR _lTemp$[ebp], edx

; 11639:     lTemp += bBeat * lBeatLength;

  000d5	0f b6 45 10	 movzx	 eax, BYTE PTR _bBeat$[ebp]
  000d9	0f af 45 f8	 imul	 eax, DWORD PTR _lBeatLength$[ebp]
  000dd	8b 4d f4	 mov	 ecx, DWORD PTR _lTemp$[ebp]
  000e0	03 c8		 add	 ecx, eax
  000e2	89 4d f4	 mov	 DWORD PTR _lTemp$[ebp], ecx

; 11640:     lTemp += bGrid * lGridLength;

  000e5	0f b6 55 14	 movzx	 edx, BYTE PTR _bGrid$[ebp]
  000e9	0f af 55 fc	 imul	 edx, DWORD PTR _lGridLength$[ebp]
  000ed	8b 45 f4	 mov	 eax, DWORD PTR _lTemp$[ebp]
  000f0	03 c2		 add	 eax, edx
  000f2	89 45 f4	 mov	 DWORD PTR _lTemp$[ebp], eax

; 11641:     *pmtTime = lTemp;

  000f5	8b 4d 20	 mov	 ecx, DWORD PTR _pmtTime$[ebp]
  000f8	8b 55 f4	 mov	 edx, DWORD PTR _lTemp$[ebp]
  000fb	89 11		 mov	 DWORD PTR [ecx], edx

; 11642:     return S_OK;

  000fd	33 c0		 xor	 eax, eax

; 11643: }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 1c 00	 ret	 28			; 0000001cH
?RhythmToTime@CPerformance@@QAGJGEEFPAU_DMUS_TIMESIGNATURE@@PAJ@Z ENDP ; CPerformance::RhythmToTime
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\tempotrk.h
_TEXT	ENDS
;	COMDAT ??0PrivateTempo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0PrivateTempo@@QAE@XZ PROC NEAR			; PrivateTempo::PrivateTempo, COMDAT
; _this$ = ecx

; 18   :     PrivateTempo() : dblTempo(120.), mtTime(0), mtDelta(0), fLast(false) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	c7 40 04 00 00
	5e 40		 mov	 DWORD PTR [eax+4], 1079902208 ; 405e0000H
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??0PrivateTempo@@QAE@XZ ENDP				; PrivateTempo::PrivateTempo
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.h
_TEXT	ENDS
;	COMDAT ??0?$TList@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TList@UPrivateTempo@@@@QAE@XZ PROC NEAR		; TList<PrivateTempo>::TList<PrivateTempo>, COMDAT
; _this$ = ecx

; 55   :     TList() {m_pHead=NULL;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$TList@UPrivateTempo@@@@QAE@XZ ENDP			; TList<PrivateTempo>::TList<PrivateTempo>
_TEXT	ENDS
PUBLIC	?Delete@?$TListItem@UPrivateTempo@@@@SGXPAV1@@Z	; TListItem<PrivateTempo>::Delete
; Function compile flags: /Odt
;	COMDAT ??1?$TList@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TList@UPrivateTempo@@@@QAE@XZ PROC NEAR		; TList<PrivateTempo>::~TList<PrivateTempo>, COMDAT
; _this$ = ecx

; 57   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		//if (m_pHead != NULL) delete m_pHead;
; 59   : 		TListItem<T>::Delete(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Delete@?$TListItem@UPrivateTempo@@@@SGXPAV1@@Z ; TListItem<PrivateTempo>::Delete

; 60   : 	} // new destructor

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$TList@UPrivateTempo@@@@QAE@XZ ENDP			; TList<PrivateTempo>::~TList<PrivateTempo>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ PROC NEAR ; TList<PrivateTempo>::GetHead, COMDAT
; _this$ = ecx

; 61   :     TListItem<T> *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@?$TList@UPrivateTempo@@@@QBEPAV?$TListItem@UPrivateTempo@@@@XZ ENDP ; TList<PrivateTempo>::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z PROC NEAR ; TList<PrivateTempo>::AddHead, COMDAT
; _this$ = ecx

; 80   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : //            assert(pItem!=NULL);
; 82   :             pItem->SetNext(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00010	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z ; TListItem<PrivateTempo>::SetNext

; 83   :             m_pHead=pItem;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 84   :         }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?AddHead@?$TList@UPrivateTempo@@@@QAEXPAV?$TListItem@UPrivateTempo@@@@@Z ENDP ; TList<PrivateTempo>::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TListItem@UPrivateTempo@@@@QAE@XZ PROC NEAR	; TListItem<PrivateTempo>::TListItem<PrivateTempo>, COMDAT
; _this$ = ecx

; 28   :     TListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0PrivateTempo@@QAE@XZ	; PrivateTempo::PrivateTempo
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0?$TListItem@UPrivateTempo@@@@QAE@XZ ENDP		; TListItem<PrivateTempo>::TListItem<PrivateTempo>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UPrivateTempo@@@@QAE@ABUPrivateTempo@@@Z
_TEXT	SEGMENT
_this$ = -4
_item$ = 8
??0?$TListItem@UPrivateTempo@@@@QAE@ABUPrivateTempo@@@Z PROC NEAR ; TListItem<PrivateTempo>::TListItem<PrivateTempo>, COMDAT
; _this$ = ecx

; 31   :     TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0PrivateTempo@@QAE@XZ	; PrivateTempo::PrivateTempo
  00011	8b 75 08	 mov	 esi, DWORD PTR _item$[ebp]
  00014	b9 06 00 00 00	 mov	 ecx, 6
  00019	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0001c	f3 a5		 rep movsd
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0?$TListItem@UPrivateTempo@@@@QAE@ABUPrivateTempo@@@Z ENDP ; TListItem<PrivateTempo>::TListItem<PrivateTempo>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ PROC NEAR ; TListItem<PrivateTempo>::GetNext, COMDAT
; _this$ = ecx

; 32   :     TListItem<T> *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetNext@?$TListItem@UPrivateTempo@@@@QBEPAV1@XZ ENDP	; TListItem<PrivateTempo>::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z PROC NEAR ; TListItem<PrivateTempo>::SetNext, COMDAT
; _this$ = ecx

; 33   :     void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNext@?$TListItem@UPrivateTempo@@@@QAEXPAV1@@Z ENDP	; TListItem<PrivateTempo>::SetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ PROC NEAR ; TListItem<PrivateTempo>::GetItemValue, COMDAT
; _this$ = ecx

; 40   :     T& GetItemValue() { return m_Tinfo; }  // additional member function

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?GetItemValue@?$TListItem@UPrivateTempo@@@@QAEAAUPrivateTempo@@XZ ENDP ; TListItem<PrivateTempo>::GetItemValue
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.cpp
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UPrivateTempo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TListItem@UPrivateTempo@@@@QAE@XZ PROC NEAR	; TListItem<PrivateTempo>::~TListItem<PrivateTempo>, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	//if (m_pNext != NULL) { delete m_pNext; }
; 22   : 	// IMPORTANT: user of the list is required to delete content first!
; 23   : 	//ZeroMemory(&m_Tinfo, sizeof(T));
; 24   : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$TListItem@UPrivateTempo@@@@QAE@XZ ENDP		; TListItem<PrivateTempo>::~TListItem<PrivateTempo>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UPrivateTempo@@@@SGXPAV1@@Z
_TEXT	SEGMENT
tv70 = -20
$T76094 = -16
$T76093 = -12
_pScan$ = -8
_pNext$ = -4
_pFirst$ = 8
?Delete@?$TListItem@UPrivateTempo@@@@SGXPAV1@@Z PROC NEAR ; TListItem<PrivateTempo>::Delete, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 29   : 	TListItem<T>* pScan = pFirst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pFirst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 30   : 	TListItem<T>* pNext = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0
$L74421:

; 31   : 	while (pScan)

  00013	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00017	74 39		 je	 SHORT $L74417

; 32   : 	{
; 33   : 		pNext = pScan->m_pNext;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0001c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0001f	89 55 fc	 mov	 DWORD PTR _pNext$[ebp], edx

; 34   : 		delete pScan;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T76094[ebp], eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T76094[ebp]
  0002b	89 4d f4	 mov	 DWORD PTR $T76093[ebp], ecx
  0002e	83 7d f4 00	 cmp	 DWORD PTR $T76093[ebp], 0
  00032	74 0f		 je	 SHORT $L76095
  00034	6a 01		 push	 1
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T76093[ebp]
  00039	e8 00 00 00 00	 call	 ??_G?$TListItem@UPrivateTempo@@@@QAEPAXI@Z
  0003e	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00041	eb 07		 jmp	 SHORT $L76096
$L76095:
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L76096:

; 35   : 		pScan = pNext;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 36   : 	}

  00050	eb c1		 jmp	 SHORT $L74421
$L74417:

; 37   : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Delete@?$TListItem@UPrivateTempo@@@@SGXPAV1@@Z ENDP	; TListItem<PrivateTempo>::Delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CPerformance@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; CPerformance::QueryInterface, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
?QueryInterface@CPerformance@@W3AGJABU_GUID@@PAPAX@Z ENDP ; CPerformance::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CPerformance@@W3AGKXZ PROC NEAR			; CPerformance::AddRef, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CPerformance@@UAGKXZ ; CPerformance::AddRef
?AddRef@CPerformance@@W3AGKXZ ENDP			; CPerformance::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@W3AGKXZ
_TEXT	SEGMENT
?Release@CPerformance@@W3AGKXZ PROC NEAR		; CPerformance::Release, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CPerformance@@UAGKXZ ; CPerformance::Release
?Release@CPerformance@@W3AGKXZ ENDP			; CPerformance::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CPerformance@@W7AGJABU_GUID@@PAPAX@Z PROC NEAR ; CPerformance::QueryInterface, COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
?QueryInterface@CPerformance@@W7AGJABU_GUID@@PAPAX@Z ENDP ; CPerformance::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@CPerformance@@W7AGKXZ PROC NEAR			; CPerformance::AddRef, COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CPerformance@@UAGKXZ ; CPerformance::AddRef
?AddRef@CPerformance@@W7AGKXZ ENDP			; CPerformance::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@W7AGKXZ
_TEXT	SEGMENT
?Release@CPerformance@@W7AGKXZ PROC NEAR		; CPerformance::Release, COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?Release@CPerformance@@UAGKXZ ; CPerformance::Release
?Release@CPerformance@@W7AGKXZ ENDP			; CPerformance::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPerformance@@WM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CPerformance@@WM@AGJABU_GUID@@PAPAX@Z PROC NEAR ; CPerformance::QueryInterface, COMDAT
  00000	83 6c 24 04 0c	 sub	 DWORD PTR [esp+4], 12	; 0000000cH
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CPerformance@@UAGJABU_GUID@@PAPAX@Z ; CPerformance::QueryInterface
?QueryInterface@CPerformance@@WM@AGJABU_GUID@@PAPAX@Z ENDP ; CPerformance::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CPerformance@@WM@AGKXZ
_TEXT	SEGMENT
?AddRef@CPerformance@@WM@AGKXZ PROC NEAR		; CPerformance::AddRef, COMDAT
  00000	83 6c 24 04 0c	 sub	 DWORD PTR [esp+4], 12	; 0000000cH
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CPerformance@@UAGKXZ ; CPerformance::AddRef
?AddRef@CPerformance@@WM@AGKXZ ENDP			; CPerformance::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CPerformance@@WM@AGKXZ
_TEXT	SEGMENT
?Release@CPerformance@@WM@AGKXZ PROC NEAR		; CPerformance::Release, COMDAT
  00000	83 6c 24 04 0c	 sub	 DWORD PTR [esp+4], 12	; 0000000cH
  00005	e9 00 00 00 00	 jmp	 ?Release@CPerformance@@UAGKXZ ; CPerformance::Release
?Release@CPerformance@@WM@AGKXZ ENDP			; CPerformance::Release
_TEXT	ENDS
END
