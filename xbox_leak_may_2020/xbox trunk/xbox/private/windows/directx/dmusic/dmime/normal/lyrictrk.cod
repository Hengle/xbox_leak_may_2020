; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\lyrictrk.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DL@BCAKFCIM@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@JJOBABEE@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@DAMKBDFL@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FO@KPIPKING@?$CI?$CIchar?$CK?$CJ?$CGpmsg?4p?9?$DOwszString?$FLwcsle@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0LE@CJKIDNAD@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@CBOHEJO@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@KNCKBPPB@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@IPNAMLAD@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEJEHDBH@p?9?$DOdwSize?5?$DN?$DN?5cb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ?LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayItem@CLyricsTrack@@MAEJABULyricInfo@@AAU?$CStandardStateData@ULyricInfo@@@@PAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KJ_J_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadLyric@CLyricsTrack@@AAEJVRiffIter@SmartRef@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@PAUIDirectMusicPerformance@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StampAndSend@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEXPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_LYRICSTRACK_EVENTHEADER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??IWString@SmartRef@@QAEPAPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06ONCILBNO@?$CBm_psz?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BWString@SmartRef@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?id@RiffIter@SmartRef@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?validate@RiffIter@SmartRef@@ABE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hr@RiffIter@SmartRef@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRiffIter@SmartRef@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?Descend@RiffIter@SmartRef@@QAE?AV12@XZ		; SmartRef::RiffIter::Descend
PUBLIC	??BRiffIter@SmartRef@@QBE_NXZ			; SmartRef::RiffIter::operator bool
PUBLIC	?hr@RiffIter@SmartRef@@QBEJXZ			; SmartRef::RiffIter::hr
PUBLIC	?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ	; SmartRef::RiffIter::type
PUBLIC	?id@RiffIter@SmartRef@@QBEKXZ			; SmartRef::RiffIter::id
PUBLIC	?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z ; `CLyricsTrack::LoadRiff'::`2'::LocalFunction::HrFailOK
PUBLIC	??_C@_0DL@BCAKFCIM@Error?3?5Unable?5to?5load?5lyric?5trac@ ; `string'
PUBLIC	??_C@_0DL@JJOBABEE@Error?3?5Unable?5to?5load?5lyric?5trac@ ; `string'
PUBLIC	?LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z ; CLyricsTrack::LoadRiff
PUBLIC	?LoadLyric@CLyricsTrack@@AAEJVRiffIter@SmartRef@@@Z ; CLyricsTrack::LoadLyric
EXTRN	??1RiffIter@SmartRef@@QAE@XZ:NEAR		; SmartRef::RiffIter::~RiffIter
EXTRN	??ERiffIter@SmartRef@@QAEAAV01@XZ:NEAR		; SmartRef::RiffIter::operator++
EXTRN	?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z:NEAR ; SmartRef::RiffIter::Find
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
;	COMDAT ??_C@_0DL@BCAKFCIM@Error?3?5Unable?5to?5load?5lyric?5trac@
; File c:\xbox\private\windows\directx\dmusic\dmime\lyrictrk.cpp
CONST	SEGMENT
??_C@_0DL@BCAKFCIM@Error?3?5Unable?5to?5load?5lyric?5trac@ DB 'Error: Una'
	DB	'ble to load lyric track: List ''lyrt'' not found.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JJOBABEE@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT
??_C@_0DL@JJOBABEE@Error?3?5Unable?5to?5load?5lyric?5trac@ DB 'Error: Una'
	DB	'ble to load lyric track: List ''lyrl'' not found.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT
_this$ = -148
$T69943 = -144
$T69942 = -140
$T69940 = -132
$T69939 = -128
$T69938 = -124
_hr$69477 = -120
_riTrackForm$ = -116
_hr$ = -60
_riEvent$ = -56
_ri$ = 8
_pIDMLoader$ = 12
?LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z PROC NEAR ; CLyricsTrack::LoadRiff, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 18   : 	struct LocalFunction
; 19   : 	{
; 20   : 		// Helper used by the LoadRiff function when we expected to find something
; 21   : 		// but a RiffIter becomes false.  In this case, if it has a success HR
; 22   : 		// indicating there were no more items then we return DMUS_E_INVALID_LYRICSTRACK
; 23   : 		// because the stream didn't contain the data we expected.  If it has a
; 24   : 		// failure hr, it was unable to read from the stream and we return its HR.
; 25   : 		static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
; 26   : 		{
; 27   : 			HRESULT hr = ri.hr();
; 28   : 			return SUCCEEDED(hr) ? DMUS_E_INVALID_LYRICSTRACK : hr;
; 29   : 		}
; 30   : 	};
; 31   : 
; 32   : 	HRESULT hr = S_OK;

  0000f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 33   : 
; 34   : 	// find <lyrt>
; 35   : 	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACK_LIST))

  00016	68 6c 79 72 74	 push	 1953659244		; 7472796cH
  0001b	6a 01		 push	 1
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  00020	e8 00 00 00 00	 call	 ?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z ; SmartRef::RiffIter::Find
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	75 29		 jne	 SHORT $L69440

; 36   : 	{
; 37   : #ifdef DBG
; 38   : 		if (SUCCEEDED(ri.hr()))

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  00036	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  0003b	85 c0		 test	 eax, eax
  0003d	7c 0f		 jl	 SHORT $L69442

; 39   : 		{
; 40   : 			Trace(1, "Error: Unable to load lyric track: List 'lyrt' not found.\n");

  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@BCAKFCIM@Error?3?5Unable?5to?5load?5lyric?5trac@
  00044	6a 01		 push	 1
  00046	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004b	83 c4 08	 add	 esp, 8
$L69442:

; 41   : 		}
; 42   : #endif
; 43   : 		return LocalFunction::HrFailOK(ri);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z ; `CLyricsTrack::LoadRiff'::`2'::LocalFunction::HrFailOK
  00057	e9 6a 01 00 00	 jmp	 $L69420
$L69440:

; 44   : 	}
; 45   : 
; 46   : 	// find <lyrl>
; 47   : 	SmartRef::RiffIter riTrackForm = ri.Descend();

  0005c	8d 55 8c	 lea	 edx, DWORD PTR _riTrackForm$[ebp]
  0005f	52		 push	 edx
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  00063	e8 00 00 00 00	 call	 ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ; SmartRef::RiffIter::Descend

; 48   : 	if (!riTrackForm)

  00068	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  0006b	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00070	0f b6 c0	 movzx	 eax, al
  00073	85 c0		 test	 eax, eax
  00075	75 1b		 jne	 SHORT $L69446

; 49   : 		return riTrackForm.hr();

  00077	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  0007a	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  0007f	89 45 84	 mov	 DWORD PTR $T69938[ebp], eax
  00082	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  00085	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  0008a	8b 45 84	 mov	 eax, DWORD PTR $T69938[ebp]
  0008d	e9 34 01 00 00	 jmp	 $L69420
$L69446:

; 50   : 	if (!riTrackForm.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACKEVENTS_LIST))

  00092	68 6c 79 72 6c	 push	 1819441516		; 6c72796cH
  00097	6a 01		 push	 1
  00099	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  0009c	e8 00 00 00 00	 call	 ?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z ; SmartRef::RiffIter::Find
  000a1	8b c8		 mov	 ecx, eax
  000a3	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  000a8	0f b6 c8	 movzx	 ecx, al
  000ab	85 c9		 test	 ecx, ecx
  000ad	75 37		 jne	 SHORT $L69456

; 51   : 	{
; 52   : #ifdef DBG
; 53   : 		if (SUCCEEDED(riTrackForm.hr()))

  000af	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  000b2	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  000b7	85 c0		 test	 eax, eax
  000b9	7c 0f		 jl	 SHORT $L69458

; 54   : 		{
; 55   : 			Trace(1, "Error: Unable to load lyric track: List 'lyrl' not found.\n");

  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@JJOBABEE@Error?3?5Unable?5to?5load?5lyric?5trac@
  000c0	6a 01		 push	 1
  000c2	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c7	83 c4 08	 add	 esp, 8
$L69458:

; 56   : 		}
; 57   : #endif
; 58   : 		return LocalFunction::HrFailOK(riTrackForm);

  000ca	8d 55 8c	 lea	 edx, DWORD PTR _riTrackForm$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 ?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z ; `CLyricsTrack::LoadRiff'::`2'::LocalFunction::HrFailOK
  000d3	89 45 80	 mov	 DWORD PTR $T69939[ebp], eax
  000d6	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  000d9	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  000de	8b 45 80	 mov	 eax, DWORD PTR $T69939[ebp]
  000e1	e9 e0 00 00 00	 jmp	 $L69420
$L69456:

; 59   : 	}
; 60   : 
; 61   : 	// process each event <lyre>
; 62   : 	SmartRef::RiffIter riEvent = riTrackForm.Descend();

  000e6	8d 45 c8	 lea	 eax, DWORD PTR _riEvent$[ebp]
  000e9	50		 push	 eax
  000ea	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  000ed	e8 00 00 00 00	 call	 ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ; SmartRef::RiffIter::Descend

; 63   : 	if (!riEvent)

  000f2	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  000f5	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	85 c9		 test	 ecx, ecx
  000ff	75 29		 jne	 SHORT $L69463

; 64   : 		return riEvent.hr();

  00101	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  00104	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  00109	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T69940[ebp], eax
  0010f	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  00112	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00117	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  0011a	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  0011f	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T69940[ebp]
  00125	e9 9c 00 00 00	 jmp	 $L69420
$L69463:

; 65   : 
; 66   : 	for ( ; riEvent; ++riEvent)

  0012a	eb 08		 jmp	 SHORT $L69465
$L69466:
  0012c	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  0012f	e8 00 00 00 00	 call	 ??ERiffIter@SmartRef@@QAEAAV01@XZ ; SmartRef::RiffIter::operator++
$L69465:
  00134	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  00137	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  0013c	0f b6 d0	 movzx	 edx, al
  0013f	85 d2		 test	 edx, edx
  00141	74 5f		 je	 SHORT $L69467

; 67   : 	{
; 68   : 		if (riEvent.type() == SmartRef::RiffIter::List && riEvent.id() == DMUS_FOURCC_LYRICSTRACKEVENT_LIST)

  00143	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  00146	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  0014b	83 f8 01	 cmp	 eax, 1
  0014e	75 50		 jne	 SHORT $L69476
  00150	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  00153	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  00158	3d 6c 79 72 65	 cmp	 eax, 1702001004		; 6572796cH
  0015d	75 41		 jne	 SHORT $L69476

; 69   : 		{
; 70   : 			HRESULT hr = this->LoadLyric(riEvent.Descend());

  0015f	83 ec 38	 sub	 esp, 56			; 00000038H
  00162	54		 push	 esp
  00163	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  00166	e8 00 00 00 00	 call	 ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ; SmartRef::RiffIter::Descend
  0016b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?LoadLyric@CLyricsTrack@@AAEJVRiffIter@SmartRef@@@Z ; CLyricsTrack::LoadLyric
  00176	89 45 88	 mov	 DWORD PTR _hr$69477[ebp], eax

; 71   : 			if (FAILED(hr))

  00179	83 7d 88 00	 cmp	 DWORD PTR _hr$69477[ebp], 0
  0017d	7d 21		 jge	 SHORT $L69476

; 72   : 				return hr;

  0017f	8b 45 88	 mov	 eax, DWORD PTR _hr$69477[ebp]
  00182	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T69942[ebp], eax
  00188	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  0018b	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00190	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  00193	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00198	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T69942[ebp]
  0019e	eb 26		 jmp	 SHORT $L69420
$L69476:

; 73   : 		}
; 74   : 	}

  001a0	eb 8a		 jmp	 SHORT $L69466
$L69467:

; 75   : 	return riEvent.hr();

  001a2	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  001a5	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  001aa	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T69943[ebp], eax
  001b0	8d 4d c8	 lea	 ecx, DWORD PTR _riEvent$[ebp]
  001b3	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  001b8	8d 4d 8c	 lea	 ecx, DWORD PTR _riTrackForm$[ebp]
  001bb	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  001c0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T69943[ebp]
$L69420:

; 76   : }

  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c2 08 00	 ret	 8
?LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z ENDP ; CLyricsTrack::LoadRiff
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z
_TEXT	SEGMENT
tv67 = -8
_hr$ = -4
_ri$ = 8
?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z PROC NEAR ; `CLyricsTrack::LoadRiff'::`2'::LocalFunction::HrFailOK, COMDAT

; 26   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 27   : 			HRESULT hr = ri.hr();

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  00009	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  0000e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 28   : 			return SUCCEEDED(hr) ? DMUS_E_INVALID_LYRICSTRACK : hr;

  00011	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00015	7c 09		 jl	 SHORT $L69947
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR tv67[ebp], -2147467259 ; 80004005H
  0001e	eb 06		 jmp	 SHORT $L69948
$L69947:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
$L69948:
  00026	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]

; 29   : 		}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?HrFailOK@LocalFunction@?1??LoadRiff@CLyricsTrack@@MAEJAAVRiffIter@SmartRef@@PAUIDirectMusicLoader@@@Z@SGJABV45@@Z ENDP ; `CLyricsTrack::LoadRiff'::`2'::LocalFunction::HrFailOK
_TEXT	ENDS
PUBLIC	?PlayItem@CLyricsTrack@@MAEJABULyricInfo@@AAU?$CStandardStateData@ULyricInfo@@@@PAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KJ_J_N@Z ; CLyricsTrack::PlayItem
PUBLIC	??0?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@PAUIDirectMusicPerformance@@I@Z ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::PMsg<_DMUS_LYRIC_PMSG>
PUBLIC	??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ	; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::~PMsg<_DMUS_LYRIC_PMSG>
PUBLIC	?StampAndSend@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEXPAUIDirectMusicGraph@@@Z ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::StampAndSend
PUBLIC	?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ	; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::hr
PUBLIC	??_C@_0DK@DAMKBDFL@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0FO@KPIPKING@?$CI?$CIchar?$CK?$CJ?$CGpmsg?4p?9?$DOwszString?$FLwcsle@ ; `string'
PUBLIC	??BWString@SmartRef@@QBEPBGXZ			; SmartRef::WString::operator unsigned short const *
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
EXTRN	_IID_IDirectMusicGraph:BYTE
EXTRN	_wcscpy:NEAR
EXTRN	_wcslen:NEAR
;	COMDAT ??_C@_0DK@DAMKBDFL@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@DAMKBDFL@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\lyrictrk.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@KPIPKING@?$CI?$CIchar?$CK?$CJ?$CGpmsg?4p?9?$DOwszString?$FLwcsle@
CONST	SEGMENT
??_C@_0FO@KPIPKING@?$CI?$CIchar?$CK?$CJ?$CGpmsg?4p?9?$DOwszString?$FLwcsle@ DB '('
	DB	'(char*)&pmsg.p->wszString[wcslen(item.wstrText)]) + 1 < (((ch'
	DB	'ar*)(pmsg.p)) + pmsg.p->dwSize)', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PlayItem@CLyricsTrack@@MAEJABULyricInfo@@AAU?$CStandardStateData@ULyricInfo@@@@PAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KJ_J_N@Z
_TEXT	SEGMENT
_this$ = -32
$T69954 = -28
$T69952 = -24
_pGraph$ = -20
_pmsg$ = -16
_hrG$ = -4
_item$ = 8
_state$ = 12
_pPerf$ = 16
_pSegSt$ = 20
_dwVirtualID$ = 24
_mtOffset$ = 28
_rtOffset$ = 32
_fClockTime$ = 40
?PlayItem@CLyricsTrack@@MAEJABULyricInfo@@AAU?$CStandardStateData@ULyricInfo@@@@PAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KJ_J_N@Z PROC NEAR ; CLyricsTrack::PlayItem, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 92   : 	// get the graph from the segment state
; 93   : 	IDirectMusicGraph *pGraph = NULL;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pGraph$[ebp], 0

; 94   : 	HRESULT hrG = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&pGraph));

  00010	8d 45 ec	 lea	 eax, DWORD PTR _pGraph$[ebp]
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGraph
  00019	8b 4d 14	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 45 14	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  00021	50		 push	 eax
  00022	ff 12		 call	 DWORD PTR [edx]
  00024	89 45 fc	 mov	 DWORD PTR _hrG$[ebp], eax

; 95   : 	if (FAILED(hrG))

  00027	83 7d fc 00	 cmp	 DWORD PTR _hrG$[ebp], 0
  0002b	7d 08		 jge	 SHORT $L69503

; 96   : 		return hrG;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _hrG$[ebp]
  00030	e9 47 01 00 00	 jmp	 $L69498
$L69503:

; 97   : 
; 98   : 	SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(pPerf, 2 * wcslen(item.wstrText));

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00038	83 c1 10	 add	 ecx, 16			; 00000010H
  0003b	e8 00 00 00 00	 call	 ??BWString@SmartRef@@QBEPBGXZ ; SmartRef::WString::operator unsigned short const *
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _wcslen
  00046	83 c4 04	 add	 esp, 4
  00049	d1 e0		 shl	 eax, 1
  0004b	50		 push	 eax
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0004f	51		 push	 ecx
  00050	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  00053	e8 00 00 00 00	 call	 ??0?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@PAUIDirectMusicPerformance@@I@Z ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::PMsg<_DMUS_LYRIC_PMSG>

; 99   : 	if (FAILED(pmsg.hr())) {

  00058	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  0005b	e8 00 00 00 00	 call	 ?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::hr
  00060	85 c0		 test	 eax, eax
  00062	7d 27		 jge	 SHORT $L69526

; 100  : 		pGraph->Release();

  00064	8b 55 ec	 mov	 edx, DWORD PTR _pGraph$[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	8b 4d ec	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  0006c	51		 push	 ecx
  0006d	ff 50 08	 call	 DWORD PTR [eax+8]

; 101  : 		return pmsg.hr();

  00070	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  00073	e8 00 00 00 00	 call	 ?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::hr
  00078	89 45 e8	 mov	 DWORD PTR $T69952[ebp], eax
  0007b	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::~PMsg<_DMUS_LYRIC_PMSG>
  00083	8b 45 e8	 mov	 eax, DWORD PTR $T69952[ebp]
  00086	e9 f1 00 00 00	 jmp	 $L69498
$L69526:

; 102  : 	}
; 103  : 
; 104  : 	assert(((char*)&pmsg.p->wszString[wcslen(item.wstrText)]) + 1 < (((char*)(pmsg.p)) + pmsg.p->dwSize)); // just to make sure we haven't miscalculated.  the last byte of the null of the string should fall before the byte just beyond the extent of the struct (and it could be several bytes before if the DMUS_LYRIC_PMSG struct ended up being padded to come out to an even multiple of bytes.

  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0008e	83 c1 10	 add	 ecx, 16			; 00000010H
  00091	e8 00 00 00 00	 call	 ??BWString@SmartRef@@QBEPBGXZ ; SmartRef::WString::operator unsigned short const *
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _wcslen
  0009c	83 c4 04	 add	 esp, 4
  0009f	8b 55 f0	 mov	 edx, DWORD PTR _pmsg$[ebp]
  000a2	8d 44 42 39	 lea	 eax, DWORD PTR [edx+eax*2+57]
  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  000a9	8b 55 f0	 mov	 edx, DWORD PTR _pmsg$[ebp]
  000ac	03 11		 add	 edx, DWORD PTR [ecx]
  000ae	3b c2		 cmp	 eax, edx
  000b0	72 11		 jb	 SHORT $L69953
  000b2	6a 68		 push	 104			; 00000068H
  000b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@DAMKBDFL@c?3?2xbox?2private?2windows?2directx?2@
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FO@KPIPKING@?$CI?$CIchar?$CK?$CJ?$CGpmsg?4p?9?$DOwszString?$FLwcsle@
  000be	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L69953:

; 105  : 	wcscpy(pmsg.p->wszString, item.wstrText);

  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000c6	83 c1 10	 add	 ecx, 16			; 00000010H
  000c9	e8 00 00 00 00	 call	 ??BWString@SmartRef@@QBEPBGXZ ; SmartRef::WString::operator unsigned short const *
  000ce	50		 push	 eax
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  000d2	83 c1 38	 add	 ecx, 56			; 00000038H
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 _wcscpy
  000db	83 c4 08	 add	 esp, 8

; 106  : 	if (fClockTime)

  000de	0f b6 55 28	 movzx	 edx, BYTE PTR _fClockTime$[ebp]
  000e2	85 d2		 test	 edx, edx
  000e4	74 2d		 je	 SHORT $L69533

; 107  : 	{
; 108  : 		pmsg.p->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  000e9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000ec	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  000f2	99		 cdq
  000f3	03 45 20	 add	 eax, DWORD PTR _rtOffset$[ebp]
  000f6	13 55 24	 adc	 edx, DWORD PTR _rtOffset$[ebp+4]
  000f9	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  000fc	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000ff	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 109  : 		pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | item.dwTimingFlags;

  00102	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00105	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00108	83 c8 41	 or	 eax, 65			; 00000041H
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  0010e	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 110  : 	}
; 111  : 	else

  00111	eb 1e		 jmp	 SHORT $L69534
$L69533:

; 112  : 	{
; 113  : 		pmsg.p->mtTime = item.lTimePhysical + mtOffset;

  00113	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00116	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00119	03 45 1c	 add	 eax, DWORD PTR _mtOffset$[ebp]
  0011c	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  0011f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 114  : 		pmsg.p->dwFlags = DMUS_PMSGF_MUSICTIME | item.dwTimingFlags;

  00122	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00125	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00128	83 c8 02	 or	 eax, 2
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  0012e	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L69534:

; 115  : 	}
; 116  : 	pmsg.p->dwVirtualTrackID = dwVirtualID;

  00131	8b 55 f0	 mov	 edx, DWORD PTR _pmsg$[ebp]
  00134	8b 45 18	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  00137	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 117  : 	pmsg.p->dwType = DMUS_PMSGT_LYRIC;

  0013a	8b 4d f0	 mov	 ecx, DWORD PTR _pmsg$[ebp]
  0013d	c7 41 28 0d 00
	00 00		 mov	 DWORD PTR [ecx+40], 13	; 0000000dH

; 118  : 	pmsg.p->dwGroupID = 0xffffffff;

  00144	8b 55 f0	 mov	 edx, DWORD PTR _pmsg$[ebp]
  00147	c7 42 30 ff ff
	ff ff		 mov	 DWORD PTR [edx+48], -1

; 119  : 
; 120  : 	pmsg.StampAndSend(pGraph);

  0014e	8b 45 ec	 mov	 eax, DWORD PTR _pGraph$[ebp]
  00151	50		 push	 eax
  00152	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  00155	e8 00 00 00 00	 call	 ?StampAndSend@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEXPAUIDirectMusicGraph@@@Z ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::StampAndSend

; 121  : 	pGraph->Release();

  0015a	8b 4d ec	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  0015d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015f	8b 45 ec	 mov	 eax, DWORD PTR _pGraph$[ebp]
  00162	50		 push	 eax
  00163	ff 52 08	 call	 DWORD PTR [edx+8]

; 122  :     return pmsg.hr();

  00166	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  00169	e8 00 00 00 00	 call	 ?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::hr
  0016e	89 45 e4	 mov	 DWORD PTR $T69954[ebp], eax
  00171	8d 4d f0	 lea	 ecx, DWORD PTR _pmsg$[ebp]
  00174	e8 00 00 00 00	 call	 ??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::~PMsg<_DMUS_LYRIC_PMSG>
  00179	8b 45 e4	 mov	 eax, DWORD PTR $T69954[ebp]
$L69498:

; 123  : }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c2 24 00	 ret	 36			; 00000024H
?PlayItem@CLyricsTrack@@MAEJABULyricInfo@@AAU?$CStandardStateData@ULyricInfo@@@@PAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KJ_J_N@Z ENDP ; CLyricsTrack::PlayItem
_TEXT	ENDS
PUBLIC	??0?$TListItem@ULyricInfo@@@@QAE@XZ		; TListItem<LyricInfo>::TListItem<LyricInfo>
PUBLIC	?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ ; TListItem<LyricInfo>::GetItemValue
PUBLIC	??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z		; TListItem<LyricInfo>::`scalar deleting destructor'
PUBLIC	?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z ; TList<LyricInfo>::AddHead
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_LYRICSTRACK_EVENTHEADER@@@Z ; SmartRef::RiffIterReadChunk
PUBLIC	??_C@_0LE@CJKIDNAD@Error?3?5Unable?5to?5load?5lyric?5trac@ ; `string'
PUBLIC	??IWString@SmartRef@@QAEPAPAGXZ			; SmartRef::WString::operator&
PUBLIC	??_C@_0EC@CBOHEJO@Error?3?5Unable?5to?5load?5lyric?5trac@ ; `string'
PUBLIC	??_C@_0DM@KNCKBPPB@Error?3?5Unable?5to?5load?5lyric?5trac@ ; `string'
PUBLIC	??_C@_0DM@IPNAMLAD@Error?3?5Unable?5to?5load?5lyric?5trac@ ; `string'
EXTRN	?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z:NEAR	; SmartRef::RiffIter::ReadText
;	COMDAT ??_C@_0LE@CJKIDNAD@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT
??_C@_0LE@CJKIDNAD@Error?3?5Unable?5to?5load?5lyric?5trac@ DB 'Error: Una'
	DB	'ble to load lyric track: DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSIC'
	DB	'TIME, DMUS_PMSGF_TOOL_FLUSH, and DMUS_PMSGF_LOCKTOREFTIME are'
	DB	' not allowed as dwTimingFlags in chunk ''lyrh''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@CBOHEJO@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT
??_C@_0EC@CBOHEJO@Error?3?5Unable?5to?5load?5lyric?5trac@ DB 'Error: Unab'
	DB	'le to load lyric track: Problem reading ''lyrn'' chunk.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@KNCKBPPB@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT
??_C@_0DM@KNCKBPPB@Error?3?5Unable?5to?5load?5lyric?5trac@ DB 'Error: Una'
	DB	'ble to load lyric track: Chunk ''lyrh'' not found.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@IPNAMLAD@Error?3?5Unable?5to?5load?5lyric?5trac@
CONST	SEGMENT
??_C@_0DM@IPNAMLAD@Error?3?5Unable?5to?5load?5lyric?5trac@ DB 'Error: Una'
	DB	'ble to load lyric track: Chunk ''lyrn'' not found.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadLyric@CLyricsTrack@@AAEJVRiffIter@SmartRef@@@Z
_TEXT	SEGMENT
tv186 = -124
tv160 = -120
tv158 = -116
tv140 = -112
tv131 = -108
tv90 = -104
tv76 = -100
_this$ = -96
$T69984 = -92
$T69981 = -88
$T69980 = -84
$T69977 = -80
$T69974 = -76
$T69973 = -72
$T69972 = -68
$T69969 = -64
$T69968 = -60
$T69967 = -56
$T69964 = -52
$T69963 = -48
$T69962 = -44
$T69959 = -40
$T69958 = -36
_ioItem$69569 = -32
_hr$ = -16
_fFoundEventHeader$ = -9
_rinfo$ = -8
_pItem$ = -4
_ri$ = 8
?LoadLyric@CLyricsTrack@@AAEJVRiffIter@SmartRef@@@Z PROC NEAR ; CLyricsTrack::LoadLyric, COMDAT
; _this$ = ecx

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	89 4d a0	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 	HRESULT hr = S_OK;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 129  : 
; 130  : 	if (!ri)

  00010	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  00013	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 1b		 jne	 SHORT $L69542

; 131  : 		return ri.hr();

  0001f	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  00022	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  00027	89 45 dc	 mov	 DWORD PTR $T69958[ebp], eax
  0002a	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  0002d	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00032	8b 45 dc	 mov	 eax, DWORD PTR $T69958[ebp]
  00035	e9 ba 02 00 00	 jmp	 $L69539
$L69542:

; 132  : 
; 133  : 	// Create an event
; 134  : 	TListItem<LyricInfo> *pItem = new TListItem<LyricInfo>;

  0003a	6a 18		 push	 24			; 00000018H
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 d8	 mov	 DWORD PTR $T69959[ebp], eax
  00047	83 7d d8 00	 cmp	 DWORD PTR $T69959[ebp], 0
  0004b	74 0d		 je	 SHORT $L69960
  0004d	8b 4d d8	 mov	 ecx, DWORD PTR $T69959[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$TListItem@ULyricInfo@@@@QAE@XZ ; TListItem<LyricInfo>::TListItem<LyricInfo>
  00055	89 45 9c	 mov	 DWORD PTR tv76[ebp], eax
  00058	eb 07		 jmp	 SHORT $L69961
$L69960:
  0005a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$L69961:
  00061	8b 4d 9c	 mov	 ecx, DWORD PTR tv76[ebp]
  00064	89 4d fc	 mov	 DWORD PTR _pItem$[ebp], ecx

; 135  : 	if (!pItem)

  00067	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0006b	75 17		 jne	 SHORT $L69547

; 136  : 		return E_OUTOFMEMORY;

  0006d	c7 45 d4 0e 00
	07 80		 mov	 DWORD PTR $T69962[ebp], -2147024882 ; 8007000eH
  00074	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  00077	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  0007c	8b 45 d4	 mov	 eax, DWORD PTR $T69962[ebp]
  0007f	e9 70 02 00 00	 jmp	 $L69539
$L69547:

; 137  : 	LyricInfo &rinfo = pItem->GetItemValue();

  00084	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00087	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ ; TListItem<LyricInfo>::GetItemValue
  0008c	89 45 f8	 mov	 DWORD PTR _rinfo$[ebp], eax

; 138  : 
; 139  : 	bool fFoundEventHeader = false;

  0008f	c6 45 f7 00	 mov	 BYTE PTR _fFoundEventHeader$[ebp], 0

; 140  : 
; 141  : 	for ( ; ri; ++ri)

  00093	eb 08		 jmp	 SHORT $L69552
$L69553:
  00095	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  00098	e8 00 00 00 00	 call	 ??ERiffIter@SmartRef@@QAEAAV01@XZ ; SmartRef::RiffIter::operator++
$L69552:
  0009d	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  000a0	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  000a5	0f b6 d0	 movzx	 edx, al
  000a8	85 d2		 test	 edx, edx
  000aa	0f 84 9d 01 00
	00		 je	 $L69554

; 142  : 	{
; 143  : 		if (ri.type() != SmartRef::RiffIter::Chunk)

  000b0	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  000b3	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  000b8	83 f8 02	 cmp	 eax, 2
  000bb	74 02		 je	 SHORT $L69555

; 144  : 			continue;

  000bd	eb d6		 jmp	 SHORT $L69553
$L69555:

; 145  : 
; 146  : 		switch(ri.id())
; 147  : 		{

  000bf	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  000c2	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  000c7	89 45 98	 mov	 DWORD PTR tv90[ebp], eax
  000ca	81 7d 98 6c 79
	72 68		 cmp	 DWORD PTR tv90[ebp], 1752332652 ; 6872796cH
  000d1	74 12		 je	 SHORT $L69568
  000d3	81 7d 98 6c 79
	72 6e		 cmp	 DWORD PTR tv90[ebp], 1852995948 ; 6e72796cH
  000da	0f 84 dd 00 00
	00		 je	 $L69594
  000e0	e9 63 01 00 00	 jmp	 $L69557
$L69568:

; 148  : 			case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
; 149  : 				// Read an event chunk
; 150  : 				DMUS_IO_LYRICSTRACK_EVENTHEADER ioItem;
; 151  : 				hr = SmartRef::RiffIterReadChunk(ri, &ioItem);

  000e5	8d 45 e0	 lea	 eax, DWORD PTR _ioItem$69569[ebp]
  000e8	50		 push	 eax
  000e9	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_LYRICSTRACK_EVENTHEADER@@@Z ; SmartRef::RiffIterReadChunk
  000f2	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 152  : 				if (FAILED(hr))

  000f5	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f9	7d 3e		 jge	 SHORT $L69576

; 153  :                 {
; 154  :                     delete pItem;

  000fb	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  000fe	89 55 cc	 mov	 DWORD PTR $T69964[ebp], edx
  00101	8b 45 cc	 mov	 eax, DWORD PTR $T69964[ebp]
  00104	89 45 d0	 mov	 DWORD PTR $T69963[ebp], eax
  00107	83 7d d0 00	 cmp	 DWORD PTR $T69963[ebp], 0
  0010b	74 0f		 je	 SHORT $L69965
  0010d	6a 01		 push	 1
  0010f	8b 4d d0	 mov	 ecx, DWORD PTR $T69963[ebp]
  00112	e8 00 00 00 00	 call	 ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
  00117	89 45 94	 mov	 DWORD PTR tv131[ebp], eax
  0011a	eb 07		 jmp	 SHORT $L69966
$L69965:
  0011c	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
$L69966:

; 155  : 					return hr;

  00123	8b 4d f0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00126	89 4d c8	 mov	 DWORD PTR $T69967[ebp], ecx
  00129	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  0012c	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00131	8b 45 c8	 mov	 eax, DWORD PTR $T69967[ebp]
  00134	e9 bb 01 00 00	 jmp	 $L69539
$L69576:

; 156  :                 }
; 157  : 
; 158  : 				// Don't allow ref/music timing flags because these are controlled by whether
; 159  : 				// the overall track is playing music or clock time and can't be set in individual
; 160  : 				// events.  Similarly, the tool flush flag isn't appropriate for an event to be played.
; 161  : 				if (ioItem.dwTimingFlags & (DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_FLUSH | DMUS_PMSGF_LOCKTOREFTIME))

  00139	8b 55 e4	 mov	 edx, DWORD PTR _ioItem$69569[ebp+4]
  0013c	83 e2 63	 and	 edx, 99			; 00000063H
  0013f	85 d2		 test	 edx, edx
  00141	74 4e		 je	 SHORT $L69580

; 162  :                 {
; 163  : 					Trace(1, "Error: Unable to load lyric track: DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, and DMUS_PMSGF_LOCKTOREFTIME are not allowed as dwTimingFlags in chunk 'lyrh'.\n");

  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0LE@CJKIDNAD@Error?3?5Unable?5to?5load?5lyric?5trac@
  00148	6a 01		 push	 1
  0014a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0014f	83 c4 08	 add	 esp, 8

; 164  :                     delete pItem;

  00152	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00155	89 45 c0	 mov	 DWORD PTR $T69969[ebp], eax
  00158	8b 4d c0	 mov	 ecx, DWORD PTR $T69969[ebp]
  0015b	89 4d c4	 mov	 DWORD PTR $T69968[ebp], ecx
  0015e	83 7d c4 00	 cmp	 DWORD PTR $T69968[ebp], 0
  00162	74 0f		 je	 SHORT $L69970
  00164	6a 01		 push	 1
  00166	8b 4d c4	 mov	 ecx, DWORD PTR $T69968[ebp]
  00169	e8 00 00 00 00	 call	 ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
  0016e	89 45 90	 mov	 DWORD PTR tv140[ebp], eax
  00171	eb 07		 jmp	 SHORT $L69971
$L69970:
  00173	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$L69971:

; 165  :                     return DMUS_E_INVALID_LYRICSTRACK;

  0017a	c7 45 bc 05 40
	00 80		 mov	 DWORD PTR $T69972[ebp], -2147467259 ; 80004005H
  00181	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  00184	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00189	8b 45 bc	 mov	 eax, DWORD PTR $T69972[ebp]
  0018c	e9 63 01 00 00	 jmp	 $L69539
$L69580:

; 166  :                 }
; 167  : 
; 168  : 				fFoundEventHeader = true;

  00191	c6 45 f7 01	 mov	 BYTE PTR _fFoundEventHeader$[ebp], 1

; 169  : 				rinfo.dwFlags = ioItem.dwFlags;

  00195	8b 55 f8	 mov	 edx, DWORD PTR _rinfo$[ebp]
  00198	8b 45 e0	 mov	 eax, DWORD PTR _ioItem$69569[ebp]
  0019b	89 02		 mov	 DWORD PTR [edx], eax

; 170  : 				rinfo.dwTimingFlags = ioItem.dwTimingFlags;

  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _rinfo$[ebp]
  001a0	8b 55 e4	 mov	 edx, DWORD PTR _ioItem$69569[ebp+4]
  001a3	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 171  : 				rinfo.lTriggerTime = ioItem.lTimeLogical;

  001a6	8b 45 f8	 mov	 eax, DWORD PTR _rinfo$[ebp]
  001a9	8b 4d e8	 mov	 ecx, DWORD PTR _ioItem$69569[ebp+8]
  001ac	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 172  : 				rinfo.lTimePhysical = ioItem.lTimePhysical;

  001af	8b 55 f8	 mov	 edx, DWORD PTR _rinfo$[ebp]
  001b2	8b 45 ec	 mov	 eax, DWORD PTR _ioItem$69569[ebp+12]
  001b5	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 173  : 				break;

  001b8	e9 8b 00 00 00	 jmp	 $L69557
$L69594:

; 174  : 
; 175  : 			case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
; 176  : 				{
; 177  : 					hr = ri.ReadText(&rinfo.wstrText);

  001bd	8b 4d f8	 mov	 ecx, DWORD PTR _rinfo$[ebp]
  001c0	83 c1 10	 add	 ecx, 16			; 00000010H
  001c3	e8 00 00 00 00	 call	 ??IWString@SmartRef@@QAEPAPAGXZ ; SmartRef::WString::operator&
  001c8	50		 push	 eax
  001c9	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  001cc	e8 00 00 00 00	 call	 ?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z ; SmartRef::RiffIter::ReadText
  001d1	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 178  : 					if (FAILED(hr))

  001d4	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001d8	7d 6e		 jge	 SHORT $L69557

; 179  :                     {
; 180  : #ifdef DBG
; 181  : 						if (hr == E_FAIL)

  001da	81 7d f0 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  001e1	75 0f		 jne	 SHORT $L69598

; 182  : 						{
; 183  : 							Trace(1, "Error: Unable to load lyric track: Problem reading 'lyrn' chunk.\n");

  001e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EC@CBOHEJO@Error?3?5Unable?5to?5load?5lyric?5trac@
  001e8	6a 01		 push	 1
  001ea	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001ef	83 c4 08	 add	 esp, 8
$L69598:

; 184  : 						}
; 185  : #endif
; 186  :                         delete pItem;

  001f2	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001f5	89 4d b4	 mov	 DWORD PTR $T69974[ebp], ecx
  001f8	8b 55 b4	 mov	 edx, DWORD PTR $T69974[ebp]
  001fb	89 55 b8	 mov	 DWORD PTR $T69973[ebp], edx
  001fe	83 7d b8 00	 cmp	 DWORD PTR $T69973[ebp], 0
  00202	74 0f		 je	 SHORT $L69975
  00204	6a 01		 push	 1
  00206	8b 4d b8	 mov	 ecx, DWORD PTR $T69973[ebp]
  00209	e8 00 00 00 00	 call	 ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
  0020e	89 45 8c	 mov	 DWORD PTR tv158[ebp], eax
  00211	eb 07		 jmp	 SHORT $L69976
$L69975:
  00213	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv158[ebp], 0
$L69976:

; 187  : 						return hr == E_FAIL ? DMUS_E_INVALID_LYRICSTRACK : hr;

  0021a	81 7d f0 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  00221	75 09		 jne	 SHORT $L69978
  00223	c7 45 88 05 40
	00 80		 mov	 DWORD PTR tv160[ebp], -2147467259 ; 80004005H
  0022a	eb 06		 jmp	 SHORT $L69979
$L69978:
  0022c	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  0022f	89 45 88	 mov	 DWORD PTR tv160[ebp], eax
$L69979:
  00232	8b 4d 88	 mov	 ecx, DWORD PTR tv160[ebp]
  00235	89 4d b0	 mov	 DWORD PTR $T69977[ebp], ecx
  00238	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  0023b	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00240	8b 45 b0	 mov	 eax, DWORD PTR $T69977[ebp]
  00243	e9 ac 00 00 00	 jmp	 $L69539
$L69557:

; 188  :                     }
; 189  : 				}
; 190  : 				break;
; 191  : 
; 192  : 			default:
; 193  : 				break;
; 194  : 		}
; 195  : 	}

  00248	e9 48 fe ff ff	 jmp	 $L69553
$L69554:

; 196  : 	hr = ri.hr();

  0024d	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  00250	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  00255	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 197  : 
; 198  : 	if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.wstrText))

  00258	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0025c	7c 46		 jl	 SHORT $L69607
  0025e	0f b6 55 f7	 movzx	 edx, BYTE PTR _fFoundEventHeader$[ebp]
  00262	85 d2		 test	 edx, edx
  00264	74 0f		 je	 SHORT $L69608
  00266	8b 4d f8	 mov	 ecx, DWORD PTR _rinfo$[ebp]
  00269	83 c1 10	 add	 ecx, 16			; 00000010H
  0026c	e8 00 00 00 00	 call	 ??BWString@SmartRef@@QBEPBGXZ ; SmartRef::WString::operator unsigned short const *
  00271	85 c0		 test	 eax, eax
  00273	75 2f		 jne	 SHORT $L69607
$L69608:

; 199  :     {
; 200  : #ifdef DBG
; 201  : 		if (!fFoundEventHeader)

  00275	0f b6 45 f7	 movzx	 eax, BYTE PTR _fFoundEventHeader$[ebp]
  00279	85 c0		 test	 eax, eax
  0027b	75 11		 jne	 SHORT $L69609

; 202  : 		{
; 203  : 			Trace(1, "Error: Unable to load lyric track: Chunk 'lyrh' not found.\n");

  0027d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@KNCKBPPB@Error?3?5Unable?5to?5load?5lyric?5trac@
  00282	6a 01		 push	 1
  00284	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00289	83 c4 08	 add	 esp, 8

; 204  : 		}
; 205  : 		else

  0028c	eb 0f		 jmp	 SHORT $L69611
$L69609:

; 206  : 		{
; 207  : 			Trace(1, "Error: Unable to load lyric track: Chunk 'lyrn' not found.\n");

  0028e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@IPNAMLAD@Error?3?5Unable?5to?5load?5lyric?5trac@
  00293	6a 01		 push	 1
  00295	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0029a	83 c4 08	 add	 esp, 8
$L69611:

; 208  : 		}
; 209  : #endif
; 210  : 		hr = DMUS_E_INVALID_LYRICSTRACK;

  0029d	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L69607:

; 211  :     }
; 212  : 
; 213  : 	if (SUCCEEDED(hr))

  002a4	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002a8	7c 11		 jl	 SHORT $L69615

; 214  :     {
; 215  : 		m_EventList.AddHead(pItem);

  002aa	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  002ad	51		 push	 ecx
  002ae	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	83 c1 34	 add	 ecx, 52			; 00000034H
  002b4	e8 00 00 00 00	 call	 ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z ; TList<LyricInfo>::AddHead

; 216  :     }
; 217  :     else

  002b9	eb 28		 jmp	 SHORT $L69616
$L69615:

; 218  :     {
; 219  :         delete pItem;

  002bb	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  002be	89 55 a8	 mov	 DWORD PTR $T69981[ebp], edx
  002c1	8b 45 a8	 mov	 eax, DWORD PTR $T69981[ebp]
  002c4	89 45 ac	 mov	 DWORD PTR $T69980[ebp], eax
  002c7	83 7d ac 00	 cmp	 DWORD PTR $T69980[ebp], 0
  002cb	74 0f		 je	 SHORT $L69982
  002cd	6a 01		 push	 1
  002cf	8b 4d ac	 mov	 ecx, DWORD PTR $T69980[ebp]
  002d2	e8 00 00 00 00	 call	 ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
  002d7	89 45 84	 mov	 DWORD PTR tv186[ebp], eax
  002da	eb 07		 jmp	 SHORT $L69616
$L69982:
  002dc	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv186[ebp], 0
$L69616:

; 220  :     }
; 221  : 
; 222  : 	return hr;

  002e3	8b 4d f0	 mov	 ecx, DWORD PTR _hr$[ebp]
  002e6	89 4d a4	 mov	 DWORD PTR $T69984[ebp], ecx
  002e9	8d 4d 08	 lea	 ecx, DWORD PTR _ri$[ebp]
  002ec	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  002f1	8b 45 a4	 mov	 eax, DWORD PTR $T69984[ebp]
$L69539:

; 223  : }

  002f4	8b e5		 mov	 esp, ebp
  002f6	5d		 pop	 ebp
  002f7	c2 38 00	 ret	 56			; 00000038H
?LoadLyric@CLyricsTrack@@AAEJVRiffIter@SmartRef@@@Z ENDP ; CLyricsTrack::LoadLyric
_TEXT	ENDS
PUBLIC	?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z	; TListItem<LyricInfo>::SetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.h
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z PROC NEAR ; TList<LyricInfo>::AddHead, COMDAT
; _this$ = ecx

; 80   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : //            assert(pItem!=NULL);
; 82   :             pItem->SetNext(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00010	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z ; TListItem<LyricInfo>::SetNext

; 83   :             m_pHead=pItem;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 84   :         }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z ENDP ; TList<LyricInfo>::AddHead
_TEXT	ENDS
PUBLIC	??0LyricInfo@@QAE@XZ				; LyricInfo::LyricInfo
; Function compile flags: /Odt
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TListItem@ULyricInfo@@@@QAE@XZ PROC NEAR		; TListItem<LyricInfo>::TListItem<LyricInfo>, COMDAT
; _this$ = ecx

; 28   :     TListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0LyricInfo@@QAE@XZ	; LyricInfo::LyricInfo
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0?$TListItem@ULyricInfo@@@@QAE@XZ ENDP		; TListItem<LyricInfo>::TListItem<LyricInfo>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ PROC NEAR ; TListItem<LyricInfo>::GetItemValue, COMDAT
; _this$ = ecx

; 40   :     T& GetItemValue() { return m_Tinfo; }  // additional member function

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ ENDP ; TListItem<LyricInfo>::GetItemValue
_TEXT	ENDS
PUBLIC	??_C@_0BA@OEJEHDBH@p?9?$DOdwSize?5?$DN?$DN?5cb?$AA@ ; `string'
PUBLIC	??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
CONST	SEGMENT
??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\shared\smartref.h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEJEHDBH@p?9?$DOdwSize?5?$DN?$DN?5cb?$AA@
CONST	SEGMENT
??_C@_0BA@OEJEHDBH@p?9?$DOdwSize?5?$DN?$DN?5cb?$AA@ DB 'p->dwSize == cb', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@PAUIDirectMusicPerformance@@I@Z
_TEXT	SEGMENT
_this$ = -8
_cb$ = -4
_pPerf$ = 8
_cbExtra$ = 12
??0?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@PAUIDirectMusicPerformance@@I@Z PROC NEAR ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::PMsg<_DMUS_LYRIC_PMSG>, COMDAT
; _this$ = ecx

; 378  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00018	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 379  : 			const UINT cb = sizeof(T) + cbExtra;

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _cbExtra$[ebp]
  00028	83 c1 40	 add	 ecx, 64			; 00000040H
  0002b	89 4d fc	 mov	 DWORD PTR _cb$[ebp], ecx

; 380  : 			m_hr = m_pPerf->AllocPMsg(cb, reinterpret_cast<DMUS_PMSG**>(&p));

  0002e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00031	52		 push	 edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _cb$[ebp]
  00035	50		 push	 eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	8b 12		 mov	 edx, DWORD PTR [edx]
  00044	51		 push	 ecx
  00045	ff 52 24	 call	 DWORD PTR [edx+36]
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 381  : 			if (SUCCEEDED(m_hr))

  0004e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00051	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00055	7c 3e		 jl	 SHORT $L69666

; 382  : 			{
; 383  : 				assert(p->dwSize == cb);

  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005e	3b 55 fc	 cmp	 edx, DWORD PTR _cb$[ebp]
  00061	74 14		 je	 SHORT $L69997
  00063	68 7f 01 00 00	 push	 383			; 0000017fH
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@OEJEHDBH@p?9?$DOdwSize?5?$DN?$DN?5cb?$AA@
  00072	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L69997:

; 384  : 				ZeroMemory(p, cb);

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _cb$[ebp]
  0007a	51		 push	 ecx
  0007b	6a 00		 push	 0
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 02		 mov	 eax, DWORD PTR [edx]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _memset
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 385  : 				p->dwSize = cb;

  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	8b 45 fc	 mov	 eax, DWORD PTR _cb$[ebp]
  00093	89 02		 mov	 DWORD PTR [edx], eax
$L69666:

; 386  : 			}
; 387  : 		}

  00095	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
??0?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@PAUIDirectMusicPerformance@@I@Z ENDP ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::PMsg<_DMUS_LYRIC_PMSG>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ PROC NEAR ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::~PMsg<_DMUS_LYRIC_PMSG>, COMDAT
; _this$ = ecx

; 388  : 		~PMsg() { if (p) m_pPerf->FreePMsg(reinterpret_cast<DMUS_PMSG*>(p)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 18		 je	 SHORT $L69675
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	50		 push	 eax
  00024	ff 51 28	 call	 DWORD PTR [ecx+40]
$L69675:
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAE@XZ ENDP	; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::~PMsg<_DMUS_LYRIC_PMSG>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?StampAndSend@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEXPAUIDirectMusicGraph@@@Z
_TEXT	SEGMENT
_this$ = -4
_pGraph$ = 8
?StampAndSend@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEXPAUIDirectMusicGraph@@@Z PROC NEAR ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::StampAndSend, COMDAT
; _this$ = ecx

; 390  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 			m_hr = pGraph->StampPMsg(reinterpret_cast<DMUS_PMSG*>(p));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _pGraph$[ebp]
  00010	8b 02		 mov	 eax, DWORD PTR [edx]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  00015	51		 push	 ecx
  00016	ff 50 0c	 call	 DWORD PTR [eax+12]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 392  : 			if (FAILED(m_hr))

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00026	7d 02		 jge	 SHORT $L69682

; 393  : 				return;

  00028	eb 30		 jmp	 SHORT $L69679
$L69682:

; 394  : 
; 395  : 			m_hr = m_pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(p));

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	52		 push	 edx
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	50		 push	 eax
  0003f	ff 51 10	 call	 DWORD PTR [ecx+16]
  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 396  : 			if (SUCCEEDED(m_hr))

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0004f	7c 09		 jl	 SHORT $L69679

; 397  : 				p = NULL; // PMsg now owned by the performance

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69679:

; 398  : 		}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?StampAndSend@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEXPAUIDirectMusicGraph@@@Z ENDP ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::StampAndSend
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4
?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ PROC NEAR ; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::hr, COMDAT
; _this$ = ecx

; 399  : 		HRESULT hr() { return m_hr; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?hr@?$PMsg@U_DMUS_LYRIC_PMSG@@@SmartRef@@QAEJXZ ENDP	; SmartRef::PMsg<_DMUS_LYRIC_PMSG>::hr
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.h
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z PROC NEAR ; TListItem<LyricInfo>::SetNext, COMDAT
; _this$ = ecx

; 33   :     void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z ENDP	; TListItem<LyricInfo>::SetNext
_TEXT	ENDS
EXTRN	?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z:NEAR	; SmartRef::RiffIter::ReadChunk
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_LYRICSTRACK_EVENTHEADER@@@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_LYRICSTRACK_EVENTHEADER@@@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_LYRICSTRACK_EVENTHEADER@@@Z ENDP ; SmartRef::RiffIterReadChunk
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
_TEXT	ENDS
;	COMDAT ??BWString@SmartRef@@QBEPBGXZ
_TEXT	SEGMENT
_this$ = -4
??BWString@SmartRef@@QBEPBGXZ PROC NEAR			; SmartRef::WString::operator unsigned short const *, COMDAT
; _this$ = ecx

; 83   : 		operator const WCHAR *() const { return m_psz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??BWString@SmartRef@@QBEPBGXZ ENDP			; SmartRef::WString::operator unsigned short const *
_TEXT	ENDS
PUBLIC	??_C@_06ONCILBNO@?$CBm_psz?$AA@			; `string'
;	COMDAT ??_C@_06ONCILBNO@?$CBm_psz?$AA@
CONST	SEGMENT
??_C@_06ONCILBNO@?$CBm_psz?$AA@ DB '!m_psz', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??IWString@SmartRef@@QAEPAPAGXZ
_TEXT	SEGMENT
_this$ = -4
??IWString@SmartRef@@QAEPAPAGXZ PROC NEAR		; SmartRef::WString::operator&, COMDAT
; _this$ = ecx

; 89   : 		WCHAR ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 11		 je	 SHORT $L70022
  0000f	6a 59		 push	 89			; 00000059H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06ONCILBNO@?$CBm_psz?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70022:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??IWString@SmartRef@@QAEPAPAGXZ ENDP			; SmartRef::WString::operator&
_TEXT	ENDS
PUBLIC	?validate@RiffIter@SmartRef@@ABE_NXZ		; SmartRef::RiffIter::validate
EXTRN	??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z:NEAR ; SmartRef::RiffIter::RiffIter
; Function compile flags: /Odt
;	COMDAT ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4
___$ReturnUdt$ = 8
?Descend@RiffIter@SmartRef@@QAE?AV12@XZ PROC NEAR	; SmartRef::RiffIter::Descend, COMDAT
; _this$ = ecx

; 426  : 		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00014	83 c6 21	 add	 esi, 33			; 00000021H
  00017	83 ec 14	 sub	 esp, 20			; 00000014H
  0001a	b9 05 00 00 00	 mov	 ecx, 5
  0001f	8b fc		 mov	 edi, esp
  00021	f3 a5		 rep movsd
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z ; SmartRef::RiffIter::RiffIter
  0002f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ENDP		; SmartRef::RiffIter::Descend
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??BRiffIter@SmartRef@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
??BRiffIter@SmartRef@@QBE_NXZ PROC NEAR			; SmartRef::RiffIter::operator bool, COMDAT
; _this$ = ecx

; 428  : 		operator bool() const { return SUCCEEDED(m_hr); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	0f 9d c1	 setge	 cl
  00012	8a c1		 mov	 al, cl
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??BRiffIter@SmartRef@@QBE_NXZ ENDP			; SmartRef::RiffIter::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?hr@RiffIter@SmartRef@@QBEJXZ
_TEXT	SEGMENT
tv65 = -8
_this$ = -4
?hr@RiffIter@SmartRef@@QBEJXZ PROC NEAR			; SmartRef::RiffIter::hr, COMDAT
; _this$ = ecx

; 429  : 		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	81 38 05 40 00
	80		 cmp	 DWORD PTR [eax], -2147467259 ; 80004005H
  00012	75 09		 jne	 SHORT $L70032
  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
  0001b	eb 08		 jmp	 SHORT $L70033
$L70032:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	89 55 f8	 mov	 DWORD PTR tv65[ebp], edx
$L70033:
  00025	8b 45 f8	 mov	 eax, DWORD PTR tv65[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?hr@RiffIter@SmartRef@@QBEJXZ ENDP			; SmartRef::RiffIter::hr
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ
_TEXT	SEGMENT
tv72 = -8
_this$ = -4
?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ PROC NEAR ; SmartRef::RiffIter::type, COMDAT
; _this$ = ecx

; 431  : 		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	81 78 21 4c 49
	53 54		 cmp	 DWORD PTR [eax+33], 1414744396 ; 5453494cH
  0001b	75 09		 jne	 SHORT $L70037
  0001d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00024	eb 16		 jmp	 SHORT $L70038
$L70037:
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	33 d2		 xor	 edx, edx
  0002b	81 79 21 52 49
	46 46		 cmp	 DWORD PTR [ecx+33], 1179011410 ; 46464952H
  00032	0f 94 c2	 sete	 dl
  00035	4a		 dec	 edx
  00036	83 e2 02	 and	 edx, 2
  00039	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
$L70038:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ENDP	; SmartRef::RiffIter::type
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?id@RiffIter@SmartRef@@QBEKXZ
_TEXT	SEGMENT
tv72 = -8
_this$ = -4
?id@RiffIter@SmartRef@@QBEKXZ PROC NEAR			; SmartRef::RiffIter::id, COMDAT
; _this$ = ecx

; 432  : 		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00019	83 f8 02	 cmp	 eax, 2
  0001c	75 0b		 jne	 SHORT $L70042
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 21	 mov	 ecx, DWORD PTR [eax+33]
  00024	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00027	eb 09		 jmp	 SHORT $L70043
$L70042:
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 29	 mov	 eax, DWORD PTR [edx+41]
  0002f	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$L70043:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?id@RiffIter@SmartRef@@QBEKXZ ENDP			; SmartRef::RiffIter::id
_TEXT	ENDS
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?validate@RiffIter@SmartRef@@ABE_NXZ
_TEXT	SEGMENT
_this$ = -4
?validate@RiffIter@SmartRef@@ABE_NXZ PROC NEAR		; SmartRef::RiffIter::validate, COMDAT
; _this$ = ecx

; 478  : 		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	7d 1e		 jge	 SHORT $L44289
  0000f	33 c9		 xor	 ecx, ecx
  00011	85 c9		 test	 ecx, ecx
  00013	75 14		 jne	 SHORT $L70047
  00015	68 de 01 00 00	 push	 478			; 000001deH
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00024	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70047:
  00029	b0 01		 mov	 al, 1
  0002b	eb 02		 jmp	 SHORT $L44287
$L44289:
  0002d	32 c0		 xor	 al, al
$L44287:
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?validate@RiffIter@SmartRef@@ABE_NXZ ENDP		; SmartRef::RiffIter::validate
_TEXT	ENDS
PUBLIC	??0WString@SmartRef@@QAE@PBG@Z			; SmartRef::WString::WString
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\lyrictrk.h
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0LyricInfo@@QAE@XZ PROC NEAR				; LyricInfo::LyricInfo, COMDAT
; _this$ = ecx

; 22   : 	LyricInfo() : dwFlags(0), dwTimingFlags(0), lTriggerTime(0), lTimePhysical(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0002e	6a 00		 push	 0
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 10	 add	 ecx, 16			; 00000010H
  00036	e8 00 00 00 00	 call	 ??0WString@SmartRef@@QAE@PBG@Z ; SmartRef::WString::WString
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0LyricInfo@@QAE@XZ ENDP				; LyricInfo::LyricInfo
_TEXT	ENDS
EXTRN	??4WString@SmartRef@@QAEAAV01@PBG@Z:NEAR	; SmartRef::WString::operator=
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4
_psz$ = 8
??0WString@SmartRef@@QAE@PBG@Z PROC NEAR		; SmartRef::WString::WString, COMDAT
; _this$ = ecx

; 79   : 		WString(const WCHAR *psz = NULL) : m_psz(NULL) { *this = psz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??4WString@SmartRef@@QAEAAV01@PBG@Z ; SmartRef::WString::operator=
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0WString@SmartRef@@QAE@PBG@Z ENDP			; SmartRef::WString::WString
_TEXT	ENDS
PUBLIC	??1?$TListItem@ULyricInfo@@@@QAE@XZ		; TListItem<LyricInfo>::~TListItem<LyricInfo>
; Function compile flags: /Odt
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z PROC NEAR	; TListItem<LyricInfo>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$TListItem@ULyricInfo@@@@QAE@XZ ; TListItem<LyricInfo>::~TListItem<LyricInfo>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69389
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69389:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z ENDP		; TListItem<LyricInfo>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1LyricInfo@@QAE@XZ				; LyricInfo::~LyricInfo
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.cpp
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TListItem@ULyricInfo@@@@QAE@XZ PROC NEAR		; TListItem<LyricInfo>::~TListItem<LyricInfo>, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	//if (m_pNext != NULL) { delete m_pNext; }
; 22   : 	// IMPORTANT: user of the list is required to delete content first!
; 23   : 	//ZeroMemory(&m_Tinfo, sizeof(T));
; 24   : }

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1LyricInfo@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$TListItem@ULyricInfo@@@@QAE@XZ ENDP		; TListItem<LyricInfo>::~TListItem<LyricInfo>
_TEXT	ENDS
PUBLIC	??1WString@SmartRef@@QAE@XZ			; SmartRef::WString::~WString
; Function compile flags: /Odt
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1LyricInfo@@QAE@XZ PROC NEAR				; LyricInfo::~LyricInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??1WString@SmartRef@@QAE@XZ ; SmartRef::WString::~WString
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1LyricInfo@@QAE@XZ ENDP				; LyricInfo::~LyricInfo
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1WString@SmartRef@@QAE@XZ PROC NEAR			; SmartRef::WString::~WString, COMDAT
; _this$ = ecx

; 82   : 		~WString() { *this = static_cast<WCHAR *>(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??4WString@SmartRef@@QAEAAV01@PBG@Z ; SmartRef::WString::operator=
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??1WString@SmartRef@@QAE@XZ ENDP			; SmartRef::WString::~WString
_TEXT	ENDS
END
