; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\cmixbins.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MIALIGJC@?$CBm_bValid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GNBHJCKE@m_bValid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LLPGOAIE@alVolumes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@FPEIKNLB@dwBitCount?5?$DM?$DN?5DSMIXBIN_ASSIGNMEN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLOHEKKI@dwBitCount?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGGNAFID@dwCount?5?$DN?$DN?5dwBitCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PHBIGOLK@p_MixBins?4m_bValid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ??0CMIXBINS@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMIXBINS@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateFromMask@CMIXBINS@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PokeMixBinVolumesBasedOnMask@CMIXBINS@@QAEXKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CMIXBINS@@QAEHAAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9CMIXBINS@@QAEHAAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0CMIXBINS@@QAE@XZ				; CMIXBINS::CMIXBINS
EXTRN	_memset:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\cmixbins.cpp
;	COMDAT ??0CMIXBINS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CMIXBINS@@QAE@XZ PROC NEAR				; CMIXBINS::CMIXBINS, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 17   :     m_bValid = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 18   :     m_DSMixBins.dwMixBinCount = 0;        

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 19   :     m_DSMixBins.lpMixBinVolumePairs = &m_VolumePair[0];

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 c2 0c	 add	 edx, 12			; 0000000cH
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 20   :     ZeroMemory(&m_VolumePair, sizeof(DSMIXBINVOLUMEPAIR) * DSMIXBIN_ASSIGNMENT_MAX);

  00026	6a 40		 push	 64			; 00000040H
  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _memset
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21   : };

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0CMIXBINS@@QAE@XZ ENDP				; CMIXBINS::CMIXBINS
_TEXT	ENDS
PUBLIC	??1CMIXBINS@@QAE@XZ				; CMIXBINS::~CMIXBINS
; Function compile flags: /Odt
;	COMDAT ??1CMIXBINS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CMIXBINS@@QAE@XZ PROC NEAR				; CMIXBINS::~CMIXBINS, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   :     //Trash our data.
; 30   :     m_bValid = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 31   :     memset(&m_DSMixBins,  0xFF, sizeof(m_DSMixBins));

  00010	6a 08		 push	 8
  00012	68 ff 00 00 00	 push	 255			; 000000ffH
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   :     memset(&m_VolumePair, 0xFF, sizeof(DSMIXBINVOLUMEPAIR) * DSMIXBIN_ASSIGNMENT_MAX);

  00026	6a 40		 push	 64			; 00000040H
  00028	68 ff 00 00 00	 push	 255			; 000000ffH
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	83 c2 0c	 add	 edx, 12			; 0000000cH
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _memset
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : };

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??1CMIXBINS@@QAE@XZ ENDP				; CMIXBINS::~CMIXBINS
_TEXT	ENDS
PUBLIC	??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_09MIALIGJC@?$CBm_bValid?$AA@		; `string'
PUBLIC	?CreateFromMask@CMIXBINS@@QAEXK@Z		; CMIXBINS::CreateFromMask
EXTRN	__imp__RtlAssert@16:NEAR
;	COMDAT ??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\cmixbins.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MIALIGJC@?$CBm_bValid?$AA@
CONST	SEGMENT
??_C@_09MIALIGJC@?$CBm_bValid?$AA@ DB '!m_bValid', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateFromMask@CMIXBINS@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -16
_i$69435 = -12
_dwChorusIndex$ = -8
_dwReverbIndex$ = -4
_dwMask$ = 8
?CreateFromMask@CMIXBINS@@QAEXK@Z PROC NEAR		; CMIXBINS::CreateFromMask, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 42   :     DWORD dwChorusIndex = -1, dwReverbIndex = -1;

  00009	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _dwChorusIndex$[ebp], -1
  00010	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _dwReverbIndex$[ebp], -1

; 43   : 
; 44   :     //Make sure we're not blowing away an already-initialized object.
; 45   :     ASSERT(!m_bValid);

  00017	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 14		 je	 SHORT $L69432
  0001f	6a 00		 push	 0
  00021	6a 2d		 push	 45			; 0000002dH
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09MIALIGJC@?$CBm_bValid?$AA@
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69432:

; 46   :     m_DSMixBins.dwMixBinCount = 0;

  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 47   :     for (DWORD i=0; i<32; i++)

  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$69435[ebp], 0
  00044	eb 09		 jmp	 SHORT $L69436
$L69437:
  00046	8b 55 f4	 mov	 edx, DWORD PTR _i$69435[ebp]
  00049	83 c2 01	 add	 edx, 1
  0004c	89 55 f4	 mov	 DWORD PTR _i$69435[ebp], edx
$L69436:
  0004f	83 7d f4 20	 cmp	 DWORD PTR _i$69435[ebp], 32 ; 00000020H
  00053	73 63		 jae	 SHORT $L69438

; 48   :     {
; 49   :         if (dwMask & (1<<i))

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _i$69435[ebp]
  0005d	d3 e0		 shl	 eax, cl
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _dwMask$[ebp]
  00062	23 c8		 and	 ecx, eax
  00064	85 c9		 test	 ecx, ecx
  00066	74 4e		 je	 SHORT $L69439

; 50   :         {
; 51   : 
; 52   :             if (i == DSMIXBIN_FXSEND_0) {

  00068	83 7d f4 0b	 cmp	 DWORD PTR _i$69435[ebp], 11 ; 0000000bH
  0006c	75 09		 jne	 SHORT $L69440

; 53   :                 dwReverbIndex = m_DSMixBins.dwMixBinCount;

  0006e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00071	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00074	89 45 fc	 mov	 DWORD PTR _dwReverbIndex$[ebp], eax
$L69440:

; 54   :             }
; 55   : 
; 56   :             if (i == DSMIXBIN_FXSEND_1) {

  00077	83 7d f4 0c	 cmp	 DWORD PTR _i$69435[ebp], 12 ; 0000000cH
  0007b	75 09		 jne	 SHORT $L69441

; 57   :                 dwChorusIndex = m_DSMixBins.dwMixBinCount;

  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00083	89 55 f8	 mov	 DWORD PTR _dwChorusIndex$[ebp], edx
$L69441:

; 58   :             }
; 59   : 
; 60   :             m_VolumePair[m_DSMixBins.dwMixBinCount].dwMixBin = i;

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 45 f4	 mov	 eax, DWORD PTR _i$69435[ebp]
  00092	89 44 ca 0c	 mov	 DWORD PTR [edx+ecx*8+12], eax

; 61   :             m_VolumePair[m_DSMixBins.dwMixBinCount].lVolume  = 0;

  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	c7 44 d0 10 00
	00 00 00	 mov	 DWORD PTR [eax+edx*8+16], 0

; 62   :             m_DSMixBins.dwMixBinCount++;

  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ad	83 c2 01	 add	 edx, 1
  000b0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L69439:

; 63   : 
; 64   :         }
; 65   :     }

  000b6	eb 8e		 jmp	 SHORT $L69437
$L69438:

; 66   : 
; 67   :     if (m_DSMixBins.dwMixBinCount <=6) {

  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	83 79 04 06	 cmp	 DWORD PTR [ecx+4], 6
  000bf	0f 87 82 00 00
	00		 ja	 $L69442

; 68   :         
; 69   :         
; 70   :         if (dwReverbIndex != -1) {

  000c5	83 7d fc ff	 cmp	 DWORD PTR _dwReverbIndex$[ebp], -1
  000c9	74 2b		 je	 SHORT $L69443

; 71   :             
; 72   :             //
; 73   :             // for audiopaths that send data to chorus or reverb , specify two identical
; 74   :             // mixbins for each fxsend. This way stereo waves will play properly and mono waves
; 75   :             // will be at the same volume level
; 76   :             //
; 77   :             
; 78   :             m_VolumePair[dwReverbIndex+1].dwMixBin = DSMIXBIN_FXSEND_0;

  000cb	8b 55 fc	 mov	 edx, DWORD PTR _dwReverbIndex$[ebp]
  000ce	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	c7 44 d0 14 0b
	00 00 00	 mov	 DWORD PTR [eax+edx*8+20], 11 ; 0000000bH

; 79   :             m_VolumePair[dwReverbIndex+1].lVolume  = 0;

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _dwReverbIndex$[ebp]
  000dc	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000df	c7 44 ca 18 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*8+24], 0

; 80   :             m_DSMixBins.dwMixBinCount++;

  000e7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ed	83 c1 01	 add	 ecx, 1
  000f0	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000f3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L69443:

; 81   :             
; 82   :         }
; 83   :         
; 84   :         if (dwChorusIndex != -1) {

  000f6	83 7d f8 ff	 cmp	 DWORD PTR _dwChorusIndex$[ebp], -1
  000fa	74 4b		 je	 SHORT $L69442

; 85   :             
; 86   :             //
; 87   :             // for audiopaths that send data to chorus or reverb , specify two identical
; 88   :             // mixbins for each fxsend. This way stereo waves will play properly and mono waves
; 89   :             // will be at the same volume level
; 90   :             //
; 91   :             
; 92   :             for (i =1; i<3;i++) {

  000fc	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$69435[ebp], 1
  00103	eb 09		 jmp	 SHORT $L69445
$L69446:
  00105	8b 45 f4	 mov	 eax, DWORD PTR _i$69435[ebp]
  00108	83 c0 01	 add	 eax, 1
  0010b	89 45 f4	 mov	 DWORD PTR _i$69435[ebp], eax
$L69445:
  0010e	83 7d f4 03	 cmp	 DWORD PTR _i$69435[ebp], 3
  00112	73 24		 jae	 SHORT $L69447

; 93   :                 m_VolumePair[dwChorusIndex+i].dwMixBin = DSMIXBIN_FXSEND_1;

  00114	8b 4d f8	 mov	 ecx, DWORD PTR _dwChorusIndex$[ebp]
  00117	03 4d f4	 add	 ecx, DWORD PTR _i$69435[ebp]
  0011a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0011d	c7 44 ca 0c 0c
	00 00 00	 mov	 DWORD PTR [edx+ecx*8+12], 12 ; 0000000cH

; 94   :                 m_VolumePair[dwChorusIndex+i].lVolume  = 0;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _dwChorusIndex$[ebp]
  00128	03 45 f4	 add	 eax, DWORD PTR _i$69435[ebp]
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	c7 44 c1 10 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+16], 0

; 95   :             }

  00136	eb cd		 jmp	 SHORT $L69446
$L69447:

; 96   : 
; 97   :             m_DSMixBins.dwMixBinCount++;

  00138	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0013b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0013e	83 c0 01	 add	 eax, 1
  00141	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L69442:

; 98   :             
; 99   :         }
; 100  :         
; 101  :     }
; 102  : 
; 103  : 
; 104  : 
; 105  :     m_bValid = TRUE;

  00147	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0014a	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 106  : };

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 04 00	 ret	 4
?CreateFromMask@CMIXBINS@@QAEXK@Z ENDP			; CMIXBINS::CreateFromMask
_TEXT	ENDS
PUBLIC	??_C@_08GNBHJCKE@m_bValid?$AA@			; `string'
PUBLIC	?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ	; CMIXBINS::GetMixBins
;	COMDAT ??_C@_08GNBHJCKE@m_bValid?$AA@
CONST	SEGMENT
??_C@_08GNBHJCKE@m_bValid?$AA@ DB 'm_bValid', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ PROC NEAR	; CMIXBINS::GetMixBins, COMDAT
; _this$ = ecx

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 114  :     ASSERT(m_bValid);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	75 14		 jne	 SHORT $L69452
  0000f	6a 00		 push	 0
  00011	6a 72		 push	 114			; 00000072H
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GNBHJCKE@m_bValid?$AA@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69452:

; 115  :     if (!m_DSMixBins.dwMixBinCount)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0002a	75 04		 jne	 SHORT $L69454

; 116  :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 06		 jmp	 SHORT $L69451
$L69454:

; 117  :     else
; 118  :         return &m_DSMixBins;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 04	 add	 eax, 4
$L69451:

; 119  : };

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ ENDP		; CMIXBINS::GetMixBins
_TEXT	ENDS
PUBLIC	??_C@_09LLPGOAIE@alVolumes?$AA@			; `string'
PUBLIC	??_C@_0CG@FPEIKNLB@dwBitCount?5?$DM?$DN?5DSMIXBIN_ASSIGNMEN@ ; `string'
PUBLIC	??_C@_0BA@HLOHEKKI@dwBitCount?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0BG@HGGNAFID@dwCount?5?$DN?$DN?5dwBitCount?$AA@ ; `string'
PUBLIC	?PokeMixBinVolumesBasedOnMask@CMIXBINS@@QAEXKPAJ@Z ; CMIXBINS::PokeMixBinVolumesBasedOnMask
;	COMDAT ??_C@_09LLPGOAIE@alVolumes?$AA@
CONST	SEGMENT
??_C@_09LLPGOAIE@alVolumes?$AA@ DB 'alVolumes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FPEIKNLB@dwBitCount?5?$DM?$DN?5DSMIXBIN_ASSIGNMEN@
CONST	SEGMENT
??_C@_0CG@FPEIKNLB@dwBitCount?5?$DM?$DN?5DSMIXBIN_ASSIGNMEN@ DB 'dwBitCou'
	DB	'nt <= DSMIXBIN_ASSIGNMENT_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLOHEKKI@dwBitCount?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BA@HLOHEKKI@dwBitCount?5?$CB?$DN?50?$AA@ DB 'dwBitCount != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGGNAFID@dwCount?5?$DN?$DN?5dwBitCount?$AA@
CONST	SEGMENT
??_C@_0BG@HGGNAFID@dwCount?5?$DN?$DN?5dwBitCount?$AA@ DB 'dwCount == dwBi'
	DB	'tCount', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PokeMixBinVolumesBasedOnMask@CMIXBINS@@QAEXKPAJ@Z
_TEXT	SEGMENT
_this$ = -24
_dwMixBinIndex$69480 = -20
_bFound$69479 = -16
_dwBitCount$ = -12
_dwCount$ = -8
_i$ = -4
_dwMixBinMask$ = 8
_alVolumes$ = 12
?PokeMixBinVolumesBasedOnMask@CMIXBINS@@QAEXKPAJ@Z PROC NEAR ; CMIXBINS::PokeMixBinVolumesBasedOnMask, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 134  :     DWORD dwCount = 0;

  0000a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwCount$[ebp], 0

; 135  :     DWORD i       = 0;

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 136  :     
; 137  :     ASSERT(m_bValid);

  00018	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	75 17		 jne	 SHORT $L69463
  00020	6a 00		 push	 0
  00022	68 89 00 00 00	 push	 137			; 00000089H
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GNBHJCKE@m_bValid?$AA@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69463:

; 138  :     ASSERT(alVolumes);        

  00037	83 7d 0c 00	 cmp	 DWORD PTR _alVolumes$[ebp], 0
  0003b	75 17		 jne	 SHORT $L69464
  0003d	6a 00		 push	 0
  0003f	68 8a 00 00 00	 push	 138			; 0000008aH
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09LLPGOAIE@alVolumes?$AA@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69464:

; 139  :     #ifdef _DEBUG
; 140  :     DWORD dwBitCount = 0;

  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwBitCount$[ebp], 0

; 141  :     for (i=0; i<32; i++)

  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00062	eb 09		 jmp	 SHORT $L69467
$L69468:
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00067	83 c1 01	 add	 ecx, 1
  0006a	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L69467:
  0006d	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00071	73 1c		 jae	 SHORT $L69469

; 142  :     {
; 143  :         if ((1<<i) & dwMixBinMask)

  00073	ba 01 00 00 00	 mov	 edx, 1
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0007b	d3 e2		 shl	 edx, cl
  0007d	23 55 08	 and	 edx, DWORD PTR _dwMixBinMask$[ebp]
  00080	85 d2		 test	 edx, edx
  00082	74 09		 je	 SHORT $L69470

; 144  :             dwBitCount++;

  00084	8b 45 f4	 mov	 eax, DWORD PTR _dwBitCount$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	89 45 f4	 mov	 DWORD PTR _dwBitCount$[ebp], eax
$L69470:

; 145  :     }        

  0008d	eb d5		 jmp	 SHORT $L69468
$L69469:

; 146  :     ASSERT(dwBitCount <= DSMIXBIN_ASSIGNMENT_MAX);

  0008f	83 7d f4 08	 cmp	 DWORD PTR _dwBitCount$[ebp], 8
  00093	76 17		 jbe	 SHORT $L69471
  00095	6a 00		 push	 0
  00097	68 92 00 00 00	 push	 146			; 00000092H
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@FPEIKNLB@dwBitCount?5?$DM?$DN?5DSMIXBIN_ASSIGNMEN@
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69471:

; 147  :     ASSERT(dwBitCount != 0);

  000ac	83 7d f4 00	 cmp	 DWORD PTR _dwBitCount$[ebp], 0
  000b0	75 17		 jne	 SHORT $L69473
  000b2	6a 00		 push	 0
  000b4	68 93 00 00 00	 push	 147			; 00000093H
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@HLOHEKKI@dwBitCount?5?$CB?$DN?50?$AA@
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69473:

; 148  :     #endif
; 149  : 
; 150  :     //Scan through bits in the mask.
; 151  :     for (i=0; i<32; i++)

  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $L69475
$L69476:
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d5	83 c1 01	 add	 ecx, 1
  000d8	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L69475:
  000db	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000df	0f 83 85 00 00
	00		 jae	 $L69477

; 152  :     {
; 153  :         //If a bit is set...
; 154  :         if ((1<<i) & dwMixBinMask)

  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ed	d3 e2		 shl	 edx, cl
  000ef	23 55 08	 and	 edx, DWORD PTR _dwMixBinMask$[ebp]
  000f2	85 d2		 test	 edx, edx
  000f4	74 6f		 je	 SHORT $L69478

; 155  :         {
; 156  :             //...then find the mixbin represented by that bit and set its volume to the next element in the alVolumes array.
; 157  :             BOOL bFound = FALSE;

  000f6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bFound$69479[ebp], 0

; 158  :             for (DWORD dwMixBinIndex=0; dwMixBinIndex<DSMIXBIN_ASSIGNMENT_MAX; dwMixBinIndex++)

  000fd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwMixBinIndex$69480[ebp], 0
  00104	eb 09		 jmp	 SHORT $L69481
$L69482:
  00106	8b 45 ec	 mov	 eax, DWORD PTR _dwMixBinIndex$69480[ebp]
  00109	83 c0 01	 add	 eax, 1
  0010c	89 45 ec	 mov	 DWORD PTR _dwMixBinIndex$69480[ebp], eax
$L69481:
  0010f	83 7d ec 08	 cmp	 DWORD PTR _dwMixBinIndex$69480[ebp], 8
  00113	73 50		 jae	 SHORT $L69478

; 159  :             {
; 160  :                 if (m_DSMixBins.lpMixBinVolumePairs[dwMixBinIndex].dwMixBin == i)

  00115	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0011b	8b 45 ec	 mov	 eax, DWORD PTR _dwMixBinIndex$69480[ebp]
  0011e	8b 0c c2	 mov	 ecx, DWORD PTR [edx+eax*8]
  00121	3b 4d fc	 cmp	 ecx, DWORD PTR _i$[ebp]
  00124	75 3d		 jne	 SHORT $L69484

; 161  :                 {
; 162  :                     m_VolumePair[dwMixBinIndex].lVolume = alVolumes[dwCount];

  00126	8b 55 ec	 mov	 edx, DWORD PTR _dwMixBinIndex$69480[ebp]
  00129	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  0012f	8b 75 0c	 mov	 esi, DWORD PTR _alVolumes$[ebp]
  00132	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00135	89 4c d0 10	 mov	 DWORD PTR [eax+edx*8+16], ecx

; 163  : 
; 164  :                     if ((i == DSMIXBIN_FXSEND_0) || (i == DSMIXBIN_FXSEND_1)) 

  00139	83 7d fc 0b	 cmp	 DWORD PTR _i$[ebp], 11	; 0000000bH
  0013d	74 06		 je	 SHORT $L69486
  0013f	83 7d fc 0c	 cmp	 DWORD PTR _i$[ebp], 12	; 0000000cH
  00143	75 13		 jne	 SHORT $L69485
$L69486:

; 165  :                     {
; 166  :                         //
; 167  :                         // reverb send, this means the next volumepair is also for the reverb
; 168  :                         //
; 169  : 
; 170  :                         m_VolumePair[dwMixBinIndex+1].lVolume = alVolumes[dwCount];

  00145	8b 55 ec	 mov	 edx, DWORD PTR _dwMixBinIndex$69480[ebp]
  00148	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  0014e	8b 75 0c	 mov	 esi, DWORD PTR _alVolumes$[ebp]
  00151	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00154	89 4c d0 18	 mov	 DWORD PTR [eax+edx*8+24], ecx
$L69485:

; 171  :                     }
; 172  : 
; 173  :                     dwCount++;

  00158	8b 55 f8	 mov	 edx, DWORD PTR _dwCount$[ebp]
  0015b	83 c2 01	 add	 edx, 1
  0015e	89 55 f8	 mov	 DWORD PTR _dwCount$[ebp], edx

; 174  :                     break;

  00161	eb 02		 jmp	 SHORT $L69478
$L69484:

; 175  :                 }
; 176  : 
; 177  :             }

  00163	eb a1		 jmp	 SHORT $L69482
$L69478:

; 178  :         }
; 179  :     }

  00165	e9 68 ff ff ff	 jmp	 $L69476
$L69477:

; 180  : 
; 181  :     #ifdef _DEBUG
; 182  :     ASSERT(dwCount == dwBitCount);

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _dwCount$[ebp]
  0016d	3b 45 f4	 cmp	 eax, DWORD PTR _dwBitCount$[ebp]
  00170	74 17		 je	 SHORT $L69460
  00172	6a 00		 push	 0
  00174	68 b6 00 00 00	 push	 182			; 000000b6H
  00179	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  0017e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HGGNAFID@dwCount?5?$DN?$DN?5dwBitCount?$AA@
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69460:

; 183  :     #endif
; 184  : };

  00189	5e		 pop	 esi
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 08 00	 ret	 8
?PokeMixBinVolumesBasedOnMask@CMIXBINS@@QAEXKPAJ@Z ENDP	; CMIXBINS::PokeMixBinVolumesBasedOnMask
_TEXT	ENDS
PUBLIC	??_C@_0BD@PHBIGOLK@p_MixBins?4m_bValid?$AA@	; `string'
PUBLIC	??8CMIXBINS@@QAEHAAV0@@Z			; CMIXBINS::operator==
EXTRN	_memcmp:NEAR
;	COMDAT ??_C@_0BD@PHBIGOLK@p_MixBins?4m_bValid?$AA@
CONST	SEGMENT
??_C@_0BD@PHBIGOLK@p_MixBins?4m_bValid?$AA@ DB 'p_MixBins.m_bValid', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??8CMIXBINS@@QAEHAAV0@@Z
_TEXT	SEGMENT
_this$ = -4
_p_MixBins$ = 8
??8CMIXBINS@@QAEHAAV0@@Z PROC NEAR			; CMIXBINS::operator==, COMDAT
; _this$ = ecx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  :     ASSERT(m_bValid);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	75 17		 jne	 SHORT $L69493
  0000f	6a 00		 push	 0
  00011	68 bf 00 00 00	 push	 191			; 000000bfH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GNBHJCKE@m_bValid?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69493:

; 192  :     ASSERT(p_MixBins.m_bValid);

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _p_MixBins$[ebp]
  00029	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0002c	75 17		 jne	 SHORT $L69494
  0002e	6a 00		 push	 0
  00030	68 c0 00 00 00	 push	 192			; 000000c0H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCCBPPEB@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@PHBIGOLK@p_MixBins?4m_bValid?$AA@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69494:

; 193  : 
; 194  :     if (m_DSMixBins.dwMixBinCount == p_MixBins.m_DSMixBins.dwMixBinCount)

  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 45 08	 mov	 eax, DWORD PTR _p_MixBins$[ebp]
  0004b	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004e	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00051	75 2b		 jne	 SHORT $L69496

; 195  :         if (memcmp(m_DSMixBins.lpMixBinVolumePairs, p_MixBins.m_DSMixBins.lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * p_MixBins.m_DSMixBins.dwMixBinCount))

  00053	8b 55 08	 mov	 edx, DWORD PTR _p_MixBins$[ebp]
  00056	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00059	c1 e0 03	 shl	 eax, 3
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _p_MixBins$[ebp]
  00060	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00063	52		 push	 edx
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _memcmp
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	85 c0		 test	 eax, eax
  00075	74 07		 je	 SHORT $L69496

; 196  :             return TRUE;

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	eb 02		 jmp	 SHORT $L69492
$L69496:

; 197  :     return FALSE;

  0007e	33 c0		 xor	 eax, eax
$L69492:

; 198  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
??8CMIXBINS@@QAEHAAV0@@Z ENDP				; CMIXBINS::operator==
_TEXT	ENDS
PUBLIC	??9CMIXBINS@@QAEHAAV0@@Z			; CMIXBINS::operator!=
; Function compile flags: /Odt
;	COMDAT ??9CMIXBINS@@QAEHAAV0@@Z
_TEXT	SEGMENT
_this$ = -4
_p_MixBins$ = 8
??9CMIXBINS@@QAEHAAV0@@Z PROC NEAR			; CMIXBINS::operator!=, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  :     return (!(*this == p_MixBins));

  00007	8b 45 08	 mov	 eax, DWORD PTR _p_MixBins$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8CMIXBINS@@QAEHAAV0@@Z ; CMIXBINS::operator==
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax

; 205  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??9CMIXBINS@@QAEHAAV0@@Z ENDP				; CMIXBINS::operator!=
_TEXT	ENDS
END
