; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\queue.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KFKCHDNB@m_lCount?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHLDIJNC@m_lCount?5?$DN?$DN?5lCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@HFBKDLIG@ENQUEUE?3?5Attempt?5to?5enqueue?5a?5NU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@HFIBDGLO@ENQUEUE?3?5Item?5thinks?5it?5is?5still@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@EEHAHJJL@ENQUEUE?3?5Item?5is?5already?5in?5the?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@HEHINOIM@ENQUEUE?3?5Queue?5is?5not?5in?5time?5or@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@INKEAMHB@ENQUEUE?3?5Attempt?5to?5enqueue?5a?5pI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GKOOECEP@pItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@FKBFKPDL@pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_S@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@GOMHPAJM@ENQUEUE?5?$CISEGMENT?5RT?$CJ?3?5NODE?5IS?5AL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@JNFDMOGE@ENQUEUE?5?$CISEGMENT?5RT?$CJ?3?5LOOP?5CONDI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@OGHILKMF@ENQUEUE?5?$CISEGMENT?5RT?$CJ?3?5NODE?5IS?5AL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@JNCAPLOG@?$CB?$CI?5pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@JHONNHBD@ENQUEUE?5?$CISEGMENT?5MT?$CJ?3?5NODE?5IS?5AL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@GAOLEFFP@ENQUEUE?5?$CISEGMENT?5MT?$CJ?3?5LOOP?5CONDI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@BLMADBPO@ENQUEUE?5?$CISEGMENT?5MT?$CJ?3?5NODE?5IS?5AL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ??0CPMsgQueue@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPMsgQueue@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sort@CPMsgQueue@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@CPMsgQueue@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CSegState@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0CPMsgQueue@@QAE@XZ				; CPMsgQueue::CPMsgQueue
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\queue.cpp
;	COMDAT ??0CPMsgQueue@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPMsgQueue@@QAE@XZ PROC NEAR				; CPMsgQueue::CPMsgQueue, COMDAT
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 14   :     m_pTop = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 15   :     m_pLastAccessed = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 16   : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 17   :     m_lCount = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 18   : #endif
; 19   : }

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0CPMsgQueue@@QAE@XZ ENDP				; CPMsgQueue::CPMsgQueue
_TEXT	ENDS
PUBLIC	??1CPMsgQueue@@QAE@XZ				; CPMsgQueue::~CPMsgQueue
PUBLIC	??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0O@KFKCHDNB@m_lCount?5?$DN?$DN?50?$AA@	; `string'
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\queue.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KFKCHDNB@m_lCount?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0O@KFKCHDNB@m_lCount?5?$DN?$DN?50?$AA@ DB 'm_lCount == 0', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??1CPMsgQueue@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CPMsgQueue@@QAE@XZ PROC NEAR				; CPMsgQueue::~CPMsgQueue, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 25   :     assert(m_lCount == 0);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000e	74 11		 je	 SHORT $L69421
  00010	6a 19		 push	 25			; 00000019H
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@KFKCHDNB@m_lCount?5?$DN?$DN?50?$AA@
  0001c	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L69421:

; 26   : #endif
; 27   : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1CPMsgQueue@@QAE@XZ ENDP				; CPMsgQueue::~CPMsgQueue
_TEXT	ENDS
PUBLIC	?GetCount@CPMsgQueue@@QAEJXZ			; CPMsgQueue::GetCount
PUBLIC	?Sort@CPMsgQueue@@QAEXXZ			; CPMsgQueue::Sort
; Function compile flags: /Odt
;	COMDAT ?Sort@CPMsgQueue@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Sort@CPMsgQueue@@QAEXXZ PROC NEAR			; CPMsgQueue::Sort, COMDAT
; _this$ = ecx

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 100  :     m_pTop = sortevents(m_pTop, GetCount()) ;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetCount@CPMsgQueue@@QAEJXZ ; CPMsgQueue::GetCount
  0000f	50		 push	 eax
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z ; sortevents
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	89 02		 mov	 DWORD PTR [edx], eax

; 101  :     m_pLastAccessed = NULL;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 102  : }  

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?Sort@CPMsgQueue@@QAEXXZ ENDP				; CPMsgQueue::Sort
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z
_TEXT	SEGMENT
tv162 = -36
tv161 = -32
tv131 = -28
tv130 = -24
_pTop$ = -20
_lRight$ = -16
_pLeft$ = -12
_pRight$ = -8
_lLeft$ = -4
_pEvents$ = 8
_lLen$ = 12
?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z PROC NEAR		; sortevents, COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 32   :     PRIV_PMSG * pLeft;
; 33   :     PRIV_PMSG * pRight ;
; 34   :     long        lLeft;
; 35   :     long        lRight ;
; 36   :     PRIV_PMSG * pTop ;
; 37   : 
; 38   :     if( lLen < 3 )

  00006	83 7d 0c 03	 cmp	 DWORD PTR _lLen$[ebp], 3
  0000a	0f 8d 82 00 00
	00		 jge	 $L69434

; 39   :     {
; 40   :         if( !pEvents )

  00010	83 7d 08 00	 cmp	 DWORD PTR _pEvents$[ebp], 0
  00014	75 07		 jne	 SHORT $L69435

; 41   :             return( 0 ) ;

  00016	33 c0		 xor	 eax, eax
  00018	e9 7c 01 00 00	 jmp	 $L69428
$L69435:

; 42   :         if( lLen == 1 )

  0001d	83 7d 0c 01	 cmp	 DWORD PTR _lLen$[ebp], 1
  00021	75 08		 jne	 SHORT $L69436

; 43   :             return( pEvents ) ;

  00023	8b 45 08	 mov	 eax, DWORD PTR _pEvents$[ebp]
  00026	e9 6e 01 00 00	 jmp	 $L69428
$L69436:

; 44   :         pLeft  = pEvents ;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pEvents$[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR _pLeft$[ebp], eax

; 45   :         pRight = pEvents->pNext ;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _pEvents$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 f8	 mov	 DWORD PTR _pRight$[ebp], edx

; 46   :         if( !pRight )

  00039	83 7d f8 00	 cmp	 DWORD PTR _pRight$[ebp], 0
  0003d	75 08		 jne	 SHORT $L69437

; 47   :             return( pLeft ) ;

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _pLeft$[ebp]
  00042	e9 52 01 00 00	 jmp	 $L69428
$L69437:

; 48   :         if( pLeft->rtTime > pRight->rtTime )

  00047	8b 45 f4	 mov	 eax, DWORD PTR _pLeft$[ebp]
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _pRight$[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR tv130[ebp], eax
  00050	89 4d e4	 mov	 DWORD PTR tv131[ebp], ecx
  00053	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  00056	8b 45 e4	 mov	 eax, DWORD PTR tv131[ebp]
  00059	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0005c	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  0005f	7c 29		 jl	 SHORT $L69438
  00061	7f 0e		 jg	 SHORT $L69883
  00063	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  00066	8b 45 e4	 mov	 eax, DWORD PTR tv131[ebp]
  00069	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  0006c	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  0006f	76 19		 jbe	 SHORT $L69438
$L69883:

; 49   :         {
; 50   :             pLeft->pNext = NULL ;

  00071	8b 55 f4	 mov	 edx, DWORD PTR _pLeft$[ebp]
  00074	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 51   :             pRight->pNext = pLeft ;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _pRight$[ebp]
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _pLeft$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx

; 52   :             return( pRight ) ;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _pRight$[ebp]
  00085	e9 0f 01 00 00	 jmp	 $L69428
$L69438:

; 53   :         }
; 54   :         return( pLeft ) ;

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _pLeft$[ebp]
  0008d	e9 07 01 00 00	 jmp	 $L69428
$L69434:

; 55   :     }
; 56   : 
; 57   :     lLeft = lLen >> 1 ;

  00092	8b 55 0c	 mov	 edx, DWORD PTR _lLen$[ebp]
  00095	d1 fa		 sar	 edx, 1
  00097	89 55 fc	 mov	 DWORD PTR _lLeft$[ebp], edx

; 58   :     lRight = lLen - lLeft;

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _lLen$[ebp]
  0009d	2b 45 fc	 sub	 eax, DWORD PTR _lLeft$[ebp]
  000a0	89 45 f0	 mov	 DWORD PTR _lRight$[ebp], eax

; 59   :     pLeft = pEvents ;

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pEvents$[ebp]
  000a6	89 4d f4	 mov	 DWORD PTR _pLeft$[ebp], ecx

; 60   :     for (;lLeft > 1;pEvents = pEvents->pNext) lLeft--;

  000a9	eb 08		 jmp	 SHORT $L69439
$L69440:
  000ab	8b 55 08	 mov	 edx, DWORD PTR _pEvents$[ebp]
  000ae	8b 02		 mov	 eax, DWORD PTR [edx]
  000b0	89 45 08	 mov	 DWORD PTR _pEvents$[ebp], eax
$L69439:
  000b3	83 7d fc 01	 cmp	 DWORD PTR _lLeft$[ebp], 1
  000b7	7e 0b		 jle	 SHORT $L69441
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _lLeft$[ebp]
  000bc	83 e9 01	 sub	 ecx, 1
  000bf	89 4d fc	 mov	 DWORD PTR _lLeft$[ebp], ecx
  000c2	eb e7		 jmp	 SHORT $L69440
$L69441:

; 61   :     pRight = sortevents( pEvents->pNext, lRight ) ;

  000c4	8b 55 f0	 mov	 edx, DWORD PTR _lRight$[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 08	 mov	 eax, DWORD PTR _pEvents$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z ; sortevents
  000d3	89 45 f8	 mov	 DWORD PTR _pRight$[ebp], eax

; 62   :     pEvents->pNext = NULL ;

  000d6	8b 55 08	 mov	 edx, DWORD PTR _pEvents$[ebp]
  000d9	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 63   :     pLeft = sortevents( pLeft, lLen - lRight ) ;

  000df	8b 45 0c	 mov	 eax, DWORD PTR _lLen$[ebp]
  000e2	2b 45 f0	 sub	 eax, DWORD PTR _lRight$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR _pLeft$[ebp]
  000e9	51		 push	 ecx
  000ea	e8 00 00 00 00	 call	 ?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z ; sortevents
  000ef	89 45 f4	 mov	 DWORD PTR _pLeft$[ebp], eax

; 64   :     pTop = NULL ;

  000f2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pTop$[ebp], 0
$L69443:

; 65   : 
; 66   :     for( ;  pLeft && pRight ;  )

  000f9	83 7d f4 00	 cmp	 DWORD PTR _pLeft$[ebp], 0
  000fd	74 7f		 je	 SHORT $L69444
  000ff	83 7d f8 00	 cmp	 DWORD PTR _pRight$[ebp], 0
  00103	74 79		 je	 SHORT $L69444

; 67   :     {
; 68   :         if( pLeft->rtTime < pRight->rtTime )

  00105	8b 55 f4	 mov	 edx, DWORD PTR _pLeft$[ebp]
  00108	8b 45 f8	 mov	 eax, DWORD PTR _pRight$[ebp]
  0010b	89 55 e0	 mov	 DWORD PTR tv161[ebp], edx
  0010e	89 45 dc	 mov	 DWORD PTR tv162[ebp], eax
  00111	8b 4d e0	 mov	 ecx, DWORD PTR tv161[ebp]
  00114	8b 55 dc	 mov	 edx, DWORD PTR tv162[ebp]
  00117	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0011a	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  0011d	7f 36		 jg	 SHORT $L69445
  0011f	7c 0e		 jl	 SHORT $L69884
  00121	8b 4d e0	 mov	 ecx, DWORD PTR tv161[ebp]
  00124	8b 55 dc	 mov	 edx, DWORD PTR tv162[ebp]
  00127	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012a	3b 42 20	 cmp	 eax, DWORD PTR [edx+32]
  0012d	73 26		 jae	 SHORT $L69445
$L69884:

; 69   :         {
; 70   :             if( !pTop )

  0012f	83 7d ec 00	 cmp	 DWORD PTR _pTop$[ebp], 0
  00133	75 08		 jne	 SHORT $L69446

; 71   :                 pTop = pLeft ;

  00135	8b 4d f4	 mov	 ecx, DWORD PTR _pLeft$[ebp]
  00138	89 4d ec	 mov	 DWORD PTR _pTop$[ebp], ecx

; 72   :             else

  0013b	eb 08		 jmp	 SHORT $L69447
$L69446:

; 73   :                 pEvents->pNext = pLeft ;

  0013d	8b 55 08	 mov	 edx, DWORD PTR _pEvents$[ebp]
  00140	8b 45 f4	 mov	 eax, DWORD PTR _pLeft$[ebp]
  00143	89 02		 mov	 DWORD PTR [edx], eax
$L69447:

; 74   :             pEvents = pLeft ;

  00145	8b 4d f4	 mov	 ecx, DWORD PTR _pLeft$[ebp]
  00148	89 4d 08	 mov	 DWORD PTR _pEvents$[ebp], ecx

; 75   :             pLeft   = pEvents->pNext ;

  0014b	8b 55 08	 mov	 edx, DWORD PTR _pEvents$[ebp]
  0014e	8b 02		 mov	 eax, DWORD PTR [edx]
  00150	89 45 f4	 mov	 DWORD PTR _pLeft$[ebp], eax

; 76   :         }
; 77   :         else

  00153	eb 24		 jmp	 SHORT $L69448
$L69445:

; 78   :         {
; 79   :             if( !pTop )

  00155	83 7d ec 00	 cmp	 DWORD PTR _pTop$[ebp], 0
  00159	75 08		 jne	 SHORT $L69449

; 80   :                 pTop = pRight ;

  0015b	8b 4d f8	 mov	 ecx, DWORD PTR _pRight$[ebp]
  0015e	89 4d ec	 mov	 DWORD PTR _pTop$[ebp], ecx

; 81   :             else

  00161	eb 08		 jmp	 SHORT $L69450
$L69449:

; 82   :                 pEvents->pNext = pRight ;

  00163	8b 55 08	 mov	 edx, DWORD PTR _pEvents$[ebp]
  00166	8b 45 f8	 mov	 eax, DWORD PTR _pRight$[ebp]
  00169	89 02		 mov	 DWORD PTR [edx], eax
$L69450:

; 83   :             pEvents = pRight ;

  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _pRight$[ebp]
  0016e	89 4d 08	 mov	 DWORD PTR _pEvents$[ebp], ecx

; 84   :             pRight  = pEvents->pNext ;

  00171	8b 55 08	 mov	 edx, DWORD PTR _pEvents$[ebp]
  00174	8b 02		 mov	 eax, DWORD PTR [edx]
  00176	89 45 f8	 mov	 DWORD PTR _pRight$[ebp], eax
$L69448:

; 85   :         }
; 86   :     }

  00179	e9 7b ff ff ff	 jmp	 $L69443
$L69444:

; 87   : 
; 88   :     if( pLeft )

  0017e	83 7d f4 00	 cmp	 DWORD PTR _pLeft$[ebp], 0
  00182	74 0a		 je	 SHORT $L69451

; 89   :         pEvents->pNext = pLeft ;

  00184	8b 4d 08	 mov	 ecx, DWORD PTR _pEvents$[ebp]
  00187	8b 55 f4	 mov	 edx, DWORD PTR _pLeft$[ebp]
  0018a	89 11		 mov	 DWORD PTR [ecx], edx

; 90   :     else

  0018c	eb 08		 jmp	 SHORT $L69452
$L69451:

; 91   :         pEvents->pNext = pRight ;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _pEvents$[ebp]
  00191	8b 4d f8	 mov	 ecx, DWORD PTR _pRight$[ebp]
  00194	89 08		 mov	 DWORD PTR [eax], ecx
$L69452:

; 92   : 
; 93   :     return( pTop ) ;

  00196	8b 45 ec	 mov	 eax, DWORD PTR _pTop$[ebp]
$L69428:

; 94   : 
; 95   : }   

  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c2 08 00	 ret	 8
?sortevents@@YGPAUPRIV_PMSG@@PAU1@J@Z ENDP		; sortevents
_TEXT	ENDS
PUBLIC	?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ	; CPMsgQueue::GetHead
PUBLIC	??_C@_0BD@OHLDIJNC@m_lCount?5?$DN?$DN?5lCount?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OHLDIJNC@m_lCount?5?$DN?$DN?5lCount?$AA@
CONST	SEGMENT
??_C@_0BD@OHLDIJNC@m_lCount?5?$DN?$DN?5lCount?$AA@ DB 'm_lCount == lCount'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetCount@CPMsgQueue@@QAEJXZ
_TEXT	SEGMENT
_this$ = -12
_pScan$ = -8
_lCount$ = -4
?GetCount@CPMsgQueue@@QAEJXZ PROC NEAR			; CPMsgQueue::GetCount, COMDAT
; _this$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 107  :     long lCount = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lCount$[ebp], 0

; 108  :     PRIV_PMSG *pScan = GetHead();

  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::GetHead
  00018	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 109  :     for (;pScan;pScan = pScan->pNext)

  0001b	eb 08		 jmp	 SHORT $L69461
$L69462:
  0001d	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	89 4d f8	 mov	 DWORD PTR _pScan$[ebp], ecx
$L69461:
  00025	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00029	74 0b		 je	 SHORT $L69463

; 110  :     {
; 111  :         lCount++;

  0002b	8b 55 fc	 mov	 edx, DWORD PTR _lCount$[ebp]
  0002e	83 c2 01	 add	 edx, 1
  00031	89 55 fc	 mov	 DWORD PTR _lCount$[ebp], edx

; 112  :     }

  00034	eb e7		 jmp	 SHORT $L69462
$L69463:

; 113  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 114  :     assert(m_lCount == lCount);

  00036	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003c	3b 4d fc	 cmp	 ecx, DWORD PTR _lCount$[ebp]
  0003f	74 11		 je	 SHORT $L69888
  00041	6a 72		 push	 114			; 00000072H
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OHLDIJNC@m_lCount?5?$DN?$DN?5lCount?$AA@
  0004d	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L69888:

; 115  : #endif
; 116  :     return lCount;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _lCount$[ebp]

; 117  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GetCount@CPMsgQueue@@QAEJXZ ENDP			; CPMsgQueue::GetCount
_TEXT	ENDS
PUBLIC	?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z	; CPMsgQueue::Enqueue
; Function compile flags: /Odt
;	COMDAT ?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z
_TEXT	SEGMENT
tv208 = -48
tv207 = -44
tv193 = -40
tv192 = -36
tv177 = -32
tv176 = -28
tv160 = -24
tv148 = -20
_this$ = -16
_pScan$ = -12
_rtTime$ = -8
_pItem$ = 8
?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z PROC NEAR	; CPMsgQueue::Enqueue, COMDAT
; _this$ = ecx

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 122  :     if (!pItem)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000d	75 05		 jne	 SHORT $L69470

; 123  :     {
; 124  :         TraceI(0, "ENQUEUE: Attempt to enqueue a NULL pItem!\n");
; 125  :         return;

  0000f	e9 c1 01 00 00	 jmp	 $L69469
$L69470:

; 126  :     }
; 127  :     // Ensure not already queued...
; 128  :     if (pItem->dwPrivFlags & PRIV_FLAG_QUEUED)

  00014	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	83 e1 01	 and	 ecx, 1
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 05		 je	 SHORT $L69472

; 129  :     {
; 130  :         TraceI(0,"ENQUEUE: Item thinks it is still in a queue!\n");
; 131  :         return;

  00021	e9 af 01 00 00	 jmp	 $L69469
$L69472:

; 132  :     }
; 133  : 	pItem->dwPrivFlags |= PRIV_FLAG_QUEUED;

  00026	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00029	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002c	83 c8 01	 or	 eax, 1
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00032	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 134  :     PRIV_PMSG *pScan; 
; 135  : #ifdef DBG
; 136  :     // Verify robustness of list. Check that the event is not already in the list
; 137  :     // and that the time stamps are all in order.
; 138  :     REFERENCE_TIME rtTime = 0;

  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _rtTime$[ebp], 0
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rtTime$[ebp+4], 0

; 139  :     for (pScan = m_pTop;pScan;pScan = pScan->pNext)

  00043	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	89 45 f4	 mov	 DWORD PTR _pScan$[ebp], eax
  0004b	eb 08		 jmp	 SHORT $L69476
$L69477:
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	89 55 f4	 mov	 DWORD PTR _pScan$[ebp], edx
$L69476:
  00055	83 7d f4 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00059	74 6b		 je	 SHORT $L69478

; 140  :     {
; 141  :         if (pScan == pItem)

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _pScan$[ebp]
  0005e	3b 45 08	 cmp	 eax, DWORD PTR _pItem$[ebp]
  00061	75 05		 jne	 SHORT $L69479

; 142  :         {
; 143  :             TraceI(0,"ENQUEUE: Item is already in the queue!\n"); 
; 144  :             return;

  00063	e9 6d 01 00 00	 jmp	 $L69469
$L69479:

; 145  :         }
; 146  :     	// this must queue events in time sorted order
; 147  :         if (pScan->rtTime < rtTime)

  00068	8b 4d f4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0006b	89 4d ec	 mov	 DWORD PTR tv148[ebp], ecx
  0006e	8b 55 ec	 mov	 edx, DWORD PTR tv148[ebp]
  00071	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00074	3b 45 fc	 cmp	 eax, DWORD PTR _rtTime$[ebp+4]
  00077	7f 1e		 jg	 SHORT $L69481
  00079	7c 0b		 jl	 SHORT $L69892
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR tv148[ebp]
  0007e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00081	3b 55 f8	 cmp	 edx, DWORD PTR _rtTime$[ebp]
  00084	73 11		 jae	 SHORT $L69481
$L69892:

; 148  :         {
; 149  :             TraceI(0,"ENQUEUE: Queue is not in time order!\n");
; 150  :             pScan->rtTime = rtTime;

  00086	8b 45 f4	 mov	 eax, DWORD PTR _pScan$[ebp]
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _rtTime$[ebp]
  0008c	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  0008f	8b 55 fc	 mov	 edx, DWORD PTR _rtTime$[ebp+4]
  00092	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 151  :         }
; 152  :         else if (pScan->rtTime > rtTime)

  00095	eb 2d		 jmp	 SHORT $L69483
$L69481:
  00097	8b 45 f4	 mov	 eax, DWORD PTR _pScan$[ebp]
  0009a	89 45 e8	 mov	 DWORD PTR tv160[ebp], eax
  0009d	8b 4d e8	 mov	 ecx, DWORD PTR tv160[ebp]
  000a0	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000a3	3b 55 fc	 cmp	 edx, DWORD PTR _rtTime$[ebp+4]
  000a6	7c 1c		 jl	 SHORT $L69483
  000a8	7f 0b		 jg	 SHORT $L69893
  000aa	8b 45 e8	 mov	 eax, DWORD PTR tv160[ebp]
  000ad	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b0	3b 4d f8	 cmp	 ecx, DWORD PTR _rtTime$[ebp]
  000b3	76 0f		 jbe	 SHORT $L69483
$L69893:

; 153  :         {
; 154  :             rtTime = pScan->rtTime;

  000b5	8b 55 f4	 mov	 edx, DWORD PTR _pScan$[ebp]
  000b8	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000bb	89 45 f8	 mov	 DWORD PTR _rtTime$[ebp], eax
  000be	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  000c1	89 4d fc	 mov	 DWORD PTR _rtTime$[ebp+4], ecx
$L69483:

; 155  :         }
; 156  :     }

  000c4	eb 87		 jmp	 SHORT $L69477
$L69478:

; 157  : #endif
; 158  :     if ( !(pItem->dwFlags & DMUS_PMSGF_REFTIME) ) // sorting on reftime, so this must be valid 

  000c6	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  000c9	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000cc	83 e0 01	 and	 eax, 1
  000cf	85 c0		 test	 eax, eax
  000d1	75 05		 jne	 SHORT $L69485

; 159  :     {
; 160  :         TraceI(0, "ENQUEUE: Attempt to enqueue a pItem with a bogus RefTime!\n");
; 161  :         return;

  000d3	e9 fd 00 00 00	 jmp	 $L69469
$L69485:

; 162  :     }
; 163  :     if (m_pLastAccessed && (m_pLastAccessed->rtTime <= pItem->rtTime))

  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000df	74 38		 je	 SHORT $L69487
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000ea	89 45 e4	 mov	 DWORD PTR tv176[ebp], eax
  000ed	89 4d e0	 mov	 DWORD PTR tv177[ebp], ecx
  000f0	8b 55 e4	 mov	 edx, DWORD PTR tv176[ebp]
  000f3	8b 45 e0	 mov	 eax, DWORD PTR tv177[ebp]
  000f6	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  000f9	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  000fc	7f 1b		 jg	 SHORT $L69487
  000fe	7c 0e		 jl	 SHORT $L69894
  00100	8b 55 e4	 mov	 edx, DWORD PTR tv176[ebp]
  00103	8b 45 e0	 mov	 eax, DWORD PTR tv177[ebp]
  00106	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00109	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  0010c	77 0b		 ja	 SHORT $L69487
$L69894:

; 164  :     {
; 165  :         pScan = m_pLastAccessed;

  0010e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00111	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00114	89 45 f4	 mov	 DWORD PTR _pScan$[ebp], eax

; 166  :     }
; 167  :     else

  00117	eb 08		 jmp	 SHORT $L69488
$L69487:

; 168  :     {
; 169  :         pScan = m_pTop;

  00119	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	89 55 f4	 mov	 DWORD PTR _pScan$[ebp], edx
$L69488:

; 170  :     }
; 171  :     if ( pScan && ( pScan->rtTime <= pItem->rtTime ) )

  00121	83 7d f4 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00125	0f 84 80 00 00
	00		 je	 $L69489
  0012b	8b 45 f4	 mov	 eax, DWORD PTR _pScan$[ebp]
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00131	89 45 dc	 mov	 DWORD PTR tv192[ebp], eax
  00134	89 4d d8	 mov	 DWORD PTR tv193[ebp], ecx
  00137	8b 55 dc	 mov	 edx, DWORD PTR tv192[ebp]
  0013a	8b 45 d8	 mov	 eax, DWORD PTR tv193[ebp]
  0013d	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  00140	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00143	7f 66		 jg	 SHORT $L69489
  00145	7c 0e		 jl	 SHORT $L69895
  00147	8b 55 dc	 mov	 edx, DWORD PTR tv192[ebp]
  0014a	8b 45 d8	 mov	 eax, DWORD PTR tv193[ebp]
  0014d	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00150	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00153	77 56		 ja	 SHORT $L69489
$L69895:

; 172  : 	{
; 173  : 		for (; pScan->pNext; pScan = pScan->pNext )

  00155	eb 08		 jmp	 SHORT $L69490
$L69491:
  00157	8b 55 f4	 mov	 edx, DWORD PTR _pScan$[ebp]
  0015a	8b 02		 mov	 eax, DWORD PTR [edx]
  0015c	89 45 f4	 mov	 DWORD PTR _pScan$[ebp], eax
$L69490:
  0015f	8b 4d f4	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00162	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00165	74 30		 je	 SHORT $L69492

; 174  : 		{
; 175  : 			if( pScan->pNext->rtTime > pItem->rtTime )

  00167	8b 55 f4	 mov	 edx, DWORD PTR _pScan$[ebp]
  0016a	8b 02		 mov	 eax, DWORD PTR [edx]
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0016f	89 45 d4	 mov	 DWORD PTR tv207[ebp], eax
  00172	89 4d d0	 mov	 DWORD PTR tv208[ebp], ecx
  00175	8b 55 d4	 mov	 edx, DWORD PTR tv207[ebp]
  00178	8b 45 d0	 mov	 eax, DWORD PTR tv208[ebp]
  0017b	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0017e	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00181	7c 12		 jl	 SHORT $L69493
  00183	7f 0e		 jg	 SHORT $L69896
  00185	8b 55 d4	 mov	 edx, DWORD PTR tv207[ebp]
  00188	8b 45 d0	 mov	 eax, DWORD PTR tv208[ebp]
  0018b	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  0018e	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00191	76 02		 jbe	 SHORT $L69493
$L69896:

; 176  : 			{
; 177  : 				break;

  00193	eb 02		 jmp	 SHORT $L69492
$L69493:

; 178  : 			}
; 179  : 		}

  00195	eb c0		 jmp	 SHORT $L69491
$L69492:

; 180  : 		pItem->pNext = pScan->pNext;

  00197	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0019a	8b 45 f4	 mov	 eax, DWORD PTR _pScan$[ebp]
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	89 0a		 mov	 DWORD PTR [edx], ecx

; 181  : 		pScan->pNext = pItem;

  001a1	8b 55 f4	 mov	 edx, DWORD PTR _pScan$[ebp]
  001a4	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  001a7	89 02		 mov	 DWORD PTR [edx], eax

; 182  :     }
; 183  : 	else 

  001a9	eb 12		 jmp	 SHORT $L69494
$L69489:

; 184  : 	{
; 185  : 		pItem->pNext = m_pTop;

  001ab	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001ae	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001b1	8b 02		 mov	 eax, DWORD PTR [edx]
  001b3	89 01		 mov	 DWORD PTR [ecx], eax

; 186  : 		m_pTop = pItem;

  001b5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  001bb	89 11		 mov	 DWORD PTR [ecx], edx
$L69494:

; 187  : 	}
; 188  :     m_pLastAccessed = pItem;

  001bd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001c3	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 189  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 190  :     m_lCount++;

  001c6	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001c9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001cc	83 c0 01	 add	 eax, 1
  001cf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d2	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L69469:

; 191  : #endif
; 192  : }

  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c2 04 00	 ret	 4
?Enqueue@CPMsgQueue@@QAEXPAUPRIV_PMSG@@@Z ENDP		; CPMsgQueue::Enqueue
_TEXT	ENDS
PUBLIC	?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z	; CPMsgQueue::FlushOldest
; Function compile flags: /Odt
;	COMDAT ?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z
_TEXT	SEGMENT
tv84 = -16
_this$ = -12
_pDelete$69502 = -8
_pNext$ = -4
_rtTime$ = 8
?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z PROC NEAR ; CPMsgQueue::FlushOldest, COMDAT
; _this$ = ecx

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :     PRIV_PMSG *pNext;
; 204  :     if (m_pTop && (pNext = m_pTop->pNext))

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	0f 84 80 00 00
	00		 je	 $L69500
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax
  0001f	83 7d fc 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00023	74 70		 je	 SHORT $L69500

; 205  :     {
; 206  :         if (pNext->rtTime < rtTime)

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00028	89 4d f0	 mov	 DWORD PTR tv84[ebp], ecx
  0002b	8b 55 f0	 mov	 edx, DWORD PTR tv84[ebp]
  0002e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00031	3b 45 0c	 cmp	 eax, DWORD PTR _rtTime$[ebp+4]
  00034	7f 5f		 jg	 SHORT $L69500
  00036	7c 0b		 jl	 SHORT $L69900
  00038	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  0003b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0003e	3b 55 08	 cmp	 edx, DWORD PTR _rtTime$[ebp]
  00041	73 52		 jae	 SHORT $L69500
$L69900:

; 207  :         {
; 208  :             PRIV_PMSG *pDelete = m_pTop;

  00043	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	89 4d f8	 mov	 DWORD PTR _pDelete$69502[ebp], ecx

; 209  :             if (m_pLastAccessed == m_pTop)

  0004b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00054	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00056	75 09		 jne	 SHORT $L69503

; 210  :             {
; 211  :                 m_pLastAccessed = pNext;

  00058	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _pNext$[ebp]
  0005e	89 42 04	 mov	 DWORD PTR [edx+4], eax
$L69503:

; 212  :             }
; 213  :             m_pTop = pNext;

  00061	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  00067	89 11		 mov	 DWORD PTR [ecx], edx

; 214  : 			pDelete->dwPrivFlags &= ~PRIV_FLAG_QUEUED;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _pDelete$69502[ebp]
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00072	8b 55 f8	 mov	 edx, DWORD PTR _pDelete$69502[ebp]
  00075	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 215  : 			pDelete->pNext = NULL;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _pDelete$69502[ebp]
  0007b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 216  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 217  :             m_lCount--;

  00081	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00087	83 ea 01	 sub	 edx, 1
  0008a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 218  : #endif
; 219  :             return pDelete;

  00090	8b 45 f8	 mov	 eax, DWORD PTR _pDelete$69502[ebp]
  00093	eb 02		 jmp	 SHORT $L69498
$L69500:

; 220  :         }
; 221  :     }
; 222  :     return NULL;

  00095	33 c0		 xor	 eax, eax
$L69498:

; 223  : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?FlushOldest@CPMsgQueue@@QAEPAUPRIV_PMSG@@_J@Z ENDP	; CPMsgQueue::FlushOldest
_TEXT	ENDS
PUBLIC	?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ	; CPMsgQueue::Dequeue
; Function compile flags: /Odt
;	COMDAT ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT
_this$ = -8
_pItem$ = -4
?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ PROC NEAR	; CPMsgQueue::Dequeue, COMDAT
; _this$ = ecx

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 228  :     PRIV_PMSG *pItem = m_pTop;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _pItem$[ebp], ecx

; 229  : 
; 230  :     if (pItem != NULL)

  00011	83 7d fc 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00015	74 47		 je	 SHORT $L69508

; 231  : 	{
; 232  :         m_pTop = pItem->pNext;

  00017	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 0a		 mov	 DWORD PTR [edx], ecx

; 233  : 		pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;

  00021	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	83 e0 fe	 and	 eax, -2			; fffffffeH
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 234  :         pItem->pNext = NULL;

  00030	8b 55 fc	 mov	 edx, DWORD PTR _pItem$[ebp]
  00033	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 235  :         if (m_pLastAccessed == pItem)

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	3b 4d fc	 cmp	 ecx, DWORD PTR _pItem$[ebp]
  00042	75 0b		 jne	 SHORT $L69509

; 236  :         {
; 237  :             m_pLastAccessed = m_pTop;

  00044	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L69509:

; 238  :         }
; 239  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 240  :         m_lCount--;

  0004f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00055	83 e8 01	 sub	 eax, 1
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L69508:

; 241  : #endif
; 242  :     }
; 243  : 
; 244  :     return pItem;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]

; 245  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ENDP		; CPMsgQueue::Dequeue
_TEXT	ENDS
PUBLIC	?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z	; CPMsgQueue::Dequeue
PUBLIC	??_C@_05GKOOECEP@pItem?$AA@			; `string'
EXTRN	__imp__RtlAssert@16:NEAR
;	COMDAT ??_C@_05GKOOECEP@pItem?$AA@
CONST	SEGMENT
??_C@_05GKOOECEP@pItem?$AA@ DB 'pItem', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z
_TEXT	SEGMENT
tv139 = -20
tv138 = -16
_this$ = -12
_pScan$ = -8
_pNext$ = -4
_pItem$ = 8
?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z PROC NEAR	; CPMsgQueue::Dequeue, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 250  :     ASSERT(pItem);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000d	75 17		 jne	 SHORT $L69514
  0000f	6a 00		 push	 0
  00011	68 fa 00 00 00	 push	 250			; 000000faH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05GKOOECEP@pItem?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69514:

; 251  : 
; 252  :     if (pItem == m_pTop)

  00026	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0002c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0002e	75 0d		 jne	 SHORT $L69516

; 253  :     {
; 254  :         return Dequeue();

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ; CPMsgQueue::Dequeue
  00038	e9 d6 00 00 00	 jmp	 $L69513
$L69516:

; 255  :     }
; 256  :     PRIV_PMSG *pScan;
; 257  :     PRIV_PMSG *pNext;
; 258  :     if (m_pLastAccessed && 
; 259  :         (m_pLastAccessed->rtTime < pItem->rtTime))

  0003d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00040	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00044	74 38		 je	 SHORT $L69519
  00046	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0004f	89 4d f0	 mov	 DWORD PTR tv138[ebp], ecx
  00052	89 55 ec	 mov	 DWORD PTR tv139[ebp], edx
  00055	8b 45 f0	 mov	 eax, DWORD PTR tv138[ebp]
  00058	8b 4d ec	 mov	 ecx, DWORD PTR tv139[ebp]
  0005b	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0005e	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  00061	7f 1b		 jg	 SHORT $L69519
  00063	7c 0e		 jl	 SHORT $L69907
  00065	8b 45 f0	 mov	 eax, DWORD PTR tv138[ebp]
  00068	8b 4d ec	 mov	 ecx, DWORD PTR tv139[ebp]
  0006b	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0006e	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  00071	73 0b		 jae	 SHORT $L69519
$L69907:

; 260  :     {
; 261  :         pScan = m_pLastAccessed;

  00073	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	89 4d f8	 mov	 DWORD PTR _pScan$[ebp], ecx

; 262  :     }
; 263  :     else

  0007c	eb 08		 jmp	 SHORT $L69520
$L69519:

; 264  :     {
; 265  :         pScan = m_pTop;

  0007e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 02		 mov	 eax, DWORD PTR [edx]
  00083	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax
$L69520:

; 266  :     }
; 267  :     for (;pScan;pScan = pNext)

  00086	eb 06		 jmp	 SHORT $L69521
$L69522:
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0008b	89 4d f8	 mov	 DWORD PTR _pScan$[ebp], ecx
$L69521:
  0008e	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00092	74 5c		 je	 SHORT $L69523

; 268  :     {
; 269  :         pNext = pScan->pNext;

  00094	8b 55 f8	 mov	 edx, DWORD PTR _pScan$[ebp]
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax

; 270  :         if (pNext == pItem)

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0009f	3b 4d 08	 cmp	 ecx, DWORD PTR _pItem$[ebp]
  000a2	75 4a		 jne	 SHORT $L69524

; 271  :         {
; 272  :             pScan->pNext = pItem->pNext;

  000a4	8b 55 f8	 mov	 edx, DWORD PTR _pScan$[ebp]
  000a7	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  :             pItem->pNext = NULL;

  000ae	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  000b1	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 274  :             pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;

  000b7	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  000ba	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000bd	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000c0	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  000c3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 275  :             if (m_pLastAccessed == pItem)

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	3b 4d 08	 cmp	 ecx, DWORD PTR _pItem$[ebp]
  000cf	75 09		 jne	 SHORT $L69525

; 276  :             {
; 277  :                 m_pLastAccessed = pScan;

  000d1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  000d7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$L69525:

; 278  :             }
; 279  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 280  :             m_lCount--;

  000da	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e0	83 ea 01	 sub	 edx, 1
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 281  : #endif
; 282  :             return pItem;

  000e9	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  000ec	eb 25		 jmp	 SHORT $L69513
$L69524:

; 283  :         }
; 284  :     }

  000ee	eb 98		 jmp	 SHORT $L69522
$L69523:

; 285  :     if (m_pLastAccessed)

  000f0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000f7	74 18		 je	 SHORT $L69526

; 286  :     {
; 287  :         // This happens every now and then as a result of a curve setting rtTime to 0
; 288  :         // in the middle of FlushEventQueue. 
; 289  :         // This should be fixed, but this patch will work for now.
; 290  :         m_pLastAccessed = NULL;

  000f9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000fc	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 291  :         return Dequeue(pItem);

  00103	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00106	50		 push	 eax
  00107	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	e8 00 00 00 00	 call	 ?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z ; CPMsgQueue::Dequeue
  0010f	eb 02		 jmp	 SHORT $L69513
$L69526:

; 292  :     }
; 293  :     return NULL;

  00111	33 c0		 xor	 eax, eax
$L69513:

; 294  : }

  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
?Dequeue@CPMsgQueue@@QAEPAUPRIV_PMSG@@PAU2@@Z ENDP	; CPMsgQueue::Dequeue
_TEXT	ENDS
PUBLIC	?GetNext@CSegState@@QAEPAV1@XZ			; CSegState::GetNext
PUBLIC	?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z	; CSegStateList::AddHead
PUBLIC	?Insert@CSegStateList@@QAEXPAVCSegState@@@Z	; CSegStateList::Insert
PUBLIC	?GetHead@CSegStateList@@QAEPAVCSegState@@XZ	; CSegStateList::GetHead
PUBLIC	?SetNext@AListItem@@QAEXPAV1@@Z			; AListItem::SetNext
PUBLIC	??_C@_0CM@FKBFKPDL@pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_S@ ; `string'
PUBLIC	??_C@_0DB@JNCAPLOG@?$CB?$CI?5pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMU@ ; `string'
;	COMDAT ??_C@_0CM@FKBFKPDL@pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_S@
CONST	SEGMENT
??_C@_0CM@FKBFKPDL@pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_S@ DB 'pScan->'
	DB	'm_dwPlaySegFlags & DMUS_SEGF_REFTIME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JNCAPLOG@?$CB?$CI?5pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMU@
CONST	SEGMENT
??_C@_0DB@JNCAPLOG@?$CB?$CI?5pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMU@ DB '!'
	DB	'( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Insert@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT
tv211 = -64
tv207 = -60
tv201 = -56
tv198 = -52
tv155 = -48
tv149 = -44
tv146 = -40
tv254 = -36
tv253 = -32
tv241 = -28
tv240 = -24
tv222 = -20
tv221 = -16
_this$ = -12
_pScan$ = -8
_pNext$ = -4
_pItem$ = 8
?Insert@CSegStateList@@QAEXPAVCSegState@@@Z PROC NEAR	; CSegStateList::Insert, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 302  :     CSegState *pScan = GetHead();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ; CSegStateList::GetHead
  00011	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 303  :     CSegState *pNext;
; 304  :     pItem->SetNext(NULL);

  00014	6a 00		 push	 0
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00019	83 c1 08	 add	 ecx, 8
  0001c	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 305  :     if (pScan)

  00021	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00025	0f 84 01 03 00
	00		 je	 $L69533

; 306  : 	{
; 307  : 		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0002e	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00031	83 e1 40	 and	 ecx, 64			; 00000040H
  00034	85 c9		 test	 ecx, ecx
  00036	0f 84 b9 01 00
	00		 je	 $L69534

; 308  : 		{
; 309  : 			ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );

  0003c	8b 55 f8	 mov	 edx, DWORD PTR _pScan$[ebp]
  0003f	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00042	83 e0 40	 and	 eax, 64			; 00000040H
  00045	85 c0		 test	 eax, eax
  00047	75 17		 jne	 SHORT $L69535
  00049	6a 00		 push	 0
  0004b	68 35 01 00 00	 push	 309			; 00000135H
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@FKBFKPDL@pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_S@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69535:

; 310  : 			// Avoid putting circularities in the list
; 311  : 			if (pItem == pScan)

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00063	3b 4d f8	 cmp	 ecx, DWORD PTR _pScan$[ebp]
  00066	75 05		 jne	 SHORT $L69537

; 312  : 			{
; 313  : 				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
; 314  : 			}
; 315  : 			else if( pItem->m_rtGivenStart < pScan->m_rtGivenStart )

  00068	e9 83 01 00 00	 jmp	 $L69539
$L69537:
  0006d	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00070	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00073	89 55 f0	 mov	 DWORD PTR tv221[ebp], edx
  00076	89 45 ec	 mov	 DWORD PTR tv222[ebp], eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv221[ebp]
  0007c	8b 55 ec	 mov	 edx, DWORD PTR tv222[ebp]
  0007f	8b 81 a4 00 00
	00		 mov	 eax, DWORD PTR [ecx+164]
  00085	3b 82 a4 00 00
	00		 cmp	 eax, DWORD PTR [edx+164]
  0008b	7f 27		 jg	 SHORT $L69543
  0008d	7c 14		 jl	 SHORT $L69921
  0008f	8b 4d f0	 mov	 ecx, DWORD PTR tv221[ebp]
  00092	8b 55 ec	 mov	 edx, DWORD PTR tv222[ebp]
  00095	8b 81 a0 00 00
	00		 mov	 eax, DWORD PTR [ecx+160]
  0009b	3b 82 a0 00 00
	00		 cmp	 eax, DWORD PTR [edx+160]
  000a1	73 11		 jae	 SHORT $L69543
$L69921:

; 316  : 			{
; 317  :                 AddHead(pItem);

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::AddHead

; 318  : 			}
; 319  : 			else

  000af	e9 3c 01 00 00	 jmp	 $L69539
$L69543:

; 320  : 			{
; 321  : 				while( pNext = pScan->GetNext() )

  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  000b7	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  000bc	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax
  000bf	83 7d fc 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  000c3	0f 84 c6 00 00
	00		 je	 $L69544

; 322  : 				{
; 323  : 					ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );

  000c9	8b 55 f8	 mov	 edx, DWORD PTR _pScan$[ebp]
  000cc	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000cf	83 e0 40	 and	 eax, 64			; 00000040H
  000d2	85 c0		 test	 eax, eax
  000d4	75 17		 jne	 SHORT $L69545
  000d6	6a 00		 push	 0
  000d8	68 43 01 00 00	 push	 323			; 00000143H
  000dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@FKBFKPDL@pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMUS_S@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69545:

; 324  : 					// Am I trying to insert something that's already in the list?
; 325  : 					if (pItem == pScan)

  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000f0	3b 4d f8	 cmp	 ecx, DWORD PTR _pScan$[ebp]
  000f3	75 05		 jne	 SHORT $L69546

; 326  : 					{
; 327  : 						break;

  000f5	e9 95 00 00 00	 jmp	 $L69544
$L69546:

; 328  : 					}
; 329  : 					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
; 330  : 					if ( ( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
; 331  : 						 pScan->m_rtGivenStart > pNext->m_rtGivenStart )

  000fa	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  000fd	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00100	83 e0 40	 and	 eax, 64			; 00000040H
  00103	85 c0		 test	 eax, eax
  00105	74 45		 je	 SHORT $L69547
  00107	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0010a	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  0010d	89 4d e8	 mov	 DWORD PTR tv240[ebp], ecx
  00110	89 55 e4	 mov	 DWORD PTR tv241[ebp], edx
  00113	8b 45 e8	 mov	 eax, DWORD PTR tv240[ebp]
  00116	8b 4d e4	 mov	 ecx, DWORD PTR tv241[ebp]
  00119	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  0011f	3b 91 a4 00 00
	00		 cmp	 edx, DWORD PTR [ecx+164]
  00125	7c 25		 jl	 SHORT $L69547
  00127	7f 14		 jg	 SHORT $L69922
  00129	8b 45 e8	 mov	 eax, DWORD PTR tv240[ebp]
  0012c	8b 4d e4	 mov	 ecx, DWORD PTR tv241[ebp]
  0012f	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  00135	3b 91 a0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+160]
  0013b	76 0f		 jbe	 SHORT $L69547
$L69922:

; 332  : 					{
; 333  : 						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
; 334  : 						// get rid of the potential circularity in the list.  Note that this
; 335  : 						// (or actually the creation of the circularity) could cause memory leaks.
; 336  : 						pScan->SetNext(NULL);

  0013d	6a 00		 push	 0
  0013f	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00142	83 c1 08	 add	 ecx, 8
  00145	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 337  : 						break;

  0014a	eb 43		 jmp	 SHORT $L69544
$L69547:

; 338  : 					}
; 339  : 					if( pItem->m_rtGivenStart < pNext->m_rtGivenStart )

  0014c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0014f	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00152	89 45 e0	 mov	 DWORD PTR tv253[ebp], eax
  00155	89 4d dc	 mov	 DWORD PTR tv254[ebp], ecx
  00158	8b 55 e0	 mov	 edx, DWORD PTR tv253[ebp]
  0015b	8b 45 dc	 mov	 eax, DWORD PTR tv254[ebp]
  0015e	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  00164	3b 88 a4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+164]
  0016a	7f 18		 jg	 SHORT $L69549
  0016c	7c 14		 jl	 SHORT $L69923
  0016e	8b 55 e0	 mov	 edx, DWORD PTR tv253[ebp]
  00171	8b 45 dc	 mov	 eax, DWORD PTR tv254[ebp]
  00174	8b 8a a0 00 00
	00		 mov	 ecx, DWORD PTR [edx+160]
  0017a	3b 88 a0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+160]
  00180	73 02		 jae	 SHORT $L69549
$L69923:

; 340  : 					{
; 341  : 						break;

  00182	eb 0b		 jmp	 SHORT $L69544
$L69549:

; 342  : 					}
; 343  : 					pScan = pNext;

  00184	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  00187	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 344  : 				}

  0018a	e9 25 ff ff ff	 jmp	 $L69543
$L69544:

; 345  : 				if (pItem != pScan)

  0018f	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00192	3b 45 f8	 cmp	 eax, DWORD PTR _pScan$[ebp]
  00195	74 59		 je	 SHORT $L69539

; 346  : 				{
; 347  : 					pItem->SetNext(pScan->GetNext());

  00197	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0019a	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0019f	89 45 d8	 mov	 DWORD PTR tv146[ebp], eax
  001a2	83 7d d8 00	 cmp	 DWORD PTR tv146[ebp], 0
  001a6	74 0b		 je	 SHORT $L69911
  001a8	8b 4d d8	 mov	 ecx, DWORD PTR tv146[ebp]
  001ab	83 c1 08	 add	 ecx, 8
  001ae	89 4d d4	 mov	 DWORD PTR tv149[ebp], ecx
  001b1	eb 07		 jmp	 SHORT $L69912
$L69911:
  001b3	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
$L69912:
  001ba	8b 55 d4	 mov	 edx, DWORD PTR tv149[ebp]
  001bd	52		 push	 edx
  001be	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001c1	83 c1 08	 add	 ecx, 8
  001c4	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 348  : 					pScan->SetNext(pItem);

  001c9	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  001cd	74 0b		 je	 SHORT $L69913
  001cf	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  001d2	83 c0 08	 add	 eax, 8
  001d5	89 45 d0	 mov	 DWORD PTR tv155[ebp], eax
  001d8	eb 07		 jmp	 SHORT $L69914
$L69913:
  001da	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
$L69914:
  001e1	8b 4d d0	 mov	 ecx, DWORD PTR tv155[ebp]
  001e4	51		 push	 ecx
  001e5	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  001e8	83 c1 08	 add	 ecx, 8
  001eb	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L69539:

; 349  : 				}
; 350  : 				else
; 351  : 				{
; 352  : 					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
; 353  : 				}
; 354  : 			}
; 355  : 		}
; 356  : 		else

  001f0	e9 35 01 00 00	 jmp	 $L69553
$L69534:

; 357  : 		{
; 358  : 			ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );

  001f5	8b 55 f8	 mov	 edx, DWORD PTR _pScan$[ebp]
  001f8	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  001fb	83 e0 40	 and	 eax, 64			; 00000040H
  001fe	85 c0		 test	 eax, eax
  00200	74 17		 je	 SHORT $L69554
  00202	6a 00		 push	 0
  00204	68 66 01 00 00	 push	 358			; 00000166H
  00209	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  0020e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@JNCAPLOG@?$CB?$CI?5pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMU@
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69554:

; 359  : 			// Avoid putting circularities in the list
; 360  : 			if (pItem == pScan)

  00219	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0021c	3b 4d f8	 cmp	 ecx, DWORD PTR _pScan$[ebp]
  0021f	75 05		 jne	 SHORT $L69556

; 361  : 			{
; 362  : 				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
; 363  : 			}
; 364  : 			else if( pItem->m_mtResolvedStart < pScan->m_mtResolvedStart )

  00221	e9 04 01 00 00	 jmp	 $L69553
$L69556:
  00226	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00229	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  0022c	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  0022f	3b 48 64	 cmp	 ecx, DWORD PTR [eax+100]
  00232	7d 11		 jge	 SHORT $L69562

; 365  : 			{
; 366  : 				AddHead(pItem);

  00234	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00237	52		 push	 edx
  00238	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	e8 00 00 00 00	 call	 ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ; CSegStateList::AddHead

; 367  : 			}
; 368  : 			else

  00240	e9 e5 00 00 00	 jmp	 $L69553
$L69562:

; 369  : 			{
; 370  : 				while( pNext = pScan->GetNext() )

  00245	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00248	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  0024d	89 45 fc	 mov	 DWORD PTR _pNext$[ebp], eax
  00250	83 7d fc 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00254	74 73		 je	 SHORT $L69563

; 371  : 				{
; 372  : 					ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );

  00256	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00259	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0025c	83 e1 40	 and	 ecx, 64			; 00000040H
  0025f	85 c9		 test	 ecx, ecx
  00261	74 17		 je	 SHORT $L69564
  00263	6a 00		 push	 0
  00265	68 74 01 00 00	 push	 372			; 00000174H
  0026a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@CCENNHEA@c?3?2xbox?2private?2windows?2directx?2@
  0026f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@JNCAPLOG@?$CB?$CI?5pScan?9?$DOm_dwPlaySegFlags?5?$CG?5DMU@
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69564:

; 373  : 					// Am I trying to insert something that's already in the list?
; 374  : 					if (pItem == pScan)

  0027a	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0027d	3b 55 f8	 cmp	 edx, DWORD PTR _pScan$[ebp]
  00280	75 02		 jne	 SHORT $L69565

; 375  : 					{
; 376  : 						break;

  00282	eb 45		 jmp	 SHORT $L69563
$L69565:

; 377  : 					}
; 378  : 					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
; 379  : 					if ( !( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
; 380  : 						 pScan->m_mtResolvedStart > pNext->m_mtResolvedStart )

  00284	8b 45 fc	 mov	 eax, DWORD PTR _pNext$[ebp]
  00287	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0028a	83 e1 40	 and	 ecx, 64			; 00000040H
  0028d	85 c9		 test	 ecx, ecx
  0028f	75 1d		 jne	 SHORT $L69566
  00291	8b 55 f8	 mov	 edx, DWORD PTR _pScan$[ebp]
  00294	8b 45 fc	 mov	 eax, DWORD PTR _pNext$[ebp]
  00297	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  0029a	3b 48 64	 cmp	 ecx, DWORD PTR [eax+100]
  0029d	7e 0f		 jle	 SHORT $L69566

; 381  : 					{
; 382  : 						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
; 383  : 						// get rid of the potential circularity in the list.  Note that this
; 384  : 						// (or actually the creation of the circularity) could cause memory leaks.
; 385  : 						pScan->SetNext(NULL);

  0029f	6a 00		 push	 0
  002a1	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  002a4	83 c1 08	 add	 ecx, 8
  002a7	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 386  : 						break;

  002ac	eb 1b		 jmp	 SHORT $L69563
$L69566:

; 387  : 					}
; 388  : 					if( pItem->m_mtResolvedStart < pNext->m_mtResolvedStart )

  002ae	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  002b1	8b 45 fc	 mov	 eax, DWORD PTR _pNext$[ebp]
  002b4	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  002b7	3b 48 64	 cmp	 ecx, DWORD PTR [eax+100]
  002ba	7d 02		 jge	 SHORT $L69568

; 389  : 					{
; 390  : 						break;

  002bc	eb 0b		 jmp	 SHORT $L69563
$L69568:

; 391  : 					}
; 392  : 					pScan = pNext;

  002be	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  002c1	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 393  : 				}

  002c4	e9 7c ff ff ff	 jmp	 $L69562
$L69563:

; 394  :                 if (pItem != pScan)

  002c9	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  002cc	3b 45 f8	 cmp	 eax, DWORD PTR _pScan$[ebp]
  002cf	74 59		 je	 SHORT $L69553

; 395  : 				{
; 396  : 					pItem->SetNext(pScan->GetNext());

  002d1	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  002d4	e8 00 00 00 00	 call	 ?GetNext@CSegState@@QAEPAV1@XZ ; CSegState::GetNext
  002d9	89 45 cc	 mov	 DWORD PTR tv198[ebp], eax
  002dc	83 7d cc 00	 cmp	 DWORD PTR tv198[ebp], 0
  002e0	74 0b		 je	 SHORT $L69915
  002e2	8b 4d cc	 mov	 ecx, DWORD PTR tv198[ebp]
  002e5	83 c1 08	 add	 ecx, 8
  002e8	89 4d c8	 mov	 DWORD PTR tv201[ebp], ecx
  002eb	eb 07		 jmp	 SHORT $L69916
$L69915:
  002ed	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv201[ebp], 0
$L69916:
  002f4	8b 55 c8	 mov	 edx, DWORD PTR tv201[ebp]
  002f7	52		 push	 edx
  002f8	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  002fb	83 c1 08	 add	 ecx, 8
  002fe	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 397  : 					pScan->SetNext(pItem);

  00303	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00307	74 0b		 je	 SHORT $L69917
  00309	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0030c	83 c0 08	 add	 eax, 8
  0030f	89 45 c4	 mov	 DWORD PTR tv207[ebp], eax
  00312	eb 07		 jmp	 SHORT $L69918
$L69917:
  00314	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv207[ebp], 0
$L69918:
  0031b	8b 4d c4	 mov	 ecx, DWORD PTR tv207[ebp]
  0031e	51		 push	 ecx
  0031f	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00322	83 c1 08	 add	 ecx, 8
  00325	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L69553:

; 398  : 				}
; 399  : 				else
; 400  : 				{
; 401  : 					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
; 402  : 				}
; 403  : 			}
; 404  : 		}
; 405  :     }
; 406  : 	else

  0032a	eb 20		 jmp	 SHORT $L69530
$L69533:

; 407  : 	{
; 408  : 		m_pHead = pItem;

  0032c	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00330	74 0b		 je	 SHORT $L69919
  00332	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00335	83 c2 08	 add	 edx, 8
  00338	89 55 c0	 mov	 DWORD PTR tv211[ebp], edx
  0033b	eb 07		 jmp	 SHORT $L69920
$L69919:
  0033d	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv211[ebp], 0
$L69920:
  00344	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00347	8b 4d c0	 mov	 ecx, DWORD PTR tv211[ebp]
  0034a	89 08		 mov	 DWORD PTR [eax], ecx
$L69530:

; 409  : 	}
; 410  : }

  0034c	8b e5		 mov	 esp, ebp
  0034e	5d		 pop	 ebp
  0034f	c2 04 00	 ret	 4
?Insert@CSegStateList@@QAEXPAVCSegState@@@Z ENDP	; CSegStateList::Insert
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@AListItem@@QAEXPAV1@@Z PROC NEAR		; AListItem::SetNext, COMDAT
; _this$ = ecx

; 19   :     void SetNext(AListItem *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNext@AListItem@@QAEXPAV1@@Z ENDP			; AListItem::SetNext
_TEXT	ENDS
PUBLIC	?GetNext@AListItem@@QBEPAV1@XZ			; AListItem::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.h
;	COMDAT ?GetNext@CSegState@@QAEPAV1@XZ
_TEXT	SEGMENT
tv71 = -12
tv68 = -8
_this$ = -4
?GetNext@CSegState@@QAEPAV1@XZ PROC NEAR		; CSegState::GetNext, COMDAT
; _this$ = ecx

; 87   :     CSegState* GetNext() { return (CSegState*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 08	 add	 ecx, 8
  0000f	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00014	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00017	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0001b	74 0b		 je	 SHORT $L69930
  0001d	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00020	83 e8 08	 sub	 eax, 8
  00023	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00026	eb 07		 jmp	 SHORT $L69931
$L69930:
  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L69931:
  0002f	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GetNext@CSegState@@QAEPAV1@XZ ENDP			; CSegState::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@AListItem@@QBEPAV1@XZ PROC NEAR		; AListItem::GetNext, COMDAT
; _this$ = ecx

; 18   :     AListItem *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNext@AListItem@@QBEPAV1@XZ ENDP			; AListItem::GetNext
_TEXT	ENDS
PUBLIC	?AddHead@AList@@QAEXPAVAListItem@@@Z		; AList::AddHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.h
;	COMDAT ?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z
_TEXT	SEGMENT
tv67 = -8
_this$ = -4
_pSegState$ = 8
?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z PROC NEAR	; CSegStateList::AddHead, COMDAT
; _this$ = ecx

; 153  :     void AddHead(CSegState* pSegState) { AList::AddHead((AListItem*)pSegState);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d 08 00	 cmp	 DWORD PTR _pSegState$[ebp], 0
  0000d	74 0b		 je	 SHORT $L69938
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pSegState$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00018	eb 07		 jmp	 SHORT $L69939
$L69938:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L69939:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?AddHead@CSegStateList@@QAEXPAVCSegState@@@Z ENDP	; CSegStateList::AddHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::AddHead, COMDAT
; _this$ = ecx

; 51   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :             if (pItem!=NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 16		 je	 SHORT $L32730

; 53   :             {
; 54   :                 pItem->SetNext(m_pHead);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 55   :                 m_pHead=pItem;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00021	89 02		 mov	 DWORD PTR [edx], eax
$L32730:

; 56   :             }
; 57   :         };

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?AddHead@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::AddHead
_TEXT	ENDS
PUBLIC	?GetHead@AList@@QBEPAVAListItem@@XZ		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.h
;	COMDAT ?GetHead@CSegStateList@@QAEPAVCSegState@@XZ
_TEXT	SEGMENT
tv69 = -12
tv66 = -8
_this$ = -4
?GetHead@CSegStateList@@QAEPAVCSegState@@XZ PROC NEAR	; CSegStateList::GetHead, COMDAT
; _this$ = ecx

; 155  :     CSegState* GetHead(){return (CSegState*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  00011	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00018	74 0b		 je	 SHORT $L69946
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001d	83 e8 08	 sub	 eax, 8
  00020	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L69947
$L69946:
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L69947:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GetHead@CSegStateList@@QAEPAVCSegState@@XZ ENDP	; CSegStateList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetHead, COMDAT
; _this$ = ecx

; 35   :     AListItem *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmperf.h
_TEXT	ENDS
;	COMDAT ?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ PROC NEAR	; CPMsgQueue::GetHead, COMDAT
; _this$ = ecx

; 252  :     PRIV_PMSG *     GetHead() { return (m_pTop);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@CPMsgQueue@@QAEPAUPRIV_PMSG@@XZ ENDP		; CPMsgQueue::GetHead
_TEXT	ENDS
END
