; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\dowork.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EM@HJNJPHHF@Error?3?5InitAudio?$CI?$CJ?5called?5with?5d@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?SetDoWorkThreadMode@@YGXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartDoWorkThreadProc@@YGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoWorkThreadProc@@YGKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitializeDirectMusicDoWorkCriticalSection@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DirectMusicDoWork@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PinkSlip@CWorker@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasBeenToldToDie@CWorker@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoPinkSlip@CWorker@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBossMan@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWorker@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPentiumTime@@YGXPA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoWork@CBossMan@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WakeUp@CWorker@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CBossMan@@QAEXPAVCWorker@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@AList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CWorker@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CBossMan@@QAEPAVCWorker@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBossMan@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
PUBLIC	?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicPinkSlipCriticalSection
_BSS	SEGMENT
_dwWorkerCount DD 01H DUP (?)
_g_hDoWorkThread DD 01H DUP (?)
_g_hDoWorkQuitEvent DD 01H DUP (?)
_g_hDoWorkWakeupEvent DD 01H DUP (?)
?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A DB 01cH DUP (?) ; gDirectMusicDoWorkCriticalSection
?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A DB 01cH DUP (?) ; gDirectMusicPinkSlipCriticalSection
_rtWakeUp DQ	01H DUP (?)
_rtGoToSleep DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_g_fUseThreads DD 01H
_DATA	ENDS
PUBLIC	??0CBossMan@@QAE@XZ				; CBossMan::CBossMan
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dowork.cpp
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 6    : CBossMan g_BossMan;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00008	e8 00 00 00 00	 call	 ??0CBossMan@@QAE@XZ	; CBossMan::CBossMan
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??1CBossMan@@QAE@XZ				; CBossMan::~CBossMan
; Function compile flags: /Odt
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00008	e8 00 00 00 00	 call	 ??1CBossMan@@QAE@XZ	; CBossMan::~CBossMan
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?SetDoWorkThreadMode@@YGXK@Z			; SetDoWorkThreadMode
PUBLIC	??_C@_0EM@HJNJPHHF@Error?3?5InitAudio?$CI?$CJ?5called?5with?5d@ ; `string'
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
;	COMDAT ??_C@_0EM@HJNJPHHF@Error?3?5InitAudio?$CI?$CJ?5called?5with?5d@
CONST	SEGMENT
??_C@_0EM@HJNJPHHF@Error?3?5InitAudio?$CI?$CJ?5called?5with?5d@ DB 'Error'
	DB	': InitAudio() called with different thread flags from previou'
	DB	's call. ', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetDoWorkThreadMode@@YGXK@Z
_TEXT	SEGMENT
_dwOff$ = 8
?SetDoWorkThreadMode@@YGXK@Z PROC NEAR			; SetDoWorkThreadMode, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   :     if(g_hDoWorkThread && dwOff) 

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hDoWorkThread, 0
  0000a	74 1c		 je	 SHORT $L69440
  0000c	83 7d 08 00	 cmp	 DWORD PTR _dwOff$[ebp], 0
  00010	74 16		 je	 SHORT $L69440

; 18   :     {
; 19   :         Trace(1,"Error: InitAudio() called with different thread flags from previous call. \n");

  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@HJNJPHHF@Error?3?5InitAudio?$CI?$CJ?5called?5with?5d@
  00017	6a 01		 push	 1
  00019	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0001e	83 c4 08	 add	 esp, 8

; 20   :         dwOff = false;

  00021	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _dwOff$[ebp], 0
$L69440:

; 21   :     }
; 22   :     g_fUseThreads = !dwOff;

  00028	33 c0		 xor	 eax, eax
  0002a	83 7d 08 00	 cmp	 DWORD PTR _dwOff$[ebp], 0
  0002e	0f 94 c0	 sete	 al
  00031	a3 00 00 00 00	 mov	 DWORD PTR _g_fUseThreads, eax

; 23   : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?SetDoWorkThreadMode@@YGXK@Z ENDP			; SetDoWorkThreadMode
_TEXT	ENDS
PUBLIC	?InitializeDirectMusicDoWorkCriticalSection@@YGXXZ ; InitializeDirectMusicDoWorkCriticalSection
EXTRN	__imp__RtlInitializeCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?InitializeDirectMusicDoWorkCriticalSection@@YGXXZ
_TEXT	SEGMENT
?InitializeDirectMusicDoWorkCriticalSection@@YGXXZ PROC NEAR ; InitializeDirectMusicDoWorkCriticalSection, COMDAT

; 115  : void InitializeDirectMusicDoWorkCriticalSection(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :     InitializeCriticalSection(&gDirectMusicDoWorkCriticalSection);

  00003	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 117  :     InitializeCriticalSection(&gDirectMusicPinkSlipCriticalSection);

  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicPinkSlipCriticalSection
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 118  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?InitializeDirectMusicDoWorkCriticalSection@@YGXXZ ENDP	; InitializeDirectMusicDoWorkCriticalSection
_TEXT	ENDS
PUBLIC	_DirectMusicDoWork@4
PUBLIC	?DoWork@CBossMan@@QAEXK@Z			; CBossMan::DoWork
EXTRN	?DirectMusicInitializedCheck@@YGXXZ:NEAR	; DirectMusicInitializedCheck
; Function compile flags: /Odt
;	COMDAT _DirectMusicDoWork@4
_TEXT	SEGMENT
_dwQuantum$ = 8
_DirectMusicDoWork@4 PROC NEAR				; COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  : #ifdef DBG
; 128  :     DirectMusicInitializedCheck();

  00003	e8 00 00 00 00	 call	 ?DirectMusicInitializedCheck@@YGXXZ ; DirectMusicInitializedCheck

; 129  : #endif
; 130  :     if (!g_fUseThreads)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fUseThreads, 0
  0000f	75 0e		 jne	 SHORT $L69486

; 131  :     {
; 132  :         g_BossMan.DoWork(dwQuantum);

  00011	8b 45 08	 mov	 eax, DWORD PTR _dwQuantum$[ebp]
  00014	50		 push	 eax
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  0001a	e8 00 00 00 00	 call	 ?DoWork@CBossMan@@QAEXK@Z ; CBossMan::DoWork
$L69486:

; 133  :     }
; 134  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
_DirectMusicDoWork@4 ENDP
_TEXT	ENDS
PUBLIC	?PinkSlip@CWorker@@QAEXXZ			; CWorker::PinkSlip
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?PinkSlip@CWorker@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PinkSlip@CWorker@@QAEXXZ PROC NEAR			; CWorker::PinkSlip, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :     ENTER_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);

  00007	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicPinkSlipCriticalSection
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 139  :     m_bToldToDie = true;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 140  :     LEAVE_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);

  00019	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicPinkSlipCriticalSection
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 141  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?PinkSlip@CWorker@@QAEXXZ ENDP				; CWorker::PinkSlip
_TEXT	ENDS
PUBLIC	?HasBeenToldToDie@CWorker@@AAE_NXZ		; CWorker::HasBeenToldToDie
; Function compile flags: /Odt
;	COMDAT ?HasBeenToldToDie@CWorker@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -8
_result$ = -1
?HasBeenToldToDie@CWorker@@AAE_NXZ PROC NEAR		; CWorker::HasBeenToldToDie, COMDAT
; _this$ = ecx

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     bool result;
; 146  :     ENTER_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);

  00009	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicPinkSlipCriticalSection
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 147  :     result = m_bToldToDie;

  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0001a	88 4d ff	 mov	 BYTE PTR _result$[ebp], cl

; 148  :     LEAVE_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicPinkSlipCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicPinkSlipCriticalSection
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 149  :     return result;

  00028	8a 45 ff	 mov	 al, BYTE PTR _result$[ebp]

; 150  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?HasBeenToldToDie@CWorker@@AAE_NXZ ENDP			; CWorker::HasBeenToldToDie
_TEXT	ENDS
PUBLIC	?DoPinkSlip@CWorker@@AAEXXZ			; CWorker::DoPinkSlip
EXTRN	_DMusicUnregisterPerformanceCounter@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?DoPinkSlip@CWorker@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoPinkSlip@CWorker@@AAEXXZ PROC NEAR			; CWorker::DoPinkSlip, COMDAT
; _this$ = ecx

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 155  :     DMusicUnregisterPerformanceCounter(m_szName);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 2c	 add	 eax, 44			; 0000002cH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _DMusicUnregisterPerformanceCounter@4

; 156  : #endif
; 157  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?DoPinkSlip@CWorker@@AAEXXZ ENDP			; CWorker::DoPinkSlip
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CBossMan@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBossMan@@QAE@XZ PROC NEAR				; CBossMan::~CBossMan, COMDAT
; _this$ = ecx

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  :     if (m_pMasterClock)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 12		 je	 SHORT $L69500

; 162  :     {
; 163  :         m_pMasterClock->Release();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	8b 12		 mov	 edx, DWORD PTR [edx]
  0001e	51		 push	 ecx
  0001f	ff 52 08	 call	 DWORD PTR [edx+8]
$L69500:

; 164  :     }
; 165  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??1CBossMan@@QAE@XZ ENDP				; CBossMan::~CBossMan
_TEXT	ENDS
PUBLIC	?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z ; CBossMan::SetMasterClock
; Function compile flags: /Odt
;	COMDAT ?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z
_TEXT	SEGMENT
_this$ = -4
_pClock$ = 8
?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z PROC NEAR ; CBossMan::SetMasterClock, COMDAT
; _this$ = ecx

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 169  :     ENTER_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);

  00007	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 170  :     if (m_pMasterClock)

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00019	74 12		 je	 SHORT $L69506

; 171  :     {
; 172  :         m_pMasterClock->Release();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	8b 12		 mov	 edx, DWORD PTR [edx]
  00029	51		 push	 ecx
  0002a	ff 52 08	 call	 DWORD PTR [edx+8]
$L69506:

; 173  :     }
; 174  :     m_pMasterClock = pClock;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pClock$[ebp]
  00033	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 175  :     if (m_pMasterClock)

  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0003d	74 12		 je	 SHORT $L69507

; 176  :     {
; 177  :         m_pMasterClock->AddRef();

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004d	50		 push	 eax
  0004e	ff 51 04	 call	 DWORD PTR [ecx+4]
$L69507:

; 178  :     }
; 179  :     LEAVE_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);

  00051	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 180  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?SetMasterClock@CBossMan@@QAEXPAUIReferenceClock@@@Z ENDP ; CBossMan::SetMasterClock
_TEXT	ENDS
PUBLIC	?GetNext@CWorker@@QAEPAV1@XZ			; CWorker::GetNext
PUBLIC	??0CWorker@@QAE@XZ				; CWorker::CWorker
PUBLIC	?GetHead@CBossMan@@QAEPAVCWorker@@XZ		; CBossMan::GetHead
PUBLIC	?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z ; CBossMan::InstallWorker
PUBLIC	?IsEmpty@AList@@QBEHXZ				; AList::IsEmpty
EXTRN	_strcpy:NEAR
EXTRN	_DMusicRegisterPerformanceCounter@12:NEAR
EXTRN	?InsertBefore@AList@@QAEXPAVAListItem@@0@Z:NEAR	; AList::InsertBefore
; Function compile flags: /Odt
;	COMDAT ?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z
_TEXT	SEGMENT
tv70 = -20
_this$ = -16
$T69899 = -12
_pScan$69519 = -8
_pWorker$ = -4
_pRoutine$ = 8
_pContext$ = 12
_dwOrder$ = 16
_pszName$ = 20
?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z PROC NEAR ; CBossMan::InstallWorker, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     ENTER_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);

  00009	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 185  :     CWorker *pWorker = new CWorker;

  00014	68 90 00 00 00	 push	 144			; 00000090H
  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 f4	 mov	 DWORD PTR $T69899[ebp], eax
  00024	83 7d f4 00	 cmp	 DWORD PTR $T69899[ebp], 0
  00028	74 0d		 je	 SHORT $L69900
  0002a	8b 4d f4	 mov	 ecx, DWORD PTR $T69899[ebp]
  0002d	e8 00 00 00 00	 call	 ??0CWorker@@QAE@XZ
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $L69901
$L69900:
  00037	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L69901:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _pWorker$[ebp], eax

; 186  :     if (pWorker)

  00044	83 7d fc 00	 cmp	 DWORD PTR _pWorker$[ebp], 0
  00048	0f 84 be 00 00
	00		 je	 $L69518

; 187  :     {
; 188  :         pWorker->m_bToldToDie = false;

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _pWorker$[ebp]
  00051	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 189  :         pWorker->m_pWorkRoutine = pRoutine;

  00055	8b 55 fc	 mov	 edx, DWORD PTR _pWorker$[ebp]
  00058	8b 45 08	 mov	 eax, DWORD PTR _pRoutine$[ebp]
  0005b	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 190  :         pWorker->m_pContext = pContext;

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _pWorker$[ebp]
  00061	8b 55 0c	 mov	 edx, DWORD PTR _pContext$[ebp]
  00064	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 191  :         pWorker->m_rtWakeUpTime = 0;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _pWorker$[ebp]
  0006a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00071	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 192  :         pWorker->m_pBossMan = this;

  00078	8b 4d fc	 mov	 ecx, DWORD PTR _pWorker$[ebp]
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 193  :         pWorker->m_dwOrder = dwOrder;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _pWorker$[ebp]
  00084	8b 4d 10	 mov	 ecx, DWORD PTR _dwOrder$[ebp]
  00087	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 194  :         CWorker *pScan = GetHead();

  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?GetHead@CBossMan@@QAEPAVCWorker@@XZ ; CBossMan::GetHead
  00092	89 45 f8	 mov	 DWORD PTR _pScan$69519[ebp], eax

; 195  :         for (;pScan;pScan = pScan->GetNext())

  00095	eb 0b		 jmp	 SHORT $L69520
$L69521:
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$69519[ebp]
  0009a	e8 00 00 00 00	 call	 ?GetNext@CWorker@@QAEPAV1@XZ ; CWorker::GetNext
  0009f	89 45 f8	 mov	 DWORD PTR _pScan$69519[ebp], eax
$L69520:
  000a2	83 7d f8 00	 cmp	 DWORD PTR _pScan$69519[ebp], 0
  000a6	74 0f		 je	 SHORT $L69522

; 196  :         {
; 197  :             if (pScan->m_dwOrder > dwOrder)

  000a8	8b 55 f8	 mov	 edx, DWORD PTR _pScan$69519[ebp]
  000ab	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000ae	3b 45 10	 cmp	 eax, DWORD PTR _dwOrder$[ebp]
  000b1	76 02		 jbe	 SHORT $L69523

; 198  :             {
; 199  :                 break;

  000b3	eb 02		 jmp	 SHORT $L69522
$L69523:

; 200  :             }
; 201  :         }

  000b5	eb e0		 jmp	 SHORT $L69521
$L69522:

; 202  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 203  :         strcpy (pWorker->m_szName,pszName);

  000b7	8b 4d 14	 mov	 ecx, DWORD PTR _pszName$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _pWorker$[ebp]
  000be	83 c2 2c	 add	 edx, 44			; 0000002cH
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 _strcpy
  000c7	83 c4 08	 add	 esp, 8

; 204  :         DMusicRegisterPerformanceCounter(pWorker->m_szName,
; 205  :                                       DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
; 206  :                                       &pWorker->m_dwElapsedTime );

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _pWorker$[ebp]
  000cd	83 c0 28	 add	 eax, 40			; 00000028H
  000d0	50		 push	 eax
  000d1	68 00 00 02 00	 push	 131072			; 00020000H
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _pWorker$[ebp]
  000d9	83 c1 2c	 add	 ecx, 44			; 0000002cH
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _DMusicRegisterPerformanceCounter@12

; 207  : 
; 208  : #endif
; 209  :         if (IsEmpty() && g_fUseThreads)

  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  000ea	85 c0		 test	 eax, eax
  000ec	74 0e		 je	 SHORT $L69524
  000ee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fUseThreads, 0
  000f5	74 05		 je	 SHORT $L69524

; 210  :         {
; 211  :             StartDoWorkThreadProc();

  000f7	e8 00 00 00 00	 call	 ?StartDoWorkThreadProc@@YGJXZ ; StartDoWorkThreadProc
$L69524:

; 212  :         }
; 213  :         InsertBefore(pScan,pWorker);

  000fc	8b 55 fc	 mov	 edx, DWORD PTR _pWorker$[ebp]
  000ff	52		 push	 edx
  00100	8b 45 f8	 mov	 eax, DWORD PTR _pScan$69519[ebp]
  00103	50		 push	 eax
  00104	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?InsertBefore@AList@@QAEXPAVAListItem@@0@Z ; AList::InsertBefore
$L69518:

; 214  :     }
; 215  :     LEAVE_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);

  0010c	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 216  :     return pWorker;

  00117	8b 45 fc	 mov	 eax, DWORD PTR _pWorker$[ebp]

; 217  : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 10 00	 ret	 16			; 00000010H
?InstallWorker@CBossMan@@QAEPAVCWorker@@P6GXPAXPA_J@Z0KPAD@Z ENDP ; CBossMan::InstallWorker
_TEXT	ENDS
EXTRN	_CreateThread@24:NEAR
EXTRN	_SetThreadPriority@8:NEAR
EXTRN	_CloseHandle@4:NEAR
EXTRN	_CreateEventA@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?StartDoWorkThreadProc@@YGJXZ
_TEXT	SEGMENT
_dwTemp$ = -4
?StartDoWorkThreadProc@@YGJXZ PROC NEAR			; StartDoWorkThreadProc, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 29   :     DWORD dwTemp = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwTemp$[ebp], 0

; 30   :     g_hDoWorkQuitEvent = CreateEvent(NULL, TRUE, 0, 0);

  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 01		 push	 1
  00011	6a 00		 push	 0
  00013	e8 00 00 00 00	 call	 _CreateEventA@16
  00018	a3 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkQuitEvent, eax

; 31   :     if (!g_hDoWorkQuitEvent)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hDoWorkQuitEvent, 0
  00024	75 0a		 jne	 SHORT $L69446

; 32   :     {
; 33   :         return E_FAIL;        

  00026	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0002b	e9 a0 00 00 00	 jmp	 $L69444
$L69446:

; 34   :     }
; 35   :     g_hDoWorkWakeupEvent = CreateEvent(NULL, FALSE, 0, 0); // FALSE for second arg means automatically reset event after worker thread wakes up

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	e8 00 00 00 00	 call	 _CreateEventA@16
  0003d	a3 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkWakeupEvent, eax

; 36   :     if (!g_hDoWorkWakeupEvent)

  00042	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hDoWorkWakeupEvent, 0
  00049	75 1c		 jne	 SHORT $L69448

; 37   :     {
; 38   :         CloseHandle(g_hDoWorkQuitEvent);

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hDoWorkQuitEvent
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _CloseHandle@4

; 39   :         g_hDoWorkQuitEvent = NULL;

  00056	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkQuitEvent, 0

; 40   :         return E_FAIL;        

  00060	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00065	eb 69		 jmp	 SHORT $L69444
$L69448:

; 41   :     }
; 42   :     g_hDoWorkThread =    CreateThread(NULL,20000,(LPTHREAD_START_ROUTINE)DoWorkThreadProc,(void*)dwTemp,0,NULL);

  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _dwTemp$[ebp]
  0006e	51		 push	 ecx
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:?DoWorkThreadProc@@YGKPAX@Z ; DoWorkThreadProc
  00074	68 20 4e 00 00	 push	 20000			; 00004e20H
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 _CreateThread@24
  00080	a3 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkThread, eax

; 43   :     if (!g_hDoWorkThread)

  00085	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hDoWorkThread, 0
  0008c	75 32		 jne	 SHORT $L69452

; 44   :     {
; 45   :         CloseHandle(g_hDoWorkQuitEvent);

  0008e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hDoWorkQuitEvent
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 _CloseHandle@4

; 46   :         CloseHandle(g_hDoWorkWakeupEvent);

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hDoWorkWakeupEvent
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _CloseHandle@4

; 47   :         g_hDoWorkQuitEvent = NULL;

  000a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkQuitEvent, 0

; 48   :         g_hDoWorkWakeupEvent = NULL;

  000af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkWakeupEvent, 0

; 49   :         return E_FAIL;        

  000b9	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000be	eb 10		 jmp	 SHORT $L69444
$L69452:

; 50   :     }
; 51   :     SetThreadPriority( g_hDoWorkThread, THREAD_PRIORITY_TIME_CRITICAL); 

  000c0	6a 0f		 push	 15			; 0000000fH
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hDoWorkThread
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _SetThreadPriority@8

; 52   :     return S_OK;

  000ce	33 c0		 xor	 eax, eax
$L69444:

; 53   : };

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?StartDoWorkThreadProc@@YGJXZ ENDP			; StartDoWorkThreadProc
_TEXT	ENDS
EXTRN	_WaitForMultipleObjects@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?DoWorkThreadProc@@YGKPAX@Z
_TEXT	SEGMENT
_result$69463 = -16
_dwQuantum$ = -12
_handles$ = -8
_pvhWndMain$ = 8
?DoWorkThreadProc@@YGKPAX@Z PROC NEAR			; DoWorkThreadProc, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 60   :     DWORD dwQuantum = 30;

  00006	c7 45 f4 1e 00
	00 00		 mov	 DWORD PTR _dwQuantum$[ebp], 30 ; 0000001eH

; 61   :     HANDLE handles[2];
; 62   :     handles[0] = g_hDoWorkQuitEvent;

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hDoWorkQuitEvent
  00012	89 45 f8	 mov	 DWORD PTR _handles$[ebp], eax

; 63   :     handles[1] = g_hDoWorkWakeupEvent;

  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hDoWorkWakeupEvent
  0001b	89 4d fc	 mov	 DWORD PTR _handles$[ebp+4], ecx
$L69461:

; 64   : 
; 65   :     while (true){

  0001e	ba 01 00 00 00	 mov	 edx, 1
  00023	85 d2		 test	 edx, edx
  00025	74 40		 je	 SHORT $L69462

; 66   :         DWORD result = WaitForMultipleObjects(2, handles, FALSE, dwQuantum);

  00027	8b 45 f4	 mov	 eax, DWORD PTR _dwQuantum$[ebp]
  0002a	50		 push	 eax
  0002b	6a 00		 push	 0
  0002d	8d 4d f8	 lea	 ecx, DWORD PTR _handles$[ebp]
  00030	51		 push	 ecx
  00031	6a 02		 push	 2
  00033	e8 00 00 00 00	 call	 _WaitForMultipleObjects@16
  00038	89 45 f0	 mov	 DWORD PTR _result$69463[ebp], eax

; 67   :         if ( result == WAIT_OBJECT_0 ) {

  0003b	83 7d f0 00	 cmp	 DWORD PTR _result$69463[ebp], 0
  0003f	75 02		 jne	 SHORT $L69465

; 68   :             break; // asked to quit

  00041	eb 24		 jmp	 SHORT $L69462
$L69465:

; 69   :         }
; 70   :         else if ( result == WAIT_OBJECT_0 + 1 ) {

  00043	83 7d f0 01	 cmp	 DWORD PTR _result$69463[ebp], 1
  00047	75 0e		 jne	 SHORT $L69468

; 71   :             // Asked to run quickly
; 72   :             g_BossMan.DoWork(0);

  00049	6a 00		 push	 0
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00050	e8 00 00 00 00	 call	 ?DoWork@CBossMan@@QAEXK@Z ; CBossMan::DoWork

; 73   :         }
; 74   :         else {

  00055	eb 0e		 jmp	 SHORT $L69466
$L69468:

; 75   :             // Normal quantum timeout
; 76   :             g_BossMan.DoWork(dwQuantum);

  00057	8b 55 f4	 mov	 edx, DWORD PTR _dwQuantum$[ebp]
  0005a	52		 push	 edx
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_BossMan@@3VCBossMan@@A
  00060	e8 00 00 00 00	 call	 ?DoWork@CBossMan@@QAEXK@Z ; CBossMan::DoWork
$L69466:

; 77   :         }
; 78   :     }

  00065	eb b7		 jmp	 SHORT $L69461
$L69462:

; 79   : 
; 80   : 	CloseHandle(g_hDoWorkQuitEvent);

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hDoWorkQuitEvent
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _CloseHandle@4

; 81   : 	CloseHandle(g_hDoWorkWakeupEvent);

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hDoWorkWakeupEvent
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _CloseHandle@4

; 82   : 
; 83   :     g_hDoWorkThread= NULL;

  0007e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkThread, 0

; 84   :     g_hDoWorkQuitEvent = NULL;

  00088	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkQuitEvent, 0

; 85   :     g_hDoWorkWakeupEvent = NULL;

  00092	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hDoWorkWakeupEvent, 0

; 86   : 
; 87   :     return 0;

  0009c	33 c0		 xor	 eax, eax

; 88   : } 

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?DoWorkThreadProc@@YGKPAX@Z ENDP			; DoWorkThreadProc
_TEXT	ENDS
PUBLIC	??0AListItem@@QAE@XZ				; AListItem::AListItem
; Function compile flags: /Odt
;	COMDAT ??0CWorker@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CWorker@@QAE@XZ PROC NEAR				; CWorker::CWorker, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CWorker@@QAE@XZ ENDP					; CWorker::CWorker
_TEXT	ENDS
PUBLIC	?Remove@CBossMan@@QAEXPAVCWorker@@@Z		; CBossMan::Remove
EXTRN	__alldiv:NEAR
EXTRN	_SetEvent@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?DoWork@CBossMan@@QAEXK@Z
_TEXT	SEGMENT
tv214 = -68
_this$ = -60
$T69914 = -56
_pWorker$69560 = -52
_rtEnd$69558 = -48
_rtStart$69557 = -40
_fStopThread$69549 = -25
_pNext$69547 = -24
_pWorker$69543 = -20
_pWorker$69553 = -16
_dwTries$69539 = -12
_rtTime$69538 = -8
_dwQuantum$ = 8
?DoWork@CBossMan@@QAEXK@Z PROC NEAR			; CBossMan::DoWork, COMDAT
; _this$ = ecx

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	56		 push	 esi
  00007	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 241  : //    GetPentiumTime(&rtWakeUp);
; 242  :     ENTER_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);

  0000a	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 243  :     dwQuantum *= 10000;     // Convert from milliseconds to REFERENCE_TIME units.

  00015	8b 45 08	 mov	 eax, DWORD PTR _dwQuantum$[ebp]
  00018	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  0001e	89 45 08	 mov	 DWORD PTR _dwQuantum$[ebp], eax

; 244  :     if (m_pMasterClock)

  00021	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00028	0f 84 40 01 00
	00		 je	 $L69537

; 245  :     {
; 246  :         REFERENCE_TIME rtTime;
; 247  :         m_pMasterClock->GetTime(&rtTime);   // Get current time.

  0002e	8d 55 f8	 lea	 edx, DWORD PTR _rtTime$69538[ebp]
  00031	52		 push	 edx
  00032	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	50		 push	 eax
  00041	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 248  :         rtTime += (dwQuantum * 2);                // Find out when everything needs to be done by.

  00044	8b 55 08	 mov	 edx, DWORD PTR _dwQuantum$[ebp]
  00047	d1 e2		 shl	 edx, 1
  00049	33 c0		 xor	 eax, eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _rtTime$69538[ebp]
  0004e	03 ca		 add	 ecx, edx
  00050	8b 55 fc	 mov	 edx, DWORD PTR _rtTime$69538[ebp+4]
  00053	13 d0		 adc	 edx, eax
  00055	89 4d f8	 mov	 DWORD PTR _rtTime$69538[ebp], ecx
  00058	89 55 fc	 mov	 DWORD PTR _rtTime$69538[ebp+4], edx

; 249  : //        DWORD fAgain = TRUE;                 // This is used to track whether we need another pass through. 
; 250  : //DbgPrint("%ld: ",(long) (rtTime / 10000));
; 251  :         for (DWORD dwTries = 0; dwTries < 2; dwTries++)

  0005b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwTries$69539[ebp], 0
  00062	eb 09		 jmp	 SHORT $L69540
$L69541:
  00064	8b 45 f4	 mov	 eax, DWORD PTR _dwTries$69539[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f4	 mov	 DWORD PTR _dwTries$69539[ebp], eax
$L69540:
  0006d	83 7d f4 02	 cmp	 DWORD PTR _dwTries$69539[ebp], 2
  00071	0f 83 f7 00 00
	00		 jae	 $L69537

; 252  :         {
; 253  : //            fAgain = FALSE;
; 254  :             // Get rid of any workers who have been told to die
; 255  :             {
; 256  :                 CWorker *pWorker = GetHead();

  00077	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ?GetHead@CBossMan@@QAEPAVCWorker@@XZ ; CBossMan::GetHead
  0007f	89 45 ec	 mov	 DWORD PTR _pWorker$69543[ebp], eax
$L69545:

; 257  :                 while(pWorker)

  00082	83 7d ec 00	 cmp	 DWORD PTR _pWorker$69543[ebp], 0
  00086	74 79		 je	 SHORT $L69546

; 258  :                 {
; 259  :                     CWorker* pNext = pWorker->GetNext();

  00088	8b 4d ec	 mov	 ecx, DWORD PTR _pWorker$69543[ebp]
  0008b	e8 00 00 00 00	 call	 ?GetNext@CWorker@@QAEPAV1@XZ ; CWorker::GetNext
  00090	89 45 e8	 mov	 DWORD PTR _pNext$69547[ebp], eax

; 260  :                     if(pWorker->HasBeenToldToDie())

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _pWorker$69543[ebp]
  00096	e8 00 00 00 00	 call	 ?HasBeenToldToDie@CWorker@@AAE_NXZ ; CWorker::HasBeenToldToDie
  0009b	0f b6 c8	 movzx	 ecx, al
  0009e	85 c9		 test	 ecx, ecx
  000a0	74 57		 je	 SHORT $L69548

; 261  :                     {
; 262  :                         pWorker->DoPinkSlip();

  000a2	8b 4d ec	 mov	 ecx, DWORD PTR _pWorker$69543[ebp]
  000a5	e8 00 00 00 00	 call	 ?DoPinkSlip@CWorker@@AAEXXZ ; CWorker::DoPinkSlip

; 263  :                         Remove(pWorker);

  000aa	8b 55 ec	 mov	 edx, DWORD PTR _pWorker$69543[ebp]
  000ad	52		 push	 edx
  000ae	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?Remove@CBossMan@@QAEXPAVCWorker@@@Z ; CBossMan::Remove

; 264  : 
; 265  :                         // If we're out of workers, we can shut down.
; 266  :                         bool fStopThread = false;

  000b6	c6 45 e7 00	 mov	 BYTE PTR _fStopThread$69549[ebp], 0

; 267  :                         if (IsEmpty() && g_fUseThreads)

  000ba	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?IsEmpty@AList@@QBEHXZ	; AList::IsEmpty
  000c2	85 c0		 test	 eax, eax
  000c4	74 0d		 je	 SHORT $L69550
  000c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fUseThreads, 0
  000cd	74 04		 je	 SHORT $L69550

; 268  :                         {
; 269  :                             fStopThread = true;

  000cf	c6 45 e7 01	 mov	 BYTE PTR _fStopThread$69549[ebp], 1
$L69550:

; 270  :                         }
; 271  :                         if (fStopThread)

  000d3	0f b6 45 e7	 movzx	 eax, BYTE PTR _fStopThread$69549[ebp]
  000d7	85 c0		 test	 eax, eax
  000d9	74 0c		 je	 SHORT $L69551

; 272  :                         {
; 273  :                             SetEvent(g_hDoWorkQuitEvent);

  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hDoWorkQuitEvent
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _SetEvent@4
$L69551:

; 274  :                         }
; 275  : 
; 276  :                         delete pWorker;

  000e7	8b 55 ec	 mov	 edx, DWORD PTR _pWorker$69543[ebp]
  000ea	89 55 c8	 mov	 DWORD PTR $T69914[ebp], edx
  000ed	8b 45 c8	 mov	 eax, DWORD PTR $T69914[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f6	83 c4 04	 add	 esp, 4
$L69548:

; 277  :                     }
; 278  :                     pWorker = pNext;

  000f9	8b 4d e8	 mov	 ecx, DWORD PTR _pNext$69547[ebp]
  000fc	89 4d ec	 mov	 DWORD PTR _pWorker$69543[ebp], ecx

; 279  :                 }

  000ff	eb 81		 jmp	 SHORT $L69545
$L69546:

; 280  :             }
; 281  : 
; 282  :             CWorker *pWorker = GetHead();

  00101	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?GetHead@CBossMan@@QAEPAVCWorker@@XZ ; CBossMan::GetHead
  00109	89 45 f0	 mov	 DWORD PTR _pWorker$69553[ebp], eax

; 283  :             for (;pWorker;pWorker = pWorker->GetNext())

  0010c	eb 0b		 jmp	 SHORT $L69554
$L69555:
  0010e	8b 4d f0	 mov	 ecx, DWORD PTR _pWorker$69553[ebp]
  00111	e8 00 00 00 00	 call	 ?GetNext@CWorker@@QAEPAV1@XZ ; CWorker::GetNext
  00116	89 45 f0	 mov	 DWORD PTR _pWorker$69553[ebp], eax
$L69554:
  00119	83 7d f0 00	 cmp	 DWORD PTR _pWorker$69553[ebp], 0
  0011d	74 4a		 je	 SHORT $L69556

; 284  :             {
; 285  : //                DbgPrint("%lx, %ld: \t",pWorker,(long)(pWorker->m_rtWakeUpTime / 10000));
; 286  : //                if (pWorker->m_rtWakeUpTime <= rtTime)
; 287  :                 {
; 288  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 289  :                     REFERENCE_TIME rtStart;
; 290  :                     GetPentiumTime(&rtStart);

  0011f	8d 55 d8	 lea	 edx, DWORD PTR _rtStart$69557[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 ?GetPentiumTime@@YGXPA_J@Z ; GetPentiumTime

; 291  :                     pWorker->m_pWorkRoutine(pWorker->m_pContext,&pWorker->m_rtWakeUpTime);

  00128	8b 45 f0	 mov	 eax, DWORD PTR _pWorker$69553[ebp]
  0012b	83 c0 10	 add	 eax, 16			; 00000010H
  0012e	50		 push	 eax
  0012f	8b 4d f0	 mov	 ecx, DWORD PTR _pWorker$69553[ebp]
  00132	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00135	52		 push	 edx
  00136	8b 45 f0	 mov	 eax, DWORD PTR _pWorker$69553[ebp]
  00139	ff 50 08	 call	 DWORD PTR [eax+8]

; 292  :                     REFERENCE_TIME rtEnd;
; 293  :                     GetPentiumTime(&rtEnd);

  0013c	8d 4d d0	 lea	 ecx, DWORD PTR _rtEnd$69558[ebp]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ?GetPentiumTime@@YGXPA_J@Z ; GetPentiumTime

; 294  :                     pWorker->m_rtElapsedTime += (rtEnd - rtStart);

  00145	8b 55 d0	 mov	 edx, DWORD PTR _rtEnd$69558[ebp]
  00148	2b 55 d8	 sub	 edx, DWORD PTR _rtStart$69557[ebp]
  0014b	8b 45 d4	 mov	 eax, DWORD PTR _rtEnd$69558[ebp+4]
  0014e	1b 45 dc	 sbb	 eax, DWORD PTR _rtStart$69557[ebp+4]
  00151	8b 4d f0	 mov	 ecx, DWORD PTR _pWorker$69553[ebp]
  00154	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  00157	03 f2		 add	 esi, edx
  00159	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0015c	13 d0		 adc	 edx, eax
  0015e	8b 45 f0	 mov	 eax, DWORD PTR _pWorker$69553[ebp]
  00161	89 70 20	 mov	 DWORD PTR [eax+32], esi
  00164	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 295  : #else
; 296  :                     pWorker->m_pWorkRoutine(pWorker->m_pContext,&pWorker->m_rtWakeUpTime);
; 297  : #endif
; 298  : //                    fAgain = TRUE;
; 299  :                 }
; 300  :             }

  00167	eb a5		 jmp	 SHORT $L69555
$L69556:

; 301  :         }

  00169	e9 f6 fe ff ff	 jmp	 $L69541
$L69537:

; 302  :     }
; 303  : //    REFERENCE_TIME rtLastSleep = rtGoToSleep;
; 304  : #ifdef IMPLEMENT_PERFORMANCE_COUNTERS
; 305  :     GetPentiumTime(&rtWakeUp);

  0016e	68 00 00 00 00	 push	 OFFSET FLAT:_rtWakeUp
  00173	e8 00 00 00 00	 call	 ?GetPentiumTime@@YGXPA_J@Z ; GetPentiumTime

; 306  :     if ((rtWakeUp - rtGoToSleep) > 10000 * 1000)

  00178	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rtWakeUp
  0017e	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _rtGoToSleep
  00184	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _rtWakeUp+4
  0018a	1b 15 04 00 00
	00		 sbb	 edx, DWORD PTR _rtGoToSleep+4
  00190	89 4d bc	 mov	 DWORD PTR tv214[ebp], ecx
  00193	89 55 c0	 mov	 DWORD PTR tv214[ebp+4], edx
  00196	83 7d c0 00	 cmp	 DWORD PTR tv214[ebp+4], 0
  0019a	7c 6f		 jl	 SHORT $L69559
  0019c	7f 09		 jg	 SHORT $L69915
  0019e	81 7d bc 80 96
	98 00		 cmp	 DWORD PTR tv214[ebp], 10000000 ; 00989680H
  001a5	76 64		 jbe	 SHORT $L69559
$L69915:

; 307  :     {
; 308  : //        DbgPrint("Interval: %ld: ",(long) ((rtWakeUp - rtGoToSleep) / 10000));
; 309  :         CWorker *pWorker = GetHead();

  001a7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  001aa	e8 00 00 00 00	 call	 ?GetHead@CBossMan@@QAEPAVCWorker@@XZ ; CBossMan::GetHead
  001af	89 45 cc	 mov	 DWORD PTR _pWorker$69560[ebp], eax

; 310  :         for (;pWorker;pWorker = pWorker->GetNext())

  001b2	eb 0b		 jmp	 SHORT $L69561
$L69562:
  001b4	8b 4d cc	 mov	 ecx, DWORD PTR _pWorker$69560[ebp]
  001b7	e8 00 00 00 00	 call	 ?GetNext@CWorker@@QAEPAV1@XZ ; CWorker::GetNext
  001bc	89 45 cc	 mov	 DWORD PTR _pWorker$69560[ebp], eax
$L69561:
  001bf	83 7d cc 00	 cmp	 DWORD PTR _pWorker$69560[ebp], 0
  001c3	74 30		 je	 SHORT $L69563

; 311  :         {
; 312  :             pWorker->m_dwElapsedTime = (DWORD) (pWorker->m_rtElapsedTime / 10000);

  001c5	8b 45 cc	 mov	 eax, DWORD PTR _pWorker$69560[ebp]
  001c8	6a 00		 push	 0
  001ca	68 10 27 00 00	 push	 10000			; 00002710H
  001cf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001d2	51		 push	 ecx
  001d3	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  001d6	52		 push	 edx
  001d7	e8 00 00 00 00	 call	 __alldiv
  001dc	8b 4d cc	 mov	 ecx, DWORD PTR _pWorker$69560[ebp]
  001df	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 313  : //            DbgPrint("%ld: %ld \t",pWorker->m_dwOrder,(long)(pWorker->m_rtElapsedTime / 100));
; 314  :             pWorker->m_rtElapsedTime = 0;

  001e2	8b 55 cc	 mov	 edx, DWORD PTR _pWorker$69560[ebp]
  001e5	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  001ec	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 315  :         }

  001f3	eb bf		 jmp	 SHORT $L69562
$L69563:

; 316  : //        DbgPrint("\n");
; 317  :         rtGoToSleep = rtWakeUp;

  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _rtWakeUp
  001fa	a3 00 00 00 00	 mov	 DWORD PTR _rtGoToSleep, eax
  001ff	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _rtWakeUp+4
  00205	89 0d 04 00 00
	00		 mov	 DWORD PTR _rtGoToSleep+4, ecx
$L69559:

; 318  :     }
; 319  : #endif
; 320  :     LEAVE_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);

  0020b	68 00 00 00 00	 push	 OFFSET FLAT:?gDirectMusicDoWorkCriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; gDirectMusicDoWorkCriticalSection
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 321  : //    DbgPrint("Slept: %ld, Worked: %ld, Percent: %ld\n",
; 322  : //        (long) (rtWakeUp - rtLastSleep), (long) (rtGoToSleep - rtWakeUp),
; 323  : //        (long) (100 * (rtGoToSleep - rtWakeUp) / (rtGoToSleep - rtLastSleep)));
; 324  : 
; 325  : }

  00216	5e		 pop	 esi
  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c2 04 00	 ret	 4
?DoWork@CBossMan@@QAEXK@Z ENDP				; CBossMan::DoWork
_TEXT	ENDS
EXTRN	__allmul:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetPentiumTime@@YGXPA_J@Z
_TEXT	SEGMENT
_cycNow$ = -8
_prtTime$ = 8
?GetPentiumTime@@YGXPA_J@Z PROC NEAR			; GetPentiumTime, COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 222  :     _int64 cycNow;
; 223  : 
; 224  :     _asm
; 225  :     {
; 226  :         RDTSC                       // Get the time in EDX:EAX

  00006	0f 31		 rdtsc

; 227  :         mov     dword ptr [cycNow], eax

  00008	89 45 f8	 mov	 DWORD PTR _cycNow$[ebp], eax

; 228  :         mov     dword ptr [cycNow+4], edx

  0000b	89 55 fc	 mov	 DWORD PTR _cycNow$[ebp+4], edx

; 229  :     }
; 230  : 
; 231  :     cycNow *= 10;          // Gives greater clock granularity.

  0000e	6a 00		 push	 0
  00010	6a 0a		 push	 10			; 0000000aH
  00012	8b 45 fc	 mov	 eax, DWORD PTR _cycNow$[ebp+4]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _cycNow$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 __allmul
  0001f	89 45 f8	 mov	 DWORD PTR _cycNow$[ebp], eax
  00022	89 55 fc	 mov	 DWORD PTR _cycNow$[ebp+4], edx

; 232  :     cycNow /= 733; // m_dwDivisor;

  00025	6a 00		 push	 0
  00027	68 dd 02 00 00	 push	 733			; 000002ddH
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _cycNow$[ebp+4]
  0002f	52		 push	 edx
  00030	8b 45 f8	 mov	 eax, DWORD PTR _cycNow$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	89 45 f8	 mov	 DWORD PTR _cycNow$[ebp], eax
  0003c	89 55 fc	 mov	 DWORD PTR _cycNow$[ebp+4], edx

; 233  :     *prtTime = cycNow;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _prtTime$[ebp]
  00042	8b 55 f8	 mov	 edx, DWORD PTR _cycNow$[ebp]
  00045	89 11		 mov	 DWORD PTR [ecx], edx
  00047	8b 45 fc	 mov	 eax, DWORD PTR _cycNow$[ebp+4]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 234  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?GetPentiumTime@@YGXPA_J@Z ENDP				; GetPentiumTime
_TEXT	ENDS
PUBLIC	?WakeUp@CWorker@@QAEXXZ				; CWorker::WakeUp
PUBLIC	?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z		; CBossMan::WakeUp
; Function compile flags: /Odt
;	COMDAT ?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z
_TEXT	SEGMENT
_this$ = -12
_rt$69571 = -8
_pWorker$ = 8
?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z PROC NEAR		; CBossMan::WakeUp, COMDAT
; _this$ = ecx

; 329  : void CBossMan::WakeUp(CWorker* pWorker){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 330  :     if(g_fUseThreads){

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fUseThreads, 0
  00010	74 15		 je	 SHORT $L69569

; 331  :         // We could deadlock if we actually tried to run worker
; 332  :         pWorker->WakeUp(); // Run me right away

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pWorker$[ebp]
  00015	e8 00 00 00 00	 call	 ?WakeUp@CWorker@@QAEXXZ	; CWorker::WakeUp

; 333  :         SetEvent(g_hDoWorkWakeupEvent);

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hDoWorkWakeupEvent
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _SetEvent@4

; 334  :     }
; 335  :     else

  00025	eb 11		 jmp	 SHORT $L69568
$L69569:

; 336  :     {
; 337  :         // No worker thread, just call worker now.
; 338  :         REFERENCE_TIME rt;
; 339  :         pWorker->m_pWorkRoutine(pWorker->m_pContext,&rt);

  00027	8d 4d f8	 lea	 ecx, DWORD PTR _rt$69571[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _pWorker$[ebp]
  0002e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _pWorker$[ebp]
  00035	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69568:

; 340  :     }
; 341  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?WakeUp@CBossMan@@QAEXPAVCWorker@@@Z ENDP		; CBossMan::WakeUp
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AListItem@@QAE@XZ PROC NEAR				; AListItem::AListItem, COMDAT
; _this$ = ecx

; 17   :     AListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AListItem@@QAE@XZ ENDP				; AListItem::AListItem
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsEmpty@AList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsEmpty@AList@@QBEHXZ PROC NEAR			; AList::IsEmpty, COMDAT
; _this$ = ecx

; 68   :     BOOL IsEmpty(void) const {return (m_pHead==NULL);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	0f 94 c1	 sete	 cl
  00012	8b c1		 mov	 eax, ecx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?IsEmpty@AList@@QBEHXZ ENDP				; AList::IsEmpty
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetNext@AListItem@@QBEPAV1@XZ			; AListItem::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dowork.h
;	COMDAT ?GetNext@CWorker@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CWorker@@QAEPAV1@XZ PROC NEAR			; CWorker::GetNext, COMDAT
; _this$ = ecx

; 15   :     CWorker *   GetNext() { return (CWorker*)AListItem::GetNext();};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CWorker@@QAEPAV1@XZ ENDP			; CWorker::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@AListItem@@QBEPAV1@XZ PROC NEAR		; AListItem::GetNext, COMDAT
; _this$ = ecx

; 18   :     AListItem *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNext@AListItem@@QBEPAV1@XZ ENDP			; AListItem::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dowork.h
_TEXT	ENDS
;	COMDAT ?WakeUp@CWorker@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?WakeUp@CWorker@@QAEXXZ PROC NEAR			; CWorker::WakeUp, COMDAT
; _this$ = ecx

; 16   :     void        WakeUp() { m_rtWakeUpTime = 0; };   // Tells the worker to wake up as soon as possible.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00011	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?WakeUp@CWorker@@QAEXXZ ENDP				; CWorker::WakeUp
_TEXT	ENDS
PUBLIC	??0AList@@QAE@XZ				; AList::AList
; Function compile flags: /Odt
;	COMDAT ??0CBossMan@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBossMan@@QAE@XZ PROC NEAR				; CBossMan::CBossMan, COMDAT
; _this$ = ecx

; 37   :                 CBossMan() { m_pMasterClock = NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0CBossMan@@QAE@XZ ENDP				; CBossMan::CBossMan
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AList@@QAE@XZ PROC NEAR				; AList::AList, COMDAT
; _this$ = ecx

; 34   :     AList() {m_pHead=NULL;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AList@@QAE@XZ ENDP					; AList::AList
_TEXT	ENDS
PUBLIC	?GetHead@AList@@QBEPAVAListItem@@XZ		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dowork.h
;	COMDAT ?GetHead@CBossMan@@QAEPAVCWorker@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CBossMan@@QAEPAVCWorker@@XZ PROC NEAR		; CBossMan::GetHead, COMDAT
; _this$ = ecx

; 40   :     CWorker*    GetHead(){return (CWorker*)AList::GetHead();};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CBossMan@@QAEPAVCWorker@@XZ ENDP		; CBossMan::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetHead, COMDAT
; _this$ = ecx

; 35   :     AListItem *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetHead
_TEXT	ENDS
PUBLIC	?Remove@AList@@QAEXPAVAListItem@@@Z		; AList::Remove
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dowork.h
;	COMDAT ?Remove@CBossMan@@QAEXPAVCWorker@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Remove@CBossMan@@QAEXPAVCWorker@@@Z PROC NEAR		; CBossMan::Remove, COMDAT
; _this$ = ecx

; 43   :     void        Remove(CWorker *pItem){AList::Remove((AListItem *)pItem);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Remove@CBossMan@@QAEXPAVCWorker@@@Z ENDP		; CBossMan::Remove
_TEXT	ENDS
EXTRN	?Remove@AListItem@@QAEPAV1@PAV1@@Z:NEAR		; AListItem::Remove
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Remove@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::Remove, COMDAT
; _this$ = ecx

; 60   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   :             if (pItem != NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 13		 je	 SHORT $L32733

; 62   :             {
; 63   :                 m_pHead=m_pHead->Remove(pItem);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	e8 00 00 00 00	 call	 ?Remove@AListItem@@QAEPAV1@PAV1@@Z ; AListItem::Remove
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	89 02		 mov	 DWORD PTR [edx], eax
$L32733:

; 64   :             }
; 65   :         };

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?Remove@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::Remove
_TEXT	ENDS
PUBLIC	?g_BossMan@@3VCBossMan@@A			; g_BossMan
_BSS	SEGMENT
?g_BossMan@@3VCBossMan@@A DQ 01H DUP (?)		; g_BossMan
_BSS	ENDS
END
