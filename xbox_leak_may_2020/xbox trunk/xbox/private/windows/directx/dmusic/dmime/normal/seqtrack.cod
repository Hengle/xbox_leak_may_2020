; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\seqtrack.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@CKCMFCBC@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MIJOINAD@pStateData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JJFOBOKJ@mtTime?5?$DO?5rSeq?4mtTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNABCHHM@mtTime?5?$DO?5rCurve?4mtStart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@EFKFPJBJ@Error?3?5Invalid?5clone?5parameters?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FM@HOGOGKH@Error?3?5Invalid?5clone?5parameters?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ?Construct@CSeqTrack@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSeqTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPersistStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicTrack8@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSeqTrack@@QAE@ABV0@JJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSeqTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSeqTrack@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSeqTrack@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSeqTrack@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDirty@CSeqTrack@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadSeq@CSeqTrack@@IAEJPAUIStream@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadCurve@CSeqTrack@@IAEJPAUIStream@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CSeqTrack@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CSeqTrack@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSizeMax@CSeqTrack@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsParamSupported@CSeqTrack@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CSeqTrack@@UAGJPAUIDirectMusicSegment@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndPlay@CSeqTrack@@UAGJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSeqStateData@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteSeqPartList@CSeqTrack@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParam@CSeqTrack@@UAGJABU_GUID@@JPAJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParam@CSeqTrack@@UAGJABU_GUID@@JPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPA_JPAX3K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPAX2K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compose@CSeqTrack@@UAGJPAUIUnknown@@KPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Join@CSeqTrack@@UAGJPAUIDirectMusicTrack@@JPAUIUnknown@@KPAPAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@?$TList@USEQ_PART@@@@QAEPAV?$TListItem@USEQ_PART@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@ABU_DMUS_IO_SEQ_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@ABU_DMUS_IO_CURVE_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SEQ_PART@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@USEQ_PART@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@USEQ_PART@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSeqTrack@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSeqTrack@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSeqTrack@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SEQ_PART@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SeqStateData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?6??EndPlay@CSeqTrack@@UAGJPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0SeqStateData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@MDDFKLEP@?$CFs?3?5Invalid?5pointer?5ppStateData?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Load@CSeqTrack@@UAGJPAUIStream@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSeqTrack@@6BIDirectMusicTrack8@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSeqTrack@@6BIPersistStream@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?Construct@CSeqTrack@@IAEXXZ			; CSeqTrack::Construct
EXTRN	__imp__RtlInitializeCriticalSection@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\seqtrack.cpp
;	COMDAT ?Construct@CSeqTrack@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Construct@CSeqTrack@@IAEXXZ PROC NEAR			; CSeqTrack::Construct, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   :     IncrementDLLCount();
; 59   : 
; 60   : 	m_pSeqPartCache = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 61   : 	m_dwPChannelsUsed = 0;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 62   : 	m_aPChannels = NULL;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 63   : 	m_dwValidate = 0;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 64   :     m_fCSInitialized = FALSE;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 65   : 	INITIALIZE_CRITICAL_SECTION(&m_CrSec);

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	83 c2 20	 add	 edx, 32			; 00000020H
  0003f	52		 push	 edx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 66   :     m_fCSInitialized = TRUE;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1

; 67   : 	m_cRef = 1;

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1

; 68   : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?Construct@CSeqTrack@@IAEXXZ ENDP			; CSeqTrack::Construct
_TEXT	ENDS
PUBLIC	?AddRef@CSeqTrack@@W3AGKXZ			; CSeqTrack::AddRef
PUBLIC	?Release@CSeqTrack@@W3AGKXZ			; CSeqTrack::Release
PUBLIC	??0IDirectMusicTrack8@@QAE@XZ			; IDirectMusicTrack8::IDirectMusicTrack8
PUBLIC	??0CSeqTrack@@QAE@XZ				; CSeqTrack::CSeqTrack
PUBLIC	?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z ; CSeqTrack::QueryInterface
PUBLIC	?AddRef@CSeqTrack@@UAGKXZ			; CSeqTrack::AddRef
PUBLIC	?Release@CSeqTrack@@UAGKXZ			; CSeqTrack::Release
PUBLIC	?IsParamSupported@CSeqTrack@@UAGJABU_GUID@@@Z	; CSeqTrack::IsParamSupported
PUBLIC	?Init@CSeqTrack@@UAGJPAUIDirectMusicSegment@@@Z	; CSeqTrack::Init
PUBLIC	?InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z ; CSeqTrack::InitPlay
PUBLIC	?EndPlay@CSeqTrack@@UAGJPAX@Z			; CSeqTrack::EndPlay
PUBLIC	?Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z ; CSeqTrack::Play
PUBLIC	?GetParam@CSeqTrack@@UAGJABU_GUID@@JPAJPAX@Z	; CSeqTrack::GetParam
PUBLIC	?SetParam@CSeqTrack@@UAGJABU_GUID@@JPAX@Z	; CSeqTrack::SetParam
PUBLIC	?AddNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z ; CSeqTrack::AddNotificationType
PUBLIC	?RemoveNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z ; CSeqTrack::RemoveNotificationType
PUBLIC	?Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z ; CSeqTrack::Clone
PUBLIC	?PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z ; CSeqTrack::PlayEx
PUBLIC	?GetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPA_JPAX3K@Z ; CSeqTrack::GetParamEx
PUBLIC	?SetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPAX2K@Z	; CSeqTrack::SetParamEx
PUBLIC	?Compose@CSeqTrack@@UAGJPAUIUnknown@@KPAPAUIDirectMusicTrack@@@Z ; CSeqTrack::Compose
PUBLIC	?Join@CSeqTrack@@UAGJPAUIDirectMusicTrack@@JPAUIUnknown@@KPAPAU2@@Z ; CSeqTrack::Join
PUBLIC	?GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z		; CSeqTrack::GetClassID
PUBLIC	?IsDirty@CSeqTrack@@UAGJXZ			; CSeqTrack::IsDirty
PUBLIC	?Load@CSeqTrack@@UAGJPAUIStream@@@Z		; CSeqTrack::Load
PUBLIC	?Save@CSeqTrack@@UAGJPAUIStream@@H@Z		; CSeqTrack::Save
PUBLIC	?GetSizeMax@CSeqTrack@@UAGJPAT_ULARGE_INTEGER@@@Z ; CSeqTrack::GetSizeMax
PUBLIC	??0?$TList@USEQ_PART@@@@QAE@XZ			; TList<SEQ_PART>::TList<SEQ_PART>
PUBLIC	??0IPersistStream@@QAE@XZ			; IPersistStream::IPersistStream
PUBLIC	??_7CSeqTrack@@6BIPersistStream@@@		; CSeqTrack::`vftable'
PUBLIC	??_7CSeqTrack@@6BIDirectMusicTrack8@@@		; CSeqTrack::`vftable'
PUBLIC	?QueryInterface@CSeqTrack@@W3AGJABU_GUID@@PAPAX@Z ; CSeqTrack::QueryInterface
EXTRN	??0CPChMap@@QAE@XZ:NEAR				; CPChMap::CPChMap
EXTRN	??0CMemTrack@@QAE@K@Z:NEAR			; CMemTrack::CMemTrack
;	COMDAT ??_7CSeqTrack@@6BIPersistStream@@@
CONST	SEGMENT
??_7CSeqTrack@@6BIPersistStream@@@ DD FLAT:?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z ; CSeqTrack::`vftable'
	DD	FLAT:?AddRef@CSeqTrack@@UAGKXZ
	DD	FLAT:?Release@CSeqTrack@@UAGKXZ
	DD	FLAT:?GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@CSeqTrack@@UAGJXZ
	DD	FLAT:?Load@CSeqTrack@@UAGJPAUIStream@@@Z
	DD	FLAT:?Save@CSeqTrack@@UAGJPAUIStream@@H@Z
	DD	FLAT:?GetSizeMax@CSeqTrack@@UAGJPAT_ULARGE_INTEGER@@@Z
CONST	ENDS
;	COMDAT ??_7CSeqTrack@@6BIDirectMusicTrack8@@@
CONST	SEGMENT
??_7CSeqTrack@@6BIDirectMusicTrack8@@@ DD FLAT:?QueryInterface@CSeqTrack@@W3AGJABU_GUID@@PAPAX@Z ; CSeqTrack::`vftable'
	DD	FLAT:?AddRef@CSeqTrack@@W3AGKXZ
	DD	FLAT:?Release@CSeqTrack@@W3AGKXZ
	DD	FLAT:?Init@CSeqTrack@@UAGJPAUIDirectMusicSegment@@@Z
	DD	FLAT:?InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z
	DD	FLAT:?EndPlay@CSeqTrack@@UAGJPAX@Z
	DD	FLAT:?Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z
	DD	FLAT:?GetParam@CSeqTrack@@UAGJABU_GUID@@JPAJPAX@Z
	DD	FLAT:?SetParam@CSeqTrack@@UAGJABU_GUID@@JPAX@Z
	DD	FLAT:?IsParamSupported@CSeqTrack@@UAGJABU_GUID@@@Z
	DD	FLAT:?AddNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z
	DD	FLAT:?RemoveNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z
	DD	FLAT:?Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z
	DD	FLAT:?PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z
	DD	FLAT:?GetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPA_JPAX3K@Z
	DD	FLAT:?SetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPAX2K@Z
	DD	FLAT:?Compose@CSeqTrack@@UAGJPAUIUnknown@@KPAPAUIDirectMusicTrack@@@Z
	DD	FLAT:?Join@CSeqTrack@@UAGJPAUIDirectMusicTrack@@JPAUIUnknown@@KPAPAU2@@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CSeqTrack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSeqTrack@@QAE@XZ PROC NEAR				; CSeqTrack::CSeqTrack, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IPersistStream@@QAE@XZ
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	e8 00 00 00 00	 call	 ??0IDirectMusicTrack8@@QAE@XZ
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSeqTrack@@6BIPersistStream@@@
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSeqTrack@@6BIDirectMusicTrack8@@@
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 08	 add	 ecx, 8
  00033	e8 00 00 00 00	 call	 ??0?$TList@USEQ_PART@@@@QAE@XZ ; TList<SEQ_PART>::TList<SEQ_PART>
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 40	 add	 ecx, 64			; 00000040H
  0003e	e8 00 00 00 00	 call	 ??0CPChMap@@QAE@XZ	; CPChMap::CPChMap
  00043	6a 1a		 push	 26			; 0000001aH
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 44	 add	 ecx, 68			; 00000044H
  0004b	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack

; 72   : 	Construct();

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?Construct@CSeqTrack@@IAEXXZ ; CSeqTrack::Construct

; 73   : }

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??0CSeqTrack@@QAE@XZ ENDP				; CSeqTrack::CSeqTrack
_TEXT	ENDS
PUBLIC	??0IPersist@@QAE@XZ				; IPersist::IPersist
; Function compile flags: /Odt
;	COMDAT ??0IPersistStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPersistStream@@QAE@XZ PROC NEAR			; IPersistStream::IPersistStream, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IPersist@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IPersistStream@@QAE@XZ ENDP				; IPersistStream::IPersistStream
_TEXT	ENDS
PUBLIC	??0IDirectMusicTrack@@QAE@XZ			; IDirectMusicTrack::IDirectMusicTrack
; Function compile flags: /Odt
;	COMDAT ??0IDirectMusicTrack8@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicTrack8@@QAE@XZ PROC NEAR			; IDirectMusicTrack8::IDirectMusicTrack8, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IDirectMusicTrack@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicTrack8@@QAE@XZ ENDP			; IDirectMusicTrack8::IDirectMusicTrack8
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPersist@@QAE@XZ PROC NEAR				; IPersist::IPersist, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IPersist@@QAE@XZ ENDP				; IPersist::IPersist
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicTrack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicTrack@@QAE@XZ PROC NEAR			; IDirectMusicTrack::IDirectMusicTrack, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicTrack@@QAE@XZ ENDP			; IDirectMusicTrack::IDirectMusicTrack
_TEXT	ENDS
PUBLIC	?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ; TList<_DMUS_IO_SEQ_ITEM>::GetHead
PUBLIC	?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z ; TList<_DMUS_IO_SEQ_ITEM>::AddHead
PUBLIC	?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ	; TList<_DMUS_IO_SEQ_ITEM>::Reverse
PUBLIC	?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ; TList<_DMUS_IO_CURVE_ITEM>::GetHead
PUBLIC	?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z ; TList<_DMUS_IO_CURVE_ITEM>::AddHead
PUBLIC	?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ	; TList<_DMUS_IO_CURVE_ITEM>::Reverse
PUBLIC	??0CSeqTrack@@QAE@ABV0@JJ@Z			; CSeqTrack::CSeqTrack
PUBLIC	?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
PUBLIC	?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z ; TList<SEQ_PART>::AddHead
PUBLIC	?Reverse@?$TList@USEQ_PART@@@@QAEXXZ		; TList<SEQ_PART>::Reverse
PUBLIC	??0?$TListItem@USEQ_PART@@@@QAE@XZ		; TListItem<SEQ_PART>::TListItem<SEQ_PART>
PUBLIC	?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ	; TListItem<SEQ_PART>::GetNext
PUBLIC	?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
PUBLIC	??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ	; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>
PUBLIC	?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
PUBLIC	?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
PUBLIC	??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ	; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>
PUBLIC	?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
PUBLIC	?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT ??0CSeqTrack@@QAE@ABV0@JJ@Z
_TEXT	SEGMENT
tv211 = -72
tv177 = -68
tv152 = -64
_this$ = -60
$T70877 = -56
$T70874 = -52
$T70871 = -48
$T70870 = -44
_rNew$69518 = -40
_pNew$69514 = -36
_rScan$69511 = -32
_rNew$69504 = -28
_pNew$69500 = -24
_rScan$69497 = -20
_pScan$69493 = -16
_pScanCurve$69507 = -12
_pNewPart$69489 = -8
_pPart$ = -4
_rTrack$ = 8
_mtStart$ = 12
_mtEnd$ = 16
??0CSeqTrack@@QAE@ABV0@JJ@Z PROC NEAR			; CSeqTrack::CSeqTrack, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	56		 push	 esi
  00007	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0IPersistStream@@QAE@XZ
  00012	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	e8 00 00 00 00	 call	 ??0IDirectMusicTrack8@@QAE@XZ
  0001d	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSeqTrack@@6BIPersistStream@@@
  00026	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSeqTrack@@6BIDirectMusicTrack8@@@
  00030	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 08	 add	 ecx, 8
  00036	e8 00 00 00 00	 call	 ??0?$TList@USEQ_PART@@@@QAE@XZ ; TList<SEQ_PART>::TList<SEQ_PART>
  0003b	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 40	 add	 ecx, 64			; 00000040H
  00041	e8 00 00 00 00	 call	 ??0CPChMap@@QAE@XZ	; CPChMap::CPChMap
  00046	6a 1a		 push	 26			; 0000001aH
  00048	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 44	 add	 ecx, 68			; 00000044H
  0004e	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack

; 78   : 	Construct();

  00053	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?Construct@CSeqTrack@@IAEXXZ ; CSeqTrack::Construct

; 79   : 	m_dwPChannelsUsed = rTrack.m_dwPChannelsUsed;

  0005b	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 45 08	 mov	 eax, DWORD PTR _rTrack$[ebp]
  00061	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00064	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 80   : 	if( m_dwPChannelsUsed )

  00067	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0006e	74 47		 je	 SHORT $L69436

; 81   : 	{
; 82   : 		m_aPChannels = new DWORD[m_dwPChannelsUsed];

  00070	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00076	c1 e1 02	 shl	 ecx, 2
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0007f	83 c4 04	 add	 esp, 4
  00082	89 45 d4	 mov	 DWORD PTR $T70870[ebp], eax
  00085	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00088	8b 45 d4	 mov	 eax, DWORD PTR $T70870[ebp]
  0008b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 83   :         if (m_aPChannels)

  0008e	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00095	74 20		 je	 SHORT $L69436

; 84   :         {
; 85   : 		    memcpy( m_aPChannels, rTrack.m_aPChannels, sizeof(DWORD) * m_dwPChannelsUsed );

  00097	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0009d	c1 e0 02	 shl	 eax, 2
  000a0	50		 push	 eax
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _rTrack$[ebp]
  000a4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a7	52		 push	 edx
  000a8	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _memcpy
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69436:

; 86   :         }
; 87   : 	}
; 88   : 
; 89   : 	TListItem<SEQ_PART>* pPart = rTrack.m_SeqPartList.GetHead();

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _rTrack$[ebp]
  000ba	83 c1 08	 add	 ecx, 8
  000bd	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  000c2	89 45 fc	 mov	 DWORD PTR _pPart$[ebp], eax

; 90   : 	for( ; pPart; pPart = pPart->GetNext() )

  000c5	eb 0b		 jmp	 SHORT $L69486
$L69487:
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  000ca	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  000cf	89 45 fc	 mov	 DWORD PTR _pPart$[ebp], eax
$L69486:
  000d2	83 7d fc 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  000d6	0f 84 24 02 00
	00		 je	 $L69435

; 91   : 	{
; 92   : 		TListItem<SEQ_PART>* pNewPart = new TListItem<SEQ_PART>;

  000dc	6a 14		 push	 20			; 00000014H
  000de	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e3	83 c4 04	 add	 esp, 4
  000e6	89 45 d0	 mov	 DWORD PTR $T70871[ebp], eax
  000e9	83 7d d0 00	 cmp	 DWORD PTR $T70871[ebp], 0
  000ed	74 0d		 je	 SHORT $L70872
  000ef	8b 4d d0	 mov	 ecx, DWORD PTR $T70871[ebp]
  000f2	e8 00 00 00 00	 call	 ??0?$TListItem@USEQ_PART@@@@QAE@XZ ; TListItem<SEQ_PART>::TListItem<SEQ_PART>
  000f7	89 45 c0	 mov	 DWORD PTR tv152[ebp], eax
  000fa	eb 07		 jmp	 SHORT $L70873
$L70872:
  000fc	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv152[ebp], 0
$L70873:
  00103	8b 55 c0	 mov	 edx, DWORD PTR tv152[ebp]
  00106	89 55 f8	 mov	 DWORD PTR _pNewPart$69489[ebp], edx

; 93   : 		if( pNewPart )

  00109	83 7d f8 00	 cmp	 DWORD PTR _pNewPart$69489[ebp], 0
  0010d	0f 84 dd 01 00
	00		 je	 $L69492

; 94   : 		{
; 95   : 			pNewPart->GetItemValue().dwPChannel = pPart->GetItemValue().dwPChannel;

  00113	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  00116	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  0011b	8b f0		 mov	 esi, eax
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _pNewPart$69489[ebp]
  00120	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00125	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00128	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 96   : 			TListItem<DMUS_IO_SEQ_ITEM>* pScan = pPart->GetItemValue().seqList.GetHead();

  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  0012e	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00133	83 c0 08	 add	 eax, 8
  00136	8b c8		 mov	 ecx, eax
  00138	e8 00 00 00 00	 call	 ?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ; TList<_DMUS_IO_SEQ_ITEM>::GetHead
  0013d	89 45 f0	 mov	 DWORD PTR _pScan$69493[ebp], eax

; 97   : 
; 98   : 			for(; pScan; pScan = pScan->GetNext())

  00140	eb 0b		 jmp	 SHORT $L69494
$L69495:
  00142	8b 4d f0	 mov	 ecx, DWORD PTR _pScan$69493[ebp]
  00145	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
  0014a	89 45 f0	 mov	 DWORD PTR _pScan$69493[ebp], eax
$L69494:
  0014d	83 7d f0 00	 cmp	 DWORD PTR _pScan$69493[ebp], 0
  00151	0f 84 9d 00 00
	00		 je	 $L69496

; 99   : 			{
; 100  : 				DMUS_IO_SEQ_ITEM& rScan = pScan->GetItemValue();

  00157	8b 4d f0	 mov	 ecx, DWORD PTR _pScan$69493[ebp]
  0015a	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
  0015f	89 45 ec	 mov	 DWORD PTR _rScan$69497[ebp], eax

; 101  : 				if( rScan.mtTime < mtStart )

  00162	8b 55 ec	 mov	 edx, DWORD PTR _rScan$69497[ebp]
  00165	8b 02		 mov	 eax, DWORD PTR [edx]
  00167	3b 45 0c	 cmp	 eax, DWORD PTR _mtStart$[ebp]
  0016a	7d 02		 jge	 SHORT $L69498

; 102  : 				{
; 103  : 					continue;

  0016c	eb d4		 jmp	 SHORT $L69495
$L69498:

; 104  : 				}
; 105  : 				if (rScan.mtTime < mtEnd)

  0016e	8b 4d ec	 mov	 ecx, DWORD PTR _rScan$69497[ebp]
  00171	8b 11		 mov	 edx, DWORD PTR [ecx]
  00173	3b 55 10	 cmp	 edx, DWORD PTR _mtEnd$[ebp]
  00176	7d 75		 jge	 SHORT $L69499

; 106  : 				{
; 107  : 					TListItem<DMUS_IO_SEQ_ITEM>* pNew = new TListItem<DMUS_IO_SEQ_ITEM>;

  00178	6a 18		 push	 24			; 00000018H
  0017a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0017f	83 c4 04	 add	 esp, 4
  00182	89 45 cc	 mov	 DWORD PTR $T70874[ebp], eax
  00185	83 7d cc 00	 cmp	 DWORD PTR $T70874[ebp], 0
  00189	74 0d		 je	 SHORT $L70875
  0018b	8b 4d cc	 mov	 ecx, DWORD PTR $T70874[ebp]
  0018e	e8 00 00 00 00	 call	 ??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>
  00193	89 45 bc	 mov	 DWORD PTR tv177[ebp], eax
  00196	eb 07		 jmp	 SHORT $L70876
$L70875:
  00198	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv177[ebp], 0
$L70876:
  0019f	8b 45 bc	 mov	 eax, DWORD PTR tv177[ebp]
  001a2	89 45 e8	 mov	 DWORD PTR _pNew$69500[ebp], eax

; 108  : 					if (pNew)

  001a5	83 7d e8 00	 cmp	 DWORD PTR _pNew$69500[ebp], 0
  001a9	74 40		 je	 SHORT $L69503

; 109  : 					{
; 110  : 						DMUS_IO_SEQ_ITEM& rNew = pNew->GetItemValue();

  001ab	8b 4d e8	 mov	 ecx, DWORD PTR _pNew$69500[ebp]
  001ae	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
  001b3	89 45 e4	 mov	 DWORD PTR _rNew$69504[ebp], eax

; 111  : 						memcpy( &rNew, &rScan, sizeof(DMUS_IO_SEQ_ITEM) );

  001b6	6a 14		 push	 20			; 00000014H
  001b8	8b 4d ec	 mov	 ecx, DWORD PTR _rScan$69497[ebp]
  001bb	51		 push	 ecx
  001bc	8b 55 e4	 mov	 edx, DWORD PTR _rNew$69504[ebp]
  001bf	52		 push	 edx
  001c0	e8 00 00 00 00	 call	 _memcpy
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : 						rNew.mtTime = rScan.mtTime - mtStart;

  001c8	8b 45 ec	 mov	 eax, DWORD PTR _rScan$69497[ebp]
  001cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cd	2b 4d 0c	 sub	 ecx, DWORD PTR _mtStart$[ebp]
  001d0	8b 55 e4	 mov	 edx, DWORD PTR _rNew$69504[ebp]
  001d3	89 0a		 mov	 DWORD PTR [edx], ecx

; 113  : 						pNewPart->GetItemValue().seqList.AddHead(pNew); // AddTail can get expensive (n^2), so

  001d5	8b 45 e8	 mov	 eax, DWORD PTR _pNew$69500[ebp]
  001d8	50		 push	 eax
  001d9	8b 4d f8	 mov	 ecx, DWORD PTR _pNewPart$69489[ebp]
  001dc	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  001e1	83 c0 08	 add	 eax, 8
  001e4	8b c8		 mov	 ecx, eax
  001e6	e8 00 00 00 00	 call	 ?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z ; TList<_DMUS_IO_SEQ_ITEM>::AddHead
$L69503:

; 114  : 													// AddHead instead and Reverse later.
; 115  : 					}
; 116  : 				}
; 117  : 				else break;

  001eb	eb 02		 jmp	 SHORT $L69506
$L69499:
  001ed	eb 05		 jmp	 SHORT $L69496
$L69506:

; 118  : 			}

  001ef	e9 4e ff ff ff	 jmp	 $L69495
$L69496:

; 119  : 			pNewPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier.

  001f4	8b 4d f8	 mov	 ecx, DWORD PTR _pNewPart$69489[ebp]
  001f7	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  001fc	83 c0 08	 add	 eax, 8
  001ff	8b c8		 mov	 ecx, eax
  00201	e8 00 00 00 00	 call	 ?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ ; TList<_DMUS_IO_SEQ_ITEM>::Reverse

; 120  : 
; 121  : 			TListItem<DMUS_IO_CURVE_ITEM>* pScanCurve = pPart->GetItemValue().curveList.GetHead();

  00206	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  00209	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  0020e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00211	8b c8		 mov	 ecx, eax
  00213	e8 00 00 00 00	 call	 ?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ; TList<_DMUS_IO_CURVE_ITEM>::GetHead
  00218	89 45 f4	 mov	 DWORD PTR _pScanCurve$69507[ebp], eax

; 122  : 
; 123  : 			for(; pScanCurve; pScanCurve = pScanCurve->GetNext())

  0021b	eb 0b		 jmp	 SHORT $L69508
$L69509:
  0021d	8b 4d f4	 mov	 ecx, DWORD PTR _pScanCurve$69507[ebp]
  00220	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
  00225	89 45 f4	 mov	 DWORD PTR _pScanCurve$69507[ebp], eax
$L69508:
  00228	83 7d f4 00	 cmp	 DWORD PTR _pScanCurve$69507[ebp], 0
  0022c	0f 84 9d 00 00
	00		 je	 $L69510

; 124  : 			{
; 125  : 				DMUS_IO_CURVE_ITEM& rScan = pScanCurve->GetItemValue();

  00232	8b 4d f4	 mov	 ecx, DWORD PTR _pScanCurve$69507[ebp]
  00235	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  0023a	89 45 e0	 mov	 DWORD PTR _rScan$69511[ebp], eax

; 126  : 				if( rScan.mtStart < mtStart )

  0023d	8b 4d e0	 mov	 ecx, DWORD PTR _rScan$69511[ebp]
  00240	8b 11		 mov	 edx, DWORD PTR [ecx]
  00242	3b 55 0c	 cmp	 edx, DWORD PTR _mtStart$[ebp]
  00245	7d 02		 jge	 SHORT $L69512

; 127  : 				{
; 128  : 					continue;

  00247	eb d4		 jmp	 SHORT $L69509
$L69512:

; 129  : 				}
; 130  : 				if (rScan.mtStart < mtEnd)

  00249	8b 45 e0	 mov	 eax, DWORD PTR _rScan$69511[ebp]
  0024c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024e	3b 4d 10	 cmp	 ecx, DWORD PTR _mtEnd$[ebp]
  00251	7d 75		 jge	 SHORT $L69513

; 131  : 				{
; 132  : 					TListItem<DMUS_IO_CURVE_ITEM>* pNew = new TListItem<DMUS_IO_CURVE_ITEM>;

  00253	6a 24		 push	 36			; 00000024H
  00255	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0025a	83 c4 04	 add	 esp, 4
  0025d	89 45 c8	 mov	 DWORD PTR $T70877[ebp], eax
  00260	83 7d c8 00	 cmp	 DWORD PTR $T70877[ebp], 0
  00264	74 0d		 je	 SHORT $L70878
  00266	8b 4d c8	 mov	 ecx, DWORD PTR $T70877[ebp]
  00269	e8 00 00 00 00	 call	 ??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>
  0026e	89 45 b8	 mov	 DWORD PTR tv211[ebp], eax
  00271	eb 07		 jmp	 SHORT $L70879
$L70878:
  00273	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv211[ebp], 0
$L70879:
  0027a	8b 55 b8	 mov	 edx, DWORD PTR tv211[ebp]
  0027d	89 55 dc	 mov	 DWORD PTR _pNew$69514[ebp], edx

; 133  : 					if (pNew)

  00280	83 7d dc 00	 cmp	 DWORD PTR _pNew$69514[ebp], 0
  00284	74 40		 je	 SHORT $L69517

; 134  : 					{
; 135  : 						DMUS_IO_CURVE_ITEM& rNew = pNew->GetItemValue();

  00286	8b 4d dc	 mov	 ecx, DWORD PTR _pNew$69514[ebp]
  00289	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  0028e	89 45 d8	 mov	 DWORD PTR _rNew$69518[ebp], eax

; 136  : 						memcpy( &rNew, &rScan, sizeof(DMUS_IO_CURVE_ITEM) );

  00291	6a 20		 push	 32			; 00000020H
  00293	8b 45 e0	 mov	 eax, DWORD PTR _rScan$69511[ebp]
  00296	50		 push	 eax
  00297	8b 4d d8	 mov	 ecx, DWORD PTR _rNew$69518[ebp]
  0029a	51		 push	 ecx
  0029b	e8 00 00 00 00	 call	 _memcpy
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 137  : 						rNew.mtStart = rScan.mtStart - mtStart;

  002a3	8b 55 e0	 mov	 edx, DWORD PTR _rScan$69511[ebp]
  002a6	8b 02		 mov	 eax, DWORD PTR [edx]
  002a8	2b 45 0c	 sub	 eax, DWORD PTR _mtStart$[ebp]
  002ab	8b 4d d8	 mov	 ecx, DWORD PTR _rNew$69518[ebp]
  002ae	89 01		 mov	 DWORD PTR [ecx], eax

; 138  : 						pNewPart->GetItemValue().curveList.AddHead(pNew); // AddTail can get expensive (n^2), so

  002b0	8b 55 dc	 mov	 edx, DWORD PTR _pNew$69514[ebp]
  002b3	52		 push	 edx
  002b4	8b 4d f8	 mov	 ecx, DWORD PTR _pNewPart$69489[ebp]
  002b7	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  002bc	83 c0 0c	 add	 eax, 12			; 0000000cH
  002bf	8b c8		 mov	 ecx, eax
  002c1	e8 00 00 00 00	 call	 ?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z ; TList<_DMUS_IO_CURVE_ITEM>::AddHead
$L69517:

; 139  : 													// AddHead instead and Reverse later.
; 140  : 					}
; 141  : 				}
; 142  : 				else break;

  002c6	eb 02		 jmp	 SHORT $L69520
$L69513:
  002c8	eb 05		 jmp	 SHORT $L69510
$L69520:

; 143  : 			}

  002ca	e9 4e ff ff ff	 jmp	 $L69509
$L69510:

; 144  : 			pNewPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier.

  002cf	8b 4d f8	 mov	 ecx, DWORD PTR _pNewPart$69489[ebp]
  002d2	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  002d7	83 c0 0c	 add	 eax, 12			; 0000000cH
  002da	8b c8		 mov	 ecx, eax
  002dc	e8 00 00 00 00	 call	 ?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ ; TList<_DMUS_IO_CURVE_ITEM>::Reverse

; 145  : 			m_SeqPartList.AddHead(pNewPart);

  002e1	8b 45 f8	 mov	 eax, DWORD PTR _pNewPart$69489[ebp]
  002e4	50		 push	 eax
  002e5	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	83 c1 08	 add	 ecx, 8
  002eb	e8 00 00 00 00	 call	 ?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z ; TList<SEQ_PART>::AddHead
$L69492:

; 146  : 		}
; 147  : 		m_SeqPartList.Reverse();

  002f0	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f3	83 c1 08	 add	 ecx, 8
  002f6	e8 00 00 00 00	 call	 ?Reverse@?$TList@USEQ_PART@@@@QAEXXZ ; TList<SEQ_PART>::Reverse

; 148  : 	}

  002fb	e9 c7 fd ff ff	 jmp	 $L69487
$L69435:

; 149  : }

  00300	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00303	5e		 pop	 esi
  00304	8b e5		 mov	 esp, ebp
  00306	5d		 pop	 ebp
  00307	c2 0c 00	 ret	 12			; 0000000cH
??0CSeqTrack@@QAE@ABV0@JJ@Z ENDP			; CSeqTrack::CSeqTrack
_TEXT	ENDS
PUBLIC	??1CSeqTrack@@QAE@XZ				; CSeqTrack::~CSeqTrack
PUBLIC	?DeleteSeqPartList@CSeqTrack@@IAEXXZ		; CSeqTrack::DeleteSeqPartList
PUBLIC	??1?$TList@USEQ_PART@@@@QAE@XZ			; TList<SEQ_PART>::~TList<SEQ_PART>
PUBLIC	?DeleteCriticalSection@@YGXPAX@Z		; DeleteCriticalSection
EXTRN	??1CPChMap@@QAE@XZ:NEAR				; CPChMap::~CPChMap
EXTRN	??1CMemTrack@@QAE@XZ:NEAR			; CMemTrack::~CMemTrack
; Function compile flags: /Odt
;	COMDAT ??1CSeqTrack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CSeqTrack@@QAE@XZ PROC NEAR				; CSeqTrack::~CSeqTrack, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSeqTrack@@6BIPersistStream@@@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSeqTrack@@6BIDirectMusicTrack8@@@

; 153  :     if (m_fCSInitialized)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  00021	74 14		 je	 SHORT $L69523

; 154  :     {
; 155  :         DeleteSeqPartList();                // This will be empty if critical section

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?DeleteSeqPartList@CSeqTrack@@IAEXXZ ; CSeqTrack::DeleteSeqPartList

; 156  :                                             // never got initialized.
; 157  : 	    DELETE_CRITICAL_SECTION(&m_CrSec);

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 20	 add	 eax, 32			; 00000020H
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection
$L69523:

; 158  :     }
; 159  : 
; 160  :     DecrementDLLCount();
; 161  : }

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 44	 add	 ecx, 68			; 00000044H
  0003d	e8 00 00 00 00	 call	 ??1CMemTrack@@QAE@XZ	; CMemTrack::~CMemTrack
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 40	 add	 ecx, 64			; 00000040H
  00048	e8 00 00 00 00	 call	 ??1CPChMap@@QAE@XZ	; CPChMap::~CPChMap
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 08	 add	 ecx, 8
  00053	e8 00 00 00 00	 call	 ??1?$TList@USEQ_PART@@@@QAE@XZ ; TList<SEQ_PART>::~TList<SEQ_PART>
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??1CSeqTrack@@QAE@XZ ENDP				; CSeqTrack::~CSeqTrack
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ ; `string'
PUBLIC	??_C@_0DP@CKCMFCBC@Warning?3?5Request?5to?5query?5unknow@ ; `string'
PUBLIC	_==@8
EXTRN	_IID_IDirectMusicTrack:BYTE
EXTRN	_IID_IDirectMusicTrack8:BYTE
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
EXTRN	_DebugBreak@0:NEAR
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IPersistStream:BYTE
EXTRN	_IsBadReadPtr@8:NEAR
EXTRN	_IsBadWritePtr@8:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'SeqTrack::QueryInterface', 00H		; `CSeqTrack::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ DB '%s: Invalid '
	DB	'pointer ppv', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT
??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ DB '%'
	DB	's: Invalid pointer (void*)&iid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CKCMFCBC@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT
??_C@_0DP@CKCMFCBC@Warning?3?5Request?5to?5query?5unknow@ DB 'Warning: Re'
	DB	'quest to query unknown interface on Sequence Track', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv92 = -4
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CSeqTrack::QueryInterface, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 175  : 	V_INAME(CSeqTrack::QueryInterface);
; 176  : 	V_PTRPTR_WRITE(ppv);

  00004	6a 04		 push	 4
  00006	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L69533
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L69533:

; 177  : 	V_REFGUID(iid);

  0002c	6a 10		 push	 16			; 00000010H
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L69537
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L69537:

; 178  : 
; 179  :    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)

  00054	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00059	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _==@8
  00062	85 c0		 test	 eax, eax
  00064	75 24		 jne	 SHORT $L69540
  00066	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack
  0006b	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _==@8
  00074	85 c0		 test	 eax, eax
  00076	75 12		 jne	 SHORT $L69540
  00078	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack8
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _==@8
  00086	85 c0		 test	 eax, eax
  00088	74 22		 je	 SHORT $L69539
$L69540:

; 180  :     {
; 181  :         *ppv = static_cast<IDirectMusicTrack*>(this);

  0008a	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  0008e	74 0b		 je	 SHORT $L70886
  00090	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00093	83 c2 04	 add	 edx, 4
  00096	89 55 fc	 mov	 DWORD PTR tv92[ebp], edx
  00099	eb 07		 jmp	 SHORT $L70887
$L70886:
  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$L70887:
  000a2	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR tv92[ebp]
  000a8	89 08		 mov	 DWORD PTR [eax], ecx

; 182  :     } else

  000aa	eb 3b		 jmp	 SHORT $L69542
$L69539:

; 183  : 	if (iid == IID_IPersistStream)

  000ac	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  000b1	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 _==@8
  000ba	85 c0		 test	 eax, eax
  000bc	74 0a		 je	 SHORT $L69543

; 184  : 	{
; 185  :         *ppv = static_cast<IPersistStream*>(this);

  000be	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 08		 mov	 DWORD PTR [eax], ecx

; 186  : 	} else

  000c6	eb 1f		 jmp	 SHORT $L69542
$L69543:

; 187  :     {
; 188  :         *ppv = NULL;

  000c8	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  000cb	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 189  :         Trace(4,"Warning: Request to query unknown interface on Sequence Track\n");

  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@CKCMFCBC@Warning?3?5Request?5to?5query?5unknow@
  000d6	6a 04		 push	 4
  000d8	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000dd	83 c4 08	 add	 esp, 8

; 190  :         return E_NOINTERFACE;

  000e0	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  000e5	eb 0e		 jmp	 SHORT $L69529
$L69542:

; 191  :     }
; 192  : 
; 193  :     reinterpret_cast<IUnknown*>(this)->AddRef();

  000e7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ec	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ef	52		 push	 edx
  000f0	ff 51 04	 call	 DWORD PTR [ecx+4]

; 194  :     return S_OK;

  000f3	33 c0		 xor	 eax, eax
$L69529:

; 195  : }

  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z ENDP	; CSeqTrack::QueryInterface
_TEXT	ENDS
PUBLIC	_IsEqualGUID@8
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==@8	PROC NEAR					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     return IsEqualGUID(guidOne,guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IsEqualGUID@8

; 190  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
_==@8	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
_TEXT	ENDS
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\seqtrack.cpp
;	COMDAT ?AddRef@CSeqTrack@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CSeqTrack@@UAGKXZ PROC NEAR			; CSeqTrack::AddRef, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  :     return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 c0 18	 add	 eax, 24			; 00000018H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 205  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?AddRef@CSeqTrack@@UAGKXZ ENDP				; CSeqTrack::AddRef
_TEXT	ENDS
PUBLIC	??_GCSeqTrack@@QAEPAXI@Z			; CSeqTrack::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CSeqTrack@@UAGKXZ
_TEXT	SEGMENT
tv72 = -12
$T70901 = -8
$T70900 = -4
_this$ = 8
?Release@CSeqTrack@@UAGKXZ PROC NEAR			; CSeqTrack::Release, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 214  :     if (!InterlockedDecrement(&m_cRef))

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 c0 18	 add	 eax, 24			; 00000018H
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00012	85 c0		 test	 eax, eax
  00014	75 2c		 jne	 SHORT $L69556

; 215  :     {
; 216  :         delete this;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	89 4d f8	 mov	 DWORD PTR $T70901[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR $T70901[ebp]
  0001f	89 55 fc	 mov	 DWORD PTR $T70900[ebp], edx
  00022	83 7d fc 00	 cmp	 DWORD PTR $T70900[ebp], 0
  00026	74 0f		 je	 SHORT $L70902
  00028	6a 01		 push	 1
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR $T70900[ebp]
  0002d	e8 00 00 00 00	 call	 ??_GCSeqTrack@@QAEPAXI@Z
  00032	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  00035	eb 07		 jmp	 SHORT $L70903
$L70902:
  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L70903:

; 217  :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 06		 jmp	 SHORT $L69555
$L69556:

; 218  :     }
; 219  : 
; 220  :     return m_cRef;

  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
$L69555:

; 221  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?Release@CSeqTrack@@UAGKXZ ENDP				; CSeqTrack::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCSeqTrack@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCSeqTrack@@QAEPAXI@Z PROC NEAR			; CSeqTrack::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSeqTrack@@QAE@XZ	; CSeqTrack::~CSeqTrack
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69562
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69562:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCSeqTrack@@QAEPAXI@Z ENDP				; CSeqTrack::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@ ; `string'
EXTRN	_CLSID_DirectMusicSeqTrack:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z@4QBDB DB 'C'
	DB	'SeqTrack::GetClassID', 00H			; `CSeqTrack::GetClassID'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
CONST	SEGMENT
??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pClassID', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_pClassID$ = 12
?GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z PROC NEAR	; CSeqTrack::GetClassID, COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  : 	V_INAME(CSeqTrack::GetClassID);
; 229  : 	V_PTR_WRITE(pClassID, CLSID); 

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pClassID$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69570
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69570:

; 230  : 	*pClassID = CLSID_DirectMusicSeqTrack;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pClassID$[ebp]
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSeqTrack
  00034	89 11		 mov	 DWORD PTR [ecx], edx
  00036	a1 04 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSeqTrack+4
  0003b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicSeqTrack+8
  00044	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00047	a1 0c 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicSeqTrack+12
  0004c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 231  : 	return S_OK;

  0004f	33 c0		 xor	 eax, eax

; 232  : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?GetClassID@CSeqTrack@@UAGJPAU_GUID@@@Z ENDP		; CSeqTrack::GetClassID
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsDirty@CSeqTrack@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?IsDirty@CSeqTrack@@UAGJXZ PROC NEAR			; CSeqTrack::IsDirty, COMDAT

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 239  : 	return S_FALSE;

  00003	b8 01 00 00 00	 mov	 eax, 1

; 240  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?IsDirty@CSeqTrack@@UAGJXZ ENDP				; CSeqTrack::IsDirty
_TEXT	ENDS
PUBLIC	?LoadSeq@CSeqTrack@@IAEJPAUIStream@@J@Z		; CSeqTrack::LoadSeq
PUBLIC	?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z ; CSeqTrack::FindPart
PUBLIC	??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@ABU_DMUS_IO_SEQ_ITEM@@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>
PUBLIC	??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@ ; `string'
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
;	COMDAT ??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
CONST	SEGMENT
??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@ DB 'Error: Fail'
	DB	'ure reading sequence track.', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadSeq@CSeqTrack@@IAEJPAUIStream@@J@Z
_TEXT	SEGMENT
tv147 = -68
_this$ = -64
$T70916 = -60
_pEvent$69621 = -56
_hr$ = -52
_li$ = -48
_dwSubSize$ = -36
_dwRead$ = -32
_pPart$ = -28
_dwSeek$ = -24
_seqEvent$ = -20
_pIStream$ = 8
_lSize$ = 12
?LoadSeq@CSeqTrack@@IAEJPAUIStream@@J@Z PROC NEAR	; CSeqTrack::LoadSeq, COMDAT
; _this$ = ecx

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 	HRESULT hr = S_OK;

  00009	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 257  : 	TListItem<SEQ_PART>* pPart;
; 258  : 
; 259  : 	ENTER_CRITICAL_SECTION(&m_CrSec);

  00010	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 20	 add	 eax, 32			; 00000020H
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 260  : 
; 261  : 	// copy contents of the stream into the list.
; 262  : 	LARGE_INTEGER li;
; 263  : 	DMUS_IO_SEQ_ITEM seqEvent;
; 264  : 	DWORD dwSubSize;
; 265  : 	// read in the size of the data structures
; 266  : 	if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))

  0001d	6a 00		 push	 0
  0001f	6a 04		 push	 4
  00021	8d 4d dc	 lea	 ecx, DWORD PTR _dwSubSize$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0002d	51		 push	 ecx
  0002e	ff 50 0c	 call	 DWORD PTR [eax+12]
  00031	85 c0		 test	 eax, eax
  00033	7d 1b		 jge	 SHORT $L69590

; 267  : 	{
; 268  :         Trace(1,"Error: Failure reading sequence track.\n");

  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  0003a	6a 01		 push	 1
  0003c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00041	83 c4 08	 add	 esp, 8

; 269  : 		hr = DMUS_E_CANNOTREAD;

  00044	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 270  : 		goto END;

  0004b	e9 51 01 00 00	 jmp	 $END$69593
$L69590:

; 271  : 	}
; 272  : 	lSize -= sizeof(DWORD);

  00050	8b 55 0c	 mov	 edx, DWORD PTR _lSize$[ebp]
  00053	83 ea 04	 sub	 edx, 4
  00056	89 55 0c	 mov	 DWORD PTR _lSize$[ebp], edx

; 273  : 
; 274  : 	DWORD dwRead, dwSeek;
; 275  : 	if( dwSubSize > sizeof(DMUS_IO_SEQ_ITEM) )

  00059	83 7d dc 14	 cmp	 DWORD PTR _dwSubSize$[ebp], 20 ; 00000014H
  0005d	76 1f		 jbe	 SHORT $L69599

; 276  : 	{
; 277  : 		dwRead = sizeof(DMUS_IO_SEQ_ITEM);

  0005f	c7 45 e0 14 00
	00 00		 mov	 DWORD PTR _dwRead$[ebp], 20 ; 00000014H

; 278  : 		dwSeek = dwSubSize - dwRead;

  00066	8b 45 dc	 mov	 eax, DWORD PTR _dwSubSize$[ebp]
  00069	2b 45 e0	 sub	 eax, DWORD PTR _dwRead$[ebp]
  0006c	89 45 e8	 mov	 DWORD PTR _dwSeek$[ebp], eax

; 279  : 		li.HighPart = 0;

  0006f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 280  : 		li.LowPart = dwSeek;

  00076	8b 4d e8	 mov	 ecx, DWORD PTR _dwSeek$[ebp]
  00079	89 4d d0	 mov	 DWORD PTR _li$[ebp], ecx

; 281  : 	}
; 282  : 	else

  0007c	eb 2e		 jmp	 SHORT $L69601
$L69599:

; 283  : 	{
; 284  : 		if( dwSubSize == 0 )

  0007e	83 7d dc 00	 cmp	 DWORD PTR _dwSubSize$[ebp], 0
  00082	75 1b		 jne	 SHORT $L69602

; 285  : 		{
; 286  :             Trace(1,"Error: Failure reading sequence track.\n");

  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00090	83 c4 08	 add	 esp, 8

; 287  : 			hr = DMUS_E_CHUNKNOTFOUND;

  00093	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 288  : 			goto END;

  0009a	e9 02 01 00 00	 jmp	 $END$69593
$L69602:

; 289  : 		}
; 290  : 		dwRead = dwSubSize;

  0009f	8b 55 dc	 mov	 edx, DWORD PTR _dwSubSize$[ebp]
  000a2	89 55 e0	 mov	 DWORD PTR _dwRead$[ebp], edx

; 291  : 		dwSeek = 0;

  000a5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dwSeek$[ebp], 0
$L69601:

; 292  : 	}
; 293  : 	if( 0 == dwRead )

  000ac	83 7d e0 00	 cmp	 DWORD PTR _dwRead$[ebp], 0
  000b0	75 0c		 jne	 SHORT $L69609

; 294  : 	{
; 295  : 		hr = DMUS_E_CANNOTREAD;

  000b2	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 296  : 		goto END;

  000b9	e9 e3 00 00 00	 jmp	 $END$69593
$L69609:

; 297  : 	}
; 298  : 	while( lSize > 0 )

  000be	83 7d 0c 00	 cmp	 DWORD PTR _lSize$[ebp], 0
  000c2	0f 8e d9 00 00
	00		 jle	 $END$69593

; 299  : 	{
; 300  : 		if( FAILED( pIStream->Read( &seqEvent, dwRead, NULL )))

  000c8	6a 00		 push	 0
  000ca	8b 45 e0	 mov	 eax, DWORD PTR _dwRead$[ebp]
  000cd	50		 push	 eax
  000ce	8d 4d ec	 lea	 ecx, DWORD PTR _seqEvent$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  000d5	8b 02		 mov	 eax, DWORD PTR [edx]
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  000da	51		 push	 ecx
  000db	ff 50 0c	 call	 DWORD PTR [eax+12]
  000de	85 c0		 test	 eax, eax
  000e0	7d 1b		 jge	 SHORT $L69612

; 301  : 		{
; 302  :             Trace(1,"Error: Failure reading sequence track.\n");

  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  000e7	6a 01		 push	 1
  000e9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ee	83 c4 08	 add	 esp, 8

; 303  : 			hr = DMUS_E_CANNOTREAD;

  000f1	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 304  : 			goto END;

  000f8	e9 a4 00 00 00	 jmp	 $END$69593
$L69612:

; 305  : 		}
; 306  : 		lSize -= dwRead;

  000fd	8b 55 0c	 mov	 edx, DWORD PTR _lSize$[ebp]
  00100	2b 55 e0	 sub	 edx, DWORD PTR _dwRead$[ebp]
  00103	89 55 0c	 mov	 DWORD PTR _lSize$[ebp], edx

; 307  : 		if( dwSeek )

  00106	83 7d e8 00	 cmp	 DWORD PTR _dwSeek$[ebp], 0
  0010a	74 2e		 je	 SHORT $L69615

; 308  : 		{
; 309  : 			if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))

  0010c	6a 00		 push	 0
  0010e	6a 01		 push	 1
  00110	8b 45 d4	 mov	 eax, DWORD PTR _li$[ebp+4]
  00113	50		 push	 eax
  00114	8b 4d d0	 mov	 ecx, DWORD PTR _li$[ebp]
  00117	51		 push	 ecx
  00118	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  0011b	8b 02		 mov	 eax, DWORD PTR [edx]
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00120	51		 push	 ecx
  00121	ff 50 14	 call	 DWORD PTR [eax+20]
  00124	85 c0		 test	 eax, eax
  00126	7d 09		 jge	 SHORT $L69617

; 310  : 			{
; 311  : 				hr = DMUS_E_CANNOTSEEK;

  00128	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 312  : 				goto END;

  0012f	eb 70		 jmp	 SHORT $END$69593
$L69617:

; 313  : 			}
; 314  : 			lSize -= dwSeek;

  00131	8b 55 0c	 mov	 edx, DWORD PTR _lSize$[ebp]
  00134	2b 55 e8	 sub	 edx, DWORD PTR _dwSeek$[ebp]
  00137	89 55 0c	 mov	 DWORD PTR _lSize$[ebp], edx
$L69615:

; 315  : 		}
; 316  : 		pPart = FindPart(seqEvent.dwPChannel);

  0013a	8b 45 f4	 mov	 eax, DWORD PTR _seqEvent$[ebp+8]
  0013d	50		 push	 eax
  0013e	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z ; CSeqTrack::FindPart
  00146	89 45 e4	 mov	 DWORD PTR _pPart$[ebp], eax

; 317  : 		if( pPart )

  00149	83 7d e4 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  0014d	74 4d		 je	 SHORT $L69620

; 318  : 		{
; 319  : 			TListItem<DMUS_IO_SEQ_ITEM>* pEvent = new TListItem<DMUS_IO_SEQ_ITEM>(seqEvent);

  0014f	6a 18		 push	 24			; 00000018H
  00151	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00156	83 c4 04	 add	 esp, 4
  00159	89 45 c4	 mov	 DWORD PTR $T70916[ebp], eax
  0015c	83 7d c4 00	 cmp	 DWORD PTR $T70916[ebp], 0
  00160	74 11		 je	 SHORT $L70917
  00162	8d 4d ec	 lea	 ecx, DWORD PTR _seqEvent$[ebp]
  00165	51		 push	 ecx
  00166	8b 4d c4	 mov	 ecx, DWORD PTR $T70916[ebp]
  00169	e8 00 00 00 00	 call	 ??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@ABU_DMUS_IO_SEQ_ITEM@@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>
  0016e	89 45 bc	 mov	 DWORD PTR tv147[ebp], eax
  00171	eb 07		 jmp	 SHORT $L70918
$L70917:
  00173	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
$L70918:
  0017a	8b 55 bc	 mov	 edx, DWORD PTR tv147[ebp]
  0017d	89 55 c8	 mov	 DWORD PTR _pEvent$69621[ebp], edx

; 320  : 			if( pEvent )

  00180	83 7d c8 00	 cmp	 DWORD PTR _pEvent$69621[ebp], 0
  00184	74 16		 je	 SHORT $L69620

; 321  : 			{
; 322  : 				pPart->GetItemValue().seqList.AddHead(pEvent); // AddTail can get

  00186	8b 45 c8	 mov	 eax, DWORD PTR _pEvent$69621[ebp]
  00189	50		 push	 eax
  0018a	8b 4d e4	 mov	 ecx, DWORD PTR _pPart$[ebp]
  0018d	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00192	83 c0 08	 add	 eax, 8
  00195	8b c8		 mov	 ecx, eax
  00197	e8 00 00 00 00	 call	 ?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z ; TList<_DMUS_IO_SEQ_ITEM>::AddHead
$L69620:

; 323  : 															// expensive (n pow 2) so
; 324  : 															// AddHead instead and reverse later.
; 325  : 			}
; 326  : 		}
; 327  : 	}

  0019c	e9 1d ff ff ff	 jmp	 $L69609
$END$69593:

; 328  : END:
; 329  : 	for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )

  001a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	83 c1 08	 add	 ecx, 8
  001a7	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  001ac	89 45 e4	 mov	 DWORD PTR _pPart$[ebp], eax
  001af	eb 0b		 jmp	 SHORT $L69625
$L69626:
  001b1	8b 4d e4	 mov	 ecx, DWORD PTR _pPart$[ebp]
  001b4	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  001b9	89 45 e4	 mov	 DWORD PTR _pPart$[ebp], eax
$L69625:
  001bc	83 7d e4 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  001c0	74 14		 je	 SHORT $L69627

; 330  : 	{
; 331  : 		pPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier

  001c2	8b 4d e4	 mov	 ecx, DWORD PTR _pPart$[ebp]
  001c5	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  001ca	83 c0 08	 add	 eax, 8
  001cd	8b c8		 mov	 ecx, eax
  001cf	e8 00 00 00 00	 call	 ?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ ; TList<_DMUS_IO_SEQ_ITEM>::Reverse

; 332  : 	}

  001d4	eb db		 jmp	 SHORT $L69626
$L69627:

; 333  : 	m_dwValidate++; // used to validate state data that's out there

  001d6	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  001dc	83 c2 01	 add	 edx, 1
  001df	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 334  : 	LEAVE_CRITICAL_SECTION(&m_CrSec);

  001e5	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	83 c1 20	 add	 ecx, 32			; 00000020H
  001eb	51		 push	 ecx
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 335  : 	return hr;

  001f2	8b 45 cc	 mov	 eax, DWORD PTR _hr$[ebp]

; 336  : }

  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c2 08 00	 ret	 8
?LoadSeq@CSeqTrack@@IAEJPAUIStream@@J@Z ENDP		; CSeqTrack::LoadSeq
_TEXT	ENDS
PUBLIC	??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@ ; `string'
PUBLIC	?LoadCurve@CSeqTrack@@IAEJPAUIStream@@J@Z	; CSeqTrack::LoadCurve
PUBLIC	??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@ABU_DMUS_IO_CURVE_ITEM@@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>
;	COMDAT ??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@
CONST	SEGMENT
??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@ DB 'Error: Fail'
	DB	'ure reading sequence track - bad data.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadCurve@CSeqTrack@@IAEJPAUIStream@@J@Z
_TEXT	SEGMENT
tv147 = -80
_this$ = -76
$T70922 = -72
_pEvent$69668 = -68
_hr$ = -64
_dwSubSize$ = -60
_li$ = -56
_dwRead$ = -44
_pPart$ = -40
_dwSeek$ = -36
_curveEvent$ = -32
_pIStream$ = 8
_lSize$ = 12
?LoadCurve@CSeqTrack@@IAEJPAUIStream@@J@Z PROC NEAR	; CSeqTrack::LoadCurve, COMDAT
; _this$ = ecx

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 352  : 	HRESULT hr = S_OK;

  00009	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 353  : 	TListItem<SEQ_PART>* pPart;
; 354  : 
; 355  : 	ENTER_CRITICAL_SECTION(&m_CrSec);

  00010	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 20	 add	 eax, 32			; 00000020H
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 356  : 
; 357  : 	DWORD dwSubSize;
; 358  : 	// copy contents of the stream into the list.
; 359  : 	LARGE_INTEGER li;
; 360  : 	DMUS_IO_CURVE_ITEM curveEvent;
; 361  : 	// read in the size of the data structures
; 362  : 	if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))

  0001d	6a 00		 push	 0
  0001f	6a 04		 push	 4
  00021	8d 4d c4	 lea	 ecx, DWORD PTR _dwSubSize$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0002d	51		 push	 ecx
  0002e	ff 50 0c	 call	 DWORD PTR [eax+12]
  00031	85 c0		 test	 eax, eax
  00033	7d 1b		 jge	 SHORT $L69641

; 363  : 	{
; 364  :         Trace(1,"Error: Failure reading sequence track.\n");

  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  0003a	6a 01		 push	 1
  0003c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00041	83 c4 08	 add	 esp, 8

; 365  : 		hr = DMUS_E_CANNOTREAD;

  00044	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 366  : 		goto END;

  0004b	e9 59 01 00 00	 jmp	 $END$69643
$L69641:

; 367  : 	}
; 368  : 	lSize -= sizeof(DWORD);

  00050	8b 55 0c	 mov	 edx, DWORD PTR _lSize$[ebp]
  00053	83 ea 04	 sub	 edx, 4
  00056	89 55 0c	 mov	 DWORD PTR _lSize$[ebp], edx

; 369  : 
; 370  : 	DWORD dwRead, dwSeek;
; 371  : 	if( dwSubSize > sizeof(DMUS_IO_CURVE_ITEM) )

  00059	83 7d c4 20	 cmp	 DWORD PTR _dwSubSize$[ebp], 32 ; 00000020H
  0005d	76 1f		 jbe	 SHORT $L69649

; 372  : 	{
; 373  : 		dwRead = sizeof(DMUS_IO_CURVE_ITEM);

  0005f	c7 45 d4 20 00
	00 00		 mov	 DWORD PTR _dwRead$[ebp], 32 ; 00000020H

; 374  : 		dwSeek = dwSubSize - dwRead;

  00066	8b 45 c4	 mov	 eax, DWORD PTR _dwSubSize$[ebp]
  00069	2b 45 d4	 sub	 eax, DWORD PTR _dwRead$[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR _dwSeek$[ebp], eax

; 375  : 		li.HighPart = 0;

  0006f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 376  : 		li.LowPart = dwSeek;

  00076	8b 4d dc	 mov	 ecx, DWORD PTR _dwSeek$[ebp]
  00079	89 4d c8	 mov	 DWORD PTR _li$[ebp], ecx

; 377  : 	}
; 378  : 	else

  0007c	eb 2e		 jmp	 SHORT $L69651
$L69649:

; 379  : 	{
; 380  : 		if( dwSubSize == 0 )

  0007e	83 7d c4 00	 cmp	 DWORD PTR _dwSubSize$[ebp], 0
  00082	75 1b		 jne	 SHORT $L69652

; 381  : 		{
; 382  :             Trace(1,"Error: Failure reading sequence track - bad data.\n");

  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00090	83 c4 08	 add	 esp, 8

; 383  : 			hr = DMUS_E_CHUNKNOTFOUND;

  00093	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 384  : 			goto END;

  0009a	e9 0a 01 00 00	 jmp	 $END$69643
$L69652:

; 385  : 		}
; 386  : 		dwRead = dwSubSize;

  0009f	8b 55 c4	 mov	 edx, DWORD PTR _dwSubSize$[ebp]
  000a2	89 55 d4	 mov	 DWORD PTR _dwRead$[ebp], edx

; 387  : 		dwSeek = 0;

  000a5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwSeek$[ebp], 0
$L69651:

; 388  : 	}
; 389  : 	if( 0 == dwRead )

  000ac	83 7d d4 00	 cmp	 DWORD PTR _dwRead$[ebp], 0
  000b0	75 1b		 jne	 SHORT $L69660

; 390  : 	{
; 391  :         Trace(1,"Error: Failure reading sequence track - bad data.\n");

  000b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@
  000b7	6a 01		 push	 1
  000b9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000be	83 c4 08	 add	 esp, 8

; 392  : 		hr = DMUS_E_CANNOTREAD;

  000c1	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 393  : 		goto END;

  000c8	e9 dc 00 00 00	 jmp	 $END$69643
$L69660:

; 394  : 	}
; 395  : 	while( lSize > 0 )

  000cd	83 7d 0c 00	 cmp	 DWORD PTR _lSize$[ebp], 0
  000d1	0f 8e d2 00 00
	00		 jle	 $END$69643

; 396  : 	{
; 397  :         curveEvent.wMergeIndex = 0; // Older format doesn't support this.

  000d7	66 c7 45 fe 00
	00		 mov	 WORD PTR _curveEvent$[ebp+30], 0

; 398  : 		if( FAILED( pIStream->Read( &curveEvent, dwRead, NULL )))

  000dd	6a 00		 push	 0
  000df	8b 45 d4	 mov	 eax, DWORD PTR _dwRead$[ebp]
  000e2	50		 push	 eax
  000e3	8d 4d e0	 lea	 ecx, DWORD PTR _curveEvent$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  000ea	8b 02		 mov	 eax, DWORD PTR [edx]
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  000ef	51		 push	 ecx
  000f0	ff 50 0c	 call	 DWORD PTR [eax+12]
  000f3	85 c0		 test	 eax, eax
  000f5	7d 0c		 jge	 SHORT $L69663

; 399  : 		{
; 400  : 			hr = DMUS_E_CANNOTREAD;

  000f7	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 401  : 			break;

  000fe	e9 a6 00 00 00	 jmp	 $END$69643
$L69663:

; 402  : 		}
; 403  :         // Sometimes, we get a pitch bend in a file that has bogus data in wParamType, which will
; 404  :         // cause pitch bend range to be set incorrectly.
; 405  :         if (curveEvent.bType == DMUS_CURVET_PBCURVE)

  00103	0f b6 55 f8	 movzx	 edx, BYTE PTR _curveEvent$[ebp+24]
  00107	83 fa 03	 cmp	 edx, 3
  0010a	75 06		 jne	 SHORT $L69665

; 406  :         {
; 407  :             curveEvent.wParamType = 0;

  0010c	66 c7 45 fc 00
	00		 mov	 WORD PTR _curveEvent$[ebp+28], 0
$L69665:

; 408  :         }
; 409  : 		lSize -= dwRead;

  00112	8b 45 0c	 mov	 eax, DWORD PTR _lSize$[ebp]
  00115	2b 45 d4	 sub	 eax, DWORD PTR _dwRead$[ebp]
  00118	89 45 0c	 mov	 DWORD PTR _lSize$[ebp], eax

; 410  : 		if( dwSeek )

  0011b	83 7d dc 00	 cmp	 DWORD PTR _dwSeek$[ebp], 0
  0011f	74 21		 je	 SHORT $L69666

; 411  : 		{
; 412  : 			pIStream->Seek( li, STREAM_SEEK_CUR, NULL );

  00121	6a 00		 push	 0
  00123	6a 01		 push	 1
  00125	8b 4d cc	 mov	 ecx, DWORD PTR _li$[ebp+4]
  00128	51		 push	 ecx
  00129	8b 55 c8	 mov	 edx, DWORD PTR _li$[ebp]
  0012c	52		 push	 edx
  0012d	8b 45 08	 mov	 eax, DWORD PTR _pIStream$[ebp]
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00135	52		 push	 edx
  00136	ff 51 14	 call	 DWORD PTR [ecx+20]

; 413  : 			lSize -= dwSeek;

  00139	8b 45 0c	 mov	 eax, DWORD PTR _lSize$[ebp]
  0013c	2b 45 dc	 sub	 eax, DWORD PTR _dwSeek$[ebp]
  0013f	89 45 0c	 mov	 DWORD PTR _lSize$[ebp], eax
$L69666:

; 414  : 		}
; 415  : 		pPart = FindPart(curveEvent.dwPChannel);

  00142	8b 4d ec	 mov	 ecx, DWORD PTR _curveEvent$[ebp+12]
  00145	51		 push	 ecx
  00146	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	e8 00 00 00 00	 call	 ?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z ; CSeqTrack::FindPart
  0014e	89 45 d8	 mov	 DWORD PTR _pPart$[ebp], eax

; 416  : 		if( pPart )

  00151	83 7d d8 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  00155	74 4d		 je	 SHORT $L69667

; 417  : 		{
; 418  : 			TListItem<DMUS_IO_CURVE_ITEM>* pEvent = new TListItem<DMUS_IO_CURVE_ITEM>(curveEvent);

  00157	6a 24		 push	 36			; 00000024H
  00159	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0015e	83 c4 04	 add	 esp, 4
  00161	89 45 b8	 mov	 DWORD PTR $T70922[ebp], eax
  00164	83 7d b8 00	 cmp	 DWORD PTR $T70922[ebp], 0
  00168	74 11		 je	 SHORT $L70923
  0016a	8d 55 e0	 lea	 edx, DWORD PTR _curveEvent$[ebp]
  0016d	52		 push	 edx
  0016e	8b 4d b8	 mov	 ecx, DWORD PTR $T70922[ebp]
  00171	e8 00 00 00 00	 call	 ??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@ABU_DMUS_IO_CURVE_ITEM@@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>
  00176	89 45 b0	 mov	 DWORD PTR tv147[ebp], eax
  00179	eb 07		 jmp	 SHORT $L70924
$L70923:
  0017b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
$L70924:
  00182	8b 45 b0	 mov	 eax, DWORD PTR tv147[ebp]
  00185	89 45 bc	 mov	 DWORD PTR _pEvent$69668[ebp], eax

; 419  : 			if( pEvent )

  00188	83 7d bc 00	 cmp	 DWORD PTR _pEvent$69668[ebp], 0
  0018c	74 16		 je	 SHORT $L69667

; 420  : 			{
; 421  : 				pPart->GetItemValue().curveList.AddHead(pEvent); // AddTail can get

  0018e	8b 4d bc	 mov	 ecx, DWORD PTR _pEvent$69668[ebp]
  00191	51		 push	 ecx
  00192	8b 4d d8	 mov	 ecx, DWORD PTR _pPart$[ebp]
  00195	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  0019a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0019d	8b c8		 mov	 ecx, eax
  0019f	e8 00 00 00 00	 call	 ?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z ; TList<_DMUS_IO_CURVE_ITEM>::AddHead
$L69667:

; 422  : 															// expensive (n pow 2) so
; 423  : 															// AddHead instead and reverse later.
; 424  : 			}
; 425  : 		}
; 426  : 	}

  001a4	e9 24 ff ff ff	 jmp	 $L69660
$END$69643:

; 427  : END:
; 428  : 	for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )

  001a9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	83 c1 08	 add	 ecx, 8
  001af	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  001b4	89 45 d8	 mov	 DWORD PTR _pPart$[ebp], eax
  001b7	eb 0b		 jmp	 SHORT $L69672
$L69673:
  001b9	8b 4d d8	 mov	 ecx, DWORD PTR _pPart$[ebp]
  001bc	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  001c1	89 45 d8	 mov	 DWORD PTR _pPart$[ebp], eax
$L69672:
  001c4	83 7d d8 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  001c8	74 14		 je	 SHORT $L69674

; 429  : 	{
; 430  : 		pPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier

  001ca	8b 4d d8	 mov	 ecx, DWORD PTR _pPart$[ebp]
  001cd	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  001d2	83 c0 0c	 add	 eax, 12			; 0000000cH
  001d5	8b c8		 mov	 ecx, eax
  001d7	e8 00 00 00 00	 call	 ?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ ; TList<_DMUS_IO_CURVE_ITEM>::Reverse

; 431  : 	}

  001dc	eb db		 jmp	 SHORT $L69673
$L69674:

; 432  : 	m_dwValidate++; // used to validate state data that's out there

  001de	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  001e1	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001e4	83 c0 01	 add	 eax, 1
  001e7	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ea	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 433  : 	LEAVE_CRITICAL_SECTION(&m_CrSec);

  001ed	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  001f0	83 c2 20	 add	 edx, 32			; 00000020H
  001f3	52		 push	 edx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 434  : 	return hr;

  001fa	8b 45 c0	 mov	 eax, DWORD PTR _hr$[ebp]

; 435  : }

  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c2 08 00	 ret	 8
?LoadCurve@CSeqTrack@@IAEJPAUIStream@@J@Z ENDP		; CSeqTrack::LoadCurve
_TEXT	ENDS
PUBLIC	??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@ ; `string'
EXTRN	_IsBadCodePtr@4:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??Load@CSeqTrack@@UAGJPAUIStream@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Load@CSeqTrack@@UAGJPAUIStream@@@Z@4QBDB DB 'C'
	DB	'SeqTrack::Load', 00H			; `CSeqTrack::Load'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
CONST	SEGMENT
??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pIStream', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CSeqTrack@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT
tv174 = -36
_li$69765 = -32
_dwSubSize$69718 = -20
_dwSubChunk$69717 = -16
_hr$ = -12
_lSize$ = -8
_dwChunk$ = -4
_this$ = 8
_pIStream$ = 12
?Load@CSeqTrack@@UAGJPAUIStream@@@Z PROC NEAR		; CSeqTrack::Load, COMDAT

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 439  : 	V_INAME(CSeqTrack::Load);
; 440  : 	V_INTERFACE(pIStream);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69682
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CSeqTrack@@UAGJPAUIStream@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69682:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L69685
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CSeqTrack@@UAGJPAUIStream@@@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L69685:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L69687
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CSeqTrack@@UAGJPAUIStream@@@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L69687:

; 441  : 	HRESULT hr = S_OK;

  00082	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 442  : 
; 443  : 	ENTER_CRITICAL_SECTION(&m_CrSec);

  00089	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	83 c0 20	 add	 eax, 32			; 00000020H
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 444  : 	m_dwValidate++; // used to validate state data that's out there

  00096	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0009c	83 c2 01	 add	 edx, 1
  0009f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 445  : 	DeleteSeqPartList();

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?DeleteSeqPartList@CSeqTrack@@IAEXXZ ; CSeqTrack::DeleteSeqPartList

; 446  : 	LEAVE_CRITICAL_SECTION(&m_CrSec);

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	83 c1 20	 add	 ecx, 32			; 00000020H
  000b3	51		 push	 ecx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 447  : 
; 448  : 	// read in the chunk id
; 449  : 	long lSize;
; 450  : 	DWORD dwChunk;
; 451  : 	if( FAILED( pIStream->Read( &dwChunk, sizeof(DWORD), NULL )))

  000ba	6a 00		 push	 0
  000bc	6a 04		 push	 4
  000be	8d 55 fc	 lea	 edx, DWORD PTR _dwChunk$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  000c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c7	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  000ca	52		 push	 edx
  000cb	ff 51 0c	 call	 DWORD PTR [ecx+12]
  000ce	85 c0		 test	 eax, eax
  000d0	7d 1b		 jge	 SHORT $L69694

; 452  : 	{
; 453  :         Trace(1,"Error: Failure reading sequence track.\n");

  000d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  000d7	6a 01		 push	 1
  000d9	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000de	83 c4 08	 add	 esp, 8

; 454  : 		hr = DMUS_E_CANNOTREAD;

  000e1	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 455  : 		goto END;

  000e8	e9 87 01 00 00	 jmp	 $END$69696
$L69694:

; 456  : 	}
; 457  : 	if( dwChunk != DMUS_FOURCC_SEQ_TRACK )

  000ed	81 7d fc 73 65
	71 74		 cmp	 DWORD PTR _dwChunk$[ebp], 1953588595 ; 74716573H
  000f4	74 1b		 je	 SHORT $L69706

; 458  : 	{
; 459  :         Trace(1,"Error: Failure reading sequence track - bad data.\n");

  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@
  000fb	6a 01		 push	 1
  000fd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00102	83 c4 08	 add	 esp, 8

; 460  : 		hr = DMUS_E_CHUNKNOTFOUND;

  00105	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 461  : 		goto END;

  0010c	e9 63 01 00 00	 jmp	 $END$69696
$L69706:

; 462  : 	}
; 463  : 	// read in the overall size
; 464  : 	if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))

  00111	6a 00		 push	 0
  00113	6a 04		 push	 4
  00115	8d 45 f8	 lea	 eax, DWORD PTR _lSize$[ebp]
  00118	50		 push	 eax
  00119	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  00121	50		 push	 eax
  00122	ff 52 0c	 call	 DWORD PTR [edx+12]
  00125	85 c0		 test	 eax, eax
  00127	7d 0c		 jge	 SHORT $L69715

; 465  : 	{
; 466  : 		hr = DMUS_E_CANNOTREAD;

  00129	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 467  : 		goto END;

  00130	e9 3f 01 00 00	 jmp	 $END$69696
$L69715:

; 468  : 	}
; 469  : 	while( lSize )

  00135	83 7d f8 00	 cmp	 DWORD PTR _lSize$[ebp], 0
  00139	0f 84 35 01 00
	00		 je	 $END$69696

; 470  : 	{
; 471  : 		DWORD dwSubChunk, dwSubSize;
; 472  : 		if( FAILED( pIStream->Read( &dwSubChunk, sizeof(DWORD), NULL )))

  0013f	6a 00		 push	 0
  00141	6a 04		 push	 4
  00143	8d 4d f0	 lea	 ecx, DWORD PTR _dwSubChunk$69717[ebp]
  00146	51		 push	 ecx
  00147	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  0014a	8b 02		 mov	 eax, DWORD PTR [edx]
  0014c	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0014f	51		 push	 ecx
  00150	ff 50 0c	 call	 DWORD PTR [eax+12]
  00153	85 c0		 test	 eax, eax
  00155	7d 1b		 jge	 SHORT $L69721

; 473  : 		{
; 474  :             Trace(1,"Error: Failure reading sequence track.\n");

  00157	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  0015c	6a 01		 push	 1
  0015e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00163	83 c4 08	 add	 esp, 8

; 475  : 			hr = DMUS_E_CANNOTREAD;

  00166	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 476  : 			goto END;

  0016d	e9 02 01 00 00	 jmp	 $END$69696
$L69721:

; 477  : 		}
; 478  : 		lSize -= sizeof(DWORD);

  00172	8b 55 f8	 mov	 edx, DWORD PTR _lSize$[ebp]
  00175	83 ea 04	 sub	 edx, 4
  00178	89 55 f8	 mov	 DWORD PTR _lSize$[ebp], edx

; 479  : 		// read in the overall size
; 480  : 		if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))

  0017b	6a 00		 push	 0
  0017d	6a 04		 push	 4
  0017f	8d 45 ec	 lea	 eax, DWORD PTR _dwSubSize$69718[ebp]
  00182	50		 push	 eax
  00183	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00186	8b 11		 mov	 edx, DWORD PTR [ecx]
  00188	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0018b	50		 push	 eax
  0018c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0018f	85 c0		 test	 eax, eax
  00191	7d 1b		 jge	 SHORT $L69727

; 481  : 		{
; 482  :             Trace(1,"Error: Failure reading sequence track.\n");

  00193	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@PBKFOMHB@Error?3?5Failure?5reading?5sequence?5@
  00198	6a 01		 push	 1
  0019a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0019f	83 c4 08	 add	 esp, 8

; 483  : 			hr = DMUS_E_CANNOTREAD;

  001a2	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 484  : 			goto END;

  001a9	e9 c6 00 00 00	 jmp	 $END$69696
$L69727:

; 485  : 		}
; 486  : 		if( (dwSubSize == 0) || (dwSubSize > (DWORD)lSize) )

  001ae	83 7d ec 00	 cmp	 DWORD PTR _dwSubSize$69718[ebp], 0
  001b2	74 08		 je	 SHORT $L69732
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _dwSubSize$69718[ebp]
  001b7	3b 4d f8	 cmp	 ecx, DWORD PTR _lSize$[ebp]
  001ba	76 1b		 jbe	 SHORT $L69731
$L69732:

; 487  : 		{
; 488  :             Trace(1,"Error: Failure reading sequence track - bad data.\n");

  001bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@KHOGGDCH@Error?3?5Failure?5reading?5sequence?5@
  001c1	6a 01		 push	 1
  001c3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001c8	83 c4 08	 add	 esp, 8

; 489  : 			hr = DMUS_E_CHUNKNOTFOUND;

  001cb	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 490  : 			goto END;

  001d2	e9 9d 00 00 00	 jmp	 $END$69696
$L69731:

; 491  : 		}
; 492  : 		lSize -= sizeof(DWORD);

  001d7	8b 55 f8	 mov	 edx, DWORD PTR _lSize$[ebp]
  001da	83 ea 04	 sub	 edx, 4
  001dd	89 55 f8	 mov	 DWORD PTR _lSize$[ebp], edx

; 493  : 		switch( dwSubChunk )
; 494  : 		{

  001e0	8b 45 f0	 mov	 eax, DWORD PTR _dwSubChunk$69717[ebp]
  001e3	89 45 dc	 mov	 DWORD PTR tv174[ebp], eax
  001e6	81 7d dc 63 75
	72 6c		 cmp	 DWORD PTR tv174[ebp], 1819440483 ; 6c727563H
  001ed	74 28		 je	 SHORT $L69760
  001ef	81 7d dc 65 76
	74 6c		 cmp	 DWORD PTR tv174[ebp], 1819571813 ; 6c747665H
  001f6	74 02		 je	 SHORT $L69748
  001f8	eb 3a		 jmp	 SHORT $L69764
$L69748:

; 495  : 		case DMUS_FOURCC_SEQ_LIST:
; 496  : 			if( FAILED( hr = LoadSeq( pIStream, dwSubSize )))

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR _dwSubSize$69718[ebp]
  001fd	51		 push	 ecx
  001fe	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00201	52		 push	 edx
  00202	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	e8 00 00 00 00	 call	 ?LoadSeq@CSeqTrack@@IAEJPAUIStream@@J@Z ; CSeqTrack::LoadSeq
  0020a	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
  0020d	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00211	7d 02		 jge	 SHORT $L69750

; 497  : 			{
; 498  : 				goto END;

  00213	eb 5f		 jmp	 SHORT $END$69696
$L69750:

; 499  : 			}
; 500  : 			break;

  00215	eb 4f		 jmp	 SHORT $L69737
$L69760:

; 501  : 		case DMUS_FOURCC_CURVE_LIST:
; 502  : 			if( FAILED( hr = LoadCurve( pIStream, dwSubSize )))

  00217	8b 45 ec	 mov	 eax, DWORD PTR _dwSubSize$69718[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  0021e	51		 push	 ecx
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00222	e8 00 00 00 00	 call	 ?LoadCurve@CSeqTrack@@IAEJPAUIStream@@J@Z ; CSeqTrack::LoadCurve
  00227	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
  0022a	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0022e	7d 02		 jge	 SHORT $L69762

; 503  : 			{
; 504  : 				goto END;

  00230	eb 42		 jmp	 SHORT $END$69696
$L69762:

; 505  : 			}
; 506  : 			break;

  00232	eb 32		 jmp	 SHORT $L69737
$L69764:

; 507  : 		default:
; 508  : 			LARGE_INTEGER li;
; 509  : 			li.HighPart = 0;

  00234	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _li$69765[ebp+4], 0

; 510  : 			li.LowPart = dwSubSize;

  0023b	8b 55 ec	 mov	 edx, DWORD PTR _dwSubSize$69718[ebp]
  0023e	89 55 e0	 mov	 DWORD PTR _li$69765[ebp], edx

; 511  : 			if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))

  00241	6a 00		 push	 0
  00243	6a 01		 push	 1
  00245	8b 45 e4	 mov	 eax, DWORD PTR _li$69765[ebp+4]
  00248	50		 push	 eax
  00249	8b 4d e0	 mov	 ecx, DWORD PTR _li$69765[ebp]
  0024c	51		 push	 ecx
  0024d	8b 55 0c	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00250	8b 02		 mov	 eax, DWORD PTR [edx]
  00252	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00255	51		 push	 ecx
  00256	ff 50 14	 call	 DWORD PTR [eax+20]
  00259	85 c0		 test	 eax, eax
  0025b	7d 09		 jge	 SHORT $L69737

; 512  : 			{
; 513  : 				hr = DMUS_E_CANNOTREAD;

  0025d	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 514  : 				goto END;

  00264	eb 0e		 jmp	 SHORT $END$69696
$L69737:

; 515  : 			}
; 516  : 			break;
; 517  : 		}
; 518  : 		lSize -= dwSubSize;

  00266	8b 55 f8	 mov	 edx, DWORD PTR _lSize$[ebp]
  00269	2b 55 ec	 sub	 edx, DWORD PTR _dwSubSize$69718[ebp]
  0026c	89 55 f8	 mov	 DWORD PTR _lSize$[ebp], edx

; 519  : 	}

  0026f	e9 c1 fe ff ff	 jmp	 $L69715
$END$69696:

; 520  : END:
; 521  : 	return hr;

  00274	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 522  : }

  00277	8b e5		 mov	 esp, ebp
  00279	5d		 pop	 ebp
  0027a	c2 08 00	 ret	 8
?Load@CSeqTrack@@UAGJPAUIStream@@@Z ENDP		; CSeqTrack::Load
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Save@CSeqTrack@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT
_this$ = 8
_pIStream$ = 12
_fClearDirty$ = 16
?Save@CSeqTrack@@UAGJPAUIStream@@H@Z PROC NEAR		; CSeqTrack::Save, COMDAT

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 526  : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 527  : }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?Save@CSeqTrack@@UAGJPAUIStream@@H@Z ENDP		; CSeqTrack::Save
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSizeMax@CSeqTrack@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_this$ = 8
_pcbSize$ = 12
?GetSizeMax@CSeqTrack@@UAGJPAT_ULARGE_INTEGER@@@Z PROC NEAR ; CSeqTrack::GetSizeMax, COMDAT

; 530  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 531  : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 532  : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?GetSizeMax@CSeqTrack@@UAGJPAT_ULARGE_INTEGER@@@Z ENDP	; CSeqTrack::GetSizeMax
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsParamSupported@CSeqTrack@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_rguidType$ = 12
?IsParamSupported@CSeqTrack@@UAGJABU_GUID@@@Z PROC NEAR	; CSeqTrack::IsParamSupported, COMDAT

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 549  : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 550  : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?IsParamSupported@CSeqTrack@@UAGJABU_GUID@@@Z ENDP	; CSeqTrack::IsParamSupported
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Init@CSeqTrack@@UAGJPAUIDirectMusicSegment@@@Z
_TEXT	SEGMENT
_this$ = 8
_pSegment$ = 12
?Init@CSeqTrack@@UAGJPAUIDirectMusicSegment@@@Z PROC NEAR ; CSeqTrack::Init, COMDAT

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 567  : 	if( m_dwPChannelsUsed && m_aPChannels )

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000a	74 23		 je	 SHORT $L69790
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00013	74 1a		 je	 SHORT $L69790

; 568  : 	{
; 569  : 		pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );

  00015	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR _pSegment$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	8b 55 0c	 mov	 edx, DWORD PTR _pSegment$[ebp]
  0002b	52		 push	 edx
  0002c	ff 51 78	 call	 DWORD PTR [ecx+120]
$L69790:

; 570  : 	}
; 571  : 	return S_OK;

  0002f	33 c0		 xor	 eax, eax

; 572  : }

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
?Init@CSeqTrack@@UAGJPAUIDirectMusicSegment@@@Z ENDP	; CSeqTrack::Init
_TEXT	ENDS
PUBLIC	??_C@_0CB@MDDFKLEP@?$CFs?3?5Invalid?5pointer?5ppStateData?6@ ; `string'
PUBLIC	??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@ ; `string'
PUBLIC	??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@ ; `string'
PUBLIC	??0SeqStateData@@QAE@XZ				; SeqStateData::SeqStateData
PUBLIC	?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z ; CSeqTrack::SetUpStateCurrentPointers
;	COMDAT ?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB DB 'I'
	DB	'DirectMusicTrack::InitPlay', 00H		; `CSeqTrack::InitPlay'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CB@MDDFKLEP@?$CFs?3?5Invalid?5pointer?5ppStateData?6@
CONST	SEGMENT
??_C@_0CB@MDDFKLEP@?$CFs?3?5Invalid?5pointer?5ppStateData?6@ DB '%s: Inva'
	DB	'lid pointer ppStateData', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@
CONST	SEGMENT
??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@ DB '%s: Inval'
	DB	'id pointer pSegmentState', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
CONST	SEGMENT
??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@ DB '%s: Invali'
	DB	'd pointer pPerf', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z
_TEXT	SEGMENT
tv171 = -20
tv150 = -16
$T70943 = -12
_pStateData$ = -8
_pSegment$ = -4
_this$ = 8
_pSegmentState$ = 12
_pPerf$ = 16
_ppStateData$ = 20
_dwTrackID$ = 24
_dwFlags$ = 28
?InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z PROC NEAR ; CSeqTrack::InitPlay, COMDAT

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 597  : 	V_INAME(IDirectMusicTrack::InitPlay);
; 598  : 	V_PTRPTR_WRITE(ppStateData);

  00006	6a 04		 push	 4
  00008	8b 45 14	 mov	 eax, DWORD PTR _ppStateData$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69803
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@MDDFKLEP@?$CFs?3?5Invalid?5pointer?5ppStateData?6@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69803:

; 599  : 	V_INTERFACE(pSegmentState);

  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegmentState$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L69805
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L69805:
  00056	6a 04		 push	 4
  00058	8b 55 0c	 mov	 edx, DWORD PTR _pSegmentState$[ebp]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00063	85 c0		 test	 eax, eax
  00065	74 19		 je	 SHORT $L69808
  00067	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@
  00071	6a ff		 push	 -1
  00073	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	e8 00 00 00 00	 call	 _DebugBreak@0
$L69808:
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegmentState$[ebp]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	8b 02		 mov	 eax, DWORD PTR [edx]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0008d	85 c0		 test	 eax, eax
  0008f	74 19		 je	 SHORT $L69810
  00091	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@JOPLINEG@?$CFs?3?5Invalid?5pointer?5pSegmentStat@
  0009b	6a ff		 push	 -1
  0009d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	e8 00 00 00 00	 call	 _DebugBreak@0
$L69810:

; 600  : 	V_INTERFACE(pPerf);

  000aa	6a 04		 push	 4
  000ac	8b 4d 10	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000b5	85 c0		 test	 eax, eax
  000b7	74 19		 je	 SHORT $L69812
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  000c3	6a ff		 push	 -1
  000c5	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cd	e8 00 00 00 00	 call	 _DebugBreak@0
$L69812:
  000d2	6a 04		 push	 4
  000d4	8b 55 10	 mov	 edx, DWORD PTR _pPerf$[ebp]
  000d7	8b 02		 mov	 eax, DWORD PTR [edx]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000df	85 c0		 test	 eax, eax
  000e1	74 19		 je	 SHORT $L69815
  000e3	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  000ed	6a ff		 push	 -1
  000ef	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f7	e8 00 00 00 00	 call	 _DebugBreak@0
$L69815:
  000fc	8b 4d 10	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  000ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00101	8b 02		 mov	 eax, DWORD PTR [edx]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00109	85 c0		 test	 eax, eax
  0010b	74 19		 je	 SHORT $L69817
  0010d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z@4QBDB
  00112	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00117	6a ff		 push	 -1
  00119	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00121	e8 00 00 00 00	 call	 _DebugBreak@0
$L69817:

; 601  : 
; 602  : 	SeqStateData* pStateData;
; 603  : 	pStateData = new SeqStateData;

  00126	6a 2c		 push	 44			; 0000002cH
  00128	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0012d	83 c4 04	 add	 esp, 4
  00130	89 45 f4	 mov	 DWORD PTR $T70943[ebp], eax
  00133	83 7d f4 00	 cmp	 DWORD PTR $T70943[ebp], 0
  00137	74 0d		 je	 SHORT $L70944
  00139	8b 4d f4	 mov	 ecx, DWORD PTR $T70943[ebp]
  0013c	e8 00 00 00 00	 call	 ??0SeqStateData@@QAE@XZ	; SeqStateData::SeqStateData
  00141	89 45 f0	 mov	 DWORD PTR tv150[ebp], eax
  00144	eb 07		 jmp	 SHORT $L70945
$L70944:
  00146	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv150[ebp], 0
$L70945:
  0014d	8b 4d f0	 mov	 ecx, DWORD PTR tv150[ebp]
  00150	89 4d f8	 mov	 DWORD PTR _pStateData$[ebp], ecx

; 604  : 	if( NULL == pStateData )

  00153	83 7d f8 00	 cmp	 DWORD PTR _pStateData$[ebp], 0
  00157	75 07		 jne	 SHORT $L69821

; 605  : 		return E_OUTOFMEMORY;

  00159	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0015e	eb 69		 jmp	 SHORT $L69799
$L69821:

; 606  : 	*ppStateData = pStateData;

  00160	8b 55 14	 mov	 edx, DWORD PTR _ppStateData$[ebp]
  00163	8b 45 f8	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00166	89 02		 mov	 DWORD PTR [edx], eax

; 607  : 	SetUpStateCurrentPointers(pStateData);

  00168	8b 4d f8	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  0016b	51		 push	 ecx
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	83 e9 04	 sub	 ecx, 4
  00172	e8 00 00 00 00	 call	 ?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z ; CSeqTrack::SetUpStateCurrentPointers

; 608  : 	// need to know the group this track is in, for the mute track GetParam
; 609  : 	IDirectMusicSegment* pSegment;
; 610  : 	if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))

  00177	8d 55 fc	 lea	 edx, DWORD PTR _pSegment$[ebp]
  0017a	52		 push	 edx
  0017b	8b 45 0c	 mov	 eax, DWORD PTR _pSegmentState$[ebp]
  0017e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00180	8b 55 0c	 mov	 edx, DWORD PTR _pSegmentState$[ebp]
  00183	52		 push	 edx
  00184	ff 51 18	 call	 DWORD PTR [ecx+24]
  00187	85 c0		 test	 eax, eax
  00189	7c 3c		 jl	 SHORT $L69825

; 611  : 	{
; 612  : 		pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );

  0018b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	83 e8 04	 sub	 eax, 4
  00191	85 c0		 test	 eax, eax
  00193	74 08		 je	 SHORT $L70946
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	89 4d ec	 mov	 DWORD PTR tv171[ebp], ecx
  0019b	eb 07		 jmp	 SHORT $L70947
$L70946:
  0019d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv171[ebp], 0
$L70947:
  001a4	8b 55 f8	 mov	 edx, DWORD PTR _pStateData$[ebp]
  001a7	83 c2 28	 add	 edx, 40			; 00000028H
  001aa	52		 push	 edx
  001ab	8b 45 ec	 mov	 eax, DWORD PTR tv171[ebp]
  001ae	50		 push	 eax
  001af	8b 4d fc	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	8b 45 fc	 mov	 eax, DWORD PTR _pSegment$[ebp]
  001b7	50		 push	 eax
  001b8	ff 52 58	 call	 DWORD PTR [edx+88]

; 613  : 		pSegment->Release();

  001bb	8b 4d fc	 mov	 ecx, DWORD PTR _pSegment$[ebp]
  001be	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c0	8b 45 fc	 mov	 eax, DWORD PTR _pSegment$[ebp]
  001c3	50		 push	 eax
  001c4	ff 52 08	 call	 DWORD PTR [edx+8]
$L69825:

; 614  : 	}
; 615  : 	return S_OK;

  001c7	33 c0		 xor	 eax, eax
$L69799:

; 616  : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 18 00	 ret	 24			; 00000018H
?InitPlay@CSeqTrack@@UAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@PAPAXKK@Z ENDP ; CSeqTrack::InitPlay
_TEXT	ENDS
PUBLIC	??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0L@MIJOINAD@pStateData?$AA@		; `string'
PUBLIC	??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@ ; `string'
PUBLIC	??_GSeqStateData@@QAEPAXI@Z			; SeqStateData::`scalar deleting destructor'
EXTRN	__imp__RtlAssert@16:NEAR
;	COMDAT ??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\seqtrack.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MIJOINAD@pStateData?$AA@
CONST	SEGMENT
??_C@_0L@MIJOINAD@pStateData?$AA@ DB 'pStateData', 00H	; `string'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?6??EndPlay@CSeqTrack@@UAGJPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?6??EndPlay@CSeqTrack@@UAGJPAX@Z@4QBDB DB 'IDi'
	DB	'rectMusicTrack::EndPlay', 00H		; `CSeqTrack::EndPlay'::`7'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@
CONST	SEGMENT
??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pStateData', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?EndPlay@CSeqTrack@@UAGJPAX@Z
_TEXT	SEGMENT
tv81 = -16
$T70952 = -12
$T70951 = -8
_pSD$69839 = -4
_this$ = 8
_pStateData$ = 12
?EndPlay@CSeqTrack@@UAGJPAX@Z PROC NEAR			; CSeqTrack::EndPlay, COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 630  : 	ASSERT( pStateData );

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pStateData$[ebp], 0
  0000a	75 17		 jne	 SHORT $L69831
  0000c	6a 00		 push	 0
  0000e	68 76 02 00 00	 push	 630			; 00000276H
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@MIJOINAD@pStateData?$AA@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69831:

; 631  : 	if( pStateData )

  00023	83 7d 0c 00	 cmp	 DWORD PTR _pStateData$[ebp], 0
  00027	74 56		 je	 SHORT $L69834

; 632  : 	{
; 633  : 		V_INAME(IDirectMusicTrack::EndPlay);
; 634  : 		V_BUFPTR_WRITE(pStateData, sizeof(SeqStateData));

  00029	6a 2c		 push	 44			; 0000002cH
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pStateData$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00034	85 c0		 test	 eax, eax
  00036	74 19		 je	 SHORT $L69838
  00038	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?6??EndPlay@CSeqTrack@@UAGJPAX@Z@4QBDB
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@
  00042	6a ff		 push	 -1
  00044	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 _DebugBreak@0
$L69838:

; 635  : 		SeqStateData* pSD = (SeqStateData*)pStateData;

  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  00054	89 4d fc	 mov	 DWORD PTR _pSD$69839[ebp], ecx

; 636  : 		delete pSD;

  00057	8b 55 fc	 mov	 edx, DWORD PTR _pSD$69839[ebp]
  0005a	89 55 f4	 mov	 DWORD PTR $T70952[ebp], edx
  0005d	8b 45 f4	 mov	 eax, DWORD PTR $T70952[ebp]
  00060	89 45 f8	 mov	 DWORD PTR $T70951[ebp], eax
  00063	83 7d f8 00	 cmp	 DWORD PTR $T70951[ebp], 0
  00067	74 0f		 je	 SHORT $L70953
  00069	6a 01		 push	 1
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR $T70951[ebp]
  0006e	e8 00 00 00 00	 call	 ??_GSeqStateData@@QAEPAXI@Z
  00073	89 45 f0	 mov	 DWORD PTR tv81[ebp], eax
  00076	eb 07		 jmp	 SHORT $L69834
$L70953:
  00078	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L69834:

; 637  : 	}
; 638  : 	return S_OK;

  0007f	33 c0		 xor	 eax, eax

; 639  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?EndPlay@CSeqTrack@@UAGJPAX@Z ENDP			; CSeqTrack::EndPlay
_TEXT	ENDS
PUBLIC	??1SeqStateData@@QAE@XZ				; SeqStateData::~SeqStateData
; Function compile flags: /Odt
;	COMDAT ??_GSeqStateData@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GSeqStateData@@QAEPAXI@Z PROC NEAR			; SeqStateData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1SeqStateData@@QAE@XZ	; SeqStateData::~SeqStateData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69847
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69847:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GSeqStateData@@QAEPAXI@Z ENDP			; SeqStateData::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z
_TEXT	SEGMENT
_this$ = -20
$T70964 = -16
$T70963 = -12
$T70962 = -8
$T70961 = -4
_pStateData$ = 8
?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z PROC NEAR ; CSeqTrack::SetUpStateCurrentPointers, COMDAT
; _this$ = ecx

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 	ASSERT(pStateData);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pStateData$[ebp], 0
  0000d	75 17		 jne	 SHORT $L69852
  0000f	6a 00		 push	 0
  00011	68 83 02 00 00	 push	 643			; 00000283H
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@MIJOINAD@pStateData?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69852:

; 644  : 	pStateData->dwPChannelsUsed = m_dwPChannelsUsed;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0002f	89 10		 mov	 DWORD PTR [eax], edx

; 645  : 	if( m_dwPChannelsUsed )

  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00038	0f 84 d4 00 00
	00		 je	 $L69853

; 646  : 	{
; 647  : 		if( pStateData->apCurrentSeq )

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  00041	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00045	74 1f		 je	 SHORT $L69854

; 648  : 		{
; 649  : 			delete [] pStateData->apCurrentSeq;

  00047	8b 55 08	 mov	 edx, DWORD PTR _pStateData$[ebp]
  0004a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004d	89 45 fc	 mov	 DWORD PTR $T70961[ebp], eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR $T70961[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00059	83 c4 04	 add	 esp, 4

; 650  : 			pStateData->apCurrentSeq = NULL;

  0005c	8b 55 08	 mov	 edx, DWORD PTR _pStateData$[ebp]
  0005f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L69854:

; 651  : 		}
; 652  : 		if( pStateData->apCurrentCurve )

  00066	8b 45 08	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00069	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0006d	74 1f		 je	 SHORT $L69856

; 653  : 		{
; 654  : 			delete [] pStateData->apCurrentCurve;

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  00072	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00075	89 55 f8	 mov	 DWORD PTR $T70962[ebp], edx
  00078	8b 45 f8	 mov	 eax, DWORD PTR $T70962[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00081	83 c4 04	 add	 esp, 4

; 655  : 			pStateData->apCurrentCurve = NULL;

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  00087	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$L69856:

; 656  : 		}
; 657  : 		pStateData->apCurrentSeq = new TListItem<DMUS_IO_SEQ_ITEM>* [m_dwPChannelsUsed];

  0008e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00091	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00094	c1 e0 02	 shl	 eax, 2
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0009d	83 c4 04	 add	 esp, 4
  000a0	89 45 f4	 mov	 DWORD PTR $T70963[ebp], eax
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  000a6	8b 55 f4	 mov	 edx, DWORD PTR $T70963[ebp]
  000a9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 658  : 		pStateData->apCurrentCurve = new TListItem<DMUS_IO_CURVE_ITEM>* [m_dwPChannelsUsed];

  000ac	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b2	c1 e1 02	 shl	 ecx, 2
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000bb	83 c4 04	 add	 esp, 4
  000be	89 45 f0	 mov	 DWORD PTR $T70964[ebp], eax
  000c1	8b 55 08	 mov	 edx, DWORD PTR _pStateData$[ebp]
  000c4	8b 45 f0	 mov	 eax, DWORD PTR $T70964[ebp]
  000c7	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 659  : 		if( pStateData->apCurrentSeq )

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  000cd	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000d1	74 1b		 je	 SHORT $L69862

; 660  : 		{
; 661  : 			memset( pStateData->apCurrentSeq, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * m_dwPChannelsUsed );

  000d3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d9	c1 e0 02	 shl	 eax, 2
  000dc	50		 push	 eax
  000dd	6a 00		 push	 0
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  000e2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 _memset
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69862:

; 662  : 		}
; 663  : 		if( pStateData->apCurrentCurve )

  000ee	8b 45 08	 mov	 eax, DWORD PTR _pStateData$[ebp]
  000f1	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000f5	74 1b		 je	 SHORT $L69853

; 664  : 		{
; 665  : 			memset( pStateData->apCurrentCurve, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * m_dwPChannelsUsed );

  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000fd	c1 e2 02	 shl	 edx, 2
  00100	52		 push	 edx
  00101	6a 00		 push	 0
  00103	8b 45 08	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00106	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 _memset
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69853:

; 666  : 		}
; 667  : 	}
; 668  : 	pStateData->dwValidate = m_dwValidate;

  00112	8b 55 08	 mov	 edx, DWORD PTR _pStateData$[ebp]
  00115	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00118	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0011b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 669  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 04 00	 ret	 4
?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z ENDP ; CSeqTrack::SetUpStateCurrentPointers
_TEXT	ENDS
PUBLIC	?RemoveHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ; TList<_DMUS_IO_SEQ_ITEM>::RemoveHead
PUBLIC	?RemoveHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ; TList<_DMUS_IO_CURVE_ITEM>::RemoveHead
PUBLIC	?RemoveHead@?$TList@USEQ_PART@@@@QAEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::RemoveHead
PUBLIC	??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z		; TListItem<SEQ_PART>::`scalar deleting destructor'
PUBLIC	??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z	; TListItem<_DMUS_IO_SEQ_ITEM>::`scalar deleting destructor'
PUBLIC	??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ?DeleteSeqPartList@CSeqTrack@@IAEXXZ
_TEXT	SEGMENT
tv139 = -56
tv134 = -52
tv91 = -48
_this$ = -44
$T70978 = -40
$T70977 = -36
$T70974 = -32
$T70973 = -28
$T70970 = -24
$T70969 = -20
$T70968 = -16
_pEvent$69877 = -12
_pCurve$69883 = -8
_pItem$69873 = -4
?DeleteSeqPartList@CSeqTrack@@IAEXXZ PROC NEAR		; CSeqTrack::DeleteSeqPartList, COMDAT
; _this$ = ecx

; 673  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 674  :     ENTER_CRITICAL_SECTION(&m_CrSec);

  00009	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 20	 add	 eax, 32			; 00000020H
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 675  : 	m_dwPChannelsUsed = 0;

  00016	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 676  : 	if (m_aPChannels) delete [] m_aPChannels;

  00020	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00023	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00027	74 15		 je	 SHORT $L69870
  00029	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002f	89 4d f0	 mov	 DWORD PTR $T70968[ebp], ecx
  00032	8b 55 f0	 mov	 edx, DWORD PTR $T70968[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003b	83 c4 04	 add	 esp, 4
$L69870:

; 677  : 	m_aPChannels = NULL;

  0003e	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 678  : 	m_pSeqPartCache = NULL;

  00048	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 679  : 	if( m_SeqPartList.GetHead() )

  00052	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 08	 add	 ecx, 8
  00058	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 cf 00 00
	00		 je	 $L69872
$L69875:

; 680  : 	{
; 681  : 		TListItem<SEQ_PART>* pItem;
; 682  : 		while( pItem = m_SeqPartList.RemoveHead() )

  00065	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	83 c1 08	 add	 ecx, 8
  0006b	e8 00 00 00 00	 call	 ?RemoveHead@?$TList@USEQ_PART@@@@QAEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::RemoveHead
  00070	89 45 fc	 mov	 DWORD PTR _pItem$69873[ebp], eax
  00073	83 7d fc 00	 cmp	 DWORD PTR _pItem$69873[ebp], 0
  00077	0f 84 b7 00 00
	00		 je	 $L69872
$L69879:

; 683  : 		{
; 684  : 			TListItem<DMUS_IO_SEQ_ITEM>* pEvent;
; 685  : 			while( pEvent = pItem->GetItemValue().seqList.RemoveHead() )

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$69873[ebp]
  00080	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00085	83 c0 08	 add	 eax, 8
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 ?RemoveHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ; TList<_DMUS_IO_SEQ_ITEM>::RemoveHead
  0008f	89 45 f4	 mov	 DWORD PTR _pEvent$69877[ebp], eax
  00092	83 7d f4 00	 cmp	 DWORD PTR _pEvent$69877[ebp], 0
  00096	74 2a		 je	 SHORT $L69885

; 686  : 			{
; 687  : 				delete pEvent;

  00098	8b 55 f4	 mov	 edx, DWORD PTR _pEvent$69877[ebp]
  0009b	89 55 e8	 mov	 DWORD PTR $T70970[ebp], edx
  0009e	8b 45 e8	 mov	 eax, DWORD PTR $T70970[ebp]
  000a1	89 45 ec	 mov	 DWORD PTR $T70969[ebp], eax
  000a4	83 7d ec 00	 cmp	 DWORD PTR $T70969[ebp], 0
  000a8	74 0f		 je	 SHORT $L70971
  000aa	6a 01		 push	 1
  000ac	8b 4d ec	 mov	 ecx, DWORD PTR $T70969[ebp]
  000af	e8 00 00 00 00	 call	 ??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z
  000b4	89 45 d0	 mov	 DWORD PTR tv91[ebp], eax
  000b7	eb 07		 jmp	 SHORT $L70972
$L70971:
  000b9	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
$L70972:

; 688  : 			}

  000c0	eb bb		 jmp	 SHORT $L69879
$L69885:

; 689  : 			TListItem<DMUS_IO_CURVE_ITEM>* pCurve;
; 690  : 			while( pCurve = pItem->GetItemValue().curveList.RemoveHead() )

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _pItem$69873[ebp]
  000c5	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  000ca	83 c0 0c	 add	 eax, 12			; 0000000cH
  000cd	8b c8		 mov	 ecx, eax
  000cf	e8 00 00 00 00	 call	 ?RemoveHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ; TList<_DMUS_IO_CURVE_ITEM>::RemoveHead
  000d4	89 45 f8	 mov	 DWORD PTR _pCurve$69883[ebp], eax
  000d7	83 7d f8 00	 cmp	 DWORD PTR _pCurve$69883[ebp], 0
  000db	74 2a		 je	 SHORT $L69886

; 691  : 			{
; 692  : 				delete pCurve;

  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _pCurve$69883[ebp]
  000e0	89 4d e0	 mov	 DWORD PTR $T70974[ebp], ecx
  000e3	8b 55 e0	 mov	 edx, DWORD PTR $T70974[ebp]
  000e6	89 55 e4	 mov	 DWORD PTR $T70973[ebp], edx
  000e9	83 7d e4 00	 cmp	 DWORD PTR $T70973[ebp], 0
  000ed	74 0f		 je	 SHORT $L70975
  000ef	6a 01		 push	 1
  000f1	8b 4d e4	 mov	 ecx, DWORD PTR $T70973[ebp]
  000f4	e8 00 00 00 00	 call	 ??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z
  000f9	89 45 cc	 mov	 DWORD PTR tv134[ebp], eax
  000fc	eb 07		 jmp	 SHORT $L70976
$L70975:
  000fe	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
$L70976:

; 693  : 			}

  00105	eb bb		 jmp	 SHORT $L69885
$L69886:

; 694  : 			delete pItem;

  00107	8b 45 fc	 mov	 eax, DWORD PTR _pItem$69873[ebp]
  0010a	89 45 d8	 mov	 DWORD PTR $T70978[ebp], eax
  0010d	8b 4d d8	 mov	 ecx, DWORD PTR $T70978[ebp]
  00110	89 4d dc	 mov	 DWORD PTR $T70977[ebp], ecx
  00113	83 7d dc 00	 cmp	 DWORD PTR $T70977[ebp], 0
  00117	74 0f		 je	 SHORT $L70979
  00119	6a 01		 push	 1
  0011b	8b 4d dc	 mov	 ecx, DWORD PTR $T70977[ebp]
  0011e	e8 00 00 00 00	 call	 ??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z
  00123	89 45 c8	 mov	 DWORD PTR tv139[ebp], eax
  00126	eb 07		 jmp	 SHORT $L70980
$L70979:
  00128	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
$L70980:

; 695  : 		}

  0012f	e9 31 ff ff ff	 jmp	 $L69875
$L69872:

; 696  : 	}
; 697  :     LEAVE_CRITICAL_SECTION(&m_CrSec);

  00134	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00137	83 c2 20	 add	 edx, 32			; 00000020H
  0013a	52		 push	 edx
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 698  : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
?DeleteSeqPartList@CSeqTrack@@IAEXXZ ENDP		; CSeqTrack::DeleteSeqPartList
_TEXT	ENDS
PUBLIC	??1?$TListItem@USEQ_PART@@@@QAE@XZ		; TListItem<SEQ_PART>::~TListItem<SEQ_PART>
; Function compile flags: /Odt
;	COMDAT ??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z PROC NEAR	; TListItem<SEQ_PART>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$TListItem@USEQ_PART@@@@QAE@XZ ; TListItem<SEQ_PART>::~TListItem<SEQ_PART>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69894
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69894:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z ENDP		; TListItem<SEQ_PART>::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z
_TEXT	SEGMENT
tv89 = -28
_this$ = -24
$T70991 = -20
$T70990 = -16
$T70987 = -12
_aPChannels$69909 = -8
_pPart$ = -4
_dwPChannel$ = 8
?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z PROC NEAR ; CSeqTrack::FindPart, COMDAT
; _this$ = ecx

; 702  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 703  : 	TListItem<SEQ_PART>* pPart;
; 704  : 	
; 705  : 	if( m_pSeqPartCache && (m_pSeqPartCache->GetItemValue().dwPChannel == dwPChannel) )

  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	74 1e		 je	 SHORT $L69900
  00012	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00018	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	3b 55 08	 cmp	 edx, DWORD PTR _dwPChannel$[ebp]
  00023	75 0b		 jne	 SHORT $L69900

; 706  : 	{
; 707  : 		return m_pSeqPartCache;

  00025	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002b	e9 2c 01 00 00	 jmp	 $L69898
$L69900:

; 708  : 	}
; 709  : 	for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )

  00030	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 08	 add	 ecx, 8
  00036	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  0003b	89 45 fc	 mov	 DWORD PTR _pPart$[ebp], eax
  0003e	eb 0b		 jmp	 SHORT $L69901
$L69902:
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  00043	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  00048	89 45 fc	 mov	 DWORD PTR _pPart$[ebp], eax
$L69901:
  0004b	83 7d fc 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  0004f	74 14		 je	 SHORT $L69903

; 710  : 	{
; 711  : 		if( pPart->GetItemValue().dwPChannel == dwPChannel )

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  00054	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR _dwPChannel$[ebp]
  0005f	75 02		 jne	 SHORT $L69904

; 712  : 		{
; 713  : 			break;

  00061	eb 02		 jmp	 SHORT $L69903
$L69904:

; 714  : 		}
; 715  : 	}

  00063	eb db		 jmp	 SHORT $L69902
$L69903:

; 716  : 	if( NULL == pPart )

  00065	83 7d fc 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  00069	0f 85 e1 00 00
	00		 jne	 $L69905

; 717  : 	{
; 718  : 		pPart = new TListItem<SEQ_PART>;

  0006f	6a 14		 push	 20			; 00000014H
  00071	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00076	83 c4 04	 add	 esp, 4
  00079	89 45 f4	 mov	 DWORD PTR $T70987[ebp], eax
  0007c	83 7d f4 00	 cmp	 DWORD PTR $T70987[ebp], 0
  00080	74 0d		 je	 SHORT $L70988
  00082	8b 4d f4	 mov	 ecx, DWORD PTR $T70987[ebp]
  00085	e8 00 00 00 00	 call	 ??0?$TListItem@USEQ_PART@@@@QAE@XZ ; TListItem<SEQ_PART>::TListItem<SEQ_PART>
  0008a	89 45 e4	 mov	 DWORD PTR tv89[ebp], eax
  0008d	eb 07		 jmp	 SHORT $L70989
$L70988:
  0008f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$L70989:
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv89[ebp]
  00099	89 55 fc	 mov	 DWORD PTR _pPart$[ebp], edx

; 719  : 		if( pPart )

  0009c	83 7d fc 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  000a0	74 1d		 je	 SHORT $L69908

; 720  : 		{
; 721  : 			pPart->GetItemValue().dwPChannel = dwPChannel;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _pPart$[ebp]
  000a5	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _dwPChannel$[ebp]
  000ad	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 722  : 			m_SeqPartList.AddHead( pPart );

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _pPart$[ebp]
  000b3	52		 push	 edx
  000b4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	83 c1 08	 add	 ecx, 8
  000ba	e8 00 00 00 00	 call	 ?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z ; TList<SEQ_PART>::AddHead
$L69908:

; 723  : 		}
; 724  : 		m_dwPChannelsUsed++;

  000bf	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c5	83 c1 01	 add	 ecx, 1
  000c8	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 725  : 		
; 726  : 		DWORD* aPChannels = new DWORD[m_dwPChannelsUsed];

  000ce	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000d4	c1 e1 02	 shl	 ecx, 2
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000dd	83 c4 04	 add	 esp, 4
  000e0	89 45 f0	 mov	 DWORD PTR $T70990[ebp], eax
  000e3	8b 55 f0	 mov	 edx, DWORD PTR $T70990[ebp]
  000e6	89 55 f8	 mov	 DWORD PTR _aPChannels$69909[ebp], edx

; 727  : 		if( aPChannels )

  000e9	83 7d f8 00	 cmp	 DWORD PTR _aPChannels$69909[ebp], 0
  000ed	74 3a		 je	 SHORT $L69912

; 728  : 		{
; 729  : 			if( m_aPChannels )

  000ef	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  000f6	74 21		 je	 SHORT $L69913

; 730  : 			{
; 731  : 				memcpy( aPChannels, m_aPChannels, sizeof(DWORD) * (m_dwPChannelsUsed - 1) );

  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000fe	8d 04 95 fc ff
	ff ff		 lea	 eax, DWORD PTR [edx*4-4]
  00105	50		 push	 eax
  00106	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0010c	52		 push	 edx
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _aPChannels$69909[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _memcpy
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69913:

; 732  : 			}
; 733  : 			aPChannels[m_dwPChannelsUsed - 1] = dwPChannel;

  00119	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _aPChannels$69909[ebp]
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _dwPChannel$[ebp]
  00125	89 4c 90 fc	 mov	 DWORD PTR [eax+edx*4-4], ecx
$L69912:

; 734  : 		}
; 735  : 		if( m_aPChannels )

  00129	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0012c	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00130	74 15		 je	 SHORT $L69915

; 736  : 		{
; 737  : 			delete [] m_aPChannels;

  00132	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00135	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00138	89 4d ec	 mov	 DWORD PTR $T70991[ebp], ecx
  0013b	8b 55 ec	 mov	 edx, DWORD PTR $T70991[ebp]
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00144	83 c4 04	 add	 esp, 4
$L69915:

; 738  : 		}
; 739  : 		m_aPChannels = aPChannels;

  00147	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _aPChannels$69909[ebp]
  0014d	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$L69905:

; 740  : 	}
; 741  : 	m_pSeqPartCache = pPart;

  00150	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00153	8b 45 fc	 mov	 eax, DWORD PTR _pPart$[ebp]
  00156	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 742  : 	return pPart;

  00159	8b 45 fc	 mov	 eax, DWORD PTR _pPart$[ebp]
$L69898:

; 743  : }

  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c2 04 00	 ret	 4
?FindPart@CSeqTrack@@IAEPAV?$TListItem@USEQ_PART@@@@K@Z ENDP ; CSeqTrack::FindPart
_TEXT	ENDS
PUBLIC	?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z ; CSeqTrack::UpdateTimeSig
EXTRN	_GUID_TimeSignature:BYTE
; Function compile flags: /Odt
;	COMDAT ?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z
_TEXT	SEGMENT
tv81 = -32
_this$ = -28
_dwGroup$69931 = -24
_hr$69928 = -20
_timesig$69926 = -16
_pSeg$69925 = -8
_mtNext$69927 = -4
_pSegSt$ = 8
_pSD$ = 12
_mt$ = 16
?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z PROC NEAR ; CSeqTrack::UpdateTimeSig, COMDAT
; _this$ = ecx

; 748  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 749  : 	// get a new time sig if needed
; 750  : 	if( (mt >= pSD->mtNextTimeSig) || (mt < pSD->mtCurTimeSig) )

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _mt$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	7d 0f		 jge	 SHORT $L69924
  00014	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  00017	8b 45 10	 mov	 eax, DWORD PTR _mt$[ebp]
  0001a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0001d	0f 8d 71 01 00
	00		 jge	 $L69923
$L69924:

; 751  : 	{
; 752  : 		IDirectMusicSegment* pSeg;
; 753  : 		DMUS_TIMESIGNATURE timesig;
; 754  : 		MUSIC_TIME mtNext;
; 755  : 		HRESULT hr;
; 756  : 		if(SUCCEEDED(hr = pSegSt->GetSegment(&pSeg)))

  00023	8d 4d f8	 lea	 ecx, DWORD PTR _pSeg$69925[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  0002a	8b 02		 mov	 eax, DWORD PTR [edx]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  0002f	51		 push	 ecx
  00030	ff 50 18	 call	 DWORD PTR [eax+24]
  00033	89 45 ec	 mov	 DWORD PTR _hr$69928[ebp], eax
  00036	83 7d ec 00	 cmp	 DWORD PTR _hr$69928[ebp], 0
  0003a	0f 8c 12 01 00
	00		 jl	 $L69930

; 757  : 		{
; 758  : 			DWORD dwGroup;
; 759  : 			if( SUCCEEDED(hr = pSeg->GetTrackGroup( this, &dwGroup )))

  00040	83 7d e4 00	 cmp	 DWORD PTR _this$[ebp], 0
  00044	74 0b		 je	 SHORT $L70995
  00046	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00049	83 c2 04	 add	 edx, 4
  0004c	89 55 e0	 mov	 DWORD PTR tv81[ebp], edx
  0004f	eb 07		 jmp	 SHORT $L70996
$L70995:
  00051	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L70996:
  00058	8d 45 e8	 lea	 eax, DWORD PTR _dwGroup$69931[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d e0	 mov	 ecx, DWORD PTR tv81[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 f8	 mov	 edx, DWORD PTR _pSeg$69925[ebp]
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _pSeg$69925[ebp]
  00068	51		 push	 ecx
  00069	ff 50 58	 call	 DWORD PTR [eax+88]
  0006c	89 45 ec	 mov	 DWORD PTR _hr$69928[ebp], eax
  0006f	83 7d ec 00	 cmp	 DWORD PTR _hr$69928[ebp], 0
  00073	0f 8c cd 00 00
	00		 jl	 $L69933

; 760  : 			{
; 761  : 				if(SUCCEEDED(hr = pSeg->GetParam( GUID_TimeSignature, dwGroup, 
; 762  : 					0, mt, &mtNext, (void*)&timesig )))

  00079	8d 55 f0	 lea	 edx, DWORD PTR _timesig$69926[ebp]
  0007c	52		 push	 edx
  0007d	8d 45 fc	 lea	 eax, DWORD PTR _mtNext$69927[ebp]
  00080	50		 push	 eax
  00081	8b 4d 10	 mov	 ecx, DWORD PTR _mt$[ebp]
  00084	51		 push	 ecx
  00085	6a 00		 push	 0
  00087	8b 55 e8	 mov	 edx, DWORD PTR _dwGroup$69931[ebp]
  0008a	52		 push	 edx
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_TimeSignature
  00090	8b 45 f8	 mov	 eax, DWORD PTR _pSeg$69925[ebp]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	8b 55 f8	 mov	 edx, DWORD PTR _pSeg$69925[ebp]
  00098	52		 push	 edx
  00099	ff 51 6c	 call	 DWORD PTR [ecx+108]
  0009c	89 45 ec	 mov	 DWORD PTR _hr$69928[ebp], eax
  0009f	83 7d ec 00	 cmp	 DWORD PTR _hr$69928[ebp], 0
  000a3	0f 8c 9d 00 00
	00		 jl	 $L69933

; 763  : 				{
; 764  : 					timesig.mtTime += mt; 

  000a9	8b 45 f0	 mov	 eax, DWORD PTR _timesig$69926[ebp]
  000ac	03 45 10	 add	 eax, DWORD PTR _mt$[ebp]
  000af	89 45 f0	 mov	 DWORD PTR _timesig$69926[ebp], eax

; 765  : 					if( pSD->dwlnMeasure )

  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  000b5	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  000b9	74 19		 je	 SHORT $L69937

; 766  : 					{
; 767  : 						pSD->dwMeasure = (timesig.mtTime - pSD->mtCurTimeSig) / pSD->dwlnMeasure;

  000bb	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  000be	8b 45 f0	 mov	 eax, DWORD PTR _timesig$69926[ebp]
  000c1	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  000c7	33 d2		 xor	 edx, edx
  000c9	f7 71 20	 div	 DWORD PTR [ecx+32]
  000cc	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  000cf	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 768  : 					}
; 769  : 					else

  000d2	eb 0a		 jmp	 SHORT $L69938
$L69937:

; 770  : 					{
; 771  : 						pSD->dwMeasure = 0;

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  000d7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$L69938:

; 772  : 					}
; 773  : 					pSD->mtCurTimeSig = timesig.mtTime;

  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _timesig$69926[ebp]
  000e4	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 774  : 					if( mtNext == 0 ) mtNext = 0x7fffffff;

  000e7	83 7d fc 00	 cmp	 DWORD PTR _mtNext$69927[ebp], 0
  000eb	75 07		 jne	 SHORT $L69939
  000ed	c7 45 fc ff ff
	ff 7f		 mov	 DWORD PTR _mtNext$69927[ebp], 2147483647 ; 7fffffffH
$L69939:

; 775  : 					pSD->mtNextTimeSig = mtNext;

  000f4	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _mtNext$69927[ebp]
  000fa	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 776  : 					if( timesig.bBeat )

  000fd	0f b6 55 f5	 movzx	 edx, BYTE PTR _timesig$69926[ebp+5]
  00101	85 d2		 test	 edx, edx
  00103	74 12		 je	 SHORT $L69940

; 777  : 					{
; 778  : 						pSD->dwlnBeat = DMUS_PPQ * 4 / timesig.bBeat;

  00105	0f b6 4d f5	 movzx	 ecx, BYTE PTR _timesig$69926[ebp+5]
  00109	b8 00 0c 00 00	 mov	 eax, 3072		; 00000c00H
  0010e	99		 cdq
  0010f	f7 f9		 idiv	 ecx
  00111	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  00114	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$L69940:

; 779  : 					}
; 780  : 					pSD->dwlnMeasure = pSD->dwlnBeat * timesig.bBeatsPerMeasure;

  00117	0f b6 45 f4	 movzx	 eax, BYTE PTR _timesig$69926[ebp+4]
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0011e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00121	0f af d0	 imul	 edx, eax
  00124	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  00127	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 781  : 					if( timesig.wGridsPerBeat )

  0012a	0f b7 4d f6	 movzx	 ecx, WORD PTR _timesig$69926[ebp+6]
  0012e	85 c9		 test	 ecx, ecx
  00130	74 14		 je	 SHORT $L69933

; 782  : 					{
; 783  : 						pSD->dwlnGrid = pSD->dwlnBeat / timesig.wGridsPerBeat;

  00132	0f b7 4d f6	 movzx	 ecx, WORD PTR _timesig$69926[ebp+6]
  00136	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  00139	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0013c	33 d2		 xor	 edx, edx
  0013e	f7 f1		 div	 ecx
  00140	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00143	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$L69933:

; 784  : 					}
; 785  : 				}
; 786  : 			}
; 787  : 			pSeg->Release();

  00146	8b 55 f8	 mov	 edx, DWORD PTR _pSeg$69925[ebp]
  00149	8b 02		 mov	 eax, DWORD PTR [edx]
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _pSeg$69925[ebp]
  0014e	51		 push	 ecx
  0014f	ff 50 08	 call	 DWORD PTR [eax+8]
$L69930:

; 788  : 		}
; 789  : 		if( FAILED(hr) )

  00152	83 7d ec 00	 cmp	 DWORD PTR _hr$69928[ebp], 0
  00156	7d 3c		 jge	 SHORT $L69923

; 790  : 		{
; 791  : 			// couldn't get time sig, default to 4/4
; 792  : 			pSD->mtNextTimeSig = 0x7fffffff;

  00158	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  0015b	c7 42 14 ff ff
	ff 7f		 mov	 DWORD PTR [edx+20], 2147483647 ; 7fffffffH

; 793  : 			pSD->dwlnBeat = DMUS_PPQ;

  00162	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  00165	c7 40 1c 00 03
	00 00		 mov	 DWORD PTR [eax+28], 768	; 00000300H

; 794  : 			pSD->dwlnMeasure = DMUS_PPQ * 4;

  0016c	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0016f	c7 41 20 00 0c
	00 00		 mov	 DWORD PTR [ecx+32], 3072 ; 00000c00H

; 795  : 			pSD->dwlnGrid = DMUS_PPQ / 4;

  00176	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  00179	c7 42 24 c0 00
	00 00		 mov	 DWORD PTR [edx+36], 192	; 000000c0H

; 796  : 			pSD->dwMeasure = 0;

  00180	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  00183	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 797  : 			pSD->mtCurTimeSig = 0;

  0018a	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0018d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
$L69923:

; 798  : 		}
; 799  : 	}
; 800  : 	// make absolutely sure there is no way these can be 0, since we divide
; 801  : 	// by them.
; 802  : 	if( 0 == pSD->dwlnGrid ) pSD->dwlnGrid = DMUS_PPQ / 4;

  00194	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  00197	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0019b	75 0a		 jne	 SHORT $L69944
  0019d	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  001a0	c7 40 24 c0 00
	00 00		 mov	 DWORD PTR [eax+36], 192	; 000000c0H
$L69944:

; 803  : 	if( 0 == pSD->dwlnBeat ) pSD->dwlnBeat = DMUS_PPQ;

  001a7	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  001aa	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  001ae	75 0a		 jne	 SHORT $L69945
  001b0	8b 55 0c	 mov	 edx, DWORD PTR _pSD$[ebp]
  001b3	c7 42 1c 00 03
	00 00		 mov	 DWORD PTR [edx+28], 768	; 00000300H
$L69945:

; 804  : 	if( 0 == pSD->dwlnMeasure ) pSD->dwlnMeasure = DMUS_PPQ * 4;

  001ba	8b 45 0c	 mov	 eax, DWORD PTR _pSD$[ebp]
  001bd	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  001c1	75 0a		 jne	 SHORT $L69922
  001c3	8b 4d 0c	 mov	 ecx, DWORD PTR _pSD$[ebp]
  001c6	c7 41 20 00 0c
	00 00		 mov	 DWORD PTR [ecx+32], 3072 ; 00000c00H
$L69922:

; 805  : }

  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c2 0c 00	 ret	 12			; 0000000cH
?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z ENDP ; CSeqTrack::UpdateTimeSig
_TEXT	ENDS
PUBLIC	??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@ ; `string'
PUBLIC	?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z ; CSeqTrack::Play
EXTRN	__alldiv:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB DB 'I'
	DB	'DirectMusicTrack::PlayEx', 00H		; `CSeqTrack::PlayEx'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
CONST	SEGMENT
??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@ DB '%s: Inval'
	DB	'id pointer pSegSt', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_pStateData$ = 12
_rtStart$ = 16
_rtEnd$ = 24
_rtOffset$ = 32
_dwFlags$ = 40
_pPerf$ = 44
_pSegSt$ = 48
_dwVirtualID$ = 52
?PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z PROC NEAR ; CSeqTrack::PlayEx, COMDAT

; 811  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 812  : 	V_INAME(IDirectMusicTrack::PlayEx);
; 813  : 	V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));

  00004	6a 2c		 push	 44			; 0000002cH
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L69961
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L69961:

; 814  : 	V_INTERFACE(pPerf);

  0002c	6a 04		 push	 4
  0002e	8b 4d 2c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L69963
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L69963:
  00054	6a 04		 push	 4
  00056	8b 55 2c	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00061	85 c0		 test	 eax, eax
  00063	74 19		 je	 SHORT $L69966
  00065	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  0006f	6a ff		 push	 -1
  00071	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	e8 00 00 00 00	 call	 _DebugBreak@0
$L69966:
  0007e	8b 4d 2c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0008b	85 c0		 test	 eax, eax
  0008d	74 19		 je	 SHORT $L69968
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00099	6a ff		 push	 -1
  0009b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	e8 00 00 00 00	 call	 _DebugBreak@0
$L69968:

; 815  : 	V_INTERFACE(pSegSt);

  000a8	6a 04		 push	 4
  000aa	8b 4d 30	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000b3	85 c0		 test	 eax, eax
  000b5	74 19		 je	 SHORT $L69970
  000b7	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
  000c1	6a ff		 push	 -1
  000c3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	e8 00 00 00 00	 call	 _DebugBreak@0
$L69970:
  000d0	6a 04		 push	 4
  000d2	8b 55 30	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  000d5	8b 02		 mov	 eax, DWORD PTR [edx]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000dd	85 c0		 test	 eax, eax
  000df	74 19		 je	 SHORT $L69973
  000e1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
  000eb	6a ff		 push	 -1
  000ed	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	e8 00 00 00 00	 call	 _DebugBreak@0
$L69973:
  000fa	8b 4d 30	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ff	8b 02		 mov	 eax, DWORD PTR [edx]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00107	85 c0		 test	 eax, eax
  00109	74 19		 je	 SHORT $L69975
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
  00115	6a ff		 push	 -1
  00117	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	e8 00 00 00 00	 call	 _DebugBreak@0
$L69975:

; 816  : 
; 817  :     HRESULT hr;
; 818  :     ENTER_CRITICAL_SECTION(&m_CrSec);

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0012a	51		 push	 ecx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 819  :     if (dwFlags & DMUS_TRACKF_CLOCK)

  00131	8b 55 28	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00134	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  0013a	85 d2		 test	 edx, edx
  0013c	74 6d		 je	 SHORT $L69977

; 820  :     {
; 821  :         // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
; 822  :         // variables.
; 823  : 	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
; 824  :             (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);

  0013e	6a 01		 push	 1
  00140	8b 45 34	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  00143	50		 push	 eax
  00144	8b 4d 30	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00147	51		 push	 ecx
  00148	8b 55 2c	 mov	 edx, DWORD PTR _pPerf$[ebp]
  0014b	52		 push	 edx
  0014c	8b 45 28	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0014f	50		 push	 eax
  00150	8b 4d 24	 mov	 ecx, DWORD PTR _rtOffset$[ebp+4]
  00153	51		 push	 ecx
  00154	8b 55 20	 mov	 edx, DWORD PTR _rtOffset$[ebp]
  00157	52		 push	 edx
  00158	6a 00		 push	 0
  0015a	68 10 27 00 00	 push	 10000			; 00002710H
  0015f	8b 45 24	 mov	 eax, DWORD PTR _rtOffset$[ebp+4]
  00162	50		 push	 eax
  00163	8b 4d 20	 mov	 ecx, DWORD PTR _rtOffset$[ebp]
  00166	51		 push	 ecx
  00167	e8 00 00 00 00	 call	 __alldiv
  0016c	50		 push	 eax
  0016d	6a 00		 push	 0
  0016f	68 10 27 00 00	 push	 10000			; 00002710H
  00174	8b 55 1c	 mov	 edx, DWORD PTR _rtEnd$[ebp+4]
  00177	52		 push	 edx
  00178	8b 45 18	 mov	 eax, DWORD PTR _rtEnd$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 __alldiv
  00181	50		 push	 eax
  00182	6a 00		 push	 0
  00184	68 10 27 00 00	 push	 10000			; 00002710H
  00189	8b 4d 14	 mov	 ecx, DWORD PTR _rtStart$[ebp+4]
  0018c	51		 push	 ecx
  0018d	8b 55 10	 mov	 edx, DWORD PTR _rtStart$[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 __alldiv
  00196	50		 push	 eax
  00197	8b 45 0c	 mov	 eax, DWORD PTR _pStateData$[ebp]
  0019a	50		 push	 eax
  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	83 e9 04	 sub	 ecx, 4
  001a1	e8 00 00 00 00	 call	 ?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z ; CSeqTrack::Play
  001a6	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 825  :     }
; 826  :     else

  001a9	eb 34		 jmp	 SHORT $L69981
$L69977:

; 827  :     {
; 828  : 	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
; 829  :             (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);

  001ab	6a 00		 push	 0
  001ad	8b 4d 34	 mov	 ecx, DWORD PTR _dwVirtualID$[ebp]
  001b0	51		 push	 ecx
  001b1	8b 55 30	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  001b4	52		 push	 edx
  001b5	8b 45 2c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  001b8	50		 push	 eax
  001b9	8b 4d 28	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  001bc	51		 push	 ecx
  001bd	6a 00		 push	 0
  001bf	6a 00		 push	 0
  001c1	8b 55 20	 mov	 edx, DWORD PTR _rtOffset$[ebp]
  001c4	52		 push	 edx
  001c5	8b 45 18	 mov	 eax, DWORD PTR _rtEnd$[ebp]
  001c8	50		 push	 eax
  001c9	8b 4d 10	 mov	 ecx, DWORD PTR _rtStart$[ebp]
  001cc	51		 push	 ecx
  001cd	8b 55 0c	 mov	 edx, DWORD PTR _pStateData$[ebp]
  001d0	52		 push	 edx
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001d4	83 e9 04	 sub	 ecx, 4
  001d7	e8 00 00 00 00	 call	 ?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z ; CSeqTrack::Play
  001dc	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L69981:

; 830  :     }
; 831  :     LEAVE_CRITICAL_SECTION(&m_CrSec);

  001df	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	83 c0 1c	 add	 eax, 28			; 0000001cH
  001e5	50		 push	 eax
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 832  : 	return hr;

  001ec	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 833  : }

  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c2 30 00	 ret	 48			; 00000030H
?PlayEx@CSeqTrack@@UAGJPAX_J11KPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z ENDP ; CSeqTrack::PlayEx
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB DB 'I'
	DB	'DirectMusicTrack::Play', 00H		; `CSeqTrack::Play'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_pStateData$ = 12
_mtStart$ = 16
_mtEnd$ = 20
_mtOffset$ = 24
_dwFlags$ = 28
_pPerf$ = 32
_pSegSt$ = 36
_dwVirtualID$ = 40
?Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z PROC NEAR ; CSeqTrack::Play, COMDAT

; 872  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 873  : 	V_INAME(IDirectMusicTrack::Play);
; 874  : 	V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));

  00004	6a 2c		 push	 44			; 0000002cH
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L69999
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@EGFIFLCK@?$CFs?3?5Invalid?5pointer?5pStateData?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L69999:

; 875  : 	V_INTERFACE(pPerf);

  0002c	6a 04		 push	 4
  0002e	8b 4d 20	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L70001
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70001:
  00054	6a 04		 push	 4
  00056	8b 55 20	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00061	85 c0		 test	 eax, eax
  00063	74 19		 je	 SHORT $L70004
  00065	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  0006f	6a ff		 push	 -1
  00071	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	e8 00 00 00 00	 call	 _DebugBreak@0
$L70004:
  0007e	8b 4d 20	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  0008b	85 c0		 test	 eax, eax
  0008d	74 19		 je	 SHORT $L70006
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@ODDHKOOL@?$CFs?3?5Invalid?5pointer?5pPerf?6?$AA@
  00099	6a ff		 push	 -1
  0009b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	e8 00 00 00 00	 call	 _DebugBreak@0
$L70006:

; 876  : 	V_INTERFACE(pSegSt);

  000a8	6a 04		 push	 4
  000aa	8b 4d 24	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000b3	85 c0		 test	 eax, eax
  000b5	74 19		 je	 SHORT $L70008
  000b7	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
  000c1	6a ff		 push	 -1
  000c3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	e8 00 00 00 00	 call	 _DebugBreak@0
$L70008:
  000d0	6a 04		 push	 4
  000d2	8b 55 24	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  000d5	8b 02		 mov	 eax, DWORD PTR [edx]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000dd	85 c0		 test	 eax, eax
  000df	74 19		 je	 SHORT $L70011
  000e1	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
  000eb	6a ff		 push	 -1
  000ed	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	e8 00 00 00 00	 call	 _DebugBreak@0
$L70011:
  000fa	8b 4d 24	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ff	8b 02		 mov	 eax, DWORD PTR [edx]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00107	85 c0		 test	 eax, eax
  00109	74 19		 je	 SHORT $L70013
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z@4QBDB
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MNKGKLHC@?$CFs?3?5Invalid?5pointer?5pSegSt?6?$AA@
  00115	6a ff		 push	 -1
  00117	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70013:

; 877  : 
; 878  : 	ENTER_CRITICAL_SECTION(&m_CrSec);

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0012a	51		 push	 ecx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 879  : 	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);

  00131	6a 00		 push	 0
  00133	8b 55 28	 mov	 edx, DWORD PTR _dwVirtualID$[ebp]
  00136	52		 push	 edx
  00137	8b 45 24	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  0013a	50		 push	 eax
  0013b	8b 4d 20	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 1c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00142	52		 push	 edx
  00143	6a 00		 push	 0
  00145	6a 00		 push	 0
  00147	8b 45 18	 mov	 eax, DWORD PTR _mtOffset$[ebp]
  0014a	50		 push	 eax
  0014b	8b 4d 14	 mov	 ecx, DWORD PTR _mtEnd$[ebp]
  0014e	51		 push	 ecx
  0014f	8b 55 10	 mov	 edx, DWORD PTR _mtStart$[ebp]
  00152	52		 push	 edx
  00153	8b 45 0c	 mov	 eax, DWORD PTR _pStateData$[ebp]
  00156	50		 push	 eax
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	83 e9 04	 sub	 ecx, 4
  0015d	e8 00 00 00 00	 call	 ?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z ; CSeqTrack::Play
  00162	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 880  :     LEAVE_CRITICAL_SECTION(&m_CrSec);

  00165	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0016b	51		 push	 ecx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 881  : 	return hr;

  00172	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 882  : }

  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 24 00	 ret	 36			; 00000024H
?Play@CSeqTrack@@UAGJPAXJJJKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@K@Z ENDP ; CSeqTrack::Play
_TEXT	ENDS
PUBLIC	?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z ; CSeqTrack::Seek
EXTRN	?Reset@CPChMap@@QAEXXZ:NEAR			; CPChMap::Reset
EXTRN	?GetInfo@CPChMap@@QAEXKJJKPAUIDirectMusicPerformance@@PAHPAKH@Z:NEAR ; CPChMap::GetInfo
EXTRN	_IID_IDirectMusicGraph:BYTE
; Function compile flags: /Odt
;	COMDAT ?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z
_TEXT	SEGMENT
_this$ = -76
_pMidi$70099 = -72
_lTemp$70092 = -68
_pNote$70085 = -64
_rItem$70080 = -60
_fMute$70081 = -56
_lTemp$70068 = -52
_pCurve$70060 = -48
_rItem$70057 = -44
_pSD$ = -40
_pGraph$ = -36
_hr$ = -32
_dwIndex$ = -28
_pEvent$ = -24
_pPart$ = -20
_dwMutePChannel$ = -16
_fMute$ = -12
_fSeek$ = -8
_dwPChannel$ = -4
_pStateData$ = 8
_mtStart$ = 12
_mtEnd$ = 16
_mtOffset$ = 20
_rtOffset$ = 24
_dwFlags$ = 32
_pPerf$ = 36
_pSegSt$ = 40
_dwVirtualID$ = 44
_fClockTime$ = 48
?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z PROC NEAR ; CSeqTrack::Play, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 902  :     if (dwFlags & DMUS_TRACKF_PLAY_OFF)

  00009	8b 45 20	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0000c	83 e0 40	 and	 eax, 64			; 00000040H
  0000f	85 c0		 test	 eax, eax
  00011	74 07		 je	 SHORT $L70028

; 903  :     {
; 904  : 	    return S_OK;

  00013	33 c0		 xor	 eax, eax
  00015	e9 8b 07 00 00	 jmp	 $L70027
$L70028:

; 905  :     }
; 906  : 	HRESULT	hr = S_OK;

  0001a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 907  : 	IDirectMusicGraph* pGraph = NULL;

  00021	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pGraph$[ebp], 0

; 908  : 	DMUS_PMSG* pEvent = NULL;

  00028	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pEvent$[ebp], 0

; 909  : 	SeqStateData* pSD = (SeqStateData*)pStateData;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _pStateData$[ebp]
  00032	89 4d d8	 mov	 DWORD PTR _pSD$[ebp], ecx

; 910  : 	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

  00035	8b 55 20	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00038	83 e2 01	 and	 edx, 1
  0003b	f7 da		 neg	 edx
  0003d	1b d2		 sbb	 edx, edx
  0003f	f7 da		 neg	 edx
  00041	89 55 f8	 mov	 DWORD PTR _fSeek$[ebp], edx

; 911  : 
; 912  : 	if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
; 913  : 		DMUS_TRACKF_LOOP) )

  00044	8b 45 20	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00047	83 e0 1b	 and	 eax, 27			; 0000001bH
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $L70037

; 914  : 	{
; 915  : 		// need to reset the PChannel Map in case of any of these flags.
; 916  : 		m_PChMap.Reset();

  0004e	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 40	 add	 ecx, 64			; 00000040H
  00054	e8 00 00 00 00	 call	 ?Reset@CPChMap@@QAEXXZ	; CPChMap::Reset
$L70037:

; 917  : 	}
; 918  : 
; 919  : 	if( pSD->dwValidate != m_dwValidate )

  00059	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0005c	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00062	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  00065	74 13		 je	 SHORT $L70038

; 920  : 	{
; 921  : 		SetUpStateCurrentPointers(pSD);

  00067	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0006a	51		 push	 ecx
  0006b	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?SetUpStateCurrentPointers@CSeqTrack@@IAEXPAUSeqStateData@@@Z ; CSeqTrack::SetUpStateCurrentPointers

; 922  : 		fSeek = TRUE;

  00073	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fSeek$[ebp], 1
$L70038:

; 923  : 	}
; 924  : 
; 925  : 	if( fSeek )

  0007a	83 7d f8 00	 cmp	 DWORD PTR _fSeek$[ebp], 0
  0007e	74 6a		 je	 SHORT $L70039

; 926  : 	{
; 927  : 		if( dwFlags & DMUS_TRACKF_START )

  00080	8b 55 20	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00083	83 e2 04	 and	 edx, 4
  00086	85 d2		 test	 edx, edx
  00088	74 31		 je	 SHORT $L70040

; 928  : 		{
; 929  : 			Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, TRUE, mtOffset, rtOffset, fClockTime );

  0008a	8b 45 30	 mov	 eax, DWORD PTR _fClockTime$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d 1c	 mov	 ecx, DWORD PTR _rtOffset$[ebp+4]
  00091	51		 push	 ecx
  00092	8b 55 18	 mov	 edx, DWORD PTR _rtOffset$[ebp]
  00095	52		 push	 edx
  00096	8b 45 14	 mov	 eax, DWORD PTR _mtOffset$[ebp]
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  000a3	52		 push	 edx
  000a4	8b 45 2c	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d 24	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 28	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  000af	52		 push	 edx
  000b0	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z ; CSeqTrack::Seek

; 930  : 		}
; 931  : 		else

  000b9	eb 2f		 jmp	 SHORT $L70039
$L70040:

; 932  : 		{
; 933  : 			Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, FALSE, mtOffset, rtOffset, fClockTime );

  000bb	8b 4d 30	 mov	 ecx, DWORD PTR _fClockTime$[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 1c	 mov	 edx, DWORD PTR _rtOffset$[ebp+4]
  000c2	52		 push	 edx
  000c3	8b 45 18	 mov	 eax, DWORD PTR _rtOffset$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d 14	 mov	 ecx, DWORD PTR _mtOffset$[ebp]
  000ca	51		 push	 ecx
  000cb	6a 00		 push	 0
  000cd	8b 55 0c	 mov	 edx, DWORD PTR _mtStart$[ebp]
  000d0	52		 push	 edx
  000d1	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 2c	 mov	 ecx, DWORD PTR _dwVirtualID$[ebp]
  000d8	51		 push	 ecx
  000d9	8b 55 24	 mov	 edx, DWORD PTR _pPerf$[ebp]
  000dc	52		 push	 edx
  000dd	8b 45 28	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 ?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z ; CSeqTrack::Seek
$L70039:

; 934  : 		}
; 935  : 	}
; 936  : 
; 937  : 	if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
; 938  : 		(void**)&pGraph )))

  000ea	8d 55 dc	 lea	 edx, DWORD PTR _pGraph$[ebp]
  000ed	52		 push	 edx
  000ee	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGraph
  000f3	8b 45 28	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  000f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f8	8b 55 28	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  000fb	52		 push	 edx
  000fc	ff 11		 call	 DWORD PTR [ecx]
  000fe	85 c0		 test	 eax, eax
  00100	7d 07		 jge	 SHORT $L70044

; 939  : 	{
; 940  : 		pGraph = NULL;

  00102	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pGraph$[ebp], 0
$L70044:

; 941  : 	}
; 942  : 
; 943  : 	DWORD dwIndex;
; 944  : 	DWORD dwPChannel;
; 945  : 	DWORD dwMutePChannel;
; 946  : 	BOOL fMute;
; 947  : 	TListItem<SEQ_PART>* pPart = m_SeqPartList.GetHead();

  00109	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	83 c1 08	 add	 ecx, 8
  0010f	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  00114	89 45 ec	 mov	 DWORD PTR _pPart$[ebp], eax

; 948  : 	for( dwIndex = 0; pPart && (dwIndex < m_dwPChannelsUsed); dwIndex++,pPart = pPart->GetNext() )

  00117	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0
  0011e	eb 14		 jmp	 SHORT $L70050
$L70051:
  00120	8b 45 e4	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00123	83 c0 01	 add	 eax, 1
  00126	89 45 e4	 mov	 DWORD PTR _dwIndex$[ebp], eax
  00129	8b 4d ec	 mov	 ecx, DWORD PTR _pPart$[ebp]
  0012c	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  00131	89 45 ec	 mov	 DWORD PTR _pPart$[ebp], eax
$L70050:
  00134	83 7d ec 00	 cmp	 DWORD PTR _pPart$[ebp], 0
  00138	0f 84 52 06 00
	00		 je	 $L70052
  0013e	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00144	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00147	0f 83 43 06 00
	00		 jae	 $L70052

; 949  : 	{
; 950  : 		dwPChannel = pPart->GetItemValue().dwPChannel;

  0014d	8b 4d ec	 mov	 ecx, DWORD PTR _pPart$[ebp]
  00150	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00155	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00158	89 45 fc	 mov	 DWORD PTR _dwPChannel$[ebp], eax

; 951  : 		if( pSD->apCurrentCurve )

  0015b	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0015e	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00162	0f 84 bd 02 00
	00		 je	 $L70053

; 952  : 		{
; 953  : 			for( ; pSD->apCurrentCurve[dwIndex]; 

  00168	eb 1d		 jmp	 SHORT $L70054
$L70055:

; 954  : 				pSD->apCurrentCurve[dwIndex] = pSD->apCurrentCurve[dwIndex]->GetNext() )

  0016a	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  0016d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00170	8b 4d e4	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00173	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00176	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
  0017b	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  0017e	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00181	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00184	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
$L70054:
  00187	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  0018a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0018d	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00190	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  00194	0f 84 8b 02 00
	00		 je	 $L70053

; 955  : 			{
; 956  : 				DMUS_IO_CURVE_ITEM& rItem = pSD->apCurrentCurve[dwIndex]->GetItemValue();

  0019a	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  0019d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001a0	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  001a3	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  001a6	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  001ab	89 45 d4	 mov	 DWORD PTR _rItem$70057[ebp], eax

; 957  : 				if( rItem.mtStart >= mtEnd )

  001ae	8b 45 d4	 mov	 eax, DWORD PTR _rItem$70057[ebp]
  001b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b3	3b 4d 10	 cmp	 ecx, DWORD PTR _mtEnd$[ebp]
  001b6	7c 05		 jl	 SHORT $L70058

; 958  : 				{
; 959  : 					break;

  001b8	e9 68 02 00 00	 jmp	 $L70053
$L70058:

; 960  : 				}
; 961  : 				m_PChMap.GetInfo( dwPChannel, rItem.mtStart, mtOffset, pSD->dwGroupBits,
; 962  : 					pPerf, &fMute, &dwMutePChannel, fClockTime );

  001bd	8b 55 30	 mov	 edx, DWORD PTR _fClockTime$[ebp]
  001c0	52		 push	 edx
  001c1	8d 45 f0	 lea	 eax, DWORD PTR _dwMutePChannel$[ebp]
  001c4	50		 push	 eax
  001c5	8d 4d f4	 lea	 ecx, DWORD PTR _fMute$[ebp]
  001c8	51		 push	 ecx
  001c9	8b 55 24	 mov	 edx, DWORD PTR _pPerf$[ebp]
  001cc	52		 push	 edx
  001cd	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  001d0	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001d3	51		 push	 ecx
  001d4	8b 55 14	 mov	 edx, DWORD PTR _mtOffset$[ebp]
  001d7	52		 push	 edx
  001d8	8b 45 d4	 mov	 eax, DWORD PTR _rItem$70057[ebp]
  001db	8b 08		 mov	 ecx, DWORD PTR [eax]
  001dd	51		 push	 ecx
  001de	8b 55 fc	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  001e1	52		 push	 edx
  001e2	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	83 c1 40	 add	 ecx, 64			; 00000040H
  001e8	e8 00 00 00 00	 call	 ?GetInfo@CPChMap@@QAEXKJJKPAUIDirectMusicPerformance@@PAHPAKH@Z ; CPChMap::GetInfo

; 963  : 				if( !fMute )

  001ed	83 7d f4 00	 cmp	 DWORD PTR _fMute$[ebp], 0
  001f1	0f 85 29 02 00
	00		 jne	 $L70059

; 964  : 				{
; 965  : 					DMUS_CURVE_PMSG* pCurve;
; 966  : 					if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
; 967  : 						(DMUS_PMSG**)&pCurve )))

  001f7	8d 45 d0	 lea	 eax, DWORD PTR _pCurve$70060[ebp]
  001fa	50		 push	 eax
  001fb	6a 58		 push	 88			; 00000058H
  001fd	8b 4d 24	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00200	8b 11		 mov	 edx, DWORD PTR [ecx]
  00202	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00205	50		 push	 eax
  00206	ff 52 24	 call	 DWORD PTR [edx+36]
  00209	85 c0		 test	 eax, eax
  0020b	0f 8c 0f 02 00
	00		 jl	 $L70059

; 968  : 					{
; 969  : 						pEvent = (DMUS_PMSG*)pCurve;

  00211	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00214	89 4d e8	 mov	 DWORD PTR _pEvent$[ebp], ecx

; 970  :                         if (fClockTime)

  00217	83 7d 30 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  0021b	74 5a		 je	 SHORT $L70066

; 971  :                         {
; 972  : 						    pCurve->wMeasure = 0;

  0021d	8b 55 d0	 mov	 edx, DWORD PTR _pCurve$70060[ebp]
  00220	66 c7 42 4a 00
	00		 mov	 WORD PTR [edx+74], 0

; 973  : 						    pCurve->bBeat = 0;

  00226	8b 45 d0	 mov	 eax, DWORD PTR _pCurve$70060[ebp]
  00229	c6 40 4e 00	 mov	 BYTE PTR [eax+78], 0

; 974  : 						    pCurve->bGrid = 0;

  0022d	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00230	c6 41 4f 00	 mov	 BYTE PTR [ecx+79], 0

; 975  : 						    pCurve->nOffset = rItem.nOffset;

  00234	8b 55 d0	 mov	 edx, DWORD PTR _pCurve$70060[ebp]
  00237	8b 45 d4	 mov	 eax, DWORD PTR _rItem$70057[ebp]
  0023a	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  0023e	66 89 4a 4c	 mov	 WORD PTR [edx+76], cx

; 976  : 						    pCurve->rtTime = ((rItem.mtStart + rItem.nOffset) * REF_PER_MIL) + rtOffset;

  00242	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  00245	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00249	8b 4d d4	 mov	 ecx, DWORD PTR _rItem$70057[ebp]
  0024c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024e	03 d0		 add	 edx, eax
  00250	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  00256	8b c2		 mov	 eax, edx
  00258	99		 cdq
  00259	03 45 18	 add	 eax, DWORD PTR _rtOffset$[ebp]
  0025c	13 55 1c	 adc	 edx, DWORD PTR _rtOffset$[ebp+4]
  0025f	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00262	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00265	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 977  :                             // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
; 978  : 						    pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;

  00268	8b 55 d0	 mov	 edx, DWORD PTR _pCurve$70060[ebp]
  0026b	c7 42 14 c1 00
	00 00		 mov	 DWORD PTR [edx+20], 193	; 000000c1H

; 979  :                         }
; 980  :                         else

  00272	e9 b9 00 00 00	 jmp	 $L70067
$L70066:

; 981  :                         {
; 982  : 						    UpdateTimeSig( pSegSt, pSD, rItem.mtStart);

  00277	8b 45 d4	 mov	 eax, DWORD PTR _rItem$70057[ebp]
  0027a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027c	51		 push	 ecx
  0027d	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  00280	52		 push	 edx
  00281	8b 45 28	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  00284	50		 push	 eax
  00285	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00288	e8 00 00 00 00	 call	 ?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z ; CSeqTrack::UpdateTimeSig

; 983  : 						    long lTemp = (rItem.mtStart - pSD->mtCurTimeSig);

  0028d	8b 4d d4	 mov	 ecx, DWORD PTR _rItem$70057[ebp]
  00290	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  00293	8b 01		 mov	 eax, DWORD PTR [ecx]
  00295	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00298	89 45 cc	 mov	 DWORD PTR _lTemp$70068[ebp], eax

; 984  : 						    pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);

  0029b	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0029e	8b 45 cc	 mov	 eax, DWORD PTR _lTemp$70068[ebp]
  002a1	33 d2		 xor	 edx, edx
  002a3	f7 71 20	 div	 DWORD PTR [ecx+32]
  002a6	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  002a9	03 42 18	 add	 eax, DWORD PTR [edx+24]
  002ac	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  002af	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 985  : 						    lTemp = lTemp % pSD->dwlnMeasure;

  002b3	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002b6	8b 45 cc	 mov	 eax, DWORD PTR _lTemp$70068[ebp]
  002b9	33 d2		 xor	 edx, edx
  002bb	f7 71 20	 div	 DWORD PTR [ecx+32]
  002be	89 55 cc	 mov	 DWORD PTR _lTemp$70068[ebp], edx

; 986  : 						    pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);

  002c1	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002c4	8b 45 cc	 mov	 eax, DWORD PTR _lTemp$70068[ebp]
  002c7	33 d2		 xor	 edx, edx
  002c9	f7 71 1c	 div	 DWORD PTR [ecx+28]
  002cc	8b 55 d0	 mov	 edx, DWORD PTR _pCurve$70060[ebp]
  002cf	88 42 4e	 mov	 BYTE PTR [edx+78], al

; 987  : 						    lTemp = lTemp % pSD->dwlnBeat;

  002d2	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002d5	8b 45 cc	 mov	 eax, DWORD PTR _lTemp$70068[ebp]
  002d8	33 d2		 xor	 edx, edx
  002da	f7 71 1c	 div	 DWORD PTR [ecx+28]
  002dd	89 55 cc	 mov	 DWORD PTR _lTemp$70068[ebp], edx

; 988  : 						    pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);

  002e0	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002e3	8b 45 cc	 mov	 eax, DWORD PTR _lTemp$70068[ebp]
  002e6	33 d2		 xor	 edx, edx
  002e8	f7 71 24	 div	 DWORD PTR [ecx+36]
  002eb	8b 55 d0	 mov	 edx, DWORD PTR _pCurve$70060[ebp]
  002ee	88 42 4f	 mov	 BYTE PTR [edx+79], al

; 989  : 						    //pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid);
; 990  : 						    pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;

  002f1	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002f4	8b 45 cc	 mov	 eax, DWORD PTR _lTemp$70068[ebp]
  002f7	33 d2		 xor	 edx, edx
  002f9	f7 71 24	 div	 DWORD PTR [ecx+36]
  002fc	0f bf d2	 movsx	 edx, dx
  002ff	8b 45 d4	 mov	 eax, DWORD PTR _rItem$70057[ebp]
  00302	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00306	03 d1		 add	 edx, ecx
  00308	8b 45 d0	 mov	 eax, DWORD PTR _pCurve$70060[ebp]
  0030b	66 89 50 4c	 mov	 WORD PTR [eax+76], dx

; 991  : 						    pCurve->mtTime = rItem.mtStart + mtOffset + rItem.nOffset;

  0030f	8b 4d d4	 mov	 ecx, DWORD PTR _rItem$70057[ebp]
  00312	8b 11		 mov	 edx, DWORD PTR [ecx]
  00314	03 55 14	 add	 edx, DWORD PTR _mtOffset$[ebp]
  00317	8b 45 d4	 mov	 eax, DWORD PTR _rItem$70057[ebp]
  0031a	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0031e	03 d1		 add	 edx, ecx
  00320	8b 45 d0	 mov	 eax, DWORD PTR _pCurve$70060[ebp]
  00323	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 992  :                             // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
; 993  : 						    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8;

  00326	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00329	c7 41 14 82 00
	00 00		 mov	 DWORD PTR [ecx+20], 130	; 00000082H
$L70067:

; 994  :                         }
; 995  : 						pCurve->dwPChannel = dwMutePChannel;

  00330	8b 55 d0	 mov	 edx, DWORD PTR _pCurve$70060[ebp]
  00333	8b 45 f0	 mov	 eax, DWORD PTR _dwMutePChannel$[ebp]
  00336	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 996  : 						pCurve->dwVirtualTrackID = dwVirtualID;

  00339	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  0033c	8b 55 2c	 mov	 edx, DWORD PTR _dwVirtualID$[ebp]
  0033f	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 997  : 						pCurve->dwType = DMUS_PMSGT_CURVE;

  00342	8b 45 d0	 mov	 eax, DWORD PTR _pCurve$70060[ebp]
  00345	c7 40 28 05 00
	00 00		 mov	 DWORD PTR [eax+40], 5

; 998  : 						pCurve->mtDuration = rItem.mtDuration;

  0034c	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  0034f	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  00352	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00355	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 999  : 						pCurve->mtResetDuration = rItem.mtResetDuration;

  00358	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  0035b	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  0035e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00361	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 1000 : 						pCurve->nStartValue = rItem.nStartValue;

  00364	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00367	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  0036a	66 8b 42 12	 mov	 ax, WORD PTR [edx+18]
  0036e	66 89 41 44	 mov	 WORD PTR [ecx+68], ax

; 1001 : 						pCurve->nEndValue = rItem.nEndValue;

  00372	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00375	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  00378	66 8b 42 14	 mov	 ax, WORD PTR [edx+20]
  0037c	66 89 41 46	 mov	 WORD PTR [ecx+70], ax

; 1002 : 						pCurve->nResetValue = rItem.nResetValue;

  00380	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00383	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  00386	66 8b 42 16	 mov	 ax, WORD PTR [edx+22]
  0038a	66 89 41 48	 mov	 WORD PTR [ecx+72], ax

; 1003 : 						pCurve->bType = rItem.bType;

  0038e	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  00391	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  00394	8a 42 18	 mov	 al, BYTE PTR [edx+24]
  00397	88 41 50	 mov	 BYTE PTR [ecx+80], al

; 1004 : 						pCurve->bCurveShape = rItem.bCurveShape;

  0039a	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  0039d	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  003a0	8a 42 19	 mov	 al, BYTE PTR [edx+25]
  003a3	88 41 51	 mov	 BYTE PTR [ecx+81], al

; 1005 : 						pCurve->bCCData = rItem.bCCData;

  003a6	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  003a9	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  003ac	8a 42 1a	 mov	 al, BYTE PTR [edx+26]
  003af	88 41 52	 mov	 BYTE PTR [ecx+82], al

; 1006 : 						pCurve->bFlags = rItem.bFlags;

  003b2	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  003b5	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  003b8	8a 42 1b	 mov	 al, BYTE PTR [edx+27]
  003bb	88 41 53	 mov	 BYTE PTR [ecx+83], al

; 1007 :                         pCurve->wParamType = rItem.wParamType;

  003be	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  003c1	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  003c4	66 8b 42 1c	 mov	 ax, WORD PTR [edx+28]
  003c8	66 89 41 54	 mov	 WORD PTR [ecx+84], ax

; 1008 :                         pCurve->wMergeIndex = rItem.wMergeIndex;

  003cc	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  003cf	8b 55 d4	 mov	 edx, DWORD PTR _rItem$70057[ebp]
  003d2	66 8b 42 1e	 mov	 ax, WORD PTR [edx+30]
  003d6	66 89 41 56	 mov	 WORD PTR [ecx+86], ax

; 1009 : 						pCurve->dwGroupID = pSD->dwGroupBits;

  003da	8b 4d d0	 mov	 ecx, DWORD PTR _pCurve$70060[ebp]
  003dd	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  003e0	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  003e3	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 1010 : 
; 1011 : 						if( pGraph )

  003e6	83 7d dc 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  003ea	74 10		 je	 SHORT $L70073

; 1012 : 						{
; 1013 : 							pGraph->StampPMsg( pEvent );

  003ec	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  003ef	51		 push	 ecx
  003f0	8b 55 dc	 mov	 edx, DWORD PTR _pGraph$[ebp]
  003f3	8b 02		 mov	 eax, DWORD PTR [edx]
  003f5	8b 4d dc	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  003f8	51		 push	 ecx
  003f9	ff 50 0c	 call	 DWORD PTR [eax+12]
$L70073:

; 1014 : 						}
; 1015 : 						if(FAILED(pPerf->SendPMsg( pEvent )))

  003fc	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  003ff	52		 push	 edx
  00400	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00403	8b 08		 mov	 ecx, DWORD PTR [eax]
  00405	8b 55 24	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00408	52		 push	 edx
  00409	ff 51 10	 call	 DWORD PTR [ecx+16]
  0040c	85 c0		 test	 eax, eax
  0040e	7d 10		 jge	 SHORT $L70059

; 1016 : 						{
; 1017 : 							pPerf->FreePMsg(pEvent);

  00410	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00413	50		 push	 eax
  00414	8b 4d 24	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00417	8b 11		 mov	 edx, DWORD PTR [ecx]
  00419	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0041c	50		 push	 eax
  0041d	ff 52 28	 call	 DWORD PTR [edx+40]
$L70059:

; 1018 : 						}
; 1019 : 					}
; 1020 : 				}
; 1021 : 			}

  00420	e9 45 fd ff ff	 jmp	 $L70055
$L70053:

; 1022 : 		}
; 1023 : 		if( pSD->apCurrentSeq )

  00425	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00428	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0042c	0f 84 59 03 00
	00		 je	 $L70076

; 1024 : 		{
; 1025 : 			for( ; pSD->apCurrentSeq[dwIndex]; 

  00432	eb 1d		 jmp	 SHORT $L70077
$L70078:

; 1026 : 				pSD->apCurrentSeq[dwIndex] = pSD->apCurrentSeq[dwIndex]->GetNext() )

  00434	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  00437	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0043a	8b 4d e4	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0043d	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00440	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
  00445	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  00448	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0044b	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0044e	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
$L70077:
  00451	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  00454	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00457	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0045a	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  0045e	0f 84 27 03 00
	00		 je	 $L70076

; 1027 : 			{
; 1028 : 				DMUS_IO_SEQ_ITEM& rItem = pSD->apCurrentSeq[dwIndex]->GetItemValue();

  00464	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  00467	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0046a	8b 55 e4	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0046d	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00470	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
  00475	89 45 c4	 mov	 DWORD PTR _rItem$70080[ebp], eax

; 1029 : 				BOOL fMute;
; 1030 : 				if( rItem.mtTime >= mtEnd )

  00478	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  0047b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0047d	3b 4d 10	 cmp	 ecx, DWORD PTR _mtEnd$[ebp]
  00480	7c 05		 jl	 SHORT $L70082

; 1031 : 				{
; 1032 : 					break;

  00482	e9 04 03 00 00	 jmp	 $L70076
$L70082:

; 1033 : 				}
; 1034 : 				m_PChMap.GetInfo( dwPChannel, rItem.mtTime, mtOffset, pSD->dwGroupBits,
; 1035 : 					pPerf, &fMute, &dwMutePChannel, fClockTime );

  00487	8b 55 30	 mov	 edx, DWORD PTR _fClockTime$[ebp]
  0048a	52		 push	 edx
  0048b	8d 45 f0	 lea	 eax, DWORD PTR _dwMutePChannel$[ebp]
  0048e	50		 push	 eax
  0048f	8d 4d c8	 lea	 ecx, DWORD PTR _fMute$70081[ebp]
  00492	51		 push	 ecx
  00493	8b 55 24	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00496	52		 push	 edx
  00497	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  0049a	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0049d	51		 push	 ecx
  0049e	8b 55 14	 mov	 edx, DWORD PTR _mtOffset$[ebp]
  004a1	52		 push	 edx
  004a2	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  004a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004a7	51		 push	 ecx
  004a8	8b 55 fc	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  004ab	52		 push	 edx
  004ac	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  004af	83 c1 40	 add	 ecx, 64			; 00000040H
  004b2	e8 00 00 00 00	 call	 ?GetInfo@CPChMap@@QAEXKJJKPAUIDirectMusicPerformance@@PAHPAKH@Z ; CPChMap::GetInfo

; 1036 : 				if( !fMute )

  004b7	83 7d c8 00	 cmp	 DWORD PTR _fMute$70081[ebp], 0
  004bb	0f 85 c5 02 00
	00		 jne	 $L70083

; 1037 : 				{
; 1038 : 					if( (rItem.bStatus & 0xf0) == 0x90 )

  004c1	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  004c4	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  004c8	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  004ce	81 f9 90 00 00
	00		 cmp	 ecx, 144		; 00000090H
  004d4	0f 85 aa 01 00
	00		 jne	 $L70084

; 1039 : 					{
; 1040 : 						// this is a note event
; 1041 : 						DMUS_NOTE_PMSG* pNote;
; 1042 : 						if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
; 1043 : 							(DMUS_PMSG**)&pNote )))

  004da	8d 55 c0	 lea	 edx, DWORD PTR _pNote$70085[ebp]
  004dd	52		 push	 edx
  004de	6a 50		 push	 80			; 00000050H
  004e0	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  004e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e5	8b 55 24	 mov	 edx, DWORD PTR _pPerf$[ebp]
  004e8	52		 push	 edx
  004e9	ff 51 24	 call	 DWORD PTR [ecx+36]
  004ec	85 c0		 test	 eax, eax
  004ee	0f 8c 8b 01 00
	00		 jl	 $L70089

; 1044 : 						{
; 1045 : 							pNote->bFlags = DMUS_NOTEF_NOTEON;

  004f4	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  004f7	c6 40 45 01	 mov	 BYTE PTR [eax+69], 1

; 1046 : 							pNote->mtDuration = rItem.mtDuration;

  004fb	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  004fe	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  00501	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00504	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1047 : 							pNote->bMidiValue = rItem.bByte1;

  00507	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  0050a	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  0050d	8a 42 0f	 mov	 al, BYTE PTR [edx+15]
  00510	88 41 4b	 mov	 BYTE PTR [ecx+75], al

; 1048 : 							pNote->bVelocity = rItem.bByte2;

  00513	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  00516	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  00519	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  0051c	88 41 44	 mov	 BYTE PTR [ecx+68], al

; 1049 : 							pNote->dwType = DMUS_PMSGT_NOTE;

  0051f	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  00522	c7 41 28 01 00
	00 00		 mov	 DWORD PTR [ecx+40], 1

; 1050 : 							pNote->bPlayModeFlags = DMUS_PLAYMODE_FIXED;

  00529	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  0052c	c6 42 49 00	 mov	 BYTE PTR [edx+73], 0

; 1051 : 							pNote->wMusicValue = pNote->bMidiValue;

  00530	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  00533	66 0f b6 48 4b	 movzx	 cx, BYTE PTR [eax+75]
  00538	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  0053b	66 89 4a 3c	 mov	 WORD PTR [edx+60], cx

; 1052 : 							pNote->bSubChordLevel = 0;  // SUBCHORD_BASS 

  0053f	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  00542	c6 40 4a 00	 mov	 BYTE PTR [eax+74], 0

; 1053 :                             if (fClockTime)

  00546	83 7d 30 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  0054a	74 58		 je	 SHORT $L70090

; 1054 :                             {
; 1055 :                                 pNote->rtTime = ((rItem.mtTime + rItem.nOffset) * REF_PER_MIL) + rtOffset;

  0054c	8b 4d c4	 mov	 ecx, DWORD PTR _rItem$70080[ebp]
  0054f	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  00553	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  00556	8b 00		 mov	 eax, DWORD PTR [eax]
  00558	03 c2		 add	 eax, edx
  0055a	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  00560	99		 cdq
  00561	03 45 18	 add	 eax, DWORD PTR _rtOffset$[ebp]
  00564	13 55 1c	 adc	 edx, DWORD PTR _rtOffset$[ebp+4]
  00567	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  0056a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0056d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1056 :                                 pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

  00570	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  00573	c7 42 14 41 00
	00 00		 mov	 DWORD PTR [edx+20], 65	; 00000041H

; 1057 :                                 pNote->wMeasure = 0;

  0057a	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  0057d	66 c7 40 3e 00
	00		 mov	 WORD PTR [eax+62], 0

; 1058 :                                 pNote->bBeat = 0;

  00583	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  00586	c6 41 42 00	 mov	 BYTE PTR [ecx+66], 0

; 1059 :                                 pNote->bGrid = 0;

  0058a	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  0058d	c6 42 43 00	 mov	 BYTE PTR [edx+67], 0

; 1060 :                                 pNote->nOffset = rItem.nOffset;

  00591	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  00594	8b 4d c4	 mov	 ecx, DWORD PTR _rItem$70080[ebp]
  00597	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  0059b	66 89 50 40	 mov	 WORD PTR [eax+64], dx

; 1061 :                             }
; 1062 :                             else

  0059f	e9 b9 00 00 00	 jmp	 $L70091
$L70090:

; 1063 :                             {
; 1064 :                                 pNote->mtTime = rItem.mtTime + mtOffset + rItem.nOffset;

  005a4	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  005a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  005a9	03 4d 14	 add	 ecx, DWORD PTR _mtOffset$[ebp]
  005ac	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  005af	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  005b3	03 c8		 add	 ecx, eax
  005b5	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  005b8	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1065 : 							    UpdateTimeSig( pSegSt, pSD, rItem.mtTime );

  005bb	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  005be	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c0	51		 push	 ecx
  005c1	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  005c4	52		 push	 edx
  005c5	8b 45 28	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  005c8	50		 push	 eax
  005c9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  005cc	e8 00 00 00 00	 call	 ?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z ; CSeqTrack::UpdateTimeSig

; 1066 :                                 pNote->dwFlags = DMUS_PMSGF_MUSICTIME;

  005d1	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  005d4	c7 41 14 02 00
	00 00		 mov	 DWORD PTR [ecx+20], 2

; 1067 : 							    long lTemp = (rItem.mtTime - pSD->mtCurTimeSig);

  005db	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  005de	8b 45 d8	 mov	 eax, DWORD PTR _pSD$[ebp]
  005e1	8b 0a		 mov	 ecx, DWORD PTR [edx]
  005e3	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  005e6	89 4d bc	 mov	 DWORD PTR _lTemp$70092[ebp], ecx

; 1068 : 							    pNote->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);

  005e9	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  005ec	8b 45 bc	 mov	 eax, DWORD PTR _lTemp$70092[ebp]
  005ef	33 d2		 xor	 edx, edx
  005f1	f7 71 20	 div	 DWORD PTR [ecx+32]
  005f4	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  005f7	03 42 18	 add	 eax, DWORD PTR [edx+24]
  005fa	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  005fd	66 89 41 3e	 mov	 WORD PTR [ecx+62], ax

; 1069 : 							    lTemp = lTemp % pSD->dwlnMeasure;

  00601	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00604	8b 45 bc	 mov	 eax, DWORD PTR _lTemp$70092[ebp]
  00607	33 d2		 xor	 edx, edx
  00609	f7 71 20	 div	 DWORD PTR [ecx+32]
  0060c	89 55 bc	 mov	 DWORD PTR _lTemp$70092[ebp], edx

; 1070 : 							    pNote->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);

  0060f	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00612	8b 45 bc	 mov	 eax, DWORD PTR _lTemp$70092[ebp]
  00615	33 d2		 xor	 edx, edx
  00617	f7 71 1c	 div	 DWORD PTR [ecx+28]
  0061a	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  0061d	88 42 42	 mov	 BYTE PTR [edx+66], al

; 1071 : 							    lTemp = lTemp % pSD->dwlnBeat;

  00620	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00623	8b 45 bc	 mov	 eax, DWORD PTR _lTemp$70092[ebp]
  00626	33 d2		 xor	 edx, edx
  00628	f7 71 1c	 div	 DWORD PTR [ecx+28]
  0062b	89 55 bc	 mov	 DWORD PTR _lTemp$70092[ebp], edx

; 1072 : 							    pNote->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);

  0062e	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00631	8b 45 bc	 mov	 eax, DWORD PTR _lTemp$70092[ebp]
  00634	33 d2		 xor	 edx, edx
  00636	f7 71 24	 div	 DWORD PTR [ecx+36]
  00639	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  0063c	88 42 43	 mov	 BYTE PTR [edx+67], al

; 1073 : 							    //pNote->nOffset = (short)(lTemp % pSD->dwlnGrid);
; 1074 : 							    pNote->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;

  0063f	8b 4d d8	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00642	8b 45 bc	 mov	 eax, DWORD PTR _lTemp$70092[ebp]
  00645	33 d2		 xor	 edx, edx
  00647	f7 71 24	 div	 DWORD PTR [ecx+36]
  0064a	0f bf d2	 movsx	 edx, dx
  0064d	8b 45 c4	 mov	 eax, DWORD PTR _rItem$70080[ebp]
  00650	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00654	03 d1		 add	 edx, ecx
  00656	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  00659	66 89 50 40	 mov	 WORD PTR [eax+64], dx
$L70091:

; 1075 :                             }
; 1076 : 							pNote->bTimeRange = 0;

  0065d	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  00660	c6 41 46 00	 mov	 BYTE PTR [ecx+70], 0

; 1077 : 							pNote->bDurRange = 0;

  00664	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  00667	c6 42 47 00	 mov	 BYTE PTR [edx+71], 0

; 1078 : 							pNote->bVelRange = 0;

  0066b	8b 45 c0	 mov	 eax, DWORD PTR _pNote$70085[ebp]
  0066e	c6 40 48 00	 mov	 BYTE PTR [eax+72], 0

; 1079 : 							pNote->cTranspose = 0;

  00672	8b 4d c0	 mov	 ecx, DWORD PTR _pNote$70085[ebp]
  00675	c6 41 4c 00	 mov	 BYTE PTR [ecx+76], 0

; 1080 : 							pEvent = (DMUS_PMSG*)pNote;

  00679	8b 55 c0	 mov	 edx, DWORD PTR _pNote$70085[ebp]
  0067c	89 55 e8	 mov	 DWORD PTR _pEvent$[ebp], edx
$L70089:

; 1081 : 						}
; 1082 : 					}
; 1083 : 					else

  0067f	e9 a4 00 00 00	 jmp	 $L70098
$L70084:

; 1084 : 					{
; 1085 : 						// it's a MIDI short that's not a note
; 1086 : 						DMUS_MIDI_PMSG* pMidi;
; 1087 : 						if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
; 1088 : 							(DMUS_PMSG**)&pMidi )))

  00684	8d 45 b8	 lea	 eax, DWORD PTR _pMidi$70099[ebp]
  00687	50		 push	 eax
  00688	6a 40		 push	 64			; 00000040H
  0068a	8b 4d 24	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0068d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0068f	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00692	50		 push	 eax
  00693	ff 52 24	 call	 DWORD PTR [edx+36]
  00696	85 c0		 test	 eax, eax
  00698	0f 8c 8a 00 00
	00		 jl	 $L70098

; 1089 : 						{
; 1090 : 							pMidi->bStatus = rItem.bStatus & 0xf0;

  0069e	8b 4d c4	 mov	 ecx, DWORD PTR _rItem$70080[ebp]
  006a1	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  006a5	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  006ab	8b 45 b8	 mov	 eax, DWORD PTR _pMidi$70099[ebp]
  006ae	88 50 38	 mov	 BYTE PTR [eax+56], dl

; 1091 : 							pMidi->bByte1 = rItem.bByte1;

  006b1	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  006b4	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  006b7	8a 42 0f	 mov	 al, BYTE PTR [edx+15]
  006ba	88 41 39	 mov	 BYTE PTR [ecx+57], al

; 1092 : 							pMidi->bByte2 = rItem.bByte2;

  006bd	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  006c0	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  006c3	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  006c6	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 1093 : 							pMidi->dwType = DMUS_PMSGT_MIDI;

  006c9	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  006cc	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 1094 :                             if (fClockTime)

  006d3	83 7d 30 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  006d7	74 2c		 je	 SHORT $L70104

; 1095 :                             {
; 1096 :                                 pMidi->rtTime = (rItem.mtTime * REF_PER_MIL) + rtOffset;

  006d9	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  006dc	8b 02		 mov	 eax, DWORD PTR [edx]
  006de	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  006e4	99		 cdq
  006e5	03 45 18	 add	 eax, DWORD PTR _rtOffset$[ebp]
  006e8	13 55 1c	 adc	 edx, DWORD PTR _rtOffset$[ebp+4]
  006eb	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  006ee	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  006f1	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1097 :                                 pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

  006f4	8b 55 b8	 mov	 edx, DWORD PTR _pMidi$70099[ebp]
  006f7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  006fa	83 c8 41	 or	 eax, 65			; 00000041H
  006fd	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  00700	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1098 :                             }
; 1099 :                             else

  00703	eb 1d		 jmp	 SHORT $L70105
$L70104:

; 1100 :                             {
; 1101 : 							    pMidi->mtTime = rItem.mtTime + mtOffset;

  00705	8b 55 c4	 mov	 edx, DWORD PTR _rItem$70080[ebp]
  00708	8b 02		 mov	 eax, DWORD PTR [edx]
  0070a	03 45 14	 add	 eax, DWORD PTR _mtOffset$[ebp]
  0070d	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  00710	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1102 :                                 pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;

  00713	8b 55 b8	 mov	 edx, DWORD PTR _pMidi$70099[ebp]
  00716	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00719	83 c8 02	 or	 eax, 2
  0071c	8b 4d b8	 mov	 ecx, DWORD PTR _pMidi$70099[ebp]
  0071f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L70105:

; 1103 :                             }
; 1104 : 							pEvent = (DMUS_PMSG*)pMidi;

  00722	8b 55 b8	 mov	 edx, DWORD PTR _pMidi$70099[ebp]
  00725	89 55 e8	 mov	 DWORD PTR _pEvent$[ebp], edx
$L70098:

; 1105 : 						}
; 1106 : 					}
; 1107 : 					if( pEvent )

  00728	83 7d e8 00	 cmp	 DWORD PTR _pEvent$[ebp], 0
  0072c	74 58		 je	 SHORT $L70083

; 1108 : 					{
; 1109 : 						pEvent->dwPChannel = dwMutePChannel;

  0072e	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00731	8b 4d f0	 mov	 ecx, DWORD PTR _dwMutePChannel$[ebp]
  00734	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1110 : 						pEvent->dwVirtualTrackID = dwVirtualID;

  00737	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  0073a	8b 45 2c	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  0073d	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 1111 : 						pEvent->dwGroupID = pSD->dwGroupBits;

  00740	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00743	8b 55 d8	 mov	 edx, DWORD PTR _pSD$[ebp]
  00746	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00749	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 1112 : 						if( pGraph )

  0074c	83 7d dc 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  00750	74 10		 je	 SHORT $L70108

; 1113 : 						{
; 1114 : 							pGraph->StampPMsg( pEvent );

  00752	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00755	51		 push	 ecx
  00756	8b 55 dc	 mov	 edx, DWORD PTR _pGraph$[ebp]
  00759	8b 02		 mov	 eax, DWORD PTR [edx]
  0075b	8b 4d dc	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  0075e	51		 push	 ecx
  0075f	ff 50 0c	 call	 DWORD PTR [eax+12]
$L70108:

; 1115 : 						}
; 1116 : 						if(FAILED(pPerf->SendPMsg( pEvent )))

  00762	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00765	52		 push	 edx
  00766	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00769	8b 08		 mov	 ecx, DWORD PTR [eax]
  0076b	8b 55 24	 mov	 edx, DWORD PTR _pPerf$[ebp]
  0076e	52		 push	 edx
  0076f	ff 51 10	 call	 DWORD PTR [ecx+16]
  00772	85 c0		 test	 eax, eax
  00774	7d 10		 jge	 SHORT $L70083

; 1117 : 						{
; 1118 : 							pPerf->FreePMsg(pEvent);

  00776	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00779	50		 push	 eax
  0077a	8b 4d 24	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0077d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0077f	8b 45 24	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00782	50		 push	 eax
  00783	ff 52 28	 call	 DWORD PTR [edx+40]
$L70083:

; 1119 : 						}
; 1120 : 					}
; 1121 : 				}
; 1122 : 			}

  00786	e9 a9 fc ff ff	 jmp	 $L70078
$L70076:

; 1123 : 		}
; 1124 : 	}

  0078b	e9 90 f9 ff ff	 jmp	 $L70051
$L70052:

; 1125 : 
; 1126 : 	if( pGraph )

  00790	83 7d dc 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  00794	74 0c		 je	 SHORT $L70111

; 1127 : 	{
; 1128 : 		pGraph->Release();

  00796	8b 4d dc	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  00799	8b 11		 mov	 edx, DWORD PTR [ecx]
  0079b	8b 45 dc	 mov	 eax, DWORD PTR _pGraph$[ebp]
  0079e	50		 push	 eax
  0079f	ff 52 08	 call	 DWORD PTR [edx+8]
$L70111:

; 1129 : 	}
; 1130 : 	return hr;

  007a2	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
$L70027:

; 1131 : }

  007a5	8b e5		 mov	 esp, ebp
  007a7	5d		 pop	 ebp
  007a8	c2 2c 00	 ret	 44			; 0000002cH
?Play@CSeqTrack@@IAEJPAXJJJ_JKPAUIDirectMusicPerformance@@PAUIDirectMusicSegmentState@@KH@Z ENDP ; CSeqTrack::Play
_TEXT	ENDS
PUBLIC	??_C@_0BF@JJFOBOKJ@mtTime?5?$DO?5rSeq?4mtTime?$AA@ ; `string'
PUBLIC	??_C@_0BI@HNABCHHM@mtTime?5?$DO?5rCurve?4mtStart?$AA@ ; `string'
PUBLIC	?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z ; CSeqTrack::SendSeekItem
;	COMDAT ??_C@_0BF@JJFOBOKJ@mtTime?5?$DO?5rSeq?4mtTime?$AA@
CONST	SEGMENT
??_C@_0BF@JJFOBOKJ@mtTime?5?$DO?5rSeq?4mtTime?$AA@ DB 'mtTime > rSeq.mtTi'
	DB	'me', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNABCHHM@mtTime?5?$DO?5rCurve?4mtStart?$AA@
CONST	SEGMENT
??_C@_0BI@HNABCHHM@mtTime?5?$DO?5rCurve?4mtStart?$AA@ DB 'mtTime > rCurve'
	DB	'.mtStart', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z
_TEXT	SEGMENT
_this$ = -36
_lTemp$70160 = -32
_pCurve$70153 = -28
_rCurve$70151 = -24
_pMidi$70135 = -20
_rCurve$70131 = -16
_rSeq$70129 = -12
_dwMutePChannel$ = -8
_fMute$ = -4
_pPerf$ = 8
_pGraph$ = 12
_pSegSt$ = 16
_pSD$ = 20
_dwVirtualID$ = 24
_mtTime$ = 28
_mtOffset$ = 32
_rtOffset$ = 36
_pSeq$ = 44
_pCurve$ = 48
_fClockTime$ = 52
?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z PROC NEAR ; CSeqTrack::SendSeekItem, COMDAT
; _this$ = ecx

; 1146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1147 : 	DWORD dwMutePChannel;
; 1148 : 	BOOL fMute;
; 1149 : 
; 1150 : 	if( pSeq )

  00009	83 7d 2c 00	 cmp	 DWORD PTR _pSeq$[ebp], 0
  0000d	0f 84 8f 01 00
	00		 je	 $L70128

; 1151 : 	{
; 1152 : 		DMUS_IO_SEQ_ITEM& rSeq = pSeq->GetItemValue();

  00013	8b 4d 2c	 mov	 ecx, DWORD PTR _pSeq$[ebp]
  00016	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
  0001b	89 45 f4	 mov	 DWORD PTR _rSeq$70129[ebp], eax

; 1153 : 		if( pCurve )

  0001e	83 7d 30 00	 cmp	 DWORD PTR _pCurve$[ebp], 0
  00022	74 24		 je	 SHORT $L70130

; 1154 : 		{
; 1155 : 			DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();

  00024	8b 4d 30	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00027	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  0002c	89 45 f0	 mov	 DWORD PTR _rCurve$70131[ebp], eax

; 1156 : 			if( rSeq.mtTime >= rCurve.mtStart + rCurve.mtDuration )

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _rCurve$70131[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 55 f0	 mov	 edx, DWORD PTR _rCurve$70131[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	8b 45 f4	 mov	 eax, DWORD PTR _rSeq$70129[ebp]
  0003d	39 08		 cmp	 DWORD PTR [eax], ecx
  0003f	7c 07		 jl	 SHORT $L70130

; 1157 : 			{
; 1158 : 				// the seq item happens after the curve item. Send the
; 1159 : 				// seq item and clear the curve item so it doesn't go out.
; 1160 : 				pCurve = NULL;

  00041	c7 45 30 00 00
	00 00		 mov	 DWORD PTR _pCurve$[ebp], 0
$L70130:

; 1161 : 			}
; 1162 : 		}
; 1163 : 		// if pCurve is NULL or was set to NULL, send out the seq item
; 1164 : 		if( NULL == pCurve )

  00048	83 7d 30 00	 cmp	 DWORD PTR _pCurve$[ebp], 0
  0004c	0f 85 50 01 00
	00		 jne	 $L70128

; 1165 : 		{
; 1166 : 			m_PChMap.GetInfo( rSeq.dwPChannel, rSeq.mtTime, mtOffset, pSD->dwGroupBits,
; 1167 : 				pPerf, &fMute, &dwMutePChannel, fClockTime );

  00052	8b 4d 34	 mov	 ecx, DWORD PTR _fClockTime$[ebp]
  00055	51		 push	 ecx
  00056	8d 55 f8	 lea	 edx, DWORD PTR _dwMutePChannel$[ebp]
  00059	52		 push	 edx
  0005a	8d 45 fc	 lea	 eax, DWORD PTR _fMute$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 14	 mov	 edx, DWORD PTR _pSD$[ebp]
  00065	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00068	50		 push	 eax
  00069	8b 4d 20	 mov	 ecx, DWORD PTR _mtOffset$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _rSeq$70129[ebp]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	50		 push	 eax
  00073	8b 4d f4	 mov	 ecx, DWORD PTR _rSeq$70129[ebp]
  00076	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00079	52		 push	 edx
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 40	 add	 ecx, 64			; 00000040H
  00080	e8 00 00 00 00	 call	 ?GetInfo@CPChMap@@QAEXKJJKPAUIDirectMusicPerformance@@PAHPAKH@Z ; CPChMap::GetInfo

; 1168 : 			if( !fMute )

  00085	83 7d fc 00	 cmp	 DWORD PTR _fMute$[ebp], 0
  00089	0f 85 13 01 00
	00		 jne	 $L70128

; 1169 : 			{
; 1170 : 				DMUS_MIDI_PMSG* pMidi;
; 1171 : 				if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
; 1172 : 					(DMUS_PMSG**)&pMidi )))

  0008f	8d 45 ec	 lea	 eax, DWORD PTR _pMidi$70135[ebp]
  00092	50		 push	 eax
  00093	6a 40		 push	 64			; 00000040H
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	8b 45 08	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0009d	50		 push	 eax
  0009e	ff 52 24	 call	 DWORD PTR [edx+36]
  000a1	85 c0		 test	 eax, eax
  000a3	0f 8c f9 00 00
	00		 jl	 $L70128

; 1173 : 				{
; 1174 : 					pMidi->bStatus = rSeq.bStatus & 0xf0;

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _rSeq$70129[ebp]
  000ac	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  000b0	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  000b6	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$70135[ebp]
  000b9	88 50 38	 mov	 BYTE PTR [eax+56], dl

; 1175 : 					pMidi->bByte1 = rSeq.bByte1;

  000bc	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  000bf	8b 55 f4	 mov	 edx, DWORD PTR _rSeq$70129[ebp]
  000c2	8a 42 0f	 mov	 al, BYTE PTR [edx+15]
  000c5	88 41 39	 mov	 BYTE PTR [ecx+57], al

; 1176 : 					pMidi->bByte2 = rSeq.bByte2;

  000c8	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  000cb	8b 55 f4	 mov	 edx, DWORD PTR _rSeq$70129[ebp]
  000ce	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  000d1	88 41 3a	 mov	 BYTE PTR [ecx+58], al

; 1177 : 					pMidi->dwType = DMUS_PMSGT_MIDI;

  000d4	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  000d7	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 1178 : 
; 1179 : 					ASSERT( mtTime > rSeq.mtTime ); // this is true for back-seeking

  000de	8b 55 f4	 mov	 edx, DWORD PTR _rSeq$70129[ebp]
  000e1	8b 45 1c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  000e4	3b 02		 cmp	 eax, DWORD PTR [edx]
  000e6	7f 17		 jg	 SHORT $L70140
  000e8	6a 00		 push	 0
  000ea	68 9b 04 00 00	 push	 1179			; 0000049bH
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@
  000f4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@JJFOBOKJ@mtTime?5?$DO?5rSeq?4mtTime?$AA@
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70140:

; 1180 :                     if (fClockTime)

  000ff	83 7d 34 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  00103	74 2a		 je	 SHORT $L70142

; 1181 :                     {
; 1182 :                         pMidi->rtTime = (mtTime * REF_PER_MIL) + rtOffset;

  00105	8b 45 1c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00108	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  0010e	99		 cdq
  0010f	03 45 24	 add	 eax, DWORD PTR _rtOffset$[ebp]
  00112	13 55 28	 adc	 edx, DWORD PTR _rtOffset$[ebp+4]
  00115	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  00118	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0011b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1183 :                         pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

  0011e	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$70135[ebp]
  00121	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00124	83 c8 41	 or	 eax, 65			; 00000041H
  00127	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  0012a	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1184 :                     }
; 1185 :                     else

  0012d	eb 1b		 jmp	 SHORT $L70143
$L70142:

; 1186 :                     {
; 1187 : 					    pMidi->mtTime = mtTime + mtOffset;

  0012f	8b 55 1c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00132	03 55 20	 add	 edx, DWORD PTR _mtOffset$[ebp]
  00135	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$70135[ebp]
  00138	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1188 :                         pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;

  0013b	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  0013e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00141	83 ca 02	 or	 edx, 2
  00144	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$70135[ebp]
  00147	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L70143:

; 1189 :                     }
; 1190 : 					pMidi->dwPChannel = dwMutePChannel;

  0014a	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  0014d	8b 55 f8	 mov	 edx, DWORD PTR _dwMutePChannel$[ebp]
  00150	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1191 : 					pMidi->dwVirtualTrackID = dwVirtualID;

  00153	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$70135[ebp]
  00156	8b 4d 18	 mov	 ecx, DWORD PTR _dwVirtualID$[ebp]
  00159	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1192 : 					pMidi->dwGroupID = pSD->dwGroupBits;

  0015c	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$70135[ebp]
  0015f	8b 45 14	 mov	 eax, DWORD PTR _pSD$[ebp]
  00162	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00165	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 1193 : 					if( pGraph )

  00168	83 7d 0c 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  0016c	74 10		 je	 SHORT $L70144

; 1194 : 					{
; 1195 : 						pGraph->StampPMsg( (DMUS_PMSG*)pMidi );

  0016e	8b 55 ec	 mov	 edx, DWORD PTR _pMidi$70135[ebp]
  00171	52		 push	 edx
  00172	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  00175	8b 08		 mov	 ecx, DWORD PTR [eax]
  00177	8b 55 0c	 mov	 edx, DWORD PTR _pGraph$[ebp]
  0017a	52		 push	 edx
  0017b	ff 51 0c	 call	 DWORD PTR [ecx+12]
$L70144:

; 1196 : 					}
; 1197 : 					if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pMidi )))

  0017e	8b 45 ec	 mov	 eax, DWORD PTR _pMidi$70135[ebp]
  00181	50		 push	 eax
  00182	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00185	8b 11		 mov	 edx, DWORD PTR [ecx]
  00187	8b 45 08	 mov	 eax, DWORD PTR _pPerf$[ebp]
  0018a	50		 push	 eax
  0018b	ff 52 10	 call	 DWORD PTR [edx+16]
  0018e	85 c0		 test	 eax, eax
  00190	7d 10		 jge	 SHORT $L70128

; 1198 : 					{
; 1199 : 						pPerf->FreePMsg((DMUS_PMSG*)pMidi);

  00192	8b 4d ec	 mov	 ecx, DWORD PTR _pMidi$70135[ebp]
  00195	51		 push	 ecx
  00196	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00199	8b 02		 mov	 eax, DWORD PTR [edx]
  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0019e	51		 push	 ecx
  0019f	ff 50 28	 call	 DWORD PTR [eax+40]
$L70128:

; 1200 : 					}
; 1201 : 				}
; 1202 : 			}
; 1203 : 		}
; 1204 : 	}
; 1205 : 	if( pCurve )

  001a2	83 7d 30 00	 cmp	 DWORD PTR _pCurve$[ebp], 0
  001a6	0f 84 39 03 00
	00		 je	 $L70125

; 1206 : 	{
; 1207 : 		DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();

  001ac	8b 4d 30	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001af	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  001b4	89 45 e8	 mov	 DWORD PTR _rCurve$70151[ebp], eax

; 1208 : 		m_PChMap.GetInfo( rCurve.dwPChannel, rCurve.mtStart, mtOffset, pSD->dwGroupBits,
; 1209 : 			pPerf, &fMute, &dwMutePChannel, fClockTime );

  001b7	8b 55 34	 mov	 edx, DWORD PTR _fClockTime$[ebp]
  001ba	52		 push	 edx
  001bb	8d 45 f8	 lea	 eax, DWORD PTR _dwMutePChannel$[ebp]
  001be	50		 push	 eax
  001bf	8d 4d fc	 lea	 ecx, DWORD PTR _fMute$[ebp]
  001c2	51		 push	 ecx
  001c3	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  001c6	52		 push	 edx
  001c7	8b 45 14	 mov	 eax, DWORD PTR _pSD$[ebp]
  001ca	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001cd	51		 push	 ecx
  001ce	8b 55 20	 mov	 edx, DWORD PTR _mtOffset$[ebp]
  001d1	52		 push	 edx
  001d2	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  001d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d7	51		 push	 ecx
  001d8	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  001db	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001de	50		 push	 eax
  001df	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	83 c1 40	 add	 ecx, 64			; 00000040H
  001e5	e8 00 00 00 00	 call	 ?GetInfo@CPChMap@@QAEXKJJKPAUIDirectMusicPerformance@@PAHPAKH@Z ; CPChMap::GetInfo

; 1210 : 		if( !fMute )

  001ea	83 7d fc 00	 cmp	 DWORD PTR _fMute$[ebp], 0
  001ee	0f 85 f1 02 00
	00		 jne	 $L70125

; 1211 : 		{
; 1212 : 			DMUS_CURVE_PMSG* pCurve;
; 1213 : 			if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
; 1214 : 				(DMUS_PMSG**)&pCurve )))

  001f4	8d 4d e4	 lea	 ecx, DWORD PTR _pCurve$70153[ebp]
  001f7	51		 push	 ecx
  001f8	6a 58		 push	 88			; 00000058H
  001fa	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  001fd	8b 02		 mov	 eax, DWORD PTR [edx]
  001ff	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00202	51		 push	 ecx
  00203	ff 50 24	 call	 DWORD PTR [eax+36]
  00206	85 c0		 test	 eax, eax
  00208	0f 8c d7 02 00
	00		 jl	 $L70125

; 1215 : 			{
; 1216 :                 if (fClockTime) // If clock time, don't fill in time signature info, it's useless.

  0020e	83 7d 34 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  00212	74 51		 je	 SHORT $L70158

; 1217 :                 {
; 1218 :                     pCurve->wMeasure = 0;

  00214	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  00217	66 c7 42 4a 00
	00		 mov	 WORD PTR [edx+74], 0

; 1219 : 				    pCurve->bBeat = 0;

  0021d	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00220	c6 40 4e 00	 mov	 BYTE PTR [eax+78], 0

; 1220 : 				    pCurve->bGrid = 0;

  00224	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  00227	c6 41 4f 00	 mov	 BYTE PTR [ecx+79], 0

; 1221 : 				    pCurve->nOffset = 0;

  0022b	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  0022e	66 c7 42 4c 00
	00		 mov	 WORD PTR [edx+76], 0

; 1222 :                     pCurve->rtTime = ((mtTime + rCurve.nOffset) * REF_PER_MIL) + rtOffset;

  00234	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  00237	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0023b	8b 45 1c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0023e	03 c1		 add	 eax, ecx
  00240	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  00246	99		 cdq
  00247	03 45 24	 add	 eax, DWORD PTR _rtOffset$[ebp]
  0024a	13 55 28	 adc	 edx, DWORD PTR _rtOffset$[ebp+4]
  0024d	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  00250	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00253	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1223 :                     pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

  00256	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  00259	c7 42 14 41 00
	00 00		 mov	 DWORD PTR [edx+20], 65	; 00000041H

; 1224 :                 }
; 1225 :                 else

  00260	e9 e2 00 00 00	 jmp	 $L70159
$L70158:

; 1226 :                 {
; 1227 :                     UpdateTimeSig( pSegSt, pSD, rCurve.mtStart);

  00265	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  00268	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026a	51		 push	 ecx
  0026b	8b 55 14	 mov	 edx, DWORD PTR _pSD$[ebp]
  0026e	52		 push	 edx
  0026f	8b 45 10	 mov	 eax, DWORD PTR _pSegSt$[ebp]
  00272	50		 push	 eax
  00273	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00276	e8 00 00 00 00	 call	 ?UpdateTimeSig@CSeqTrack@@IAEXPAUIDirectMusicSegmentState@@PAUSeqStateData@@J@Z ; CSeqTrack::UpdateTimeSig

; 1228 : 				    long lTemp = (rCurve.mtStart - pSD->mtCurTimeSig);

  0027b	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  0027e	8b 55 14	 mov	 edx, DWORD PTR _pSD$[ebp]
  00281	8b 01		 mov	 eax, DWORD PTR [ecx]
  00283	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00286	89 45 e0	 mov	 DWORD PTR _lTemp$70160[ebp], eax

; 1229 : 				    pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);

  00289	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0028c	8b 45 e0	 mov	 eax, DWORD PTR _lTemp$70160[ebp]
  0028f	33 d2		 xor	 edx, edx
  00291	f7 71 20	 div	 DWORD PTR [ecx+32]
  00294	8b 55 14	 mov	 edx, DWORD PTR _pSD$[ebp]
  00297	03 42 18	 add	 eax, DWORD PTR [edx+24]
  0029a	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  0029d	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 1230 : 				    lTemp = lTemp % pSD->dwlnMeasure;

  002a1	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002a4	8b 45 e0	 mov	 eax, DWORD PTR _lTemp$70160[ebp]
  002a7	33 d2		 xor	 edx, edx
  002a9	f7 71 20	 div	 DWORD PTR [ecx+32]
  002ac	89 55 e0	 mov	 DWORD PTR _lTemp$70160[ebp], edx

; 1231 : 				    pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);

  002af	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002b2	8b 45 e0	 mov	 eax, DWORD PTR _lTemp$70160[ebp]
  002b5	33 d2		 xor	 edx, edx
  002b7	f7 71 1c	 div	 DWORD PTR [ecx+28]
  002ba	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  002bd	88 42 4e	 mov	 BYTE PTR [edx+78], al

; 1232 : 				    lTemp = lTemp % pSD->dwlnBeat;

  002c0	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002c3	8b 45 e0	 mov	 eax, DWORD PTR _lTemp$70160[ebp]
  002c6	33 d2		 xor	 edx, edx
  002c8	f7 71 1c	 div	 DWORD PTR [ecx+28]
  002cb	89 55 e0	 mov	 DWORD PTR _lTemp$70160[ebp], edx

; 1233 : 				    pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);

  002ce	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002d1	8b 45 e0	 mov	 eax, DWORD PTR _lTemp$70160[ebp]
  002d4	33 d2		 xor	 edx, edx
  002d6	f7 71 24	 div	 DWORD PTR [ecx+36]
  002d9	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  002dc	88 42 4f	 mov	 BYTE PTR [edx+79], al

; 1234 : 				    pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rCurve.nOffset;

  002df	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002e2	8b 45 e0	 mov	 eax, DWORD PTR _lTemp$70160[ebp]
  002e5	33 d2		 xor	 edx, edx
  002e7	f7 71 24	 div	 DWORD PTR [ecx+36]
  002ea	0f bf d2	 movsx	 edx, dx
  002ed	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  002f0	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  002f4	03 d1		 add	 edx, ecx
  002f6	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  002f9	66 89 50 4c	 mov	 WORD PTR [eax+76], dx

; 1235 : 				    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME;

  002fd	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  00300	c7 41 14 02 00
	00 00		 mov	 DWORD PTR [ecx+20], 2

; 1236 :                     ASSERT( mtTime > rCurve.mtStart );// this is true for back-seeking

  00307	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  0030a	8b 45 1c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0030d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0030f	7f 17		 jg	 SHORT $L70165
  00311	6a 00		 push	 0
  00313	68 d4 04 00 00	 push	 1236			; 000004d4H
  00318	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@KPFEFCJH@c?3?2xbox?2private?2windows?2directx?2@
  0031d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@HNABCHHM@mtTime?5?$DO?5rCurve?4mtStart?$AA@
  00322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70165:

; 1237 : 				    // in any case, play curve at mtTime + mtOffset + pCurve->nOffset
; 1238 : 				    pCurve->mtTime = mtTime + mtOffset + rCurve.nOffset;

  00328	8b 4d 1c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0032b	03 4d 20	 add	 ecx, DWORD PTR _mtOffset$[ebp]
  0032e	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  00331	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00335	03 c8		 add	 ecx, eax
  00337	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  0033a	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1239 :                     pCurve->dwFlags = DMUS_PMSGF_MUSICTIME;

  0033d	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00340	c7 40 14 02 00
	00 00		 mov	 DWORD PTR [eax+20], 2
$L70159:

; 1240 :                 }
; 1241 : 
; 1242 : 				pCurve->dwPChannel = dwMutePChannel;

  00347	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  0034a	8b 55 f8	 mov	 edx, DWORD PTR _dwMutePChannel$[ebp]
  0034d	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1243 : 				pCurve->dwVirtualTrackID = dwVirtualID;

  00350	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00353	8b 4d 18	 mov	 ecx, DWORD PTR _dwVirtualID$[ebp]
  00356	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1244 : 				pCurve->dwType = DMUS_PMSGT_CURVE;

  00359	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  0035c	c7 42 28 05 00
	00 00		 mov	 DWORD PTR [edx+40], 5

; 1245 : 				pCurve->bType = rCurve.bType;

  00363	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00366	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00369	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  0036c	88 50 50	 mov	 BYTE PTR [eax+80], dl

; 1246 : 				pCurve->bCCData = rCurve.bCCData;

  0036f	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00372	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00375	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  00378	88 50 52	 mov	 BYTE PTR [eax+82], dl

; 1247 : 				pCurve->bFlags = rCurve.bFlags;

  0037b	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  0037e	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00381	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  00384	88 50 53	 mov	 BYTE PTR [eax+83], dl

; 1248 : 				pCurve->dwGroupID = pSD->dwGroupBits;

  00387	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  0038a	8b 4d 14	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0038d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00390	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 1249 : 				pCurve->nStartValue = rCurve.nStartValue;

  00393	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00396	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00399	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  0039d	66 89 50 44	 mov	 WORD PTR [eax+68], dx

; 1250 : 				pCurve->nEndValue = rCurve.nEndValue;

  003a1	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  003a4	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  003a7	66 8b 51 14	 mov	 dx, WORD PTR [ecx+20]
  003ab	66 89 50 46	 mov	 WORD PTR [eax+70], dx

; 1251 : 				pCurve->nResetValue = rCurve.nResetValue;

  003af	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  003b2	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  003b5	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  003b9	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 1252 : 				
; 1253 : 				if( mtTime >= rCurve.mtStart + rCurve.mtDuration )

  003bd	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  003c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c2	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  003c5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003c8	39 4d 1c	 cmp	 DWORD PTR _mtTime$[ebp], ecx
  003cb	7c 6b		 jl	 SHORT $L70167

; 1254 : 				{
; 1255 : 					// playing at a time past the curve's duration. Just play
; 1256 : 					// an instant curve at that time instead. Instant curves
; 1257 : 					// play at their endvalue. Duration is irrelavant.
; 1258 : 					pCurve->bCurveShape = DMUS_CURVES_INSTANT;

  003cd	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  003d0	c6 40 51 01	 mov	 BYTE PTR [eax+81], 1

; 1259 : 					if( pCurve->bFlags & DMUS_CURVE_RESET )

  003d4	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  003d7	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  003db	83 e2 01	 and	 edx, 1
  003de	85 d2		 test	 edx, edx
  003e0	74 54		 je	 SHORT $L70168

; 1260 : 					{
; 1261 : 						if( mtTime >= rCurve.mtStart + rCurve.mtDuration + 
; 1262 : 							rCurve.mtResetDuration + rCurve.nOffset )

  003e2	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  003e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e7	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  003ea	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003ed	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  003f0	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  003f3	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  003f6	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  003fa	03 c8		 add	 ecx, eax
  003fc	39 4d 1c	 cmp	 DWORD PTR _mtTime$[ebp], ecx
  003ff	7c 12		 jl	 SHORT $L70169

; 1263 : 						{
; 1264 : 							// don't need the curve reset any more
; 1265 : 							pCurve->bFlags &= ~DMUS_CURVE_RESET;

  00401	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  00404	0f b6 51 53	 movzx	 edx, BYTE PTR [ecx+83]
  00408	83 e2 fe	 and	 edx, -2			; fffffffeH
  0040b	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  0040e	88 50 53	 mov	 BYTE PTR [eax+83], dl

; 1266 : 						}
; 1267 : 						else

  00411	eb 23		 jmp	 SHORT $L70168
$L70169:

; 1268 : 						{
; 1269 : 							// otherwise make sure the reset event happens at the same time
; 1270 : 							// it would have if we weren't seeking back.
; 1271 : 							pCurve->mtResetDuration = rCurve.mtStart + rCurve.mtDuration +
; 1272 : 								rCurve.mtResetDuration + rCurve.nOffset - mtTime;

  00413	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00416	8b 11		 mov	 edx, DWORD PTR [ecx]
  00418	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  0041b	03 50 04	 add	 edx, DWORD PTR [eax+4]
  0041e	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00421	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00424	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  00427	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0042b	03 d1		 add	 edx, ecx
  0042d	2b 55 1c	 sub	 edx, DWORD PTR _mtTime$[ebp]
  00430	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  00433	89 50 40	 mov	 DWORD PTR [eax+64], edx
$L70168:

; 1273 : 						}
; 1274 : 					}
; 1275 : 				}
; 1276 : 				else

  00436	eb 73		 jmp	 SHORT $L70171
$L70167:

; 1277 : 				{
; 1278 : 					// playing at a time in the middle of a curve.
; 1279 : 					pCurve->bCurveShape = rCurve.bCurveShape;

  00438	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  0043b	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  0043e	8a 42 19	 mov	 al, BYTE PTR [edx+25]
  00441	88 41 51	 mov	 BYTE PTR [ecx+81], al

; 1280 :                     if (fClockTime)

  00444	83 7d 34 00	 cmp	 DWORD PTR _fClockTime$[ebp], 0
  00448	74 1e		 je	 SHORT $L70172

; 1281 :                     {
; 1282 :                         pCurve->mtOriginalStart = mtTime - (rCurve.mtStart + mtOffset + rCurve.nOffset);

  0044a	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  0044d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0044f	03 55 20	 add	 edx, DWORD PTR _mtOffset$[ebp]
  00452	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  00455	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00459	03 d1		 add	 edx, ecx
  0045b	8b 45 1c	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0045e	2b c2		 sub	 eax, edx
  00460	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  00463	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 1283 :                     }
; 1284 :                     else

  00466	eb 17		 jmp	 SHORT $L70173
$L70172:

; 1285 :                     {
; 1286 : 				    	pCurve->mtOriginalStart = rCurve.mtStart + mtOffset + rCurve.nOffset;

  00468	8b 55 e8	 mov	 edx, DWORD PTR _rCurve$70151[ebp]
  0046b	8b 02		 mov	 eax, DWORD PTR [edx]
  0046d	03 45 20	 add	 eax, DWORD PTR _mtOffset$[ebp]
  00470	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  00473	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00477	03 c2		 add	 eax, edx
  00479	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  0047c	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
$L70173:

; 1287 :                     }
; 1288 : 					if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )

  0047f	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  00482	0f b6 42 51	 movzx	 eax, BYTE PTR [edx+81]
  00486	83 f8 01	 cmp	 eax, 1
  00489	74 14		 je	 SHORT $L70174

; 1289 : 					{
; 1290 : 						pCurve->mtDuration = rCurve.mtStart + rCurve.mtDuration - mtTime;

  0048b	8b 4d e8	 mov	 ecx, DWORD PTR _rCurve$70151[ebp]
  0048e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00490	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  00493	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00496	2b 55 1c	 sub	 edx, DWORD PTR _mtTime$[ebp]
  00499	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  0049c	89 51 38	 mov	 DWORD PTR [ecx+56], edx
$L70174:

; 1291 : 					}
; 1292 : 					pCurve->mtResetDuration = rCurve.mtResetDuration;

  0049f	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  004a2	8b 45 e8	 mov	 eax, DWORD PTR _rCurve$70151[ebp]
  004a5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004a8	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
$L70171:

; 1293 : 				}
; 1294 : 
; 1295 : 				if( pGraph )

  004ab	83 7d 0c 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  004af	74 10		 je	 SHORT $L70175

; 1296 : 				{
; 1297 : 					pGraph->StampPMsg( (DMUS_PMSG*)pCurve );

  004b1	8b 55 e4	 mov	 edx, DWORD PTR _pCurve$70153[ebp]
  004b4	52		 push	 edx
  004b5	8b 45 0c	 mov	 eax, DWORD PTR _pGraph$[ebp]
  004b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ba	8b 55 0c	 mov	 edx, DWORD PTR _pGraph$[ebp]
  004bd	52		 push	 edx
  004be	ff 51 0c	 call	 DWORD PTR [ecx+12]
$L70175:

; 1298 : 				}
; 1299 : 				if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pCurve )))

  004c1	8b 45 e4	 mov	 eax, DWORD PTR _pCurve$70153[ebp]
  004c4	50		 push	 eax
  004c5	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  004c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  004ca	8b 45 08	 mov	 eax, DWORD PTR _pPerf$[ebp]
  004cd	50		 push	 eax
  004ce	ff 52 10	 call	 DWORD PTR [edx+16]
  004d1	85 c0		 test	 eax, eax
  004d3	7d 10		 jge	 SHORT $L70125

; 1300 : 				{
; 1301 : 					pPerf->FreePMsg((DMUS_PMSG*)pCurve);

  004d5	8b 4d e4	 mov	 ecx, DWORD PTR _pCurve$70153[ebp]
  004d8	51		 push	 ecx
  004d9	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  004dc	8b 02		 mov	 eax, DWORD PTR [edx]
  004de	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  004e1	51		 push	 ecx
  004e2	ff 50 28	 call	 DWORD PTR [eax+40]
$L70125:

; 1302 : 				}
; 1303 : 			}
; 1304 : 		}
; 1305 : 	}
; 1306 : }

  004e5	8b e5		 mov	 esp, ebp
  004e7	5d		 pop	 ebp
  004e8	c2 30 00	 ret	 48			; 00000030H
?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z ENDP ; CSeqTrack::SendSeekItem
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z
_TEXT	SEGMENT
tv200 = -840
tv164 = -836
_dwCC$70267 = -832
_rTemp$70261 = -828
_rTemp$70256 = -824
_rTemp$70251 = -820
_rCurveItem$70241 = -816
_rSeqItem$70225 = -812
_pGraph$ = -808
_dwIndex$ = -804
_pPart$ = -800
_pSeqItemPBend$ = -796
_pCurveItemPBend$ = -792
_pCurveItem$ = -788
_apCurveItemCC$ = -784
_pSeqItem$ = -396
_pCurveItemMonoAT$ = -392
_pSeqItemMonoAT$ = -388
_apSeqItemCC$ = -384
_this$ = 8
_pSegSt$ = 12
_pPerf$ = 16
_dwVirtualID$ = 20
_pSD$ = 24
_mtTime$ = 28
_fGetPrevious$ = 32
_mtOffset$ = 36
_rtOffset$ = 40
_fClockTime$ = 48
?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z PROC NEAR ; CSeqTrack::Seek, COMDAT

; 1315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 03 00
	00		 sub	 esp, 840		; 00000348H

; 1316 : 	DWORD dwIndex;
; 1317 : 	TListItem<SEQ_PART>* pPart;
; 1318 : 	TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem;
; 1319 : 	TListItem<DMUS_IO_CURVE_ITEM>* pCurveItem;
; 1320 : 
; 1321 : 	// in the case of mtTime == 0 and fGetPrevious (which means DMUS_SEGF_START was
; 1322 : 	// set in Play() ) we want to reset all lists to the beginning regardless of time.
; 1323 : 	if( fGetPrevious && ( mtTime == 0 ) )

  00009	83 7d 20 00	 cmp	 DWORD PTR _fGetPrevious$[ebp], 0
  0000d	0f 84 fa 00 00
	00		 je	 $L70197
  00013	83 7d 1c 00	 cmp	 DWORD PTR _mtTime$[ebp], 0
  00017	0f 85 f0 00 00
	00		 jne	 $L70197

; 1324 : 	{
; 1325 : 		pPart = m_SeqPartList.GetHead();

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 08	 add	 ecx, 8
  00023	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  00028	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _pPart$[ebp], eax

; 1326 : 		for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )

  0002e	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwIndex$[ebp], 0
  00038	eb 0f		 jmp	 SHORT $L70198
$L70199:
  0003a	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 85 dc fc ff
	ff		 mov	 DWORD PTR _dwIndex$[ebp], eax
$L70198:
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00052	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00055	0f 83 ab 00 00
	00		 jae	 $L70200

; 1327 : 		{
; 1328 : 			if( pPart )

  0005b	83 bd e0 fc ff
	ff 00		 cmp	 DWORD PTR _pPart$[ebp], 0
  00062	0f 84 97 00 00
	00		 je	 $L70201

; 1329 : 			{
; 1330 : 				pSeqItem = pPart->GetItemValue().seqList.GetHead();

  00068	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _pPart$[ebp]
  0006e	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00073	83 c0 08	 add	 eax, 8
  00076	8b c8		 mov	 ecx, eax
  00078	e8 00 00 00 00	 call	 ?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ; TList<_DMUS_IO_SEQ_ITEM>::GetHead
  0007d	89 85 74 fe ff
	ff		 mov	 DWORD PTR _pSeqItem$[ebp], eax

; 1331 : 				if( pSeqItem && pSD->apCurrentSeq )

  00083	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _pSeqItem$[ebp], 0
  0008a	74 1e		 je	 SHORT $L70202
  0008c	8b 45 18	 mov	 eax, DWORD PTR _pSD$[ebp]
  0008f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00093	74 15		 je	 SHORT $L70202

; 1332 : 				{
; 1333 : 					pSD->apCurrentSeq[dwIndex] = pSeqItem;

  00095	8b 4d 18	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00098	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009b	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _dwIndex$[ebp]
  000a1	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _pSeqItem$[ebp]
  000a7	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
$L70202:

; 1334 : 				}
; 1335 : 				pCurveItem = pPart->GetItemValue().curveList.GetHead();

  000aa	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _pPart$[ebp]
  000b0	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  000b5	83 c0 0c	 add	 eax, 12			; 0000000cH
  000b8	8b c8		 mov	 ecx, eax
  000ba	e8 00 00 00 00	 call	 ?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ; TList<_DMUS_IO_CURVE_ITEM>::GetHead
  000bf	89 85 ec fc ff
	ff		 mov	 DWORD PTR _pCurveItem$[ebp], eax

; 1336 : 				if( pCurveItem && pSD->apCurrentCurve )

  000c5	83 bd ec fc ff
	ff 00		 cmp	 DWORD PTR _pCurveItem$[ebp], 0
  000cc	74 1e		 je	 SHORT $L70203
  000ce	8b 55 18	 mov	 edx, DWORD PTR _pSD$[ebp]
  000d1	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000d5	74 15		 je	 SHORT $L70203

; 1337 : 				{
; 1338 : 					pSD->apCurrentCurve[dwIndex] = pCurveItem;

  000d7	8b 45 18	 mov	 eax, DWORD PTR _pSD$[ebp]
  000da	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000dd	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _dwIndex$[ebp]
  000e3	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _pCurveItem$[ebp]
  000e9	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
$L70203:

; 1339 : 				}
; 1340 : 				pPart = pPart->GetNext();

  000ec	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _pPart$[ebp]
  000f2	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  000f7	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _pPart$[ebp], eax

; 1341 : 			}
; 1342 : 			else

  000fd	eb 02		 jmp	 SHORT $L70204
$L70201:

; 1343 : 			{
; 1344 : 				break;

  000ff	eb 05		 jmp	 SHORT $L70200
$L70204:

; 1345 : 			}
; 1346 : 		}

  00101	e9 34 ff ff ff	 jmp	 $L70199
$L70200:

; 1347 : 		return S_OK;

  00106	33 c0		 xor	 eax, eax
  00108	e9 9f 05 00 00	 jmp	 $L70192
$L70197:

; 1348 : 	}
; 1349 : 
; 1350 : #define CC_1	96
; 1351 : 	// CC_1 is the limit of the CC#'s we pay attention to. CC#96 through #101
; 1352 : 	// are registered and non-registered parameter #'s, and data increment and
; 1353 : 	// decrement, which we are choosing to ignore.
; 1354 : 
; 1355 : 	TListItem<DMUS_IO_SEQ_ITEM>*	apSeqItemCC[ CC_1 ];
; 1356 : 	TListItem<DMUS_IO_CURVE_ITEM>*	apCurveItemCC[ CC_1 ];
; 1357 : 	TListItem<DMUS_IO_SEQ_ITEM>*	pSeqItemMonoAT;
; 1358 : 	TListItem<DMUS_IO_CURVE_ITEM>*	pCurveItemMonoAT;
; 1359 : 	TListItem<DMUS_IO_SEQ_ITEM>*	pSeqItemPBend;
; 1360 : 	TListItem<DMUS_IO_CURVE_ITEM>*	pCurveItemPBend;
; 1361 : 	IDirectMusicGraph* pGraph;
; 1362 : 	if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
; 1363 : 		(void**)&pGraph )))

  0010d	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _pGraph$[ebp]
  00113	51		 push	 ecx
  00114	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGraph
  00119	8b 55 0c	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  0011c	8b 02		 mov	 eax, DWORD PTR [edx]
  0011e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSegSt$[ebp]
  00121	51		 push	 ecx
  00122	ff 10		 call	 DWORD PTR [eax]
  00124	85 c0		 test	 eax, eax
  00126	7d 0a		 jge	 SHORT $L70215

; 1364 : 	{
; 1365 : 		pGraph = NULL;

  00128	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pGraph$[ebp], 0
$L70215:

; 1366 : 	}
; 1367 : 
; 1368 : 	pPart = m_SeqPartList.GetHead();

  00132	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	83 c1 08	 add	 ecx, 8
  00138	e8 00 00 00 00	 call	 ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ; TList<SEQ_PART>::GetHead
  0013d	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _pPart$[ebp], eax

; 1369 : 	for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )

  00143	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwIndex$[ebp], 0
  0014d	eb 0f		 jmp	 SHORT $L70216
$L70217:
  0014f	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00155	83 c2 01	 add	 edx, 1
  00158	89 95 dc fc ff
	ff		 mov	 DWORD PTR _dwIndex$[ebp], edx
$L70216:
  0015e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00161	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00167	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0016a	0f 83 1f 05 00
	00		 jae	 $L70218

; 1370 : 	{
; 1371 : 		if( pPart )

  00170	83 bd e0 fc ff
	ff 00		 cmp	 DWORD PTR _pPart$[ebp], 0
  00177	0f 84 0d 05 00
	00		 je	 $L70219

; 1372 : 		{
; 1373 : 			memset(apSeqItemCC, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * CC_1);

  0017d	68 80 01 00 00	 push	 384			; 00000180H
  00182	6a 00		 push	 0
  00184	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR _apSeqItemCC$[ebp]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _memset
  00190	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1374 : 			memset(apCurveItemCC, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * CC_1);

  00193	68 80 01 00 00	 push	 384			; 00000180H
  00198	6a 00		 push	 0
  0019a	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _apCurveItemCC$[ebp]
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _memset
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1375 : 			pSeqItemMonoAT = NULL;

  001a9	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pSeqItemMonoAT$[ebp], 0

; 1376 : 			pCurveItemMonoAT = NULL;

  001b3	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pCurveItemMonoAT$[ebp], 0

; 1377 : 			pSeqItemPBend = NULL;

  001bd	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pSeqItemPBend$[ebp], 0

; 1378 : 			pCurveItemPBend = NULL;

  001c7	c7 85 e8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pCurveItemPBend$[ebp], 0

; 1379 : 
; 1380 : 			// scan the seq event list in this part, storing any CC, MonoAT, and PBend
; 1381 : 			// events we come across.
; 1382 : 			for( pSeqItem = pPart->GetItemValue().seqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )

  001d1	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _pPart$[ebp]
  001d7	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  001dc	83 c0 08	 add	 eax, 8
  001df	8b c8		 mov	 ecx, eax
  001e1	e8 00 00 00 00	 call	 ?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ; TList<_DMUS_IO_SEQ_ITEM>::GetHead
  001e6	89 85 74 fe ff
	ff		 mov	 DWORD PTR _pSeqItem$[ebp], eax
  001ec	eb 11		 jmp	 SHORT $L70222
$L70223:
  001ee	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _pSeqItem$[ebp]
  001f4	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
  001f9	89 85 74 fe ff
	ff		 mov	 DWORD PTR _pSeqItem$[ebp], eax
$L70222:
  001ff	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _pSeqItem$[ebp], 0
  00206	0f 84 cc 00 00
	00		 je	 $L70224

; 1383 : 			{
; 1384 : 				DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();

  0020c	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _pSeqItem$[ebp]
  00212	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
  00217	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _rSeqItem$70225[ebp], eax

; 1385 : 				if( rSeqItem.mtTime >= mtTime )

  0021d	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _rSeqItem$70225[ebp]
  00223	8b 11		 mov	 edx, DWORD PTR [ecx]
  00225	3b 55 1c	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  00228	7c 05		 jl	 SHORT $L70226

; 1386 : 				{
; 1387 : 					break;

  0022a	e9 a9 00 00 00	 jmp	 $L70224
$L70226:

; 1388 : 				}
; 1389 : 				if( !fGetPrevious )

  0022f	83 7d 20 00	 cmp	 DWORD PTR _fGetPrevious$[ebp], 0
  00233	75 02		 jne	 SHORT $L70227

; 1390 : 				{
; 1391 : 					// if we don't care about previous events, just continue
; 1392 : 					continue;

  00235	eb b7		 jmp	 SHORT $L70223
$L70227:

; 1393 : 				}
; 1394 : 				switch( rSeqItem.bStatus & 0xf0 )
; 1395 : 				{

  00237	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _rSeqItem$70225[ebp]
  0023d	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00241	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00247	89 8d bc fc ff
	ff		 mov	 DWORD PTR tv164[ebp], ecx
  0024d	81 bd bc fc ff
	ff b0 00 00 00	 cmp	 DWORD PTR tv164[ebp], 176 ; 000000b0H
  00257	74 1a		 je	 SHORT $L70232
  00259	81 bd bc fc ff
	ff d0 00 00 00	 cmp	 DWORD PTR tv164[ebp], 208 ; 000000d0H
  00263	74 54		 je	 SHORT $L70234
  00265	81 bd bc fc ff
	ff e0 00 00 00	 cmp	 DWORD PTR tv164[ebp], 224 ; 000000e0H
  0026f	74 56		 je	 SHORT $L70235
  00271	eb 60		 jmp	 SHORT $L70229
$L70232:

; 1396 : 				case MIDI_CCHANGE:
; 1397 : 					// ignore Registered and Non-registered Parameters,
; 1398 : 					// Data increment, Data decrement, and Data entry MSB and LSB.
; 1399 : 					if( ( rSeqItem.bByte1 < CC_1 ) && ( rSeqItem.bByte1 != 6 ) &&
; 1400 : 						( rSeqItem.bByte1 != 38 ) )

  00273	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _rSeqItem$70225[ebp]
  00279	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  0027d	83 f8 60	 cmp	 eax, 96			; 00000060H
  00280	7d 35		 jge	 SHORT $L70233
  00282	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _rSeqItem$70225[ebp]
  00288	0f b6 51 0f	 movzx	 edx, BYTE PTR [ecx+15]
  0028c	83 fa 06	 cmp	 edx, 6
  0028f	74 26		 je	 SHORT $L70233
  00291	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _rSeqItem$70225[ebp]
  00297	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0029b	83 f9 26	 cmp	 ecx, 38			; 00000026H
  0029e	74 17		 je	 SHORT $L70233

; 1401 : 					{
; 1402 : 						apSeqItemCC[ rSeqItem.bByte1 ] = pSeqItem;

  002a0	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _rSeqItem$70225[ebp]
  002a6	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  002aa	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _pSeqItem$[ebp]
  002b0	89 8c 85 80 fe
	ff ff		 mov	 DWORD PTR _apSeqItemCC$[ebp+eax*4], ecx
$L70233:

; 1403 : 					}
; 1404 : 					break;

  002b7	eb 1a		 jmp	 SHORT $L70229
$L70234:

; 1405 : 				case MIDI_MTOUCH:
; 1406 : 					pSeqItemMonoAT = pSeqItem;

  002b9	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _pSeqItem$[ebp]
  002bf	89 95 7c fe ff
	ff		 mov	 DWORD PTR _pSeqItemMonoAT$[ebp], edx

; 1407 : 					break;

  002c5	eb 0c		 jmp	 SHORT $L70229
$L70235:

; 1408 : 				case MIDI_PBEND:
; 1409 : 					pSeqItemPBend = pSeqItem;

  002c7	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _pSeqItem$[ebp]
  002cd	89 85 e4 fc ff
	ff		 mov	 DWORD PTR _pSeqItemPBend$[ebp], eax
$L70229:

; 1410 : 					break;
; 1411 : 				default:
; 1412 : 					break;
; 1413 : 				}
; 1414 : 			}

  002d3	e9 16 ff ff ff	 jmp	 $L70223
$L70224:

; 1415 : 			if( pSD->apCurrentSeq )

  002d8	8b 4d 18	 mov	 ecx, DWORD PTR _pSD$[ebp]
  002db	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  002df	74 15		 je	 SHORT $L70237

; 1416 : 			{
; 1417 : 				pSD->apCurrentSeq[dwIndex] = pSeqItem;

  002e1	8b 55 18	 mov	 edx, DWORD PTR _pSD$[ebp]
  002e4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002e7	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  002ed	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _pSeqItem$[ebp]
  002f3	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$L70237:

; 1418 : 			}
; 1419 : 			// scan the curve event list in this part, storing any CC, MonoAT, and PBend
; 1420 : 			// events we come across
; 1421 : 			for( pCurveItem = pPart->GetItemValue().curveList.GetHead(); pCurveItem; pCurveItem = pCurveItem->GetNext() )

  002f6	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _pPart$[ebp]
  002fc	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ; TListItem<SEQ_PART>::GetItemValue
  00301	83 c0 0c	 add	 eax, 12			; 0000000cH
  00304	8b c8		 mov	 ecx, eax
  00306	e8 00 00 00 00	 call	 ?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ; TList<_DMUS_IO_CURVE_ITEM>::GetHead
  0030b	89 85 ec fc ff
	ff		 mov	 DWORD PTR _pCurveItem$[ebp], eax
  00311	eb 11		 jmp	 SHORT $L70238
$L70239:
  00313	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR _pCurveItem$[ebp]
  00319	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
  0031e	89 85 ec fc ff
	ff		 mov	 DWORD PTR _pCurveItem$[ebp], eax
$L70238:
  00324	83 bd ec fc ff
	ff 00		 cmp	 DWORD PTR _pCurveItem$[ebp], 0
  0032b	0f 84 29 02 00
	00		 je	 $L70240

; 1422 : 			{
; 1423 : 				DMUS_IO_CURVE_ITEM& rCurveItem = pCurveItem->GetItemValue();

  00331	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR _pCurveItem$[ebp]
  00337	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  0033c	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _rCurveItem$70241[ebp], eax

; 1424 : 				if( rCurveItem.mtStart >= mtTime )

  00342	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  00348	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034a	3b 4d 1c	 cmp	 ecx, DWORD PTR _mtTime$[ebp]
  0034d	7c 05		 jl	 SHORT $L70242

; 1425 : 				{
; 1426 : 					break;

  0034f	e9 06 02 00 00	 jmp	 $L70240
$L70242:

; 1427 : 				}
; 1428 : 				if( !fGetPrevious )

  00354	83 7d 20 00	 cmp	 DWORD PTR _fGetPrevious$[ebp], 0
  00358	75 02		 jne	 SHORT $L70243

; 1429 : 				{
; 1430 : 					// if we don't care about previous events, just continue
; 1431 : 					continue;

  0035a	eb b7		 jmp	 SHORT $L70239
$L70243:

; 1432 : 				}
; 1433 : 				switch( rCurveItem.bType )
; 1434 : 				{

  0035c	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _rCurveItem$70241[ebp]
  00362	8a 42 18	 mov	 al, BYTE PTR [edx+24]
  00365	88 85 b8 fc ff
	ff		 mov	 BYTE PTR tv200[ebp], al
  0036b	80 bd b8 fc ff
	ff 03		 cmp	 BYTE PTR tv200[ebp], 3
  00372	0f 84 6b 01 00
	00		 je	 $L70259
  00378	80 bd b8 fc ff
	ff 04		 cmp	 BYTE PTR tv200[ebp], 4
  0037f	74 12		 je	 SHORT $L70248
  00381	80 bd b8 fc ff
	ff 05		 cmp	 BYTE PTR tv200[ebp], 5
  00388	0f 84 e1 00 00
	00		 je	 $L70254
  0038e	e9 c2 01 00 00	 jmp	 $L70245
$L70248:

; 1435 : 				case DMUS_CURVET_CCCURVE:
; 1436 : 					if( ( rCurveItem.bCCData < CC_1 ) && ( rCurveItem.bCCData != 6 ) &&
; 1437 : 						( rCurveItem.bCCData != 38 ) )

  00393	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR _rCurveItem$70241[ebp]
  00399	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  0039d	83 fa 60	 cmp	 edx, 96			; 00000060H
  003a0	0f 8d c4 00 00
	00		 jge	 $L70249
  003a6	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  003ac	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  003b0	83 f9 06	 cmp	 ecx, 6
  003b3	0f 84 b1 00 00
	00		 je	 $L70249
  003b9	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _rCurveItem$70241[ebp]
  003bf	0f b6 42 1a	 movzx	 eax, BYTE PTR [edx+26]
  003c3	83 f8 26	 cmp	 eax, 38			; 00000026H
  003c6	0f 84 9e 00 00
	00		 je	 $L70249

; 1438 : 					{
; 1439 : 						if( apCurveItemCC[ rCurveItem.bCCData ] )

  003cc	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR _rCurveItem$70241[ebp]
  003d2	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  003d6	83 bc 95 f0 fc
	ff ff 00	 cmp	 DWORD PTR _apCurveItemCC$[ebp+edx*4], 0
  003de	74 73		 je	 SHORT $L70250

; 1440 : 						{
; 1441 : 							DMUS_IO_CURVE_ITEM& rTemp = apCurveItemCC[ rCurveItem.bCCData ]->GetItemValue();

  003e0	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  003e6	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  003ea	8b 8c 8d f0 fc
	ff ff		 mov	 ecx, DWORD PTR _apCurveItemCC$[ebp+ecx*4]
  003f1	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  003f6	89 85 cc fc ff
	ff		 mov	 DWORD PTR _rTemp$70251[ebp], eax

; 1442 : 							if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
; 1443 : 								rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )

  003fc	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _rCurveItem$70241[ebp]
  00402	8b 02		 mov	 eax, DWORD PTR [edx]
  00404	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR _rCurveItem$70241[ebp]
  0040a	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0040d	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _rCurveItem$70241[ebp]
  00413	0f bf 4a 10	 movsx	 ecx, WORD PTR [edx+16]
  00417	03 c1		 add	 eax, ecx
  00419	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _rTemp$70251[ebp]
  0041f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00421	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _rTemp$70251[ebp]
  00427	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0042a	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _rTemp$70251[ebp]
  00430	0f bf 52 10	 movsx	 edx, WORD PTR [edx+16]
  00434	03 ca		 add	 ecx, edx
  00436	3b c1		 cmp	 eax, ecx
  00438	7e 17		 jle	 SHORT $L70252

; 1444 : 							{
; 1445 : 								apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;

  0043a	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  00440	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  00444	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _pCurveItem$[ebp]
  0044a	89 94 8d f0 fc
	ff ff		 mov	 DWORD PTR _apCurveItemCC$[ebp+ecx*4], edx
$L70252:

; 1446 : 							}
; 1447 : 						}
; 1448 : 						else

  00451	eb 17		 jmp	 SHORT $L70249
$L70250:

; 1449 : 						{
; 1450 : 							apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;

  00453	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  00459	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  0045d	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _pCurveItem$[ebp]
  00463	89 94 8d f0 fc
	ff ff		 mov	 DWORD PTR _apCurveItemCC$[ebp+ecx*4], edx
$L70249:

; 1451 : 						}
; 1452 : 					}
; 1453 : 					break;

  0046a	e9 e6 00 00 00	 jmp	 $L70245
$L70254:

; 1454 : 				case DMUS_CURVET_MATCURVE:
; 1455 : 					if( pCurveItemMonoAT )

  0046f	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR _pCurveItemMonoAT$[ebp], 0
  00476	74 5d		 je	 SHORT $L70255

; 1456 : 					{
; 1457 : 						DMUS_IO_CURVE_ITEM& rTemp = pCurveItemMonoAT->GetItemValue();

  00478	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _pCurveItemMonoAT$[ebp]
  0047e	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  00483	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _rTemp$70256[ebp], eax

; 1458 : 						if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
; 1459 : 							rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )

  00489	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _rCurveItem$70241[ebp]
  00497	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0049a	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  004a0	0f bf 50 10	 movsx	 edx, WORD PTR [eax+16]
  004a4	03 ca		 add	 ecx, edx
  004a6	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _rTemp$70256[ebp]
  004ac	8b 10		 mov	 edx, DWORD PTR [eax]
  004ae	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _rTemp$70256[ebp]
  004b4	03 50 04	 add	 edx, DWORD PTR [eax+4]
  004b7	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _rTemp$70256[ebp]
  004bd	0f bf 40 10	 movsx	 eax, WORD PTR [eax+16]
  004c1	03 d0		 add	 edx, eax
  004c3	3b ca		 cmp	 ecx, edx
  004c5	7e 0c		 jle	 SHORT $L70257

; 1460 : 						{
; 1461 : 							pCurveItemMonoAT = pCurveItem;

  004c7	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR _pCurveItem$[ebp]
  004cd	89 8d 78 fe ff
	ff		 mov	 DWORD PTR _pCurveItemMonoAT$[ebp], ecx
$L70257:

; 1462 : 						}
; 1463 : 					}
; 1464 : 					else

  004d3	eb 0c		 jmp	 SHORT $L70258
$L70255:

; 1465 : 					{
; 1466 : 						pCurveItemMonoAT = pCurveItem;

  004d5	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _pCurveItem$[ebp]
  004db	89 95 78 fe ff
	ff		 mov	 DWORD PTR _pCurveItemMonoAT$[ebp], edx
$L70258:

; 1467 : 					}
; 1468 : 					break;

  004e1	eb 72		 jmp	 SHORT $L70245
$L70259:

; 1469 : 				case DMUS_CURVET_PBCURVE:
; 1470 : 					if( pCurveItemPBend )

  004e3	83 bd e8 fc ff
	ff 00		 cmp	 DWORD PTR _pCurveItemPBend$[ebp], 0
  004ea	74 5d		 je	 SHORT $L70260

; 1471 : 					{
; 1472 : 						DMUS_IO_CURVE_ITEM& rTemp = pCurveItemPBend->GetItemValue();

  004ec	8b 8d e8 fc ff
	ff		 mov	 ecx, DWORD PTR _pCurveItemPBend$[ebp]
  004f2	e8 00 00 00 00	 call	 ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
  004f7	89 85 c4 fc ff
	ff		 mov	 DWORD PTR _rTemp$70261[ebp], eax

; 1473 : 						if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
; 1474 : 							rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )

  004fd	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  00503	8b 08		 mov	 ecx, DWORD PTR [eax]
  00505	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _rCurveItem$70241[ebp]
  0050b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0050e	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _rCurveItem$70241[ebp]
  00514	0f bf 50 10	 movsx	 edx, WORD PTR [eax+16]
  00518	03 ca		 add	 ecx, edx
  0051a	8b 85 c4 fc ff
	ff		 mov	 eax, DWORD PTR _rTemp$70261[ebp]
  00520	8b 10		 mov	 edx, DWORD PTR [eax]
  00522	8b 85 c4 fc ff
	ff		 mov	 eax, DWORD PTR _rTemp$70261[ebp]
  00528	03 50 04	 add	 edx, DWORD PTR [eax+4]
  0052b	8b 85 c4 fc ff
	ff		 mov	 eax, DWORD PTR _rTemp$70261[ebp]
  00531	0f bf 40 10	 movsx	 eax, WORD PTR [eax+16]
  00535	03 d0		 add	 edx, eax
  00537	3b ca		 cmp	 ecx, edx
  00539	7e 0c		 jle	 SHORT $L70262

; 1475 : 						{
; 1476 : 							pCurveItemPBend = pCurveItem;

  0053b	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR _pCurveItem$[ebp]
  00541	89 8d e8 fc ff
	ff		 mov	 DWORD PTR _pCurveItemPBend$[ebp], ecx
$L70262:

; 1477 : 						}
; 1478 : 					}
; 1479 : 					else

  00547	eb 0c		 jmp	 SHORT $L70245
$L70260:

; 1480 : 					{
; 1481 : 						pCurveItemPBend = pCurveItem;

  00549	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _pCurveItem$[ebp]
  0054f	89 95 e8 fc ff
	ff		 mov	 DWORD PTR _pCurveItemPBend$[ebp], edx
$L70245:

; 1482 : 					}
; 1483 : 					break;
; 1484 : 				default:
; 1485 : 					break;
; 1486 : 				}
; 1487 : 			}

  00555	e9 b9 fd ff ff	 jmp	 $L70239
$L70240:

; 1488 : 			if( pSD->apCurrentCurve )

  0055a	8b 45 18	 mov	 eax, DWORD PTR _pSD$[ebp]
  0055d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00561	74 15		 je	 SHORT $L70265

; 1489 : 			{
; 1490 : 				pSD->apCurrentCurve[dwIndex] = pCurveItem;

  00563	8b 4d 18	 mov	 ecx, DWORD PTR _pSD$[ebp]
  00566	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00569	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0056f	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR _pCurveItem$[ebp]
  00575	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
$L70265:

; 1491 : 			}
; 1492 : 			if( fGetPrevious )

  00578	83 7d 20 00	 cmp	 DWORD PTR _fGetPrevious$[ebp], 0
  0057c	0f 84 f7 00 00
	00		 je	 $L70266

; 1493 : 			{
; 1494 : 				DWORD dwCC;
; 1495 : 				// create and send past events appropriately
; 1496 : 				SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemPBend, pCurveItemPBend, fClockTime );

  00582	8b 55 30	 mov	 edx, DWORD PTR _fClockTime$[ebp]
  00585	52		 push	 edx
  00586	8b 85 e8 fc ff
	ff		 mov	 eax, DWORD PTR _pCurveItemPBend$[ebp]
  0058c	50		 push	 eax
  0058d	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _pSeqItemPBend$[ebp]
  00593	51		 push	 ecx
  00594	8b 55 2c	 mov	 edx, DWORD PTR _rtOffset$[ebp+4]
  00597	52		 push	 edx
  00598	8b 45 28	 mov	 eax, DWORD PTR _rtOffset$[ebp]
  0059b	50		 push	 eax
  0059c	8b 4d 24	 mov	 ecx, DWORD PTR _mtOffset$[ebp]
  0059f	51		 push	 ecx
  005a0	8b 55 1c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  005a3	52		 push	 edx
  005a4	8b 45 14	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  005a7	50		 push	 eax
  005a8	8b 4d 18	 mov	 ecx, DWORD PTR _pSD$[ebp]
  005ab	51		 push	 ecx
  005ac	8b 55 0c	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  005af	52		 push	 edx
  005b0	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _pGraph$[ebp]
  005b6	50		 push	 eax
  005b7	8b 4d 10	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  005ba	51		 push	 ecx
  005bb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  005be	e8 00 00 00 00	 call	 ?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z ; CSeqTrack::SendSeekItem

; 1497 : 				SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemMonoAT, pCurveItemMonoAT, fClockTime );

  005c3	8b 55 30	 mov	 edx, DWORD PTR _fClockTime$[ebp]
  005c6	52		 push	 edx
  005c7	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _pCurveItemMonoAT$[ebp]
  005cd	50		 push	 eax
  005ce	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _pSeqItemMonoAT$[ebp]
  005d4	51		 push	 ecx
  005d5	8b 55 2c	 mov	 edx, DWORD PTR _rtOffset$[ebp+4]
  005d8	52		 push	 edx
  005d9	8b 45 28	 mov	 eax, DWORD PTR _rtOffset$[ebp]
  005dc	50		 push	 eax
  005dd	8b 4d 24	 mov	 ecx, DWORD PTR _mtOffset$[ebp]
  005e0	51		 push	 ecx
  005e1	8b 55 1c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  005e4	52		 push	 edx
  005e5	8b 45 14	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  005e8	50		 push	 eax
  005e9	8b 4d 18	 mov	 ecx, DWORD PTR _pSD$[ebp]
  005ec	51		 push	 ecx
  005ed	8b 55 0c	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  005f0	52		 push	 edx
  005f1	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _pGraph$[ebp]
  005f7	50		 push	 eax
  005f8	8b 4d 10	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  005fb	51		 push	 ecx
  005fc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  005ff	e8 00 00 00 00	 call	 ?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z ; CSeqTrack::SendSeekItem

; 1498 : 				for( dwCC = 0; dwCC < CC_1; dwCC++ )

  00604	c7 85 c0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwCC$70267[ebp], 0
  0060e	eb 0f		 jmp	 SHORT $L70268
$L70269:
  00610	8b 95 c0 fc ff
	ff		 mov	 edx, DWORD PTR _dwCC$70267[ebp]
  00616	83 c2 01	 add	 edx, 1
  00619	89 95 c0 fc ff
	ff		 mov	 DWORD PTR _dwCC$70267[ebp], edx
$L70268:
  0061f	83 bd c0 fc ff
	ff 60		 cmp	 DWORD PTR _dwCC$70267[ebp], 96 ; 00000060H
  00626	73 51		 jae	 SHORT $L70266

; 1499 : 				{
; 1500 : 					SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, apSeqItemCC[dwCC], apCurveItemCC[dwCC], fClockTime );

  00628	8b 45 30	 mov	 eax, DWORD PTR _fClockTime$[ebp]
  0062b	50		 push	 eax
  0062c	8b 8d c0 fc ff
	ff		 mov	 ecx, DWORD PTR _dwCC$70267[ebp]
  00632	8b 94 8d f0 fc
	ff ff		 mov	 edx, DWORD PTR _apCurveItemCC$[ebp+ecx*4]
  00639	52		 push	 edx
  0063a	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR _dwCC$70267[ebp]
  00640	8b 8c 85 80 fe
	ff ff		 mov	 ecx, DWORD PTR _apSeqItemCC$[ebp+eax*4]
  00647	51		 push	 ecx
  00648	8b 55 2c	 mov	 edx, DWORD PTR _rtOffset$[ebp+4]
  0064b	52		 push	 edx
  0064c	8b 45 28	 mov	 eax, DWORD PTR _rtOffset$[ebp]
  0064f	50		 push	 eax
  00650	8b 4d 24	 mov	 ecx, DWORD PTR _mtOffset$[ebp]
  00653	51		 push	 ecx
  00654	8b 55 1c	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00657	52		 push	 edx
  00658	8b 45 14	 mov	 eax, DWORD PTR _dwVirtualID$[ebp]
  0065b	50		 push	 eax
  0065c	8b 4d 18	 mov	 ecx, DWORD PTR _pSD$[ebp]
  0065f	51		 push	 ecx
  00660	8b 55 0c	 mov	 edx, DWORD PTR _pSegSt$[ebp]
  00663	52		 push	 edx
  00664	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _pGraph$[ebp]
  0066a	50		 push	 eax
  0066b	8b 4d 10	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0066e	51		 push	 ecx
  0066f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00672	e8 00 00 00 00	 call	 ?SendSeekItem@CSeqTrack@@IAEXPAUIDirectMusicPerformance@@PAUIDirectMusicGraph@@PAUIDirectMusicSegmentState@@PAUSeqStateData@@KJJ_JPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@PAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@H@Z ; CSeqTrack::SendSeekItem

; 1501 : 				}

  00677	eb 97		 jmp	 SHORT $L70269
$L70266:

; 1502 : 			}
; 1503 : 			pPart = pPart->GetNext();

  00679	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _pPart$[ebp]
  0067f	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  00684	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _pPart$[ebp], eax
$L70219:

; 1504 : 		}
; 1505 : 	}

  0068a	e9 c0 fa ff ff	 jmp	 $L70217
$L70218:

; 1506 : 
; 1507 : 	if( pGraph )

  0068f	83 bd d8 fc ff
	ff 00		 cmp	 DWORD PTR _pGraph$[ebp], 0
  00696	74 12		 je	 SHORT $L70271

; 1508 : 	{
; 1509 : 		pGraph->Release();

  00698	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _pGraph$[ebp]
  0069e	8b 02		 mov	 eax, DWORD PTR [edx]
  006a0	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _pGraph$[ebp]
  006a6	51		 push	 ecx
  006a7	ff 50 08	 call	 DWORD PTR [eax+8]
$L70271:

; 1510 : 	}
; 1511 : 	return S_OK;

  006aa	33 c0		 xor	 eax, eax
$L70192:

; 1512 : }

  006ac	8b e5		 mov	 esp, ebp
  006ae	5d		 pop	 ebp
  006af	c2 2c 00	 ret	 44			; 0000002cH
?Seek@CSeqTrack@@IAGJPAUIDirectMusicSegmentState@@PAUIDirectMusicPerformance@@KPAUSeqStateData@@JHJ_JH@Z ENDP ; CSeqTrack::Seek
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetParam@CSeqTrack@@UAGJABU_GUID@@JPAJPAX@Z
_TEXT	SEGMENT
_this$ = 8
_rguidType$ = 12
_mtTime$ = 16
_pmtNext$ = 20
_pData$ = 24
?GetParam@CSeqTrack@@UAGJABU_GUID@@JPAJPAX@Z PROC NEAR	; CSeqTrack::GetParam, COMDAT

; 1533 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1534 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1535 : }

  00008	5d		 pop	 ebp
  00009	c2 14 00	 ret	 20			; 00000014H
?GetParam@CSeqTrack@@UAGJABU_GUID@@JPAJPAX@Z ENDP	; CSeqTrack::GetParam
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetParam@CSeqTrack@@UAGJABU_GUID@@JPAX@Z
_TEXT	SEGMENT
_this$ = 8
_rguidType$ = 12
_mtTime$ = 16
_pData$ = 20
?SetParam@CSeqTrack@@UAGJABU_GUID@@JPAX@Z PROC NEAR	; CSeqTrack::SetParam, COMDAT

; 1552 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1553 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1554 : }

  00008	5d		 pop	 ebp
  00009	c2 10 00	 ret	 16			; 00000010H
?SetParam@CSeqTrack@@UAGJABU_GUID@@JPAX@Z ENDP		; CSeqTrack::SetParam
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPA_JPAX3K@Z
_TEXT	SEGMENT
_this$ = 8
_rguidType$ = 12
_rtTime$ = 16
_prtNext$ = 24
_pParam$ = 28
_pStateData$ = 32
_dwFlags$ = 36
?GetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPA_JPAX3K@Z PROC NEAR ; CSeqTrack::GetParamEx, COMDAT

; 1558 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1560 : }

  00008	5d		 pop	 ebp
  00009	c2 20 00	 ret	 32			; 00000020H
?GetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPA_JPAX3K@Z ENDP	; CSeqTrack::GetParamEx
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPAX2K@Z
_TEXT	SEGMENT
_this$ = 8
_rguidType$ = 12
_rtTime$ = 16
_pParam$ = 24
_pStateData$ = 28
_dwFlags$ = 32
?SetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPAX2K@Z PROC NEAR ; CSeqTrack::SetParamEx, COMDAT

; 1564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1565 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1566 : }

  00008	5d		 pop	 ebp
  00009	c2 1c 00	 ret	 28			; 0000001cH
?SetParamEx@CSeqTrack@@UAGJABU_GUID@@_JPAX2K@Z ENDP	; CSeqTrack::SetParamEx
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_rguidNotification$ = 12
?AddNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z PROC NEAR ; CSeqTrack::AddNotificationType, COMDAT

; 1579 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1580 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1581 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?AddNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z ENDP	; CSeqTrack::AddNotificationType
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_rguidNotification$ = 12
?RemoveNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z PROC NEAR ; CSeqTrack::RemoveNotificationType, COMDAT

; 1594 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1596 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?RemoveNotificationType@CSeqTrack@@UAGJABU_GUID@@@Z ENDP ; CSeqTrack::RemoveNotificationType
_TEXT	ENDS
PUBLIC	??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@ ; `string'
PUBLIC	??_C@_0EH@EFKFPJBJ@Error?3?5Invalid?5clone?5parameters?5@ ; `string'
PUBLIC	??_C@_0FM@HOGOGKH@Error?3?5Invalid?5clone?5parameters?5@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z@4QBDB DB 'I'
	DB	'DirectMusicTrack::Clone', 00H		; `CSeqTrack::Clone'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@
CONST	SEGMENT
??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@ DB '%s: Inva'
	DB	'lid pointer ppTrack', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@EFKFPJBJ@Error?3?5Invalid?5clone?5parameters?5@
CONST	SEGMENT
??_C@_0EH@EFKFPJBJ@Error?3?5Invalid?5clone?5parameters?5@ DB 'Error: Inva'
	DB	'lid clone parameters to Sequence Track, start time is %ld.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@HOGOGKH@Error?3?5Invalid?5clone?5parameters?5@
CONST	SEGMENT
??_C@_0FM@HOGOGKH@Error?3?5Invalid?5clone?5parameters?5@ DB 'Error: Inval'
	DB	'id clone parameters to Sequence Track, start time %ld is grea'
	DB	'ter than end %ld.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT
tv92 = -16
$T71034 = -12
_hr$ = -8
_pDM$ = -4
_this$ = 8
_mtStart$ = 12
_mtEnd$ = 16
_ppTrack$ = 20
?Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z PROC NEAR ; CSeqTrack::Clone, COMDAT

; 1614 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1615 : 	V_INAME(IDirectMusicTrack::Clone);
; 1616 : 	V_PTRPTR_WRITE(ppTrack);

  00006	6a 04		 push	 4
  00008	8b 45 14	 mov	 eax, DWORD PTR _ppTrack$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70326
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@DBOFCDJN@?$CFs?3?5Invalid?5pointer?5ppTrack?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70326:

; 1617 : 
; 1618 : 	HRESULT hr = S_OK;

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1619 : 
; 1620 : 	if(mtStart < 0 )

  00035	83 7d 0c 00	 cmp	 DWORD PTR _mtStart$[ebp], 0
  00039	7d 1d		 jge	 SHORT $L70329

; 1621 : 	{
; 1622 :         Trace(1,"Error: Invalid clone parameters to Sequence Track, start time is %ld.\n",mtStart);

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  0003e	51		 push	 ecx
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@EFKFPJBJ@Error?3?5Invalid?5clone?5parameters?5@
  00044	6a 01		 push	 1
  00046	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1623 : 		return E_INVALIDARG;

  0004e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00053	e9 b2 00 00 00	 jmp	 $L70322
$L70329:

; 1624 : 	}
; 1625 : 	if(mtStart > mtEnd)

  00058	8b 55 0c	 mov	 edx, DWORD PTR _mtStart$[ebp]
  0005b	3b 55 10	 cmp	 edx, DWORD PTR _mtEnd$[ebp]
  0005e	7e 21		 jle	 SHORT $L70332

; 1626 : 	{
; 1627 :         Trace(1,"Error: Invalid clone parameters to Sequence Track, start time %ld is greater than end %ld.\n",mtStart,mtEnd);

  00060	8b 45 10	 mov	 eax, DWORD PTR _mtEnd$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  00067	51		 push	 ecx
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FM@HOGOGKH@Error?3?5Invalid?5clone?5parameters?5@
  0006d	6a 01		 push	 1
  0006f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 1628 : 		return E_INVALIDARG;

  00077	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0007c	e9 89 00 00 00	 jmp	 $L70322
$L70332:

; 1629 : 	}
; 1630 : 
; 1631 : 	ENTER_CRITICAL_SECTION(&m_CrSec);

  00081	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00084	83 c2 1c	 add	 edx, 28			; 0000001cH
  00087	52		 push	 edx
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1632 :     CSeqTrack *pDM;
; 1633 :     NEWCATCH(pDM,CSeqTrack(*this, mtStart, mtEnd))

  0008e	6a 4c		 push	 76			; 0000004cH
  00090	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00095	83 c4 04	 add	 esp, 4
  00098	89 45 f4	 mov	 DWORD PTR $T71034[ebp], eax
  0009b	83 7d f4 00	 cmp	 DWORD PTR $T71034[ebp], 0
  0009f	74 1c		 je	 SHORT $L71035
  000a1	8b 45 10	 mov	 eax, DWORD PTR _mtEnd$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR _mtStart$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 ea 04	 sub	 edx, 4
  000af	52		 push	 edx
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR $T71034[ebp]
  000b3	e8 00 00 00 00	 call	 ??0CSeqTrack@@QAE@ABV0@JJ@Z ; CSeqTrack::CSeqTrack
  000b8	89 45 f0	 mov	 DWORD PTR tv92[ebp], eax
  000bb	eb 07		 jmp	 SHORT $L71036
$L71035:
  000bd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$L71036:
  000c4	8b 45 f0	 mov	 eax, DWORD PTR tv92[ebp]
  000c7	89 45 fc	 mov	 DWORD PTR _pDM$[ebp], eax

; 1634 : /*    try
; 1635 :     {
; 1636 :         pDM = new CSeqTrack(*this, mtStart, mtEnd);
; 1637 :     }
; 1638 :     catch( ... )
; 1639 :     {
; 1640 :         pDM = NULL;
; 1641 :     }*/
; 1642 : 
; 1643 : 	LEAVE_CRITICAL_SECTION(&m_CrSec);

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000d0	51		 push	 ecx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1644 :     if (pDM == NULL) {

  000d7	83 7d fc 00	 cmp	 DWORD PTR _pDM$[ebp], 0
  000db	75 07		 jne	 SHORT $L70338

; 1645 :         return E_OUTOFMEMORY;

  000dd	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  000e2	eb 26		 jmp	 SHORT $L70322
$L70338:

; 1646 :     }
; 1647 : 
; 1648 :     hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);

  000e4	8b 55 14	 mov	 edx, DWORD PTR _ppTrack$[ebp]
  000e7	52		 push	 edx
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicTrack
  000ed	8b 45 fc	 mov	 eax, DWORD PTR _pDM$[ebp]
  000f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f2	8b 55 fc	 mov	 edx, DWORD PTR _pDM$[ebp]
  000f5	52		 push	 edx
  000f6	ff 11		 call	 DWORD PTR [ecx]
  000f8	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1649 :     pDM->Release();

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _pDM$[ebp]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	8b 55 fc	 mov	 edx, DWORD PTR _pDM$[ebp]
  00103	52		 push	 edx
  00104	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1650 : 
; 1651 : 	return hr;

  00107	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L70322:

; 1652 : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 10 00	 ret	 16			; 00000010H
?Clone@CSeqTrack@@UAGJJJPAPAUIDirectMusicTrack@@@Z ENDP	; CSeqTrack::Clone
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Compose@CSeqTrack@@UAGJPAUIUnknown@@KPAPAUIDirectMusicTrack@@@Z
_TEXT	SEGMENT
_this$ = 8
_pContext$ = 12
_dwTrackGroup$ = 16
_ppResultTrack$ = 20
?Compose@CSeqTrack@@UAGJPAUIUnknown@@KPAPAUIDirectMusicTrack@@@Z PROC NEAR ; CSeqTrack::Compose, COMDAT

; 1659 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1660 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1661 : }

  00008	5d		 pop	 ebp
  00009	c2 10 00	 ret	 16			; 00000010H
?Compose@CSeqTrack@@UAGJPAUIUnknown@@KPAPAUIDirectMusicTrack@@@Z ENDP ; CSeqTrack::Compose
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Join@CSeqTrack@@UAGJPAUIDirectMusicTrack@@JPAUIUnknown@@KPAPAU2@@Z
_TEXT	SEGMENT
_this$ = 8
_pNewTrack$ = 12
_mtJoin$ = 16
_pContext$ = 20
_dwTrackGroup$ = 24
_ppResultTrack$ = 28
?Join@CSeqTrack@@UAGJPAUIDirectMusicTrack@@JPAUIUnknown@@KPAPAU2@@Z PROC NEAR ; CSeqTrack::Join, COMDAT

; 1669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1670 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1671 : }

  00008	5d		 pop	 ebp
  00009	c2 18 00	 ret	 24			; 00000018H
?Join@CSeqTrack@@UAGJPAUIDirectMusicTrack@@JPAUIUnknown@@KPAPAU2@@Z ENDP ; CSeqTrack::Join
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.h
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ PROC NEAR ; TList<_DMUS_IO_SEQ_ITEM>::GetHead, COMDAT
; _this$ = ecx

; 61   :     TListItem<T> *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ENDP ; TList<_DMUS_IO_SEQ_ITEM>::GetHead
_TEXT	ENDS
PUBLIC	?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext
; Function compile flags: /Odt
;	COMDAT ?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z PROC NEAR ; TList<_DMUS_IO_SEQ_ITEM>::AddHead, COMDAT
; _this$ = ecx

; 80   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : //            assert(pItem!=NULL);
; 82   :             pItem->SetNext(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00010	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext

; 83   :             m_pHead=pItem;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 84   :         }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?AddHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@@Z ENDP ; TList<_DMUS_IO_SEQ_ITEM>::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ PROC NEAR ; TList<_DMUS_IO_SEQ_ITEM>::RemoveHead, COMDAT
; _this$ = ecx

; 91   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 92   :             TListItem<T> *li;
; 93   :             li=m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 94   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L70364

; 95   : 			{
; 96   :                 m_pHead=m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 97   : 				li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext
$L70364:

; 98   : 			}
; 99   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 100  :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@XZ ENDP ; TList<_DMUS_IO_SEQ_ITEM>::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ PROC NEAR ; TList<_DMUS_IO_CURVE_ITEM>::GetHead, COMDAT
; _this$ = ecx

; 61   :     TListItem<T> *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ENDP ; TList<_DMUS_IO_CURVE_ITEM>::GetHead
_TEXT	ENDS
PUBLIC	?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext
; Function compile flags: /Odt
;	COMDAT ?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z PROC NEAR ; TList<_DMUS_IO_CURVE_ITEM>::AddHead, COMDAT
; _this$ = ecx

; 80   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : //            assert(pItem!=NULL);
; 82   :             pItem->SetNext(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00010	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext

; 83   :             m_pHead=pItem;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 84   :         }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?AddHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@@Z ENDP ; TList<_DMUS_IO_CURVE_ITEM>::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ PROC NEAR ; TList<_DMUS_IO_CURVE_ITEM>::RemoveHead, COMDAT
; _this$ = ecx

; 91   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 92   :             TListItem<T> *li;
; 93   :             li=m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 94   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L70372

; 95   : 			{
; 96   :                 m_pHead=m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 97   : 				li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext
$L70372:

; 98   : 			}
; 99   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 100  :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEPAV?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@XZ ENDP ; TList<_DMUS_IO_CURVE_ITEM>::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TList@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TList@USEQ_PART@@@@QAE@XZ PROC NEAR		; TList<SEQ_PART>::TList<SEQ_PART>, COMDAT
; _this$ = ecx

; 55   :     TList() {m_pHead=NULL;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$TList@USEQ_PART@@@@QAE@XZ ENDP			; TList<SEQ_PART>::TList<SEQ_PART>
_TEXT	ENDS
PUBLIC	?Delete@?$TListItem@USEQ_PART@@@@SGXPAV1@@Z	; TListItem<SEQ_PART>::Delete
; Function compile flags: /Odt
;	COMDAT ??1?$TList@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TList@USEQ_PART@@@@QAE@XZ PROC NEAR		; TList<SEQ_PART>::~TList<SEQ_PART>, COMDAT
; _this$ = ecx

; 57   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		//if (m_pHead != NULL) delete m_pHead;
; 59   : 		TListItem<T>::Delete(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Delete@?$TListItem@USEQ_PART@@@@SGXPAV1@@Z ; TListItem<SEQ_PART>::Delete

; 60   : 	} // new destructor

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$TList@USEQ_PART@@@@QAE@XZ ENDP			; TList<SEQ_PART>::~TList<SEQ_PART>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ PROC NEAR ; TList<SEQ_PART>::GetHead, COMDAT
; _this$ = ecx

; 61   :     TListItem<T> *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@?$TList@USEQ_PART@@@@QBEPAV?$TListItem@USEQ_PART@@@@XZ ENDP ; TList<SEQ_PART>::GetHead
_TEXT	ENDS
PUBLIC	?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z	; TListItem<SEQ_PART>::SetNext
; Function compile flags: /Odt
;	COMDAT ?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z PROC NEAR ; TList<SEQ_PART>::AddHead, COMDAT
; _this$ = ecx

; 80   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : //            assert(pItem!=NULL);
; 82   :             pItem->SetNext(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00010	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z ; TListItem<SEQ_PART>::SetNext

; 83   :             m_pHead=pItem;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 84   :         }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?AddHead@?$TList@USEQ_PART@@@@QAEXPAV?$TListItem@USEQ_PART@@@@@Z ENDP ; TList<SEQ_PART>::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@?$TList@USEQ_PART@@@@QAEPAV?$TListItem@USEQ_PART@@@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@?$TList@USEQ_PART@@@@QAEPAV?$TListItem@USEQ_PART@@@@XZ PROC NEAR ; TList<SEQ_PART>::RemoveHead, COMDAT
; _this$ = ecx

; 91   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 92   :             TListItem<T> *li;
; 93   :             li=m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 94   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L70384

; 95   : 			{
; 96   :                 m_pHead=m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 97   : 				li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z ; TListItem<SEQ_PART>::SetNext
$L70384:

; 98   : 			}
; 99   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 100  :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@?$TList@USEQ_PART@@@@QAEPAV?$TListItem@USEQ_PART@@@@XZ ENDP ; TList<SEQ_PART>::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ PROC NEAR	; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>, COMDAT
; _this$ = ecx

; 28   :     TListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ENDP	; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@ABU_DMUS_IO_SEQ_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4
_item$ = 8
??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@ABU_DMUS_IO_SEQ_ITEM@@@Z PROC NEAR ; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>, COMDAT
; _this$ = ecx

; 31   :     TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 75 08	 mov	 esi, DWORD PTR _item$[ebp]
  0000c	b9 05 00 00 00	 mov	 ecx, 5
  00011	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00014	f3 a5		 rep movsd
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@ABU_DMUS_IO_SEQ_ITEM@@@Z ENDP ; TListItem<_DMUS_IO_SEQ_ITEM>::TListItem<_DMUS_IO_SEQ_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ PROC NEAR ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext, COMDAT
; _this$ = ecx

; 32   :     TListItem<T> *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ENDP ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ PROC NEAR ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue, COMDAT
; _this$ = ecx

; 40   :     T& GetItemValue() { return m_Tinfo; }  // additional member function

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?GetItemValue@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEAAU_DMUS_IO_SEQ_ITEM@@XZ ENDP ; TListItem<_DMUS_IO_SEQ_ITEM>::GetItemValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ PROC NEAR	; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>, COMDAT
; _this$ = ecx

; 28   :     TListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ENDP	; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@ABU_DMUS_IO_CURVE_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4
_item$ = 8
??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@ABU_DMUS_IO_CURVE_ITEM@@@Z PROC NEAR ; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>, COMDAT
; _this$ = ecx

; 31   :     TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 75 08	 mov	 esi, DWORD PTR _item$[ebp]
  0000c	b9 08 00 00 00	 mov	 ecx, 8
  00011	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00014	f3 a5		 rep movsd
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@ABU_DMUS_IO_CURVE_ITEM@@@Z ENDP ; TListItem<_DMUS_IO_CURVE_ITEM>::TListItem<_DMUS_IO_CURVE_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ PROC NEAR ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext, COMDAT
; _this$ = ecx

; 32   :     TListItem<T> *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ENDP ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ PROC NEAR ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue, COMDAT
; _this$ = ecx

; 40   :     T& GetItemValue() { return m_Tinfo; }  // additional member function

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?GetItemValue@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEAAU_DMUS_IO_CURVE_ITEM@@XZ ENDP ; TListItem<_DMUS_IO_CURVE_ITEM>::GetItemValue
_TEXT	ENDS
PUBLIC	??0SEQ_PART@@QAE@XZ				; SEQ_PART::SEQ_PART
; Function compile flags: /Odt
;	COMDAT ??0?$TListItem@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TListItem@USEQ_PART@@@@QAE@XZ PROC NEAR		; TListItem<SEQ_PART>::TListItem<SEQ_PART>, COMDAT
; _this$ = ecx

; 28   :     TListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SEQ_PART@@QAE@XZ	; SEQ_PART::SEQ_PART
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0?$TListItem@USEQ_PART@@@@QAE@XZ ENDP			; TListItem<SEQ_PART>::TListItem<SEQ_PART>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ PROC NEAR	; TListItem<SEQ_PART>::GetNext, COMDAT
; _this$ = ecx

; 32   :     TListItem<T> *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ENDP	; TListItem<SEQ_PART>::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ PROC NEAR ; TListItem<SEQ_PART>::GetItemValue, COMDAT
; _this$ = ecx

; 40   :     T& GetItemValue() { return m_Tinfo; }  // additional member function

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?GetItemValue@?$TListItem@USEQ_PART@@@@QAEAAUSEQ_PART@@XZ ENDP ; TListItem<SEQ_PART>::GetItemValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z PROC NEAR ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext, COMDAT
; _this$ = ecx

; 33   :     void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z ENDP ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z PROC NEAR ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext, COMDAT
; _this$ = ecx

; 33   :     void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z ENDP ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z PROC NEAR	; TListItem<SEQ_PART>::SetNext, COMDAT
; _this$ = ecx

; 33   :     void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z ENDP	; TListItem<SEQ_PART>::SetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.cpp
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@USEQ_PART@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12
_pNewHead$70531 = -8
_pNext$70532 = -4
?Reverse@?$TList@USEQ_PART@@@@QAEXXZ PROC NEAR		; TList<SEQ_PART>::Reverse, COMDAT
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 	if( m_pHead )

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 66		 je	 SHORT $L70529

; 199  : 	{
; 200  : 		TListItem<T>* pNewHead = m_pHead;

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR _pNewHead$70531[ebp], edx

; 201  : 		TListItem<T>* pNext = m_pHead->GetNext();

  00019	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  00023	89 45 fc	 mov	 DWORD PTR _pNext$70532[ebp], eax

; 202  : 		pNewHead->SetNext(NULL);

  00026	6a 00		 push	 0
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _pNewHead$70531[ebp]
  0002b	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z ; TListItem<SEQ_PART>::SetNext

; 203  : 		for( m_pHead = pNext; m_pHead; m_pHead = pNext )

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 fc	 mov	 edx, DWORD PTR _pNext$70532[ebp]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	eb 08		 jmp	 SHORT $L70533
$L70534:
  0003a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$70532[ebp]
  00040	89 08		 mov	 DWORD PTR [eax], ecx
$L70533:
  00042	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00045	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00048	74 25		 je	 SHORT $L70535

; 204  : 		{
; 205  : 			pNext = m_pHead->GetNext();

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@USEQ_PART@@@@QBEPAV1@XZ ; TListItem<SEQ_PART>::GetNext
  00054	89 45 fc	 mov	 DWORD PTR _pNext$70532[ebp], eax

; 206  : 			m_pHead->SetNext(pNewHead);

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _pNewHead$70531[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00060	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@USEQ_PART@@@@QAEXPAV1@@Z ; TListItem<SEQ_PART>::SetNext

; 207  : 			pNewHead = m_pHead;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d f8	 mov	 DWORD PTR _pNewHead$70531[ebp], ecx

; 208  : 		}

  0006d	eb cb		 jmp	 SHORT $L70534
$L70535:

; 209  : 		m_pHead = pNewHead;

  0006f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 45 f8	 mov	 eax, DWORD PTR _pNewHead$70531[ebp]
  00075	89 02		 mov	 DWORD PTR [edx], eax
$L70529:

; 210  : 	}
; 211  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?Reverse@?$TList@USEQ_PART@@@@QAEXXZ ENDP		; TList<SEQ_PART>::Reverse
_TEXT	ENDS
PUBLIC	??1SEQ_PART@@QAE@XZ				; SEQ_PART::~SEQ_PART
; Function compile flags: /Odt
;	COMDAT ??1?$TListItem@USEQ_PART@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TListItem@USEQ_PART@@@@QAE@XZ PROC NEAR		; TListItem<SEQ_PART>::~TListItem<SEQ_PART>, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	//if (m_pNext != NULL) { delete m_pNext; }
; 22   : 	// IMPORTANT: user of the list is required to delete content first!
; 23   : 	//ZeroMemory(&m_Tinfo, sizeof(T));
; 24   : }

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1SEQ_PART@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$TListItem@USEQ_PART@@@@QAE@XZ ENDP			; TListItem<SEQ_PART>::~TListItem<SEQ_PART>
_TEXT	ENDS
PUBLIC	??1?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ		; TList<_DMUS_IO_SEQ_ITEM>::~TList<_DMUS_IO_SEQ_ITEM>
PUBLIC	??1?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ	; TList<_DMUS_IO_CURVE_ITEM>::~TList<_DMUS_IO_CURVE_ITEM>
; Function compile flags: /Odt
;	COMDAT ??1SEQ_PART@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1SEQ_PART@@QAE@XZ PROC NEAR				; SEQ_PART::~SEQ_PART, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ; TList<_DMUS_IO_CURVE_ITEM>::~TList<_DMUS_IO_CURVE_ITEM>
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	e8 00 00 00 00	 call	 ??1?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ; TList<_DMUS_IO_SEQ_ITEM>::~TList<_DMUS_IO_SEQ_ITEM>
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1SEQ_PART@@QAE@XZ ENDP				; SEQ_PART::~SEQ_PART
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@USEQ_PART@@@@SGXPAV1@@Z
_TEXT	SEGMENT
tv70 = -20
$T71131 = -16
$T71130 = -12
_pScan$ = -8
_pNext$ = -4
_pFirst$ = 8
?Delete@?$TListItem@USEQ_PART@@@@SGXPAV1@@Z PROC NEAR	; TListItem<SEQ_PART>::Delete, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 29   : 	TListItem<T>* pScan = pFirst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pFirst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 30   : 	TListItem<T>* pNext = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0
$L70545:

; 31   : 	while (pScan)

  00013	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00017	74 39		 je	 SHORT $L70541

; 32   : 	{
; 33   : 		pNext = pScan->m_pNext;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0001c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001f	89 55 fc	 mov	 DWORD PTR _pNext$[ebp], edx

; 34   : 		delete pScan;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T71131[ebp], eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T71131[ebp]
  0002b	89 4d f4	 mov	 DWORD PTR $T71130[ebp], ecx
  0002e	83 7d f4 00	 cmp	 DWORD PTR $T71130[ebp], 0
  00032	74 0f		 je	 SHORT $L71132
  00034	6a 01		 push	 1
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T71130[ebp]
  00039	e8 00 00 00 00	 call	 ??_G?$TListItem@USEQ_PART@@@@QAEPAXI@Z
  0003e	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00041	eb 07		 jmp	 SHORT $L71133
$L71132:
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L71133:

; 35   : 		pScan = pNext;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 36   : 	}

  00050	eb c1		 jmp	 SHORT $L70545
$L70541:

; 37   : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Delete@?$TListItem@USEQ_PART@@@@SGXPAV1@@Z ENDP	; TListItem<SEQ_PART>::Delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12
_pNewHead$70554 = -8
_pNext$70555 = -4
?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ PROC NEAR	; TList<_DMUS_IO_SEQ_ITEM>::Reverse, COMDAT
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 	if( m_pHead )

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 66		 je	 SHORT $L70552

; 199  : 	{
; 200  : 		TListItem<T>* pNewHead = m_pHead;

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR _pNewHead$70554[ebp], edx

; 201  : 		TListItem<T>* pNext = m_pHead->GetNext();

  00019	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
  00023	89 45 fc	 mov	 DWORD PTR _pNext$70555[ebp], eax

; 202  : 		pNewHead->SetNext(NULL);

  00026	6a 00		 push	 0
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _pNewHead$70554[ebp]
  0002b	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext

; 203  : 		for( m_pHead = pNext; m_pHead; m_pHead = pNext )

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 fc	 mov	 edx, DWORD PTR _pNext$70555[ebp]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	eb 08		 jmp	 SHORT $L70556
$L70557:
  0003a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$70555[ebp]
  00040	89 08		 mov	 DWORD PTR [eax], ecx
$L70556:
  00042	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00045	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00048	74 25		 je	 SHORT $L70558

; 204  : 		{
; 205  : 			pNext = m_pHead->GetNext();

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::GetNext
  00054	89 45 fc	 mov	 DWORD PTR _pNext$70555[ebp], eax

; 206  : 			m_pHead->SetNext(pNewHead);

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _pNewHead$70554[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00060	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::SetNext

; 207  : 			pNewHead = m_pHead;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d f8	 mov	 DWORD PTR _pNewHead$70554[ebp], ecx

; 208  : 		}

  0006d	eb cb		 jmp	 SHORT $L70557
$L70558:

; 209  : 		m_pHead = pNewHead;

  0006f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 45 f8	 mov	 eax, DWORD PTR _pNewHead$70554[ebp]
  00075	89 02		 mov	 DWORD PTR [edx], eax
$L70552:

; 210  : 	}
; 211  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?Reverse@?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAEXXZ ENDP	; TList<_DMUS_IO_SEQ_ITEM>::Reverse
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12
_pNewHead$70564 = -8
_pNext$70565 = -4
?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ PROC NEAR ; TList<_DMUS_IO_CURVE_ITEM>::Reverse, COMDAT
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 	if( m_pHead )

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 66		 je	 SHORT $L70562

; 199  : 	{
; 200  : 		TListItem<T>* pNewHead = m_pHead;

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR _pNewHead$70564[ebp], edx

; 201  : 		TListItem<T>* pNext = m_pHead->GetNext();

  00019	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
  00023	89 45 fc	 mov	 DWORD PTR _pNext$70565[ebp], eax

; 202  : 		pNewHead->SetNext(NULL);

  00026	6a 00		 push	 0
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _pNewHead$70564[ebp]
  0002b	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext

; 203  : 		for( m_pHead = pNext; m_pHead; m_pHead = pNext )

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 fc	 mov	 edx, DWORD PTR _pNext$70565[ebp]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	eb 08		 jmp	 SHORT $L70566
$L70567:
  0003a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pNext$70565[ebp]
  00040	89 08		 mov	 DWORD PTR [eax], ecx
$L70566:
  00042	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00045	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00048	74 25		 je	 SHORT $L70568

; 204  : 		{
; 205  : 			pNext = m_pHead->GetNext();

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	e8 00 00 00 00	 call	 ?GetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QBEPAV1@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::GetNext
  00054	89 45 fc	 mov	 DWORD PTR _pNext$70565[ebp], eax

; 206  : 			m_pHead->SetNext(pNewHead);

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _pNewHead$70564[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00060	e8 00 00 00 00	 call	 ?SetNext@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::SetNext

; 207  : 			pNewHead = m_pHead;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d f8	 mov	 DWORD PTR _pNewHead$70564[ebp], ecx

; 208  : 		}

  0006d	eb cb		 jmp	 SHORT $L70567
$L70568:

; 209  : 		m_pHead = pNewHead;

  0006f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 45 f8	 mov	 eax, DWORD PTR _pNewHead$70564[ebp]
  00075	89 02		 mov	 DWORD PTR [edx], eax
$L70562:

; 210  : 	}
; 211  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?Reverse@?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAEXXZ ENDP	; TList<_DMUS_IO_CURVE_ITEM>::Reverse
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSeqTrack@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CSeqTrack@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; CSeqTrack::QueryInterface, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CSeqTrack@@UAGJABU_GUID@@PAPAX@Z ; CSeqTrack::QueryInterface
?QueryInterface@CSeqTrack@@W3AGJABU_GUID@@PAPAX@Z ENDP	; CSeqTrack::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CSeqTrack@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CSeqTrack@@W3AGKXZ PROC NEAR			; CSeqTrack::AddRef, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CSeqTrack@@UAGKXZ ; CSeqTrack::AddRef
?AddRef@CSeqTrack@@W3AGKXZ ENDP				; CSeqTrack::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CSeqTrack@@W3AGKXZ
_TEXT	SEGMENT
?Release@CSeqTrack@@W3AGKXZ PROC NEAR			; CSeqTrack::Release, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CSeqTrack@@UAGKXZ ; CSeqTrack::Release
?Release@CSeqTrack@@W3AGKXZ ENDP			; CSeqTrack::Release
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??_U@YAPAXI@Z PROC NEAR					; operator new[], COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 24   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_U@YAPAXI@Z ENDP					; operator new[]
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??_V@YAXPAX@Z PROC NEAR					; operator delete[], COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 29   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_V@YAXPAX@Z ENDP					; operator delete[]
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xboxutil.h
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT
___formal$ = 8
?DeleteCriticalSection@@YGXPAX@Z PROC NEAR		; DeleteCriticalSection, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   : }

  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
?DeleteCriticalSection@@YGXPAX@Z ENDP			; DeleteCriticalSection
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\seqtrack.h
_TEXT	ENDS
;	COMDAT ??0SeqStateData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SeqStateData@@QAE@XZ PROC NEAR			; SeqStateData::SeqStateData, COMDAT
; _this$ = ecx

; 29   : 	SeqStateData()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	{
; 31   : 		mtCurTimeSig = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 32   : 		mtNextTimeSig = 0;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 33   : 		dwMeasure = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 34   : 		dwlnBeat = DMUS_PPQ;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 1c 00 03
	00 00		 mov	 DWORD PTR [eax+28], 768	; 00000300H

; 35   : 		dwlnMeasure = DMUS_PPQ * 4;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 20 00 0c
	00 00		 mov	 DWORD PTR [ecx+32], 3072 ; 00000c00H

; 36   : 		dwlnGrid = DMUS_PPQ / 4;

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	c7 42 24 c0 00
	00 00		 mov	 DWORD PTR [edx+36], 192	; 000000c0H

; 37   : 		apCurrentSeq = NULL;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 38   : 		apCurrentCurve = NULL;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 39   : 	}

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0SeqStateData@@QAE@XZ ENDP				; SeqStateData::SeqStateData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1SeqStateData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12
$T71174 = -8
$T71173 = -4
??1SeqStateData@@QAE@XZ PROC NEAR			; SeqStateData::~SeqStateData, COMDAT
; _this$ = ecx

; 41   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 		if( apCurrentSeq )

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 15		 je	 SHORT $L50658

; 43   : 		{
; 44   : 			delete [] apCurrentSeq;

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 55 fc	 mov	 DWORD PTR $T71173[ebp], edx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR $T71173[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00024	83 c4 04	 add	 esp, 4
$L50658:

; 45   : 		}
; 46   : 		if( apCurrentCurve )

  00027	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0002e	74 15		 je	 SHORT $L50657

; 47   : 		{
; 48   : 			delete [] apCurrentCurve;

  00030	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00033	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00036	89 45 f8	 mov	 DWORD PTR $T71174[ebp], eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR $T71174[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00042	83 c4 04	 add	 esp, 4
$L50657:

; 49   : 		}
; 50   : 	}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??1SeqStateData@@QAE@XZ ENDP				; SeqStateData::~SeqStateData
_TEXT	ENDS
PUBLIC	??0?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ		; TList<_DMUS_IO_SEQ_ITEM>::TList<_DMUS_IO_SEQ_ITEM>
PUBLIC	??0?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ	; TList<_DMUS_IO_CURVE_ITEM>::TList<_DMUS_IO_CURVE_ITEM>
; Function compile flags: /Odt
;	COMDAT ??0SEQ_PART@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SEQ_PART@@QAE@XZ PROC NEAR				; SEQ_PART::SEQ_PART, COMDAT
; _this$ = ecx

; 61   : 	SEQ_PART() : pNext(NULL) {}; // always initialize pNext to NULL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e8 00 00 00 00	 call	 ??0?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ; TList<_DMUS_IO_SEQ_ITEM>::TList<_DMUS_IO_SEQ_ITEM>
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00021	e8 00 00 00 00	 call	 ??0?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ; TList<_DMUS_IO_CURVE_ITEM>::TList<_DMUS_IO_CURVE_ITEM>
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0SEQ_PART@@QAE@XZ ENDP				; SEQ_PART::SEQ_PART
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.h
_TEXT	ENDS
;	COMDAT ??0?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ PROC NEAR	; TList<_DMUS_IO_SEQ_ITEM>::TList<_DMUS_IO_SEQ_ITEM>, COMDAT
; _this$ = ecx

; 55   :     TList() {m_pHead=NULL;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ENDP		; TList<_DMUS_IO_SEQ_ITEM>::TList<_DMUS_IO_SEQ_ITEM>
_TEXT	ENDS
PUBLIC	?Delete@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@SGXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::Delete
; Function compile flags: /Odt
;	COMDAT ??1?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ PROC NEAR	; TList<_DMUS_IO_SEQ_ITEM>::~TList<_DMUS_IO_SEQ_ITEM>, COMDAT
; _this$ = ecx

; 57   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		//if (m_pHead != NULL) delete m_pHead;
; 59   : 		TListItem<T>::Delete(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Delete@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@SGXPAV1@@Z ; TListItem<_DMUS_IO_SEQ_ITEM>::Delete

; 60   : 	} // new destructor

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$TList@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ENDP		; TList<_DMUS_IO_SEQ_ITEM>::~TList<_DMUS_IO_SEQ_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ PROC NEAR	; TList<_DMUS_IO_CURVE_ITEM>::TList<_DMUS_IO_CURVE_ITEM>, COMDAT
; _this$ = ecx

; 55   :     TList() {m_pHead=NULL;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ENDP		; TList<_DMUS_IO_CURVE_ITEM>::TList<_DMUS_IO_CURVE_ITEM>
_TEXT	ENDS
PUBLIC	?Delete@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@SGXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::Delete
; Function compile flags: /Odt
;	COMDAT ??1?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ PROC NEAR	; TList<_DMUS_IO_CURVE_ITEM>::~TList<_DMUS_IO_CURVE_ITEM>, COMDAT
; _this$ = ecx

; 57   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		//if (m_pHead != NULL) delete m_pHead;
; 59   : 		TListItem<T>::Delete(m_pHead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Delete@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@SGXPAV1@@Z ; TListItem<_DMUS_IO_CURVE_ITEM>::Delete

; 60   : 	} // new destructor

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$TList@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ENDP		; TList<_DMUS_IO_CURVE_ITEM>::~TList<_DMUS_IO_CURVE_ITEM>
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\tlist.cpp
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@SGXPAV1@@Z
_TEXT	SEGMENT
tv70 = -20
$T71194 = -16
$T71193 = -12
_pScan$ = -8
_pNext$ = -4
_pFirst$ = 8
?Delete@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@SGXPAV1@@Z PROC NEAR ; TListItem<_DMUS_IO_SEQ_ITEM>::Delete, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 29   : 	TListItem<T>* pScan = pFirst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pFirst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 30   : 	TListItem<T>* pNext = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0
$L69303:

; 31   : 	while (pScan)

  00013	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00017	74 39		 je	 SHORT $L69299

; 32   : 	{
; 33   : 		pNext = pScan->m_pNext;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0001c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0001f	89 55 fc	 mov	 DWORD PTR _pNext$[ebp], edx

; 34   : 		delete pScan;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T71194[ebp], eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T71194[ebp]
  0002b	89 4d f4	 mov	 DWORD PTR $T71193[ebp], ecx
  0002e	83 7d f4 00	 cmp	 DWORD PTR $T71193[ebp], 0
  00032	74 0f		 je	 SHORT $L71195
  00034	6a 01		 push	 1
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T71193[ebp]
  00039	e8 00 00 00 00	 call	 ??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z
  0003e	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00041	eb 07		 jmp	 SHORT $L71196
$L71195:
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L71196:

; 35   : 		pScan = pNext;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 36   : 	}

  00050	eb c1		 jmp	 SHORT $L69303
$L69299:

; 37   : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Delete@?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@SGXPAV1@@Z ENDP ; TListItem<_DMUS_IO_SEQ_ITEM>::Delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@SGXPAV1@@Z
_TEXT	SEGMENT
tv70 = -20
$T71201 = -16
$T71200 = -12
_pScan$ = -8
_pNext$ = -4
_pFirst$ = 8
?Delete@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@SGXPAV1@@Z PROC NEAR ; TListItem<_DMUS_IO_CURVE_ITEM>::Delete, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 29   : 	TListItem<T>* pScan = pFirst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pFirst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 30   : 	TListItem<T>* pNext = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0
$L69313:

; 31   : 	while (pScan)

  00013	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00017	74 39		 je	 SHORT $L69309

; 32   : 	{
; 33   : 		pNext = pScan->m_pNext;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0001c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0001f	89 55 fc	 mov	 DWORD PTR _pNext$[ebp], edx

; 34   : 		delete pScan;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _pScan$[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T71201[ebp], eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T71201[ebp]
  0002b	89 4d f4	 mov	 DWORD PTR $T71200[ebp], ecx
  0002e	83 7d f4 00	 cmp	 DWORD PTR $T71200[ebp], 0
  00032	74 0f		 je	 SHORT $L71202
  00034	6a 01		 push	 1
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T71200[ebp]
  00039	e8 00 00 00 00	 call	 ??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z
  0003e	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00041	eb 07		 jmp	 SHORT $L71203
$L71202:
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L71203:

; 35   : 		pScan = pNext;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _pScan$[ebp], edx

; 36   : 	}

  00050	eb c1		 jmp	 SHORT $L69313
$L69309:

; 37   : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Delete@?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@SGXPAV1@@Z ENDP ; TListItem<_DMUS_IO_CURVE_ITEM>::Delete
_TEXT	ENDS
PUBLIC	??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ	; TListItem<_DMUS_IO_SEQ_ITEM>::~TListItem<_DMUS_IO_SEQ_ITEM>
; Function compile flags: /Odt
;	COMDAT ??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z PROC NEAR ; TListItem<_DMUS_IO_SEQ_ITEM>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ; TListItem<_DMUS_IO_SEQ_ITEM>::~TListItem<_DMUS_IO_SEQ_ITEM>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69398
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69398:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAEPAXI@Z ENDP	; TListItem<_DMUS_IO_SEQ_ITEM>::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ PROC NEAR	; TListItem<_DMUS_IO_SEQ_ITEM>::~TListItem<_DMUS_IO_SEQ_ITEM>, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	//if (m_pNext != NULL) { delete m_pNext; }
; 22   : 	// IMPORTANT: user of the list is required to delete content first!
; 23   : 	//ZeroMemory(&m_Tinfo, sizeof(T));
; 24   : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ ENDP	; TListItem<_DMUS_IO_SEQ_ITEM>::~TListItem<_DMUS_IO_SEQ_ITEM>
_TEXT	ENDS
PUBLIC	??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ	; TListItem<_DMUS_IO_CURVE_ITEM>::~TListItem<_DMUS_IO_CURVE_ITEM>
; Function compile flags: /Odt
;	COMDAT ??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z PROC NEAR ; TListItem<_DMUS_IO_CURVE_ITEM>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ; TListItem<_DMUS_IO_CURVE_ITEM>::~TListItem<_DMUS_IO_CURVE_ITEM>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69401
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69401:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAEPAXI@Z ENDP	; TListItem<_DMUS_IO_CURVE_ITEM>::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ PROC NEAR	; TListItem<_DMUS_IO_CURVE_ITEM>::~TListItem<_DMUS_IO_CURVE_ITEM>, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	//if (m_pNext != NULL) { delete m_pNext; }
; 22   : 	// IMPORTANT: user of the list is required to delete content first!
; 23   : 	//ZeroMemory(&m_Tinfo, sizeof(T));
; 24   : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ ENDP	; TListItem<_DMUS_IO_CURVE_ITEM>::~TListItem<_DMUS_IO_CURVE_ITEM>
_TEXT	ENDS
END
