/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdbld.cpp

Abstract:

    This module contains routines to generate ROM binary for DVD dongle.

--*/

#include "dvdbldp.h"

XDCS_DVD_CODE_INFORMATION xdcs;
HANDLE OutputFileHandle = INVALID_HANDLE_VALUE;
ULONG CompressedSize;
ULONG UncompressedSize;

UCHAR ImgbPrivateKeyData[] = {
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xCD,0xE1,0xAD,0xFB,
    0x97,0x2B,0x02,0xF8,0xC9,0xB4,0xFF,0xF7,
    0x81,0x6C,0xC1,0x91,0x11,0xB8,0x44,0x5A,
    0xF9,0x18,0x6C,0x20,0xB5,0xBC,0xA9,0x17,
    0xD7,0x21,0x76,0x50,0x65,0xA0,0xB5,0x7B,
    0x70,0x57,0x19,0x3C,0xA0,0x03,0x59,0x27,
    0x5D,0xBA,0xE1,0x66,0xEE,0xAF,0xB1,0xFE,
    0x59,0xCE,0x9A,0x80,0x96,0xA8,0x8A,0x0A,
    0x96,0x05,0x92,0x1D,0x43,0xF9,0xB5,0x10,
    0x22,0xE8,0xB7,0xFC,0x93,0x40,0x85,0x63,
    0xF9,0x96,0xEC,0x24,0xE8,0xDE,0xAC,0x65,
    0x17,0xA7,0xD7,0x6C,0xFB,0x0A,0x6E,0x0C,
    0xFA,0xCC,0xF3,0xB1,0xC9,0x13,0x6A,0xB0,
    0x99,0x10,0x1B,0x69,0x7B,0xB0,0x1E,0x36,
    0x9E,0xDD,0x67,0xD4,0xD2,0xE3,0xB1,0x11,
    0xE7,0xEB,0x8C,0x14,0x6F,0xCC,0xCE,0x71,
    0xA5,0x29,0xA2,0xCE,0x00,0x00,0x00,0x00,
    0x07,0xB3,0xF5,0x5E,0x12,0x32,0x0D,0x07,
    0x28,0x09,0x10,0xCB,0x78,0xFD,0xDA,0x92,
    0xB3,0xCB,0x54,0xBF,0x66,0x5F,0x0E,0xCB,
    0x0B,0x66,0x94,0xDA,0x03,0xCB,0xBA,0x05,
    0xA5,0xE6,0x4B,0xBD,0x28,0xC8,0x12,0xB1,
    0x6C,0x6B,0x2A,0x9D,0x86,0xE1,0x57,0xAC,
    0xC1,0x8F,0x1B,0xF7,0x26,0x39,0x3E,0x44,
    0x9E,0x53,0x12,0x25,0x88,0x0A,0x3F,0xE0,
    0xF7,0xA5,0xB8,0xCD,0xF7,0xE3,0x63,0xA8,
    0xF3,0xBD,0x78,0xFE,0x5C,0xB2,0x73,0x84,
    0xE3,0x25,0x9A,0x28,0xE2,0x35,0x55,0xC3,
    0x4B,0xD4,0x17,0x96,0xBE,0xC8,0xC6,0x26,
    0x40,0x2C,0xEC,0x2E,0x54,0x28,0x0E,0xBC,
    0x6B,0xE0,0x0F,0x58,0xB7,0xAB,0x93,0x84,
    0x78,0x47,0x53,0x06,0xD1,0x84,0xBE,0x79,
    0x35,0x13,0xA6,0x75,0x76,0xCF,0x8E,0xC0,
    0x00,0x00,0x00,0x00,0x95,0xAE,0xEA,0x78,
    0x33,0xBB,0x54,0x92,0x45,0xE4,0xA6,0xD1,
    0xFA,0x5E,0xE0,0x94,0x1E,0xAC,0xFA,0x4D,
    0x06,0x48,0xEE,0x92,0x4F,0x19,0x2A,0xD3,
    0xE6,0x45,0x75,0x4E,0x24,0x6B,0xDB,0x18,
    0xF0,0xD0,0x42,0xEA,0x8E,0x2D,0x3F,0xC8,
    0x40,0xB1,0x30,0x59,0x0B,0x3C,0x94,0x6A,
    0x91,0xD8,0x3C,0xDC,0xC5,0xE7,0x84,0xB1,
    0x1D,0x01,0x38,0x62,0x38,0x0E,0x23,0x1E,
    0xCF,0x69,0x7C,0xAD,0xC5,0xA3,0xE2,0x97,
    0x57,0x72,0x65,0x66,0xD2,0x76,0x74,0x58,
    0x1C,0x58,0x6D,0x70,0x18,0x43,0x8D,0x83,
    0x45,0x29,0x23,0xC6,0xA0,0xB8,0x06,0x96,
    0x0E,0xCA,0x2B,0x16,0xF4,0x62,0x48,0x77,
    0x0B,0x1A,0x89,0xA8,0x41,0xB8,0xD6,0xFF,
    0x3A,0x76,0x4B,0xF4,0x2D,0x52,0x96,0xF8,
    0xC6,0x69,0xA9,0x31,0x00,0x00,0x00,0x00,
    0xB3,0xC9,0x4D,0xCE,0x69,0xEF,0x44,0x70,
    0x7E,0x77,0x52,0x14,0x0E,0x71,0x52,0xED,
    0x48,0x6D,0x2C,0xFA,0x77,0x6A,0xA0,0x78,
    0xC8,0x05,0x24,0xB7,0xD3,0x00,0x2E,0x44,
    0x36,0x73,0xE1,0x87,0x1A,0x75,0x4D,0x7F,
    0x62,0xA4,0x0D,0xB2,0x6C,0xB9,0x07,0x5E,
    0xF7,0x9E,0x21,0x42,0xDD,0xC9,0xA2,0x6A,
    0x62,0x96,0xD6,0x4B,0xF2,0x25,0x87,0x75,
    0x4B,0xE4,0x21,0x5F,0x59,0xCD,0x76,0x40,
    0x6D,0x35,0xC1,0xBD,0x6A,0x12,0xED,0x12,
    0x89,0xB5,0xA8,0x58,0xF4,0x15,0x95,0x47,
    0x84,0xFA,0xF1,0xD8,0xE2,0x85,0x9C,0x52,
    0x81,0xDD,0x0B,0x64,0x48,0xF0,0xFC,0x1F,
    0x9A,0x31,0x12,0xA1,0x08,0xD8,0x0C,0xF9,
    0x64,0xAE,0x36,0x04,0x2E,0x1D,0xCE,0xBD,
    0x3F,0xFC,0xEE,0x62,0xB2,0x8B,0x4E,0x4C,
    0x00,0x00,0x00,0x00,0xA3,0x67,0xDF,0xAE,
    0xF0,0x4B,0x5F,0xF5,0x46,0xB1,0x67,0x39,
    0x24,0x29,0xD6,0xE2,0xDF,0x78,0xB1,0x05,
    0x63,0x3F,0x03,0xB0,0xEF,0x01,0x14,0xD8,
    0x42,0x69,0x4D,0x1D,0x87,0xB2,0x4C,0x3B,
    0x21,0xD6,0xA2,0xA1,0xBD,0x5E,0xCB,0xB2,
    0x97,0xBB,0x23,0xD8,0xB6,0x0B,0x68,0x94,
    0x25,0x6F,0x2B,0xFD,0xAD,0x6F,0x33,0x58,
    0xB1,0x77,0x1E,0x77,0x0D,0xF3,0xFC,0xCE,
    0x32,0x58,0x9A,0x15,0xC7,0xCE,0x29,0x5A,
    0x8A,0x0F,0x94,0xF9,0xBD,0x3C,0xAC,0x45,
    0xC3,0x6E,0x3C,0x72,0x95,0x2D,0xDD,0x16,
    0x30,0x5F,0x9D,0xD7,0x1C,0x76,0xA2,0x6C,
    0xCE,0xF0,0x7B,0x35,0xDC,0xD4,0x7E,0xEF,
    0x8E,0x01,0x53,0xE8,0x43,0xF8,0x18,0xDF,
    0xBD,0x25,0x6C,0xBC,0x5E,0x42,0x5D,0xA1,
    0x75,0xC9,0x76,0x7E,0x00,0x00,0x00,0x00,
    0xA9,0x91,0x2B,0xBF,0x27,0x08,0x55,0xC3,
    0xDE,0xC9,0x11,0xF1,0x37,0xCC,0xAA,0xC9,
    0x81,0xC8,0x1D,0xD1,0x12,0xA4,0xB0,0xD6,
    0x65,0xAB,0xBB,0x92,0xD5,0x37,0x6F,0x70,
    0x8C,0xAC,0x30,0xF7,0xA7,0x79,0x10,0xEC,
    0x46,0xA3,0x08,0x2A,0xC4,0x9A,0xD0,0x49,
    0x3A,0x77,0x23,0xF2,0x86,0xEF,0x82,0xE5,
    0xE5,0x7B,0x50,0xED,0xD5,0x43,0xA7,0x33,
    0xED,0xD7,0xA4,0x7A,0xB6,0x35,0x60,0x9D,
    0xB9,0xAD,0x93,0xB4,0xD6,0x3C,0x3D,0xCE,
    0xDF,0x43,0x00,0xC2,0xFC,0xE1,0x5A,0x98,
    0x3A,0x07,0x7B,0xCE,0xA1,0x2F,0xEE,0x01,
    0x70,0x83,0x8B,0xC1,0x3F,0xB7,0x79,0x5E,
    0x3D,0x2F,0xBD,0x9F,0x7D,0xD9,0xBE,0x66,
    0xE2,0x32,0xD4,0x92,0x3D,0xD5,0xE1,0x9F,
    0xE7,0x2F,0x22,0x52,0xCA,0xD1,0xFB,0xBC,
    0x6F,0x80,0x82,0x34,0x1D,0x13,0x07,0x39,
    0x24,0xC7,0x83,0x7D,0x61,0x9A,0x73,0x84,
    0x6B,0x30,0x79,0x10,0xE6,0x1F,0xC7,0xC1,
    0x0F,0x22,0x09,0xAA,0x15,0xB7,0x00,0x1D,
    0x6E,0x1A,0x93,0x4D,0x34,0xC7,0x1B,0x75,
    0x56,0xAF,0x48,0x14,0x6D,0x66,0x9A,0xB6,
    0x8E,0x69,0xFA,0x67,0x95,0x78,0xEC,0xE6,
    0x9E,0xAF,0x43,0xA0,0x3D,0x43,0x6F,0xD1,
    0x49,0x4F,0x35,0x6A,0x9C,0x83,0xB3,0x03,
    0x50,0x40,0x2C,0x4A,0x63,0x2B,0x15,0x43,
    0x6C,0x1E,0xDD,0x9D,0x61,0xA3,0x04,0xBB,
    0x87,0xB6,0x35,0x1A,0x32,0x48,0x0F,0x87,
    0xF3,0xE9,0x32,0x38,0x8B,0x7A,0x5F,0x74,
    0x87,0x47,0x5A,0xEE,0x65,0x5C,0xBC,0x9F,
    0xAF,0xB5,0x88,0xA6,0x77,0x5B,0xA5,0x3A,
    0xB7,0xDB,0x54,0xB4,0xF5,0x78,0x32,0x1E,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};

VOID
TranslateError(
    IN DWORD ErrorCode
    )
{
    LPVOID lpMsgBuf;

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, ErrorCode, 0, (LPTSTR)&lpMsgBuf, 0, NULL );
    fprintf( stderr, "DVDBLD : error DV%04x : %s\n", ErrorCode, lpMsgBuf );
    LocalFree( lpMsgBuf );
}

MI_MEMORY
DIAMONDAPI
LzxAlloc(
    ULONG cb
    )
{
    return LocalAlloc( LPTR, cb );
}

VOID
DIAMONDAPI
LzxFree(
    MI_MEMORY pv
    )
{
    LocalFree( pv );
}

int
DIAMONDAPI
CompressionCallback(
    void * pfol,
    unsigned char * compressed_data,
    long compressed_size,
    long uncompressed_size
    )
{
    ULONG BytesWritten;
    LZXBOX_BLOCK Block;

    //
    // Write block header
    //

    Block.CompressedSize = (USHORT)compressed_size;
    Block.UncompressedSize = (USHORT)uncompressed_size;

    CompressedSize += sizeof Block + compressed_size;
    UncompressedSize += uncompressed_size;

    if ( !WriteFile(OutputFileHandle, &Block, sizeof(Block), &BytesWritten, NULL) ) {
        return -1;
    }

    //
    // Write compressed data
    //

    if ( !WriteFile(OutputFileHandle, compressed_data, compressed_size, &BytesWritten, NULL) ) {
        return -1;
    }

    return 0;
}

DWORD
CompressFile(
    IN PVOID  InputBuffer,
    IN SIZE_T InputSize,
    IN HANDLE OutputFileHandle
    )
{
    DWORD error;
    UINT DestSize;
    int LciReturn;
    UINT SourceSize;
    ULONG_PTR Source;
    LZXCONFIGURATION cfg;
    LCI_CONTEXT_HANDLE Handle;
    SIZE_T BytesRead, BytesRemaining;
    SIZE_T BytesCompressed;

    SourceSize = LZX_CHUNK_SIZE;
    cfg.WindowSize = LZX_WINDOW_SIZE;
    cfg.SecondPartitionSize = 64 * 1024;

    LciReturn = LCICreateCompression( &SourceSize, &cfg, LzxAlloc, LzxFree,
                                      &DestSize, &Handle, CompressionCallback,
                                      NULL );

    if ( LciReturn != MCI_ERROR_NO_ERROR) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    BytesRemaining = InputSize;
    Source = (ULONG_PTR)InputBuffer;
    BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;

    while ( BytesRemaining ) {
        LciReturn = LCICompress( Handle, (PVOID)Source, BytesRead, NULL,
                                 DestSize, &BytesCompressed );

        if ( LciReturn != MCI_ERROR_NO_ERROR ) {
            fprintf( stderr, "Compression failed (%d)\n", LciReturn );
            break;
        }

        BytesRemaining -= BytesRead;
        BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;
        Source += SourceSize;
    }

    LCIFlushCompressorOutput( Handle );
    LCIDestroyCompression( Handle );

    return BytesRemaining ? ERROR_GEN_FAILURE : ERROR_SUCCESS;
}

enum { ftOther, ftXbe, ftBin };

int FtOfFile(LPCSTR szName)
{
    LPSTR psz;
    psz = strrchr(szName, '.');

    if(!psz)
        return ftOther;
    if ( _stricmp(psz,".bin") == 0 )
        return ftBin;
    if ( _stricmp(psz,".xbe") == 0 )
        return ftXbe;
    return ftOther;
}

int __cdecl main( int argc, char *argv[] )
{
    HANDLE InputFileHandle  = INVALID_HANDLE_VALUE;
    HANDLE InputFileMapped  = NULL;
    HANDLE OutputFileMapped = NULL;
    PBYTE  InputBuffer = NULL;
    XDCS_DVD_CODE_INFORMATION *MappedHeader = NULL;
    SIZE_T InputSize;
    DWORD  error = ~0;
    DWORD  BytesWritten;
    ULONG Region;
    ULONG Version;
    BYTE HeaderDigest[ XC_DIGEST_LEN ];
    PXBEIMAGE_HEADER pxih;
    PXBEIMAGE_CERTIFICATE pxcert;
    PXBEIMAGE_SECTION pxsh;
    ULONG cbXbeHeaders;
    int dcbHeaders;
    int ftInput, ftOutput;
    BYTE rgbBuf[8192];
    PBYTE pbSign;

    if ( argc != 5 && argc ) {
        fprintf(stderr, "Usage:\tDVDBLD <version> <region> <input-file> <output-file>\n");
        fprintf(stderr, "\tinput-file can be .exe, .xbe, or .rom\n");
        fprintf(stderr, "\toutputfile can be .xbe or .rom\n");
        TranslateError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    ftInput = FtOfFile(argv[3]);
    ftOutput = FtOfFile(argv[4]);

    if(ftOutput == ftOther) {
        fprintf(stderr, "illegal output file type\n");
        TranslateError( ERROR_INVALID_PARAMETER );
        return -3;
    }

    __try {

        if ( ftInput == ftOutput ) {

            //
            // Copy from existing image file
            //

            if ( !CopyFile(argv[3], argv[4], FALSE) ) {
                goto Error;
            }
            OutputFileHandle = CreateFile( argv[4],
                GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, 0 );

            if ( OutputFileHandle == INVALID_HANDLE_VALUE ) {
                goto Error;
            }

        } else {
            /* We're going to do a file conversion, so set up the input and
             * output files and get ready to convert */

            InputFileHandle = CreateFile( argv[3], GENERIC_READ, FILE_SHARE_READ, 0,
                                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 );

            if ( InputFileHandle == INVALID_HANDLE_VALUE ) {
                goto Error;
            }

            InputSize = GetFileSize( InputFileHandle, 0 );

            InputFileMapped = CreateFileMapping( InputFileHandle, 0, PAGE_READONLY,
                                                 0, InputSize, 0 );

            if ( InputFileMapped == NULL ) {
                goto Error;
            }

            InputBuffer = (PBYTE)MapViewOfFile( InputFileMapped, FILE_MAP_READ, 0, 0, 0 );

            if ( !InputBuffer ) {
                goto Error;
            }

            OutputFileHandle = CreateFile( argv[4],
                GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, 0 );

            if ( OutputFileHandle == INVALID_HANDLE_VALUE ) {
                goto Error;
            }

            switch(ftInput) {
            case ftXbe:
                /* Copying xbe->bin, so we need to spit out the header --
                 * we fill in the file size later on */
                pxih = (PXBEIMAGE_HEADER)InputBuffer;
                if(pxih->SizeOfImage != InputSize) {
                    error = ERROR_BAD_FORMAT;
                    goto Error;
                }
                if(!WriteFile(OutputFileHandle, &xdcs, sizeof xdcs,
                        &BytesWritten, NULL))
                    goto Error;
                if(!WriteFile(OutputFileHandle, InputBuffer,
                        InputSize, &BytesWritten, NULL))
                    goto Error;
                break;

            case ftBin:
                /* Copying bin->xbe, so we just need to lose the header */
                if(!WriteFile(OutputFileHandle,
                        ((XDCS_DVD_CODE_INFORMATION *)InputBuffer + 1),
                        InputSize - sizeof xdcs, &BytesWritten, NULL))
                    goto Error;
                break;

            default:
                /* Copying from a PE file, so we need to make space for the
                 * XBE headers */
                cbXbeHeaders = sizeof *pxih + XBEIMAGE_CERTIFICATE_BASE_SIZEOF +
					sizeof *pxsh;

                if ( ftOutput == ftBin && !WriteFile(OutputFileHandle,
                        &xdcs, sizeof xdcs, &BytesWritten, NULL) )
                    goto Error;

                if(INVALID_SET_FILE_POINTER == SetFilePointer(OutputFileHandle,
                        cbXbeHeaders, NULL, FILE_CURRENT))
                    goto Error;

                error = CompressFile( InputBuffer, InputSize, OutputFileHandle);

                if ( error != ERROR_SUCCESS ) {
                    TranslateError( error );
                    __leave;
                }

                if(UncompressedSize != InputSize) {
                    error = ERROR_GEN_FAILURE;
                    goto Error;
                }
                break;
            }
        }

        OutputFileMapped = CreateFileMapping( OutputFileHandle, 0, PAGE_READWRITE, 0, 0, 0 );

        if ( OutputFileMapped == INVALID_HANDLE_VALUE ) {
            goto Error;
        }

        MappedHeader = (XDCS_DVD_CODE_INFORMATION*)MapViewOfFile( OutputFileMapped, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
        if ( !MappedHeader ) {
            goto Error;
        }

        //
        // Locate the XBE headers
        //

        if(ftOutput == ftBin)
            pxih = (PXBEIMAGE_HEADER)(MappedHeader + 1);
        else
            pxih = (PXBEIMAGE_HEADER)MappedHeader;

        switch(ftInput) {
        case ftOther:
            pxcert = (PXBEIMAGE_CERTIFICATE)(pxih + 1);
            pxsh = (PXBEIMAGE_SECTION)((PUCHAR)pxcert +
				XBEIMAGE_CERTIFICATE_BASE_SIZEOF);

            //
            // Populate the base header
            //

            memset(pxih, 0, sizeof *pxih);
            pxih->Signature = XBEIMAGE_SIGNATURE;
            pxih->BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
            pxih->SizeOfHeaders = cbXbeHeaders;
            pxih->SizeOfImage = cbXbeHeaders + CompressedSize;
            pxih->SizeOfImageHeader = sizeof *pxih;
            pxih->TimeDateStamp = time(NULL);
            pxih->Certificate = (PXBEIMAGE_CERTIFICATE)
                ((ULONG_PTR)pxcert - (ULONG_PTR)pxih +
                XBEIMAGE_STANDARD_BASE_ADDRESS);
            pxih->NumberOfSections = 1;
            pxih->SectionHeaders =  (PXBEIMAGE_SECTION)
                ((ULONG_PTR)pxsh - (ULONG_PTR)pxih +
                XBEIMAGE_STANDARD_BASE_ADDRESS);

            //
            // Populate the certificate
            //

            memset(pxcert, 0, sizeof *pxcert);
            pxcert->SizeOfCertificate = XBEIMAGE_CERTIFICATE_BASE_SIZEOF;
            pxcert->TimeDateStamp = pxih->TimeDateStamp;
            pxcert->TitleID = 0xfffe0000;
            pxcert->AllowedMediaTypes = XBEIMAGE_MEDIA_TYPE_DONGLE;

            //
            // Populate the section header
            //

            memset(pxsh, 0, sizeof *pxsh);
            pxsh->VirtualAddress = XBEIMAGE_STANDARD_BASE_ADDRESS +
                cbXbeHeaders;
            pxsh->VirtualSize = InputSize;
            pxsh->PointerToRawData = cbXbeHeaders;
            pxsh->SizeOfRawData = CompressedSize;

            //
            // Calculate digest of raw data (compressed code)
            //

            XCCalcDigest( (PBYTE)pxih + cbXbeHeaders,
                          pxsh->SizeOfRawData, pxsh->SectionDigest );

            break;

        default:
            pxcert = (PXBEIMAGE_CERTIFICATE)((PBYTE)pxih +
                (ULONG_PTR)pxih->Certificate - (ULONG_PTR)pxih->BaseAddress);
            pxsh = (PXBEIMAGE_SECTION)((PBYTE)pxih +
                (ULONG_PTR)pxih->SectionHeaders - (ULONG_PTR)pxih->BaseAddress);
            /* Make sure the header is big enough to contain the data we're
             * interested in.  If the file isn't big enough to contain ther
             * headers, we'll crash and error out */
            if(pxih->Signature != XBEIMAGE_SIGNATURE ||
                (PBYTE)pxcert < (PBYTE)pxih || (PBYTE)pxsh < (PBYTE)pxih ||
                ((PBYTE)pxcert + pxcert->SizeOfCertificate) -
				(PBYTE)pxih > (int)pxih->SizeOfHeaders ||
                (PBYTE)(pxsh + 1) - (PBYTE)pxih > (int)pxih->SizeOfHeaders)
            {
                error = ERROR_BAD_FORMAT;
                goto Error;
            }
        }

        Region = strtoul(argv[2], 0, 0);
        Version = strtoul( argv[1], 0, 0 );

        //
        // We only do the region/version stamping and signature computation if we
        // have a non-zero region/version.  Otherwise, we have to assume we're
        // just repackaging an already-signed (retail-signed) XBE
        //

        if(Region || Version) {

            //
            // Stamp the region
            //

            if(Region)
                pxcert->GameRegion = Region;

            //
            // Stamp the version
            //

            if(Version)
                pxcert->Version = Version;

            //
            // Sign the header
            //

            pbSign = pxih->EncryptedDigest + sizeof pxih->EncryptedDigest;
            XCCalcDigest(pbSign, (PBYTE)pxih + pxih->SizeOfHeaders - pbSign,
                HeaderDigest);
            XCSignDigest(HeaderDigest, ImgbPrivateKeyData, pxih->EncryptedDigest);
        }

        if(!pxcert->GameRegion || !pxcert->Version) {
            error = ERROR_INVALID_PARAMETER;
            goto Error;
        }

        //
        // And backfill the binary header
        //
        if(ftOutput == ftBin) {
            MappedHeader->bcdVersion = (USHORT)pxcert->Version;
            MappedHeader->dwCodeLength = sizeof xdcs + pxih->SizeOfImage;
        }

        //
        // Clean up
        //

        if ( !UnmapViewOfFile(MappedHeader)) {
Error:
            error = GetLastError();
            TranslateError( GetLastError() );
            __leave;
        }

        MappedHeader = NULL;
        error = ERROR_SUCCESS;

    } __finally {

        if ( InputBuffer ) {
            UnmapViewOfFile( InputBuffer );
        }

        if ( MappedHeader ) {
            UnmapViewOfFile( MappedHeader );
        }

        if ( InputFileMapped ) {
            CloseHandle( InputFileMapped );
        }

        if ( OutputFileMapped ) {
            CloseHandle( OutputFileMapped );
        }

        if ( InputFileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( InputFileHandle );
        }

        if ( OutputFileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( OutputFileHandle );
        }

        if ( error != ERROR_SUCCESS ) {
            DeleteFile( argv[4] );
        }
    }
}
